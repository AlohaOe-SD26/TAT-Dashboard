# [BLAZE MIS Project 2 - Phase 3 Implementation] - v12.25.2 AUDIT TAB BLAZE + MIS ID FIX
# v12.25.2 CHANGELOG (AUDIT TAB BLAZE + MIS ID FIX):
#   ğŸ”´ FIX: Blaze Discounts Not Showing in Audit Popup
#     * ISSUE: Section 3 showed "No Blaze discounts" even when titles exist in Google Sheet
#     * ROOT CAUSE: buildBlazeSection() only checked approvedMatches (requires re-approval)
#       - User expectation: If Blaze title is IN the Google Sheet, it's already approved
#     * THE FIX: Added check for deal.blaze_discount_title from Google Sheet
#       - If title exists in sheet, look it up in blazeData.currentRows
#       - Display full details (status, type, value, locations, dates) if found
#       - If title in sheet but not found in Blaze data, still show it with "In Sheet Only" badge
#     * PRIORITY ORDER: 
#       1. blaze_discount_title from Google Sheet (already applied = approved)
#       2. approvedMatches (newly approved in ID Matcher)
#       3. deal.blaze_titles directly attached
#       4. blazeMatches global
#   ğŸ”´ FIX: Multiple MIS IDs Not Parsed in Audit Table
#     * ISSUE: MIS ID column showed combined IDs as single string instead of separate buttons
#     * ROOT CAUSE: renderAuditOverview() used deal.current_sheet_id directly
#     * THE FIX: Now uses parseMultipleMisIdsForAudit() to split IDs
#       - Creates separate button for each MIS ID
#       - Each button triggers lookupMisId() with clean ID
#   ğŸ”´ FIX: "STIIIZY MONTHLY+ WEEKLY DEAL PLANNER" Ignore Logic
#     * Added to BOTH Audit Tab and ID Matcher Tab
#     * parseMultipleMisIds() now filters out this note text
#     * parseMultipleMisIdsForAudit() already had this logic
#     * Only rows containing actual numeric IDs are shown as MIS ID buttons
#   ğŸŸ¢ ENHANCED: Blaze Section Table Display
#     * Shows "(from Sheet)" label for titles sourced from Google Sheet column
#     * "In Sheet Only" badge for titles not found in current Blaze data
#     * Row highlighting for sheet-sourced titles
#
# v12.25.1 CHANGELOG (SETUP TAB FIX):
#   ğŸ”´ FIX: Initialize Button Not Working
#     * ISSUE: Button clicked but nothing happened (no browser launch)
#     * ROOT CAUSE: initializeAllSystems() used 'event.target' but 'event' was undefined
#       - onclick="initializeAllSystems()" did NOT pass event parameter
#       - JavaScript error: ReferenceError: event is not defined
#     * THE FIX: 
#       - Changed function signature: initializeAllSystems(btnElement)
#       - Changed onclick: onclick="initializeAllSystems(this)"
#       - Button element now properly captured for disable/enable logic
#
# v12.25.0 CHANGELOG (COMPREHENSIVE AUDIT TAB + SET-BASED MATCHING):
#   Ã°Å¸Å¸Â¢ NEW: Comprehensive Audit Tab (OWN SUB-NAV TAB - NOT nested in ID Matcher)
#     * Located in MIS sub-nav, after "Up-Down Planning" button
#     * Full Audit mode: All deals from selected Google Sheet tab
#     * Custom Audit mode: Filter by Section (Weekly/Monthly/Sale), Weekday, Date
#     * Weekend Toggle: Quick filter for Sat+Sun
#     * Date Picker: For specific date filtering
#   Ã°Å¸Å¸Â¢ NEW: Sequential Audit Process
#     * Start Audit: Confirmation popup with deal count
#     * Progress tracking: "Deal 12 of 47" indicator
#     * Mark buttons: Verified Ã¢Å“â€¦ / Needs Attention Ã¢Å¡Â Ã¯Â¸Â / Skip Ã¢ÂÂ­Ã¯Â¸Â
#     * Previous/Next navigation through deals
#     * Exit Audit: Saves progress and exits
#   Ã°Å¸Å¸Â¢ NEW: Audit Popup with 3 Sections
#     * Section 1: Google Sheet Data (full row from matchesData)
#     * Section 2: Assigned MIS ID Entries (now supports MULTIPLE MIS IDs!)
#     * Section 3: Blaze Discounts (if assigned)
#     * Notes field per MIS entry
#     * Multi-brand verification checklist
#   Ã°Å¸Å¸Â¢ NEW: State Persistence
#     * Server-side state file in AUDIT_REPORTS folder
#     * Browser localStorage backup
#     * Resume incomplete audits on return
#   Ã°Å¸Å¸Â¢ NEW: Export Report
#     * CSV export: Row, Section, Brand, Weekday, MIS ID, Status, Issues, Notes
#   Ã°Å¸â€Â´ FIX: SET-BASED MATCHING (Order Independent)
#     * ISSUE: "Dixon, Davis" vs "Davis, Dixon" marked as mismatch
#     * THE FIX: Split by comma, trim, compare as JavaScript Sets
#     * Logic: set(sheet_list) == set(csv_list) - order no longer matters
#   Ã°Å¸â€Â´ FIX: NaN/Blank as Universal Match
#     * Blank, empty, NaN, null, undefined in Locations/Categories = "All"
#     * Treated as universal match (Include All)
#   Ã°Å¸â€Â´ FIX: "All Except" Logic
#     * "All Locations Except:" and "All Categories Except:" now properly compared
#     * Exclusion lists compared as sets for order independence
#   Ã°Å¸â€Â´ FIX: Weekly Deals + Specific Date Filter
#     * ISSUE: Weekly deals excluded when using Specific Date filter
#     * THE FIX: Weekly deals now included if their weekday matches selected weekday toggle
#     * Weekly deals run every week - specific date only filters by weekday match
#   Ã°Å¸â€Â´ FIX: Monthly Deals Weekday Column (Day-of-Month Format)
#     * ISSUE: Monthly "weekday" column contains "10th", "15th" format, not actual weekdays
#     * THE FIX: Parse day-of-month values, calculate actual weekday for tab month
#     * NOTE: This column format may change - see parseDayOfMonthValues() for updates
#   Ã°Å¸â€Â´ FIX: Multiple MIS IDs Support
#     * Now parses and displays multiple MIS IDs (same as ID Matcher)
#     * Ignores "STIIIZY MONTHLY + WEEKLY DEAL PLANNER" text (user notes, not IDs)
#   Ã°Å¸â€Â´ FIX: Brand + Linked Brand Display
#     * MIS table now shows "Brand / Linked" column
#     * Compares both brand AND linked brand for matching
#     * Cross-match support (sheet linked = MIS brand, etc.)
#   Ã°Å¸Å¸Â¢ REUSES: All existing ID Matcher functions
#     * matchesData array for data source
#     * showSuggestionTooltip() pattern for popup
#     * lookupMisIdWithValidation() for MIS ID buttons
#     * goToSheetRow() for Google Sheet navigation
#
# v12.24.8 CHANGELOG (ENHANCED COMPARISON + END DATE BUTTON FIX):
#   ÃƒÂ°Ã…Â¸Ã¢â‚¬ÂÃ‚Â´ FIX: End Date Buttons Now Show Correct Colors
#     * ISSUE: End date buttons showed GREY instead of RED/GREEN/ORANGE
#     * ROOT CAUSE #1: Empty inline style when getEndDateButtonColor() returned empty
#       - THE FIX: Added fallback style if empty: `style || 'background:#6c757d; ...'`
#     * ROOT CAUSE #2: Wrong element ID for tab name lookup
#       - Code used: document.getElementById('sheet-select') ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ null
#       - Correct ID: document.getElementById('mis-tab')
#       - THE FIX: Changed to use 'mis-tab' which has the tab name like "February 2026"
#   ÃƒÂ°Ã…Â¸Ã¢â‚¬ÂÃ‚Â´ FIX: Credential Loading Crash When No Profile Detected
#     * ISSUE: Setup tab didn't populate, credentials didn't load
#     * ROOT CAUSE: BLAZE_CONFIG_FILE/TOKEN_FILE/CREDENTIALS_FILE could be None
#       - Calling .exists() on None crashes with AttributeError
#     * THE FIX: Added None guards in load_credentials_config() and authenticate_google_sheets()
#   ÃƒÂ°Ã…Â¸Ã…Â¸Ã‚Â¢ NEW: Multiple Assigned MIS IDs Support
#     * Google Sheet can have multiple MIS IDs (line-separated in cell)
#     * Each ID rendered as its own row in Assigned section
#     * Tag shown per row: "ASSIGNED (W1)", "ASSIGNED (W2)", etc.
#   ÃƒÂ°Ã…Â¸Ã…Â¸Ã‚Â¢ NEW: Enhanced Comparison Helpers
#     * getWeekdayMatchStyle() - Multi-day aware, GREEN if MIS contains all sheet days
#     * getCategoryMatchStyle() - Handles blank=All, "All Except", specific lists
#     * getLocationMatchStyle() - Same logic as category
#   ÃƒÂ°Ã…Â¸Ã…Â¸Ã‚Â¢ NEW: All Comparable Fields Now Color-Coded
#     * Weekday: GREEN if MIS weekdays contain all Google Sheet weekdays
#     * Brand: GREEN if exact/contains match
#     * Category: GREEN if both All, or both have same specific list
#     * Discount: GREEN if values match
#     * Vendor %: GREEN if values match
#     * Locations: GREEN if both All, or both have same specific list
#
# v12.24.7 CHANGELOG (FIX: ASSIGNED MIS ID TAG STRIPPING):
#   ÃƒÂ°Ã…Â¸Ã¢â‚¬ÂÃ‚Â´ FIX: Assigned MIS ID Now Strips Tag Prefixes for Lookup
#     * ISSUE: Assigned section showed "MIS ID not found in CSV" even when present
#     * ROOT CAUSE: Google Sheet IDs have tags like "W1 12345", CSV has clean "12345"
#       - Comparison: String(s.mis_id) === assignedMisId failed
#       - "12345" !== "W1 12345"
#     * THE FIX: Added cleanMisId() helper function
#       - Strips tag prefixes: "W1 12345" ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ "12345"
#       - Handles patterns: "W1", "M2", "S1", etc.
#       - Falls back to last numeric sequence if no tag pattern
#     * DISPLAY: Shows tag in header if present: "(Tag: W1)"
#     * LOOKUP: Uses clean ID for suggestion matching & MIS automation
#
# v12.24.6 CHANGELOG (NEW: ASSIGNED SECTION + END DATE COLORS):
#   ÃƒÂ°Ã…Â¸Ã…Â¸Ã‚Â¢ NEW: Assigned MIS ID Section in Suggestions Popup
#     * Shows currently assigned MIS ID above suggestions list
#     * Same datatable structure as suggestions for consistency
#     * Green border/header to distinguish from suggestions
#     * Full data display if ID found in CSV, minimal if not
#     * "ASSIGNED" status badge + "Current" action badge
#   ÃƒÂ°Ã…Â¸Ã…Â¸Ã‚Â¢ NEW: End Date Button Color Coding
#     * Compares end date month to Google Sheet tab name month
#     * RED: End date is in PAST month (expired - needs update!)
#     * GREEN: End date is CURRENT month (correct)
#     * ORANGE: End date is FUTURE month (already extended)
#     * Applied to BOTH Assigned section and all Suggestions
#     * Tooltip shows detailed status message
#   ÃƒÂ°Ã…Â¸Ã…Â¸Ã‚Â¢ NEW: Updated Color Legend
#     * Added End Date color legend (Past/Current/Future Month)
#     * Separated from field match legend for clarity
#
# v12.24.5 CHANGELOG (FIX: JWT KEY EXTRACTION):
#   ÃƒÂ°Ã…Â¸Ã¢â‚¬ÂÃ‚Â´ FIX: Token Extraction Now Checks "jwt" Key FIRST
#     * ISSUE: Auth 200 OK but token not found - server uses "jwt" key
#     * ROOT CAUSE: Blaze Ecom API returns token as top-level "jwt" key
#       - Response: {"jwt": "eyJ...", ...}
#       - We were checking data.attributes.token, headers, etc.
#     * THE FIX: Added priority check for response_data.get('jwt')
#       - Line ~2258: if 'jwt' in response_data: token = response_data['jwt']
#     * EXTRACTION ORDER NOW:
#       1. Authorization header
#       2. Access-Token header  
#       3. response.json()['jwt']  ÃƒÂ¢Ã¢â‚¬Â Ã‚Â NEW PRIORITY
#       4. data.attributes.token
#       5. data.id / data.token / meta.token / token / access_token
#     * RESULT: JWT successfully captured ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ sync can proceed
#
# v12.24.3 CHANGELOG (FIX: COMPREHENSIVE TOKEN EXTRACTION):
#   ÃƒÂ°Ã…Â¸Ã¢â‚¬ÂÃ‚Â´ FIX: Token Extraction Now Checks Headers FIRST + Multiple Body Paths
#     * ISSUE: Still getting "Authentication failed" after json.dumps fix
#     * ROOT CAUSE: Token location varies in JSON:API - may be in headers OR body
#     * THE FIX: Comprehensive extraction in get_ecom_token():
#       1. Headers (checked FIRST - common in JSON:API):
#          - Authorization: Bearer [token]
#          - Access-Token: [token]
#       2. Body Paths (fallback):
#          - data.attributes.token
#          - data.id (some APIs return token as ID)
#          - data.token
#          - meta.token
#          - token (top-level)
#          - access_token (OAuth style)
#     * DEBUG LOGGING ADDED:
#       - Full response headers printed
#       - Response body printed (first 1000 chars)
#       - Payload debug with redacted password
#       - Shows which path found the token
#     * PAYLOAD VERIFIED: type="auth" (not "login")
#     * 422 HANDLING: Added specific error for payload format rejection
#
# v12.24.2 CHANGELOG (FIX: JSON:API CONTENT-TYPE OVERRIDE):
#   ÃƒÂ°Ã…Â¸Ã¢â‚¬ÂÃ‚Â´ FIX: requests.post(json=) Was Overriding Content-Type Header
#     * ISSUE: 401 "Invalid Blaze credentials" despite correct payload
#     * ROOT CAUSE: Using `json=payload` in requests.post() auto-sets
#       Content-Type to "application/json", OVERRIDING our explicit
#       "application/vnd.api+json" header required by JSON:API spec
#     * THE FIX: Use `data=json.dumps(payload)` instead of `json=payload`
#       - get_ecom_token(): Line ~2183 - data=json.dumps(payload)
#       - trigger_ecom_sync(): Line ~2288 - data=json.dumps(payload)
#     * ADDED: Extra debug logging for Content-Type verification
#     * RESULT: Correct Content-Type preserved ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ API accepts credentials
#
# v12.24.1 CHANGELOG (FIX: ECOM SYNC - MISSION CONTROL API):
#   ÃƒÂ°Ã…Â¸Ã…Â¸Ã‚Â¢ FIX: Corrected API Integration for Blaze Ecom Sync
#     * ISSUE: v12.24.0 used wrong endpoint (api.blaze.me/api/v1/sync - 404)
#     * ROOT CAUSE: Tymber sync uses Ecom Mission Control API, not Retail API
#     * THE FIX: Implemented correct 3-step flow:
#       1. Authenticate: POST https://ecom-api.blaze.me/api/v1/auth/login
#       2. Get JWT token from response
#       3. Sync: POST https://ecom-api.blaze.me/api/v1/store/sync-requests
#     * NEW FUNCTIONS:
#       - get_ecom_token(email, password) ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ JWT token
#       - trigger_ecom_sync(store_uuid, token) ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ sync result
#     * HEADERS REQUIRED:
#       - X-Store: [STORE_UUID]
#       - Authorization: Bearer [JWT_TOKEN]
#       - Content-Type: application/vnd.api+json
#     * PAYLOAD: {"data":{"type":"store_sync_requests","attributes":{"request_type":"on_demand"}}}
#     * sync_keys.json NOW USES store_uuid (not api_key/api_secret)
#     * UI: Now requires Blaze email/password from Blaze Config section
#     * STATUS: Enhanced error messages (ÃƒÂ°Ã…Â¸Ã¢â‚¬ÂÃ¢â‚¬Ëœ auth, ÃƒÂ°Ã…Â¸Ã¢â‚¬Å“Ã‚Â UUID, ÃƒÂ°Ã…Â¸Ã…Â¡Ã‚Â« permission)
#
# v12.24.0 CHANGELOG (NEW: BLAZE ECOM SYNC TO TYMBER):
#   ÃƒÂ°Ã…Â¸Ã…Â¸Ã‚Â¢ NEW: Blaze Ecom Sync Feature
#     * UI: Added store dropdown (12 locations) + "SYNC TO TYMBER" button in Setup tab
#     * BACKEND: New /api/blaze/ecom-sync endpoint for store-specific sync
#     * SECURITY: API keys stored in secrets/sync_keys.json (not in code)
#     * STORES: DAVIS, DIXON, NAPA, SANTA ROSA, OAKLAND, SAN FRANCISCO,
#               LOS ANGELES, SAN DIEGO, SAN JOSE, SACRAMENTO, FRESNO, LONG BEACH
#     * HELPER: load_sync_keys() function with graceful error handling
#     * STATUS: Real-time feedback (Ready ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ Syncing... ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ Sync Complete/Failed)
#
# v12.22.8 CHANGELOG (FIX: SINGLE-SELECT SELECT2 DROPDOWNS IN CHECKLIST):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX: Brand, Linked Brand, Rebate Type Now Properly Validated in Checklist
#     * ISSUE: These fields always showed "(empty)" and never turned green
#       - Checklist showed Brand as "(empty)" even when filled
#       - Linked Brand never validated correctly
#       - Rebate Type never turned green even when correct
#     * ROOT CAUSE: getSelect2Value() used wrong approach for single-select
#       - Used: select.options[i].selected (works for multi-select ONLY)
#       - Select2 single-select stores value in container's title attribute
#       - inject_mis_validation() does it correctly, inject_checklist_banner() didn't
#     * THE FIX: Updated getSelect2Value() to handle both types
#       - Added isMulti parameter to function signature
#       - Single-select (isMulti=false): Read from 'select2-{fieldId}-container' title
#       - Multi-select (isMulti=true): Use existing options iteration
#     * IMPLEMENTATION (line ~30852):
#       function getSelect2Value(fieldId, isMulti) {
#           if (!isMulti) {
#               const containerId = 'select2-' + fieldId + '-container';
#               const container = document.getElementById(containerId);
#               return container ? [container.getAttribute('title')] : [];
#           }
#           // ... existing multi-select logic
#       }
#     * CALL SITE UPDATE (line ~31066):
#       actual = getSelect2Value(fieldId, isMulti);  // Now passes isMulti flag
#     * AFFECTED FIELDS (now working):
#       - Brand (brand_id) ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ select2-brand_id-container ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Linked Brand (linked_brand_id) ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ select2-linked_brand_id-container ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Rebate Type (daily_discount_type_id) ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ select2-daily_discount_type_id-container ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#     * RESULT:
#       - All 11 checklist fields now properly monitored ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Brand/Linked Brand/Rebate Type turn green when correct ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Real-time validation works for all field types ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
# v12.22.7 CHANGELOG (FIX: PHASE 1 MIS ID BUTTONS + CHECKLIST VALIDATION):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX 1: Phase 1 Up-Down Planning MIS ID Buttons Now Pass Row Data
#     * ISSUE: MIS ID buttons in Phase 1 didn't pass row data to validation
#       - CREATE_PART1, CREATE_PART2, PATCH buttons had no data-row attribute
#       - Clicking them triggered backend Google Sheet search (inefficient)
#       - Validation didn't use the split's actual data
#     * THE FIX: Pass `split` data to renderClickableMisId() for all action types
#       - Line 9144: CREATE_PART1 ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ renderClickableMisId(..., split)
#       - Line 9156: CREATE_PART2 ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ renderClickableMisId(..., split)
#       - Line 9174: PATCH ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ renderClickableMisId(..., split)
#       - GAP already passed split.interrupting_deal (unchanged)
#     * RESULT: Phase 1 MIS ID buttons now have validation data attached ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX 2: Checklist "All Locations" and "All Categories" Validation
#     * ISSUE: Checklist showed false mismatch errors
#       - Expected: "All Locations" (from Google Sheet)
#       - Actual: Empty in MIS (which MEANS "All Locations")
#       - Result: "1 field(s) don't match" error (FALSE POSITIVE)
#     * ROOT CAUSE: compareMultiSelect() only checked for empty string
#       - `if (!expected || expected === '')` didn't catch "All Locations"
#       - "All Locations" was split into ["All", "Locations"] and failed match
#     * THE FIX: Explicit checks for "All" strings (lines ~30864-30905)
#       - locations: "all locations", "all", starts with "all locations"
#       - categories: "all categories", "all", starts with "all categories"
#       - Empty MIS selection = correct when "All" is expected
#     * RESULT:
#       - "All Locations" expected + empty MIS = ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ Correct
#       - "All Categories" expected + empty MIS = ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ Correct
#       - No more false "1 field(s) don't match" errors ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX 3: Rebate Type False Positive (was actually Issue 2)
#     * ISSUE: "1 field(s) don't match" appeared even with correct Rebate Type
#     * ROOT CAUSE: The mismatch was from Stores/Categories, not Rebate Type
#       - Checklist summary just showed count, didn't specify which field
#       - User assumed Rebate Type was the problem
#     * THE FIX: Same as Fix 2 - fixing Locations/Categories fixes this ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
# v12.22.6 CHANGELOG (FIX: MIS ID BUTTON VALIDATOR MODE SWITCHING):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX: MIS ID Button Now Properly Switches Validator to Automation Mode
#     * ISSUE: Checklist appeared but validation ran in "manual mode"
#       - inject_checklist_banner() was called ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œ (checklist showed)
#       - BUT persistent validator (inject_mis_validation) was ALSO running
#       - That validator was in "manual mode" from previous injection
#       - Result: "Manual mode - skipping Phase 2 validation" in console
#     * ROOT CAUSE: V2 Persistent Validator Architecture
#       - inject_mis_validation() injects a validator that runs continuously
#       - Once injected, it monitors for modal open/close
#       - New checklist injection didn't notify the existing validator
#     * THE FIX: Call BOTH functions
#       - inject_checklist_banner() ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ visual checklist panel
#       - inject_mis_validation(expected_data) ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ sends message to switch mode
#       - V2 architecture: If validator already active, just sends message
#       - Message tells validator to switch from 'manual' to 'automation'
#     * IMPLEMENTATION (line ~22380):
#       inject_checklist_banner(driver, expected_data, mode='compare')  # Visual
#       inject_mis_validation(driver, expected_data=expected_data)      # Mode switch
#     * CONSOLE OUTPUT (expected after fix):
#       [V2] ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ Validator already active, sending message instead of re-injecting
#       [V2] ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ Switched to AUTOMATION mode
#       [MIS-VALIDATION] Validation mode: automation  (NOT manual!)
#     * RESULT:
#       - Checklist panel appears ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Validator runs in automation mode ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Phase 2 validation (all fields including After Wholesale) ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
# v12.22.5 CHANGELOG (FIX: MIS ID BUTTON VALIDATION + CHECKLIST):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX: MIS ID Button Now Uses Same Validation as Compare to Google Sheet
#     * ISSUE: MIS ID button click had broken validation
#       - After Wholesale toggle not being validated
#       - Checklist popup not appearing
#       - Banner said "Check Deal Entry Checklist" but checklist didn't exist
#     * ROOT CAUSE: Two separate validation systems
#       - MIS ID button used: inject_mis_validation() ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ summary banner only
#       - Compare to Google Sheet used: inject_checklist_banner() ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ full checklist
#       - inject_mis_validation() NEVER called inject_checklist_banner()
#     * THE FIX: Unified validation system (Option B)
#       - MIS ID button now calls inject_checklist_banner() directly
#       - Same validation logic as Compare to Google Sheet button
#       - No more duplicate validation code paths
#     * IMPLEMENTATION (line ~22328):
#       - OLD: inject_mis_validation(driver, expected_data=expected_data)
#       - NEW: inject_checklist_banner(driver, expected_data, mode='compare')
#       - Fallback: If checklist fails, uses inject_mis_validation() for basic validation
#       - No row data: Still uses inject_mis_validation() for Rebate Type + Weekday only
#     * CONSOLE OUTPUT:
#       [MIS LOOKUP] Injecting checklist banner with row data
#       [MIS LOOKUP] Expected: Brand=Stiiizy, Weekday=Monday
#       [MIS LOOKUP] After Wholesale: True
#       [MIS LOOKUP] ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ Checklist banner injected for MIS ID 12345
#     * RESULT:
#       - MIS ID button shows same checklist popup as Compare to Google Sheet ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - After Wholesale toggle now validated properly ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - All field mismatches visible in checklist panel ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Single unified validation system (no duplication) ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
# v12.22.4 CHANGELOG (FIX: WEEKLY DEALS USE COLUMN A FOR WEEKDAY):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX: Weekly Deals Now Read Weekday from Column A Instead of Column K
#     * ISSUE: Weekly deals incorrectly used Column K ('Weekday/ Day of Month')
#       - Column A header: "Weekday" (correct for Weekly)
#       - Column K header: "Weekday/ Day of Month" (correct for Monthly/Sale)
#       - get_col() checked Column K FIRST, so Weekly used wrong column
#     * ROOT CAUSE: Column priority in get_col() calls
#       - Old: get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')
#       - Column K checked first ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ always used if data exists
#       - All sections used same priority ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ Weekly got wrong column
#     * THE FIX: Section-aware column selection
#       - Weekly: get_col(row, ['Weekday', 'Day of Week'], '') ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ Column A first
#       - Monthly/Sale: get_col(row, ['Weekday/ Day of Month', ...]) ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ Column K first
#     * LOCATIONS FIXED (10 total):
#       - Line ~4048: detect_multi_day_groups()
#       - Line ~4167: enhanced_match_mis_ids()
#       - Line ~4527: audit_google_vs_mis()
#       - Line ~5088: generate_mis_csv_with_multiday()
#       - Line ~5141: generate_mis_csv_with_multiday() inner loop
#       - Line ~21793: Zombie detection section loop
#       - Line ~26591: Section processing loop
#       - Line ~27079: Weekly processing (api_phase1_analysis)
#       - Line ~27381: Weekly processing (wk_str)
#       - Line ~28466: Weekly processing (api_split_audit)
#     * PATTERN USED:
#       if section_type == 'weekly':
#           weekday = get_col(row, ['Weekday', 'Day of Week'], '')
#       else:
#           weekday = get_col(row, ['Weekday/ Day of Month', ...], '')
#     * RESULT: Weekly deals now correctly read from Column A ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Monthly deals still use Column K (ordinals like "1st, 10th") ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Sale deals still use Column K or Column C as appropriate ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
# v12.22.3 CHANGELOG (FIX: SUGGESTIONS POPUP END DATE AUTOMATION):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX: End Date Update Button in MIS ID Suggestions Popup
#     * ISSUE: End Date "Update" button in Suggestions popup fails
#       - User clicks date ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ adjusts with dropdowns ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ clicks Update
#       - Automation fails to find MIS ID in datatable
#       - Phase 1 End Date button works fine (different code path)
#     * ROOT CAUSE: Wrong API endpoint
#       - Broken: `/api/mis/update-end-date` (has MIS ID lookup issues)
#       - Working: `/api/mis/automate-end-date` (used by Phase 1)
#     * THE FIX: Replace updateMisEndDate() to use working endpoint
#       - Changed from: `/api/mis/update-end-date`
#       - Changed to: `/api/mis/automate-end-date`
#       - Added proper loading overlay (matches Phase 1 style)
#       - Fixed date format: MM/DD/YY ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ MM/DD/YYYY (full year)
#       - Added googleRow from matchesData for better context
#     * IMPLEMENTATION (line ~12156):
#       - Gets date values from dropdown selectors (unchanged)
#       - Formats as MM/DD/YYYY (full year, not 2-digit)
#       - Calls working /api/mis/automate-end-date endpoint
#       - Shows full-screen loading overlay
#       - Updates display on success
#     * CONSOLE OUTPUT:
#       [UPDATE-END-DATE] Starting with date: 01/31/2026 MIS ID: 12345
#     * RESULT: Suggestions popup End Date button now works ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
# v12.22.2 CHANGELOG (FIX: CONTINUE ROW REBATE TYPE):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ FIX: Rebate Type Not Populating for Continue Row Create Button
#     * ISSUE: Continue row in Up-Down Planning Phase 1 ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ Create ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ Pre-Flight
#       - All fields populate correctly EXCEPT Rebate Type (empty)
#       - GAP row works fine (has Rebate Type)
#     * ROOT CAUSE (Backend): splits_required structure missing rebate fields
#       - Lines ~26817-26855: splits_required object built for each split
#       - Only `interrupting_deal` nested object had retail/wholesale/after_wholesale
#       - Main split (weekly deal) was MISSING these fields
#       - Continue rows use main split data ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ no rebate type available
#     * ROOT CAUSE (Frontend): Strict equality check
#       - Code: `if (sourceData.wholesale === 'TRUE')` 
#       - Failed if value was 'true', true (boolean), or other formats
#     * THE FIX (Backend - line ~26831):
#       Added missing fields to splits_required:
#       - 'linked_brand': weekly.get('linked_brand', ''),
#       - 'retail': weekly.get('retail', ''),
#       - 'wholesale': weekly.get('wholesale', ''),
#       - 'after_wholesale': weekly.get('after_wholesale', ''),
#     * THE FIX (Frontend - line ~9360):
#       Made rebate type detection more robust:
#       - const wholesaleVal = String(sourceData.wholesale || '').toUpperCase();
#       - const retailVal = String(sourceData.retail || '').toUpperCase();
#       - if (wholesaleVal === 'TRUE') rebateType = 'Wholesale';
#     * CONSOLE OUTPUT (after fix):
#       [AUTOMATE] Rebate Type: Wholesale (W: TRUE -> TRUE, R: FALSE -> FALSE)
#     * RESULT: Continue row Create button now populates Rebate Type ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
# v12.22.1 CHANGELOG (ENHANCEMENT: WEEKLY DEAL DATE AUTO-FILL):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸Ãƒâ€¦Ã‚Â¸Ãƒâ€šÃ‚Â¢ ENHANCEMENT: Smart Date Auto-Fill for Weekly Deals
#     * FEATURE: Automatically set Start/End dates for Weekly deals
#       - Start Date: 1st day of the month
#       - End Date: Last day of the month (handles 28/29/30/31 correctly)
#     * DATE SOURCE PRIORITY:
#       1. Primary: Parse from Google Sheet tab name (e.g., "January 2026", "Feb 2026")
#       2. Fallback: Use current date's month/year if tab parsing fails
#     * TAB NAME PARSING:
#       - Supports full month names: "January 2026", "December 2025"
#       - Supports abbreviations: "Jan 2026", "Dec 2025"
#       - Regex: /([a-zA-Z]+)\s*(\d{4})/
#       - Uses first 3 letters to match month (case-insensitive)
#     * IMPLEMENTATION (lines ~12223-12289):
#       if (sectionType === 'weekly') {
#           const tabName = document.getElementById('mis-tab')?.value || '';
#           // Parse "January 2026" -> month=0, year=2026
#           const tabMatch = tabName.match(/([a-zA-Z]+)\s*(\d{4})/);
#           // Calculate first and last day of month
#           const lastDay = new Date(targetYear, targetMonth + 1, 0).getDate();
#           startDate = `${monthNum}/01/${targetYear}`;
#           endDate = `${monthNum}/${lastDay}/${targetYear}`;
#       }
#     * CONSOLE OUTPUT:
#       [WEEKLY-DATE-FIX] Parsed tab name: January 2026 -> Month: 0, Year: 2026
#       [WEEKLY-DATE-FIX] Auto-filled dates for Weekly deal:
#         Start Date: 01/01/2026 (1st of month)
#         End Date: 01/31/2026 (last day of month)
#     * NON-WEEKLY DEALS: Unchanged behavior (parses from date_raw field)
#     * RESULT: Weekly deals auto-fill with full month date range ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#
# v12.22.0 CHANGELOG (CRITICAL FIX: MULTI-DAY DEAL WEEKDAY COLLECTION):
#   ÃƒÆ’Ã‚Â°Ãƒâ€¦Ã‚Â¸ÃƒÂ¢Ã¢â€šÂ¬Ã‚ÂÃƒâ€šÃ‚Â´ CRITICAL FIX: Multi-Day Deal Weekday Collection for Pre-Flight Popup
#     * ISSUE: Pre-Flight popup only shows ONE weekday for multi-day deals
#       - Google Sheet has a multi-day group (3 rows, same deal):
#         Row 45: Monday    - Highatus, 40% off (GROUP HEADER)
#         Row 46: Wednesday - Highatus, 40% off (GROUP MEMBER)
#         Row 47: Friday    - Highatus, 40% off (GROUP MEMBER)
#       - User clicks Create on any row in group
#       - Pre-Flight popup opens with Weekday field
#       - Expected: "Monday, Wednesday, Friday" (ALL weekdays selected)
#       - Actual: Only shows weekday of clicked row (e.g., "Monday") ÃƒÆ’Ã‚Â¢Ãƒâ€šÃ‚ÂÃƒâ€¦Ã¢â‚¬â„¢
#     * ROOT CAUSE: useUnifiedPreFlightForIDMatcher() at line ~12128
#       - Code: `const weekday = match.weekday || '';`
#       - Only reads single row's weekday, ignores group membership
#       - Doesn't check match.multi_day_group.weekdays array
#       - Result: Pre-Flight only knows about ONE weekday
#     * THE FIX: Check for multi-day group and collect ALL weekdays
#       - Detect if row is part of multi-day group via match.multi_day_group
#       - If group exists, extract weekdays array: match.multi_day_group.weekdays
#       - Filter out missing/invalid weekdays
#       - Join with comma: "Monday, Wednesday, Friday"
#       - NEW CODE (line ~12128):
#         let weekday = match.weekday || '';
#         if (match.multi_day_group && match.multi_day_group.weekdays) {
#             const weekdaysList = match.multi_day_group.weekdays.filter(
#                 w => w && !w.toLowerCase().includes('missing')
#             );
#             if (weekdaysList.length > 0) {
#                 weekday = weekdaysList.join(', ');
#                 console.log('[MULTI-DAY-FIX] Combined weekday string:', weekday);
#             }
#         }
#     * CONSOLE OUTPUT (after fix):
#       [MULTI-DAY-FIX] Group detected! group_id: 9a3d328682f4
#       [MULTI-DAY-FIX] All weekdays in group: ["Monday", "Wednesday", "Friday"]
#       [MULTI-DAY-FIX] Combined weekday string: Monday, Wednesday, Friday
#     * RESULT: Pre-Flight popup now shows ALL weekdays for multi-day deals ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Click Create on header row ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ Shows all weekdays ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Click Create on member row ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ Shows all weekdays ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - Single-day deals ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ Shows single weekday (unchanged) ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#       - openUnifiedPreFlight() already handles comma-separated weekdays ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦
#   - TECHNICAL NOTES:
#     * match.multi_day_group structure:
#       { group_id: "9a3d328682f4", weekdays: ["Monday", "Wednesday", "Friday"], is_first: true }
#     * The weekdays array is populated by backend detect_multi_day_groups()
#     * Frontend already used this pattern in display code (line ~11656)
#     * openUnifiedPreFlight() line ~9511 already splits weekday by comma
#     * No changes needed to openUnifiedPreFlight() - it's already ready!
#
# v12.21.4.2 CHANGELOG (CRITICAL FIX: LINKED BRAND AUTO-FILL):
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 10: Linked Brand Not Auto-Filling in Pre-Flight Popup
#     * ISSUE: Linked Brand dropdown shows empty, not auto-selected
#       - User clicks Create from ID Matcher
#       - Google Sheet has: Brand="Highatus", Linked Brand="Cannabiotix"
#       - Pre-Flight popup opens:
#         * Brand dropdown: empty ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#         * Linked Brand dropdown: empty ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#       - Console shows: "brandOptions: Array(0)" (empty!)
#     * ROOT CAUSE: brandOptions uses splitPlanningData.brand_list
#       - splitPlanningData is ONLY populated for Up-Down Planning tab
#       - When coming from ID Matcher, splitPlanningData is empty
#       - Result: brandOptions = [] (no brands to select from!)
#       - Code tries to select "Cannabiotix" in empty dropdown ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ fails ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#     * THE FIX: Build brandOptions from settingsCache.brandLinkedMap
#       - settingsCache.brandLinkedMap is populated by loadSettingsDropdownData()
#       - Contains: {highatus: "Cannabiotix", raw: "Cookies", ...}
#       - Extract all unique brands:
#         1. Keys = main brands (e.g., "highatus")
#         2. Values = linked brands (e.g., "Cannabiotix")
#         3. Combine both into single sorted list
#       - NEW CODE (line ~9405):
#         function getBrandOptionsFromSettings() {
#           if (!settingsCache.brandLinkedMap || Object.keys(...).length === 0) {
#             return splitPlanningData.brand_list || [];  // Fallback
#           }
#           const brandSet = new Set();
#           // Add main brands (capitalize keys)
#           Object.keys(settingsCache.brandLinkedMap).forEach(brand => {
#             const displayBrand = brand.charAt(0).toUpperCase() + brand.slice(1);
#             brandSet.add(displayBrand);
#           });
#           // Add linked brands (already capitalized)
#           Object.values(settingsCache.brandLinkedMap).forEach(linkedBrand => {
#             if (linkedBrand && linkedBrand.trim()) {
#               brandSet.add(linkedBrand.trim());
#             }
#           });
#           return Array.from(brandSet).sort();
#         }
#         const brandOptions = getBrandOptionsFromSettings();
#     * IMPLEMENTATION DETAILS:
#       - Keys in brandLinkedMap are lowercase ("highatus")
#       - Capitalize first letter for display ("Highatus")
#       - Values are already properly cased ("Cannabiotix")
#       - Use Set to avoid duplicates
#       - Sort alphabetically for better UX
#       - Fallback to splitPlanningData if settings not loaded
#     * CONSOLE OUTPUT (after fix):
#       [PRE-FLIGHT] Brand options from Settings: 45 brands
#       [LINKED-BRAND-DROPDOWN] data.linked_brand: Cannabiotix
#       [LINKED-BRAND-DROPDOWN] brandOptions: Array(45)  ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â NOW HAS OPTIONS!
#       [LINKED-BRAND-DROPDOWN] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ SELECTED: "Cannabiotix" (matches...)
#     * RESULT: Brand and Linked Brand dropdowns now populated ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - Works for ID Matcher Create button ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - Works for Up-Down Planning Create button ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - Works for Suggestions popup Create button ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - Linked brand auto-selected correctly ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   - USER IMPACT:
#     * Linked Brand dropdown now has options ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Linked Brand auto-fills from Google Sheet ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Brand dropdown also populated from Settings ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Works consistently across all Create button locations ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * No more empty dropdowns in Pre-Flight popup ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   - TECHNICAL NOTES:
#     * getBrandOptionsFromSettings() helper function added
#     * Extracts brands from settingsCache.brandLinkedMap (both keys and values)
#     * Used by both Brand dropdown and Linked Brand dropdown
#     * Capitalizes main brands (keys) for proper display
#     * Preserves casing for linked brands (values)
#     * Returns sorted array for better UX
#     * Falls back to splitPlanningData.brand_list if settings not loaded
#     * Debug logging: "[PRE-FLIGHT] Brand options from Settings: X brands"
# v12.21.4.1 CHANGELOG (DEBUG: ENHANCED EXCEPTION LOGGING):
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â DEBUG ENHANCEMENT: Comma-Separated Exception Parsing
#     * ISSUE REPORTED: "All Locations Except: Davis, Dixon" only excludes Davis
#     * SYMPTOM: Second exception (Dixon) not being excluded
#     * DIAGNOSTIC ADDITIONS:
#       1. Enhanced regex to handle edge cases:
#          - Try: /except[:\s]+([^)]+)/i (stops at closing paren)
#          - Fallback: /except[:\s]+(.*?)$/i (capture to end)
#       2. Log raw exception string before splitting:
#          console.log('Raw exception string:', JSON.stringify(exceptionsStr))
#       3. Added empty string filter after split:
#          .filter(s => s.length > 0)
#       4. Per-store detailed logging:
#          - Shows each store being checked
#          - Shows which exception it matches (if any)
#          - Example output:
#            ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ EXCLUDING: "Davis" (matches exception "Davis")
#            ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ EXCLUDING: "Dixon" (matches exception "Dixon")
#            ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ KEEPING: "Beverly Hills"
#       5. Summary logging:
#          "12 total ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ 2 excluded ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ 10 remaining"
#     * EXPECTED CONSOLE OUTPUT:
#       [SMART-LOCATION] All Locations Except logic:
#         Input String: "All Locations Except: Davis, Dixon"
#         Raw exception string: "Davis, Dixon"
#         Master List: [12 stores]
#         Exceptions Raw: ["Davis", "Dixon"]
#         Exceptions Expanded: ["Davis", "Dixon"]
#         ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ EXCLUDING: "Davis" (matches exception "Davis")
#         ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ KEEPING: "Beverly Hills"
#         ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ EXCLUDING: "Dixon" (matches exception "Dixon")
#         ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ KEEPING: "El Sobrante"
#         ... (continues for all stores)
#         Final Result: [10 stores]
#         Summary: 12 total ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ 2 excluded ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ 10 remaining
#     * PURPOSE: Identify where comma-separated parsing is failing
#     * ACTION: User should check console logs and report what they see
# v12.21.4 CHANGELOG (CRITICAL FIXES: STORE MAPPING + ALL LOCATIONS EXCEPT):
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 8: Store Name Sanitization for MIS Automation
#     * ISSUE: Settings tab stores don't match MIS dropdown names
#       - Settings tab: "Fresno (Palm)" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#       - MIS dropdown: "Fresno" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - Result: Automation fails to select stores
#     * ROOT CAUSE: resolve_store_selection() returned names directly without mapping
#       - User selects "Fresno (Palm)" in Pre-Flight popup
#       - Function returns ["Fresno (Palm)"] 
#       - atomic_multi_select tries to find "Fresno (Palm)" in MIS
#       - MIS only has "Fresno" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ selection fails ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#     * THE FIX: Apply STORE_MAPPING before automation
#       - resolve_store_selection() now applies STORE_MAPPING
#       - "Fresno (Palm)" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ "Fresno" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - "Beverly" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ "Beverly Hills" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - Specific stores AND exceptions both mapped
#     * STORE_MAPPING Dictionary (lines 1627-1642, 1668-1683):
#       {
#         "West Hollywood": "West Hollywood",
#         "Beverly": "Beverly Hills",
#         "Beverly Hills": "Beverly Hills",
#         "Koreatown": "Koreatown",
#         "Riverside": "Riverside",
#         "Fresno": "Fresno",
#         "Fresno (Palm)": "Fresno",
#         "Fresno Shaw": "Fresno Shaw",
#         "Oxnard": "Oxnard",
#         "El Sobrante": "El Sobrante",
#         "Laguna Woods": "Laguna Woods",
#         "Hawthorne": "Hawthorne",
#         "Dixon": "Dixon",
#         "Davis": "Davis"
#       }
#     * IMPLEMENTATION:
#       - Case 3 (Specific Stores): Apply mapping to each store
#         mapped = STORE_MAPPING.get(store, store)
#         Logs: "Store mapping: 'Fresno (Palm)' ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ 'Fresno'"
#       - Case 2 (All Except): Apply mapping to exceptions list
#         mapped_exceptions = [STORE_MAPPING.get(exc, exc) for exc in exceptions]
#     * RESULT: Automation now works with Settings tab store names ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - User sees: "Fresno (Palm)" in Pre-Flight dropdown
#       - Backend sends: "Fresno" to MIS automation
#       - MIS finds: "Fresno" in dropdown ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 9: "All Locations Except:" Auto-Populate Logic
#     * ISSUE: Pre-Flight popup doesn't handle "All Locations Except:" correctly
#       - Google Sheet: "All Locations Except: Davis, Hawthorne"
#       - Expected: Auto-select 10 stores (all except Davis, Hawthorne)
#       - Actual: Only selected Davis and Hawthorne (backwards!) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#     * ROOT CAUSE: expandLocationCodes() had broken logic
#       - Line 9229: return exceptions.map(...) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#       - This returned ONLY the exceptions, not the remaining stores
#       - Should return: Master List MINUS exceptions
#     * THE FIX: Implement proper subtraction logic
#       Step 1: Start with Master List (all 12 stores from Settings tab)
#       Step 2: Extract exceptions ("Davis, Hawthorne")
#       Step 3: Expand exception codes ("DV" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ "Davis")
#       Step 4: Subtract exceptions from master list
#       Result: Return 10 stores (all except Davis, Hawthorne) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * IMPLEMENTATION (line ~9219):
#       const masterList = settingsCache.stores || [12 default stores];
#       const exceptions = exceptionsRaw.map(code => 
#           locationCodeMap[code.toLowerCase()] || code
#       );
#       const result = masterList.filter(store => 
#           !exceptions.some(exc => exc.toLowerCase() === store.toLowerCase())
#       );
#       return result;  // ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ All stores EXCEPT exceptions
#     * CONSOLE LOGGING:
#       [SMART-LOCATION] All Locations Except logic:
#         Master List: [Dixon, Davis, Beverly Hills, ...]
#         Exceptions Raw: ["Davis", "Hawthorne"]
#         Exceptions Expanded: ["Davis", "Hawthorne"]
#         Result (Master - Exceptions): [Dixon, Beverly Hills, El Sobrante, ...]
#     * RESULT: Pre-Flight popup now auto-selects correct stores ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - Input: "All Locations Except: Davis, Hawthorne"
#       - Auto-selected: 10 stores (all except Davis, Hawthorne) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   - USER IMPACT:
#     * Store automation now works correctly ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * No more "Could not fill Store" warnings ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * "All Locations Except:" logic works in Pre-Flight popup ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Settings tab controls store names (single source of truth) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Mapping handles special characters, parentheses, etc. ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   - TECHNICAL NOTES:
#     * STORE_MAPPING defined twice (lines 1627 and 1668) - duplicate, safe
#     * Mapping applied in resolve_store_selection() (backend automation)
#     * Subtraction logic applied in expandLocationCodes() (frontend Pre-Flight)
#     * Both use case-insensitive comparison for reliability
#     * Fallback: If store not in mapping, uses original name
#     * Debug logging shows mapping transformations and subtraction results
# v12.21.3 CHANGELOG (FINAL FIXES FOR PHASE 3):
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 5: Rebate Type Auto-Fill Not Working
#     * ISSUE: Rebate Type dropdown in Pre-Flight popup not auto-filling
#     * ROOT CAUSE: Google Sheet columns named "Wholesale?" and "Retail?" (with ?)
#       - Code was checking for 'Wholesale' and 'Retail' (without ?)
#       - Column name mismatch caused checkboxes not to be detected
#     * FIX: Check both variants - with and without question marks
#       - raw_row_data?.['Retail?'] (primary check)
#       - raw_row_data?.['Retail'] (fallback)
#       - Added console logging: [REBATE-TYPE-DEBUG] for debugging
#     * RESULT: Rebate Type now auto-fills correctly ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 6: Wrong Store List in Pre-Flight Popup
#     * ISSUE: Hardcoded store list showing wrong locations
#       - Showed: San Jose, Santa Cruz, Fresno, DTSJ, Campbell, etc.
#       - Should show: Dixon, Davis, Beverly Hills, El Sobrante, etc.
#     * ROOT CAUSE: Pre-Flight popup used hardcoded array instead of Settings tab
#       - const storeOptions = ['San Jose', 'Santa Cruz', ...] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#       - Should use: settingsCache.stores (loaded from Settings tab)
#     * FIX: Use Settings tab stores like brands/categories
#       - const storeOptions = settingsCache.stores || fallback
#       - Loads from "Store Name" column starting at row 4
#       - Same pattern as brand_list and category_list
#     * FIX: Ensure settings loaded before popup opens
#       - Added await loadSettingsDropdownData() in automateCreateDeal
#       - Adapter function already had this (useUnifiedPreFlightForIDMatcher)
#     * RESULT: Pre-Flight popup now shows correct stores from Settings tab ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ ENHANCEMENT: Compare Checklist Visibility Improvements
#     * ISSUE: Checklist sometimes not visible after Compare
#     * IMPROVEMENTS:
#       - Increased setTimeout from 500ms to 800ms (more reliable)
#       - Added multiple visibility styles: display, visibility, opacity, zIndex
#       - Enhanced console logging with DEBUG details
#       - Added search for all checklist elements if main banner not found
#       - Logs banner display/opacity status for debugging
#     * RESULT: More reliable checklist visibility + better debugging ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   - TECHNICAL DETAILS:
#     * Column name checks now resilient to ? punctuation
#     * Settings loading ensures fresh data from Google Sheet
#     * Store list dynamically updates when Settings tab changes
#     * Checklist injection verified with comprehensive logging
#   - USER IMPACT:
#     * Rebate Type auto-fills correctly from Google Sheet ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Store locations match Settings tab exactly ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Compare checklist more reliably visible ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Better console debugging for troubleshooting ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
# v12.21.2 CHANGELOG (ADDITIONAL CRITICAL FIXES):
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 3: Create Button TypeError - Non-String Discount/Vendor
#     * ISSUE: Clicking Create in Suggestions Popup caused error:
#       "TypeError: (match.discount || "").replace is not a function"
#     * ROOT CAUSE: match.discount was a number, not a string
#       - Can't call .replace() on a number
#       - adapter function assumed string values
#     * FIX: Convert to string before .replace() operation
#       - const discount = String(match.discount || '').replace('%', '');
#       - const vendorContrib = String(match.vendor_contrib || '').replace('%', '');
#     * RESULT: Create button in Suggestions Popup now works ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 4: Compare Button Checklist Visibility
#     * ISSUE: Compare button validates correctly but checklist popup not visible
#     * SYMPTOM: Console shows "Found MIS ID" but no visual checklist sidebar
#     * ROOT CAUSE: Timing issue between backend injection and frontend display
#       - Backend injects checklist banner via inject_checklist_banner()
#       - Frontend sets VALIDATION_MODE='automation' and EXPECTED_DATA
#       - But checklist banner not explicitly made visible
#     * FIX: Added 500ms setTimeout after Compare success
#       - Waits for backend injection to complete
#       - Finds checklist banner by ID: 'checklist-banner-v18'
#       - Forces visibility: display='block', opacity='1'
#       - Scrolls into view if off-screen
#       - Triggers runValidation() to update field states
#     * RESULT: Compare button now shows checklist popup ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#   - TECHNICAL DETAILS:
#     * String() wrapper safely handles null, undefined, numbers, strings
#     * setTimeout(500ms) allows backend Selenium injection time to complete
#     * scrollIntoView with smooth behavior for better UX
#     * runValidation() refresh ensures field icons update correctly
#   - USER IMPACT:
#     * Create in Suggestions Popup ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Now works (no more TypeError) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Compare to Google Sheet ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Checklist popup now visible ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Consistent validation experience across all workflows ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
# v12.21.1 CHANGELOG (CRITICAL BUGFIXES):
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 1: ID Matcher Create Button Unification
#     * ISSUE: ID Matcher was using old white "Create New Deal in MIS" popup
#     * Up-Down Planning was using new dark "Pre-Flight Confirmation" popup
#     * INCONSISTENT USER EXPERIENCE - Two different UIs for same action
#     * FIX: Created `useUnifiedPreFlightForIDMatcher()` adapter function
#       - Converts ID Matcher data format to Pre-Flight data format
#       - Calls `openUnifiedPreFlight()` (same as Up-Down Planning)
#       - BOTH tabs now use identical dark blue Pre-Flight popup ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * RESULT: Consistent UX across all Create workflows
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â°ÃƒÆ’Ã¢â‚¬Â¦Ãƒâ€šÃ‚Â¸ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â´ CRITICAL FIX 2: Compare to Google Sheet Not Finding Matches
#     * ISSUE: Backend returns mode='comparison', frontend checks mode='automation'
#     * ISSUE: Backend doesn't return expected_data in JSON
#     * RESULT: Frontend never activates automation mode, stays in manual ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢
#     * Console showed: "Found MIS ID 973" then "MIS ID not found" (contradictory!)
#     * FIX: Backend now returns:
#       - mode: 'automation' (matches frontend check) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#       - expected_data: {...} (frontend needs this) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * RESULT: Compare button correctly activates checklist validation
#   - TECHNICAL DETAILS:
#     * ID Matcher adapter extracts: brand, linked_brand, weekday, categories, 
#       locations, discount, vendor_contrib, rebate_type, after_wholesale
#     * Parses date_raw (MM/DD/YY or MM/DD/YYYY) to start_date/end_date
#     * Calls openUnifiedPreFlight with converted data
#     * Compare endpoint injection still works (v12.19 feature preserved)
#     * Compare endpoint now returns data for frontend validation activation
#   - USER IMPACT:
#     * ID Matcher Create ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Now shows dark Pre-Flight popup (consistent) ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * Compare button ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Now correctly finds matches and activates checklist ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
#     * No more "MIS ID not found" false warnings ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦
# v12.21 CHANGELOG (PHASE 3: SMART PRE-FLIGHT & DATA INTEGRITY):
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ SMART LOCATION EXPANSION:
#     * JavaScript now auto-expands location codes to full store names
#     * Mapping: "DV"ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢"Davis", "MOD"ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢"Modesto", "SJ"ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢"San Jose", etc.
#     * Pre-Flight popup automatically checks correct Store checkboxes
#     * No more manual checkbox selection for known codes
#     * Handles "All Locations" and "All Locations Except" patterns
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ SMART REBATE TYPE DETECTION:
#     * Detects "Rebate After Wholesale" vs plain "Retail"/"Wholesale"
#     * Logic: If rebate_type="Retail" AND after_wholesale=True ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ "Rebate After Wholesale"
#     * Provides clearer semantic meaning to users
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ ORIGINAL VALUE TRACKING:
#     * Added 9 hidden input fields to track original Google Sheet values:
#       - pf-original-discount
#       - pf-original-vendor
#       - pf-original-brand
#       - pf-original-linked
#       - pf-original-weekday
#       - pf-original-categories
#       - pf-original-locations
#       - pf-original-rebate-type
#       - pf-original-after-wholesale
#     * Enables "Modified" status detection in future validation
#     * Checklist can show Yellow Warning when user edits values
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ FUNCTION RENAME:
#     * showPreFlightPopup() ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ openUnifiedPreFlight()
#     * Signifies architectural shift to unified, intelligent popup
#     * Maintains all v12.20 date dropdown functionality
#   - ARCHITECTURE IMPROVEMENTS:
#     * Centralized location code mapping (locationCodeMap)
#     * Smart expansion function (expandLocationCodes)
#     * Smart rebate detection function (detectSmartRebateType)
#     * Console logging for debugging smart transformations
#   - USER EXPERIENCE:
#     * Users no longer manually select stores for known codes
#     * Dropdown auto-population now "smart" (understands abbreviations)
#     * Data integrity preserved (original values tracked)
#     * Future checklist can warn: "You changed Discount from 20% to 25%"
#   - TESTING PRIORITY:
#     * Location codes expand correctly (DV ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Davis checkbox selected)
#     * Rebate After Wholesale detected and displayed
#     * Hidden fields populated with original values
#     * Store checkboxes auto-selected based on smart expansion
# v12.20 CHANGELOG (PHASE 2: FRONTEND UNIFICATION):
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ TASK 1-3 COMPLETED IN v12.19 (Backend API Wiring):
#     * Compare endpoint now calls inject_checklist_banner with mode='compare'
#     * Checklist banner supports dual modes (create/compare)
#     * Alert banner simplified to show only status + metadata
#   ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ TASK 4 COMPLETED (Frontend Refactor):
#     * UNIFIED CREATE WORKFLOW:
#       - Both Up-Down Planning AND ID Matcher now use /api/mis/automate-create-deal
#       - Pre-Flight Popup date inputs converted to dropdowns (Month/Day/Year)
#       - executeCreateDeal() refactored to use unified endpoint
#       - Eliminates dual code paths and "Schizophrenic Routing"
#     * PRE-FLIGHT POPUP IMPROVEMENTS:
#       - Start/End Date now use dropdown selectors instead of text inputs
#       - Month: Jan-Dec dropdown
#       - Day: 1-31 dropdown (auto-populated)
#       - Year: Current year ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â±2 years
#       - Auto-initialization from data.start_date/end_date (MM/DD/YY format)
#     * ID MATCHER CREATE BUTTON:
#       - Now reads all form values (Weekday, Category, Locations, etc.)
#       - Validates required fields (Weekday, Rebate Type)
#       - Constructs proper sheetPayload matching Up-Down Planning format
#       - Calls /api/mis/automate-create-deal (same as Pre-Flight popup)
#       - Backend injects checklist banner automatically
#   - IMPACT: Single source of truth for Create logic
#     * Consistent validation across all Create buttons
#     * Checklist banner appears for ALL Create workflows
#     * Simplified maintenance (one backend endpoint instead of two)
#   - REMOVED ENDPOINTS:
#     * /api/mis/create-deal (legacy ID Matcher endpoint) - no longer called
#   - TESTING PRIORITY:
#     * Up-Down Planning Create button ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Pre-Flight popup ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Checklist appears
#     * ID Matcher Create button ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Pre-Flight popup ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Checklist appears
#     * Date dropdowns populate correctly from Google Sheet dates
#     * All field validations work consistently
# v12.19 CHANGELOG (PHASE 1: BACKEND API WIRING):
#   - Compare endpoint rewiring (Gap Analysis Task 1)
#   - Mode-aware checklist banner (Gap Analysis Task 2)
#   - Simplified alert banner (Gap Analysis Task 3)
# v12.18.2 CHANGELOG (PRE-FLIGHT CONFIRMATION):
#   - NEW: Pre-flight Confirmation Popup before Create automation
#     * Shows all values that will be entered in MIS form
#     * Allows modification of any field before proceeding
#     * Multi-select dropdowns: Weekday, Category, Store (Ctrl+Click)
#     * Single-select dropdown: Rebate Type
#     * Text inputs: Discount, Vendor Rebate
#     * Validates Weekday and Rebate Type are required
#   - FIXED: Rebate Type now reads from Column R (Wholesale) and Column T (Retail)
#   - FIXED: Weekday now reads from Column A for Weekly/Sale deals
#   - FIXED: Monthly deals auto-calculate weekday from date range
#   - IMPROVED: tier1_deals and weekly_deals now include all rebate fields
#   - IMPROVED: interrupting_deal dict now includes weekday, retail, wholesale fields
# v12.18.1 CHANGELOG (CHECKLIST BANNER IMPROVEMENTS):
#   - FIXED: Weekday now passed from interrupting_deal for GAP rows
#   - FIXED: Linked Brand lookup from Settings tab when not in sheet_data
#   - FIXED: Rebate Type fields (retail/wholesale/after_wholesale) added to interrupting_deal
#   - FIXED: Vendor Rebate validation with proper percentage normalization
#   - FIXED: Linked Brand handles "no linked brand" case (empty = correct)
#   - NEW: Category shows partial progress (2/4 selected) with color coding
#     * Green text for matched categories
#     * Yellow text for still-needed categories
#     * Red text for extra (wrong) categories
#   - NEW: Discount and Vendor Rebate now auto-filled again
#   - IMPROVED: Debug logging shows sourceData and sheetPayload in console
# v12.18 CHANGELOG (CHECKLIST BANNER):
#   - NEW: Checklist Banner for Up-Down Planning Create button
#     * Shows all expected values in a floating checklist panel
#     * Only automates 5 reliable fields: Brand, Linked Brand, Rebate Type, Start Date, End Date
#     * User manually fills: Weekday, Store, Category, Discount, Vendor Rebate, After Wholesale
#     * Live validation with checkmarks ([EMOJI] correct, [EMOJI] mismatch, [EMOJI] empty)
#     * Blocks save if Weekday or Rebate Type is empty
#   - NEW: inject_checklist_banner() function for validation UI
#   - FIXED: Multi-brand validation now correctly determines brand per MIS ID
#     * New get_brand_for_mis_id() helper function
#     * Parses "S1: 966, S2: 967" format to match position with brands
#     * Supports S/W/M prefixes for Sale/Weekly/Monthly deals
#   - IMPROVED: Enhanced logging for multi-brand row detection
# v12.17 CHANGELOG (POPUP & VALIDATION FIXES):
#   - FIXED: Stores dropdown now shows actual store names (Dixon, Davis, etc.)
#     * Filters "All Locations", "All Locations Except:" special values
#   - FIXED: Categories dropdown now shows actual categories (Flowers, Prerolls, etc.)
#     * Filters "All Categories", "All Categories Except:" special values
#   - FIXED: Rebate Type auto-populates from Google Sheet checkboxes
#     * Added retail, wholesale, after_wholesale fields to matchesData
#   - FIXED: Sale section dates auto-populate in Create popup
#     * Parses date_raw field from "Sale Runs:" / "Contracted Duration" column
#     * Supports "MM/DD/YY - MM/DD/YY" date range format
#   - FIXED: Validation now uses Settings tab for Linked Brand lookup
#     * Stores brand_settings in GLOBAL_DATA during matching
#     * Falls back to Settings mapping if row doesn't have Linked Brand
#   - FIXED: Validation Locations now uses resolve_location_columns()
#     * Properly handles "Same as Marketing" and exception columns
#   - NEW: Enhanced Create Deal Popup with ALL editable fields
#     * Linked Brand, Rebate Type, Weekday, After Wholesale dropdowns
#     * Category multi-select, Locations with mode selector
#     * Min/Max Weight, Discount %, Vendor % inputs
#   - NEW: /api/get-settings-dropdowns endpoint
#     * Fetches Stores, Categories, Brand[EMOJI]LinkedBrand from Settings tab
#   - NEW: JavaScript settingsCache with loadSettingsDropdownData()
# v12.15 CHANGELOG (AUTOMATION ENDPOINTS FIXED):
#   - FIXED: End Date button with comprehensive diagnostic logging
#     * 11-step logging to identify exactly where failures occur
#     * Increased modal wait from 1.0s to 2.0s
#     * Added explicit clickability verification before interaction
#     * Added before/after value logging for debugging
#   - FIXED: Phase 1 Create Deal button now uses ROBUST atomic functions
#     * Copied full atomic_single_select, atomic_multi_select, atomic_text_input from ID Matcher
#     * Added weekday intersection calculation (prevents data corruption)
#     * Now fills ALL fields: Rebate Type, After Wholesale, Min/Max Weight
#     * JavaScript updated to send retail/wholesale data in payload
#   - PRESERVED: All v12.14 Sale section fixes intact
#     * Full column header 'Contracted Duration (MM/DD/YY - MM/DD/YY)' preserved
# v12.14 UP-DOWN PLANNING SALE FIX
# v12.14 CHANGELOG (UP-DOWN PLANNING SALE SECTION FIX):
#   - FIXED: Sale deals now appear in Up-Down Planning Phase 1 and Phase 2
#     * Bug: Sale deals were reading dates from Column K instead of Column C
#     * Line 25265: Changed Sale date column from 'Weekday/ Day of Month' to 'Sale Runs:'
#     * Line 25388: Fixed Phase 2 Sale date column detection
#     * Line 26551: Fixed third instance of Sale date column detection
#   - IMPACT: Sale deals now properly expand dates and detect conflicts
#     * Sale deals act as Tier 1 (like Monthly) interrupting Weekly deals
#     * Conflicts based on: Brand match + Date overlap + Location overlap
#     * Split plans generated when discount/vendor values differ
#     * Attribute comparison included for manual review decisions
#   - TECHNICAL: Section-aware column detection for tier1_deals
#     * Monthly section: Reads from Column K ('Weekday/ Day of Month')
#     * Sale section: Reads from Column C ('Sale Runs:', 'Contracted Duration')
#     * Both use proper date expansion functions (parse_monthly_dates, parse_sale_dates)
# v12.13 CHANGELOG (SALE SECTION COLUMN MAPPING FIX):
#   - FIXED: Sale section column swapping bug completely removed
#     * Bug: Lines 3532-3534 and 3887-3892 swapped Brand/Weekday columns for Sale
#     * Root Cause: Old CSV had dates+weekdays in one column, code swapped to compensate
#     * New Structure: Column C = Dates ONLY, Column K = Weekdays ONLY (decoupled)
#   - UPDATED: enhanced_match_mis_ids function
#     * Removed Brand/Weekday swap logic (lines 3531-3537)
#     * Sale section now reads Brand from Column E (correct)
#     * Sale section now reads Weekday from Column K (correct)
#   - UPDATED: audit_google_vs_mis function
#     * Removed Brand/Weekday swap logic (lines 3883-3888)
#     * Sale section now uses correct column mapping
#   - CRITICAL: Column K parsing
#     * Weekday values split ONLY by comma (,) - NOT by forward slash (/)
#     * Header is "Weekday/ Day of Month" but slash is part of header, not data
#     * Data examples: "Friday", "Friday, Saturday" (comma-separated only)
#   - CRITICAL: Column C parsing
#     * Date values are comma-separated dates: "01/16/26" or "01/16/26, 01/23/26"
#     * Header may say "Sale Runs:" or "Contracted Duration"
#     * Parse data values, ignore header text
#   - NOTE: Sale section deals are single-row entities
#     * Multi-day grouping logic does NOT apply to Sale section
#     * One row contains all dates/weekdays for that sale deal
# v12.12.13 CHANGELOG (CRITICAL BUG FIX):
#   - FIXED: Function name collision breaking Up-Down Planning tab
#     * Bug: Two functions named parse_sale_dates() with different signatures
#     * Line 3325: parse_sale_dates(date_str, target_month, target_year) -> List[date]
#     * Line 20593: parse_sale_dates(sale_str) -> list (added in v12.12.12)
#     * Python overwrote first definition, breaking 5 call sitC:/Users/Kinny/Desktop/BLAZE_BOOTSTRAP/NEWEST/TAT-Dashboard/src/main - your incomplete version - Copy.pyes expecting 3 args
#     * Error: "parse_sale_dates() takes 1 positional argument but 3 were given"
#   - SOLUTION: Renamed v12.12.12 function to parse_sale_dates_for_validation()
#     * Original function at line 3325 preserved for Split Audit date expansion
#     * Validation function renamed to avoid collision
#     * Single call site updated at line ~20687
# v12.12.12 CHANGELOG (MONTHLY + SALE DEAL VALIDATION):
#   - NEW: Section-aware validation for Monthly and Sale deals
#     * Backend detects section type from _section column added to combined_df
#     * Monthly deals: Uses "Weekday/Day of Month" column with ordinal parsing (1st, 10th)
#     * Sale deals: Uses "Sale Runs:" column with date-weekday parsing (01/16/26 - Friday)
#   - NEW: Monthly deal validation
#     * Verifies start_date == end_date (monthly deals are single-day)
#     * Calculates expected weekday from date using tab month/year
#     * Flags weekday/date mismatch if wrong weekday selected for the date
#     * Example: If 01/01/2026 entered, validates that Thursday is selected
#   - NEW: Sale deal validation
#     * Parses multiple sale dates from comma-separated format
#     * Validates date range covers all expected sale dates
#     * Validates selected weekdays match expected sale days
#     * Warns if end date extends beyond last sale date (advisory, not blocking)
#   - NEW: "Other Entries Expected" bordered section in validation banner
#     * Shows only when multiple entries needed (e.g., "1st, 10th" but only 1st validated)
#     * Displays expected Start/End Date and Weekday for remaining entries
#     * Positioned on right side of banner with distinct border for visibility
#   - BACKEND: New helper functions
#     * find_weekday_column_value(): Section-aware column detection
#     * parse_monthly_ordinals(): Extracts day numbers from "1st, 10th" strings
#     * parse_sale_dates_for_validation(): Extracts date-weekday pairs from sale date strings
#     * calculate_expected_dates(): Computes dates/weekdays based on section and tab name
#   - BACKEND: expected_data now includes
#     * section_type: 'weekly', 'monthly', or 'sale'
#     * all_expected_entries: Array of expected entry objects
#     * raw_date_value: Original value from Google Sheet
#     * tab_name: Current sheet tab for date calculations
#   - JAVASCRIPT: New date getter functions
#     * getStartDateValue(), getEndDateValue()
#     * getWeekdayFromDate(): Calculates weekday from date string
#     * findMatchingEntry(): Matches MIS dates to expected entries
#     * getOtherExpectedEntries(): Finds entries not covered by current MIS entry
# v12.12.11 CHANGELOG (VALIDATION RE-INJECT BUTTON):
#   - NEW: "Re-inject Validation" button in Audit tab
#     * Placed next to subtab buttons (visible across all Audit subtabs)
#     * Utility-style button (green/distinct color) to stand out as action, not tab
#     * Purpose: Re-inject validation code into MIS browser tab after page refresh
#     * Solves: When MIS tab refreshes/logs out, validation code disappears
#     * One-click re-injection of: Force Show Save, Compare to Google Sheet,
#       Manual Validation banner, and all validation "catch" code
#   - IMPLEMENTATION NOTES FOR FUTURE AI AGENTS:
#     * Option 1 (IMPLEMENTED): Manual button - user clicks to re-inject
#       - Simple, predictable, no race conditions
#       - User has full control over when injection happens
#       - Won't interfere with other automation operations
#     * Option 2 (FUTURE CONSIDERATION): Automatic polling/re-injection
#       - Would need background thread or JS interval to detect missing code
#       - Risks: race conditions, injection mid-operation, resource usage
#       - Would need safeguards: only poll when idle, no modal open, etc.
#       - More complex but hands-free experience
#       - If implementing Option 2, consider:
#         > Polling interval (e.g., every 5 seconds)
#         > "Is page ready?" detection (check for specific DOM elements)
#         > "Is operation in progress?" flag to prevent mid-automation injection
#         > User preference toggle to enable/disable auto-injection
# v12.12.10 CHANGELOG (AFTER WHOLESALE FIX):
#   - FIXED: After Wholesale toggle validation now works correctly
#     * Priority-based column name detection (exact match first)
#     * Direct boolean handling for Google Sheets checkboxes
#     * Column priority: "After Wholesale Discount" > "After Wholesale" > fallbacks
# v12.12.9 CHANGELOG (NOT FOUND BUTTON FIX):
#   - FIXED: "Not Found - Manual Mode" RED button now displays correctly
#     * Added notFoundMode flag to preserve RED state after exitListeningMode()
#     * Button stays RED for 5 seconds before auto-resetting
#     * exitListeningMode() now checks flag before resetting button appearance
# v12.12.8 CHANGELOG (LOCATIONS COLUMN FIX):
#   - FIXED: Locations column detection with multiple fallback names
#     * Added find_locations_value() helper function
#     * Searches: "Locations (Discount Applies at)", "Locations", "Location", etc.
#     * Handles NaN/None values properly with pd.isna() check
# v12.12.7 CHANGELOG (DISCOUNT + STORE VALIDATION FIX):
#   - FIXED: Discount column detection accepts standalone "Discount" column
#   - FIXED: Store validation with proper name mapping (Google Sheet -> MIS)
#     * "Beverly Hills" -> "Beverly", "Fresno (Palm)" -> "Fresno"
#   - FIXED: "All Locations" now accepts blank OR all 12 stores selected
# v12.11 CHANGELOG (COMPREHENSIVE BANNER - SHOWS ALL ERRORS):
#   - FIXED: Banner now shows ALL errors (critical AND advisory) in single list
#     * Was: Banner only showed advisory warnings, ignored critical errors
#     * Now: Banner shows comprehensive list of ALL issues
#     * Critical errors listed first with [EMOJI] + "(BLOCKS SAVE)"
#     * Advisory warnings listed second with [EMOJI]
#   - IMPROVED: Banner color priority
#     * RED banner: Any critical errors (even if advisory too)
#     * ORANGE banner: Only advisory warnings (no critical)
#     * GREEN banner: All fields correct
#   - IMPROVED: Banner updates for critical validation changes
#     * Change Rebate Type [EMOJI] Banner updates [EMOJI]
#     * Change Weekday [EMOJI] Banner updates [EMOJI]
#     * Any critical field change [EMOJI] Banner reflects immediately [EMOJI]
#   - ENHANCED: Comprehensive error tracking
#     * criticalErrors object: {rebateType, weekday}
#     * Deep comparison for critical validation state
#     * Banner updates when EITHER critical OR advisory changes
#   - NEW: Header shows blocking count
#     * "[EMOJI] 3 Issues Found (2 errors blocking save)"
#     * Clear indication of what blocks Save button
#   - Examples:
#     * 2 critical + 1 advisory [EMOJI] RED banner, lists all 3
#     * 0 critical + 2 advisory [EMOJI] ORANGE banner, lists both
#     * 1 critical + 0 advisory [EMOJI] RED banner, shows critical
#     * 0 critical + 0 advisory [EMOJI] GREEN banner, all correct
# v12.10.3 CHANGELOG (BANNER INITIALIZATION FIX):
#   - FIXED: Banner now appears immediately on first validation run
#     * Was: Banner missing when automation fills correctly (0 warnings [EMOJI] 0 warnings)
#     * Why: Deep compare on first run: JSON.stringify({}) === JSON.stringify({})
#     * Now: Check if banner exists, create if missing (even if warnings unchanged)
#     * Logic: if (warningsChanged || bannerMissing) { create banner }
#   - IMPROVED: Banner initialization
#     * First validation run [EMOJI] Banner created immediately [EMOJI]
#     * User makes edit [EMOJI] Banner updates correctly [EMOJI]
#     * No more "banner appears only after edit" bug [EMOJI]
#   - Added logging for initial banner creation
#     * Console shows: "Initial banner created (first validation run)"
#     * Helps debug initialization timing issues
# v12.10.2 CHANGELOG (BANNER UPDATE FIX):
#   - FIXED: Banner now updates dynamically as fields change
#     * Was: Only updated when warning COUNT changed (0[EMOJI]1, 1[EMOJI]2)
#     * Now: Updates when ANY warning CONTENT changes
#     * Uses deep comparison: JSON.stringify(warnings) vs old warnings
#     * Catches: Count changes, field changes, value changes
#   - IMPROVED: Banner update detection
#     * Before: if (warningCount !== oldWarningCount || warningCount === 0)
#     * After: if (JSON.stringify(warnings) !== JSON.stringify(oldWarnings))
#     * No more "stuck banner" after automation
#   - Examples now working:
#     * Change Brand: Stiiizy [EMOJI] Jeeter [EMOJI] Banner updates [EMOJI]
#     * Fix Brand, break Discount (1[EMOJI]1 warnings) [EMOJI] Banner updates [EMOJI]
#     * Change Discount: 20% [EMOJI] 25% [EMOJI] Banner updates [EMOJI]
#     * All correct [EMOJI] Change anything [EMOJI] Banner updates immediately [EMOJI]
# v12.10.1 CHANGELOG (SYNTAX FIX):
#   - CRITICAL: Weekday is now RED (blocks Save) like Rebate Type
#     * Weekday MUST have at least one day selected
#     * RED box appears if blank
#     * Save button hidden until at least one day selected
#     * Applies to BOTH automation AND manual mode
#   - FIXED: Multi-select detection for Weekday and Stores
#     * Proper iteration: for (let i = 0; i < select.options.length; i++)
#     * Was using for...of which didn't work properly
#     * Now detects ALL selected values correctly
#     * Added debug logging to show selected count
#   - FIXED: Categories "All Categories (Except: *)" logic
#     * "*" is now recognized as filler exception (ignored)
#     * Blank actual = "All Categories" when expected is "All Categories (Except: *)"
#     * No false warnings for this common Google Sheet pattern
#   - UPDATED: Manual mode validation
#     * Now validates: Rebate Type + Weekday (both RED, both block Save)
#     * Banner shows: "Manual mode: Validating Rebate Type + Weekday only"
#     * Was: Only Rebate Type
#   - UPDATED: Error messages
#     * hideSaveButton now shows errors for BOTH fields if invalid
#     * Banner advisory text: "can save if Rebate Type and Weekday are filled"
#     * Was: "can save if Rebate Type is filled"
#   - UPDATED: Validation loop
#     * Checks BOTH rebateValid AND weekdayValid
#     * Hide save if EITHER is invalid
#     * Show save only when BOTH are valid
#   - IMPROVED: State tracking
#     * Added weekdayValid to validation state
#     * Proper cleanup on modal close
#   - REMOVED: Duplicate validation script (723 lines deleted)
#     * Was causing confusion with multiple versions
#     * Now single clean validation script
# v12.9 CHANGELOG (PERSISTENT VALIDATION + MODE TRACKING):
#   - NEW: Persistent validation banner (ALWAYS visible until Save clicked)
#     * Green banner when all correct: "[EMOJI] All Fields Correct - Ready to Save!"
#     * Orange banner when warnings: "[EMOJI] X Fields May Need Review"
#     * Shows validation mode (Automation vs Manual)
#     * Only disappears when Save clicked or modal closed
#   - NEW: Save button detection
#     * Detects when user clicks Save button
#     * Stops validation immediately
#     * Cleans up banner and Force button
#     * Signals end of validation session
#   - NEW: Cancel button detection
#     * Detects when user clicks Cancel/Close button
#     * Clears automation expected data
#     * Switches to manual validation mode
#     * Prevents "ghosting" of old automation data
#   - NEW: Validation mode tracking (Automation vs Manual)
#     * Automation mode: Validates all fields against Google Sheet
#     * Manual mode: Only validates Rebate Type (CRITICAL)
#     * Mode displayed in banner
#     * Switches automatically on Cancel
#   - NEW: Category validation (Phase 2)
#     * Validates categories against Google Sheet
#     * Case-insensitive, order-independent
#     * Multi-select support
#     * ORANGE boxes for mismatches
#   - NEW: Linked Brand validation (Phase 2)
#     * Validates linked brand against Google Sheet
#     * ORANGE boxes for mismatches
#   - IMPROVED: Manual entry detection
#     * If user manually clicks "Add New", starts in manual mode
#     * No expected data = manual mode automatically
#   - IMPROVED: Persistent UI
#     * Banner always visible (green or orange)
#     * Force button persistent until modal close
#     * Clear feedback at all times
#   - IMPROVED: Better lifecycle management
#     * Save = end validation
#     * Cancel = switch to manual mode
#     * Modal close = full cleanup
# v12.8.3 CHANGELOG (ENHANCED VALIDATION LOGIC):
#   - FIXED: Weekday validation now case-insensitive
#     * "MONDAY" vs "Monday" vs "monday" all match correctly
#     * No false positives for different capitalization
#   - FIXED: Stores validation handles blank = "All Locations"
#     * When actual stores field is blank (no selections), validates as "All Locations"
#     * No false warning when automation correctly leaves field blank
#   - ENHANCED: Full support for "All Locations Except:" validation
#     * Validates "All Locations Except: X, Y, Z" correctly
#     * Compares expected stores (master list minus exceptions) vs actual selections
#     * Matches Python's MASTER_STORE_LIST for consistency
#     * Example: "All Locations Except: Beverly, Davis" validates correctly
#   - ENHANCED: Store validation logic with three cases:
#     * Case 1: "All Locations" [EMOJI] expects blank field
#     * Case 2: "All Locations Except: X, Y" [EMOJI] expects master list minus exceptions
#     * Case 3: Specific stores "Beverly, Davis" [EMOJI] expects exact match
#   - IMPROVED: Case-insensitive store comparisons
#     * "Beverly" vs "beverly" match correctly
#     * Order doesn't matter (Beverly, Davis == Davis, Beverly)
#   - IMPROVED: Better error messages for store mismatches
#     * Shows "(blank)" when field is empty
#     * Lists actual vs expected stores clearly
# v12.8.2 CHANGELOG (ORANGE BOX FIX + ENHANCED SUMMARY):
#   - FIXED: ORANGE boxes now properly visible on all field types
#     * Select2 dropdowns (Brand, Weekday, Stores): 3px solid orange border
#     * Input fields (Discount, Vendor Contrib): 3px solid orange border + glow
#     * Toggle (After Wholesale): Orange border on entire row
#     * Increased border width from 2px to 3px for better visibility
#     * Enhanced shadow/glow effect for prominence
#   - ENHANCED: Summary banner now shows detailed error breakdown
#     * Lists each field with Expected vs Actual values
#     * Color-coded boxes for expected/actual values
#     * Clear field names: Brand, Weekday, Stores, Discount, etc.
#     * Example: "Brand: Expected [Stiiizy], Actual [Jeeter]"
#     * Makes it easy to see what needs correction at a glance
#   - IMPROVED: Better logging for debugging
#     * Logs when ORANGE boxes are added/removed
#     * Logs field IDs and types
#     * Helps diagnose styling issues
#   - IMPROVED: Tooltip positioning and styling
#     * Works on all field types correctly
#     * Clear error messages with context
# v12.8 PHASE 2 CHANGELOG (FULL FIELD VALIDATION):
#   - NEW: Full field validation against Google Sheet data
#     * Compares ALL fields to expected values from automation
#     * Fields validated: Brand, Weekday, Discount, Vendor Contrib, Stores, After Wholesale toggle
#     * ORANGE boxes (2px solid) for mismatches (advisory, doesn't block Save)
#     * Hover tooltips showing "Expected: X, Actual: Y"
#   - NEW: Error summary banner at top of modal
#     * Shows count: "[EMOJI] 3 fields may need review"
#     * Clarifies these are advisory (can still save)
#     * Updates dynamically as fields change
#   - NEW: Smart field comparison logic
#     * Handles multi-select fields (Weekday, Stores)
#     * Compares percentages (Discount, Vendor Contrib)
#     * Validates boolean toggle (After Wholesale)
#     * Ignores blank/unselected fields (no false positives)
#   - IMPROVED: Two-tier validation system
#     * Phase 1 (RED): Rebate Type MUST be filled [EMOJI] Blocks Save
#     * Phase 2 (ORANGE): All other fields [EMOJI] Advisory only
#   - IMPROVED: Enhanced tooltips
#     * RED: "[EMOJI] Rebate Type is required!"
#     * ORANGE: "[EMOJI] Brand mismatch: Expected 'Stiiizy', found 'Jeeter'"
#   - IMPROVED: Console logging for debugging
#     * Logs all validation checks
#     * Shows which fields have warnings
#     * Helps diagnose automation issues
# v12.8.1 CHANGELOG (BUGFIX - PERSISTENT FORCE BUTTON):
#   - FIXED: Force Show Save button now persistent during entire validation session
#     * Previously: Button disappeared after being clicked
#     * Now: Button remains visible until modal closes
#     * Allows multiple uses if needed
#     * Prevents confusion if error reoccurs
#   - IMPROVED: Force button behavior more intuitive
#     * Logs when clicked (for debugging)
#     * Only removes when modal closes
#     * User can click multiple times safely
# v12.8 CHANGELOG - PHASE 1 (MIS VALIDATION SYSTEM - REBATE TYPE):
#   - NEW: MIS Creation Modal Validation System
#     * Automatically monitors when MIS creation modal is open
#     * CRITICAL validation: Rebate Type must not be "- Select -"
#     * RED box with tooltip around Rebate Type field when invalid
#     * Save button automatically hidden when validation fails
#     * Clear error message explaining the issue
#   - NEW: Force Show Save safety button
#     * Floating button (top-left) to override validation if needed
#     * Prevents soft-lock if validation glitches
#     * Removes itself after use
#   - NEW: Validation injection system
#     * JavaScript injected after automation fills form
#     * Monitors modal open/close state
#     * Validates on 500ms interval (no performance impact)
#     * Console logging for debugging
#   - NEW: Manual validation endpoint (/api/mis/inject-validation)
#     * Can be triggered independently for manual entries
#     * Enables validation without running automation
#   - IMPROVED: Prevents saving with blank Rebate Type
#     * Applies to both automation AND manual entries
#     * Visual feedback (RED box, tooltip, error message)
#     * Non-intrusive (doesn't block field interaction)
#   - PHASE 2 READY: Architecture supports full field validation
#     * Current: Rebate Type only (critical error)
#     * Future: All fields compared against Google Sheet
#     * Future: ORANGE boxes for mismatches, dates validation
# v12.7.3 CHANGELOG (SIMPLIFIED NAVIGATION):
#   - FIXED: Removed unreliable button detection completely
#   - ENHANCED: Direct navigation to creation URL
#     * URL: https://retail.blaze.me/company-promotions/promotions/add#promotion-type
#     * This URL automatically opens the discount creation interface
#     * Bypasses need to find and click "Add Company Promotions" button
#   - ENHANCED: Validates page load by waiting for discount type options
#     * Waits for BOGO/Bundle/Global/Collection buttons to appear
#     * Confirms creation interface loaded successfully
#     * More reliable than button detection
#   - IMPROVED: Cleaner, simpler, more maintainable code
#   - IMPROVED: Faster automation (no button search delays)
# v12.7.2 CHANGELOG (SMART NAVIGATION + ROBUST BUTTON SELECTOR):
#   - ENHANCED: Smart page detection before navigation
#     * Checks if already on promotions page with valid URL patterns:
#       - https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=25
#       - https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=50
#       - https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=100
#     * Verifies "Add Company Promotions" button is visible
#     * Skips navigation if both conditions met (saves time)
#   - ENHANCED: Robust button selector for "Add Company Promotions"
#     * Primary selector: Matches MUI classes + text (handles React rendering)
#     * Fallback selector: Simple text match (if primary fails)
#     * Better error messages for debugging
#     * Handles multiple HTML structures
#   - IMPROVED: Logging clarity for navigation and button detection
# v12.7.1 CHANGELOG (BUGFIX):
#   - FIXED: Title suggestions dropdown in Create popup now closes properly
#     * Closes when clicking outside the input field
#     * Closes when tabbing to another field
#     * Closes when clicking on another part of the form
#     * Uses 150ms delay to ensure click events on suggestions register first
#   - Added: hideTitleSuggestions() helper function
#   - Added: onblur handler to title input field
# v12.7 CHANGELOG (CREATE BLAZE AUTOMATION + ENHANCED UX):
#   - NEW: Auto-load existing Blaze selections from Google Sheet
#     * When opening modal, parses "Blaze Discount Title" column
#     * Validates titles against Blaze promotions
#     * Found titles [EMOJI] Added to queue normally
#     * Not found titles [EMOJI] Added with [EMOJI] warning icon, grayed out, [Create] button
#     * Not found items are removable with red [X] button
#   - NEW: [View] button on all queue, suggestion, and library items
#     * Opens existing detail modal (showDetailModal)
#     * Shows full discount details without leaving page
#   - NEW: Enhanced hover tooltips (FUTURE - PLACEHOLDER)
#     * Will show detail info + value calculations per store
#     * Currently uses existing tooltip behavior
#   - NEW: [Create] button in modal header (next to Locations)
#     * Opens creation popup form
#     * Title field: Empty with suggested variations dropdown
#     * Type dropdown: Manual selection with auto-detected suggestion text
#     * Description: Manual entry with [Autofill] button
#     * Autofill fills: Brand, Type, Value, Locations, Creation Date+Time
#   - NEW: Blaze creation automation (/api/blaze/create-discount)
#     * Switches to/opens Blaze browser tab
#     * Logs in if needed using credentials from setup
#     * Navigates to company-promotions page
#     * Clicks "Add Company Promotions" button
#     * Selects discount type from dropdown (Bundle/BOGO/Global/Collection)
#     * Fills title field
#     * PAUSES for manual completion (dates, products, locations, etc.)
#     * Future enhancement: Auto-fill remaining fields
#   - NEW: Duplicate name detection
#     * Before creating, checks if name exists in Blaze
#     * If exists: Prompt user to select existing OR continue with modified name
#     * Modified name: User can add note/suffix (e.g., "v2", "2025")
#   - NEW: Title input with undo functionality
#     * Click input [EMOJI] Shows suggested title variations
#     * Type freely [EMOJI] Can still select suggestions
#     * Select suggestion after typing [EMOJI] [Undo] button appears
#     * Click [Undo] [EMOJI] Reverts to typed text
#   - NEW: Sheet write enhancement for not-found items
#     * Writes: "Title Name (NOTE: Needs to be created)"
#     * Red text only on "(NOTE: Needs to be created)" portion
#     * Rest of title remains normal color
#   - ENHANCED: Queue now shows [Create] button for not-found items
#     * Click [Create] [EMOJI] Opens creation modal with title pre-filled
#   - ENHANCED: Suggestions/Library items now have [View] buttons
#     * Non-intrusive placement
#     * Maintains checkbox click functionality
# v12.6 CHANGELOG (UX ENHANCEMENTS + CRITICAL BUG FIX):
#   - CRITICAL BUGFIX: OK button no longer clears Blaze Discount selections
#     * approveSingleMatch() now preserves existing blaze_titles array
#     * Both multi-brand and first-approval cases updated
#     * User can now approve MIS IDs without losing Blaze discount selections
#   - NEW: Collapsible Weekday Headers in Breakdown List (default: collapsed)
#     * Cleaner view - weekday sections start collapsed
#     * Click weekday header to expand/collapse
#     * Shows deal count even when collapsed
#   - NEW: Pink Multi-Day Reference sections (default: collapsed)
#     * Multi-day deal references now have PINK background (#ffe6f0)
#     * Collapsed by default showing "Multi Day Deals Present: [brands]"
#     * Click to expand and see full reference rows
#     * Helps reduce clutter in Breakdown view
#   - ENHANCED: Scrollable Queue in Blaze Modal
#     * Queue section now scrolls after 2 visible rows
#     * Header shows counter: "Selected Queue (X items)"
#     * Prevents modal from becoming too tall
#   - ENHANCED: Full Library section now collapsible (default: collapsed)
#     * Click "Full Library" header to expand/collapse
#     * Starts collapsed to reduce initial modal height
#   - FIXED: Filter dropdown now strictly filters by brand name
#     * All filter options (NONE/BOGO/B2G1/BULK) respect brand name + alternates
#     * No more irrelevant promotions appearing in filtered results
# v12.5 CHANGELOG (BLAZE DISCOUNT TITLE INTEGRATION + BUG FIX):
#   - BUGFIX: Breakdown view now preserves Monthly and Sale sections
#     * Previously, switching to Breakdown mode deleted non-weekly rows
#     * Now saves monthly/sale rows before rebuild, re-appends after
#   - NEW: Blaze Discount Title selection in ID Matcher
#     * Blue "Blaze" button added to Actions column for each row
#     * Opens modal popup for selecting Blaze discounts to link to Google Sheet row
#     * Modal shows current row details, suggested matches, and full library
#     * Suggested matches scored by brand name appearing in Blaze promo title
#     * Full library searchable by name with status filter (All/Active/Inactive)
#     * Drag-and-drop queue to order selected titles
#     * Multiple discounts can be linked to single sheet row
#     * Auto-fetches Blaze data if not already synced (shows loading spinner)
#   - NEW: Suggestion filter dropdown (NONE/BOGO/B2G1/BULK)
#     * NONE: Default, shows all brand matches
#     * BOGO: Filters to titles containing "BOGO"
#     * B2G1: Filters to titles containing "B2G1"
#     * BULK: Filters to bulk patterns (Bulk, Mix & Match, X for $Y)
#   - NEW: Alternate Brand Names input
#     * Add alternate spellings/variations of brand name
#     * Expands suggestion search to include alternates
#     * Tags display with remove button
#   - NEW: Status filter for Full Library (All/Active/Inactive)
#   - REMOVED: 10 suggestion limit - now shows ALL matching suggestions
#   - NEW: Three separate Apply buttons in ID Matcher
#     * "Apply MIS IDs" - Only writes MIS IDs to Google Sheet
#     * "Apply Blaze Titles" - Only writes Blaze Discount Titles to sheet
#     * "Apply All" - Writes both MIS IDs and Blaze Titles
#   - NEW: Blaze Discount Title column support
#     * Auto-detects "Blaze Discount Title" column in Google Sheet
#     * Writes newline-separated titles preserving queue order
#     * Supports editing existing values before applying
#   - VISUAL: Smaller Approve/Deny buttons to fit Blaze button
#     * Approve/Deny buttons now use compact styling
#     * Blaze button shows blue outline when empty, solid blue with count when selected
#   - ENHANCED: approvedMatches now tracks both MIS IDs and Blaze titles
#     * Format: {mis_ids: [...], brands: [...], blaze_titles: [...], section: '...'}
#     * Approve/Deny buttons affect both MIS and Blaze selections
#   - NEW: /api/mis/apply-blaze-titles endpoint
#     * Writes Blaze titles to Google Sheet "Blaze Discount Title" column
#     * Preserves order from selection queue
# v12.4 CHANGELOG (MULTI-DAY REFERENCE SYSTEM):
#   - NEW: Multi-day deals now show yellow reference rows on subsequent weekdays
#     * First weekday: Full group with all members (yellow background)
#     * Subsequent weekdays: Yellow reference rows showing ONLY members for that day
#     * Yellow rows have "First instance: Monday" in Notes column
#     * Yellow row buttons (not purple) for better differentiation
#     * Orange border (#ff9800) around entire group of reference rows
#     * Reference rows appear BEFORE regular deals in each weekday section
#   - NEW: Header notes for multi-day deals
#     * Format: [Rows] Brand - D: X% V: Y% Mon, Thu
#     * Appears on ALL weekdays where the multi-day deal runs
#     * [Rows] button opens dropdown with brand-specific row buttons
#     * Multi-brand deals show "Terra...+" with full brand list in dropdown
#     * Dropdown format: "Terra [Row 10 Mon] [Row 15 Wed] [Row 20 Fri]"
#     * Notes stacked vertically for easier reading
#   - VISUAL: Weekday headers now have BRIGHT CYAN background (#00ffff)
#     * Dark blue text (#003366) for better contrast
#     * Brands list stacked vertically (numbered list)
#     * Notes stacked vertically (one per line)
#     * Stand out more clearly from deal rows
#   - LOGIC: Multi-day detection now collects ALL unique weekdays from ALL member rows
#     * Handles complex groups where members have different weekdays
#     * Correctly identifies Monday + Thursday groups even with 2+ brands
#     * Sorts weekdays in calendar order (Mon [EMOJI] Sun)
#   - FIXED: Deal count now includes yellow reference rows
#     * Monday shows: 21 deals (includes groups + singles)
#     * Thursday shows: 15 deals (includes yellow refs + regular deals)
# v12.3 CHANGELOG (MULTI-DAY GROUP FIXES):
#   - FIXED: Multi-day group deals now appear correctly in Breakdown List
#     * Group headers only have 1 cell (expand/collapse button)
#     * BUG: Cell count check (cells.length <= 3) ran BEFORE weekday extraction
#     * Result: All group headers exited early with "Not enough cells" error
#     * Solution: Move cell count check INSIDE single row branch only
#     * Group headers now: Extract groupId [EMOJI] Find members [EMOJI] Get weekday from first member
#     * Single rows now: Check cell count [EMOJI] Get weekday from row
#     * Multi-day groups appear under first weekday with all members
#     * Notes appear on subsequent weekdays with clickable row buttons
#   - FIXED: Case sensitivity bug (MONDAY vs Monday)
#     * Weekday text from cells is all caps: "MONDAY", "TUESDAY", etc.
#     * Bucket keys are proper case: "Monday", "Tuesday", etc.
#     * Solution: Normalize all weekday text to proper case before lookup
#   - FIXED: Full List not accessible after Breakdown
#     * Breakdown clears tbody, destroying original rows
#     * Solution: Save originalTableState on first breakdown trigger
#     * Full List restores from saved state
# v12.2 CHANGELOG (WEEKDAY BREAKDOWN LIST):
#   - NEW: Weekly Deals Breakdown List View
#     * Toggle between "Full List" (original) and "Breakdown List" (organized by weekday)
#     * Breakdown List organizes deals by weekday sections (Monday [EMOJI] Sunday)
#     * Each weekday header shows: deal count, brands list (tooltip), multi-day notes
#     * Multi-day deals: Full group appears under first weekday only
#     * Other weekdays show notes with clickable row buttons
#     * Single-day deals appear under their respective weekday
#     * Larger weekday text (1.4em) for better visibility
#   - SIMPLIFIED APPROACH: Breakdown reads from Full List (live tbody)
#     * Full List renders normally first (always works)
#     * Breakdown List reorganizes visible rows from live tbody
#     * No master cache - works directly with existing rendered rows
#     * filterMatchResultsBySection triggers breakdown with 50ms delay
#     * Extensive console logging added for debugging
# v12.2 CHANGELOG (CONTINUE ELIGIBILITY FIX):
#   - FIXED: ID Matcher Continue/Recycle eligibility now handles unparseable tab names gracefully
#     * Added cannotDetermineDate flag to checkContinueEligibility()
#     * When tab name can't be parsed [EMOJI] shows "? UNDETERMINED" instead of "NEW ENTRY"
#     * No longer adds "Cannot parse tab name for date" to mismatches list
#     * Prevents false "NEW ENTRY" when tab name format is non-standard
#     * Only calculates new end date when tab can be successfully parsed
# v12.1 CHANGELOG (MAUDIT + MULTI-BRAND SUPPORT):
#   - NEW: goToSheetRow() function - Click row number to open Google Sheet at that row
#   - NEW: window.globalSpreadsheetId - Stores spreadsheet ID for navigation
#   - NEW: /api/mis/load-sheet now returns spreadsheet_id
#   - NEW: autoSyncBlazeData() - Auto-syncs Blaze Company Promotions on startup if token exists
#   - NEW: MAudit Tab - Verify Google Sheet deals against MIS CSV
#     * Subtabs: "ID Matcher" and "Google > MAudit" under ID Matcher section
#     * /api/mis/maudit endpoint for verification
#     * Compares: Discount, Vendor %, Start/End Dates, Brand, Locations
#     * Groups results: Verified, Mismatches, Not Found, Missing MIS ID
#     * Clickable row numbers (goToSheetRow) and MIS IDs (lookupMisId)
#   - NEW: Multi-Brand Helper Functions
#     * parse_multi_brand() - Parses "Brand A, Brand B" into list
#     * is_multi_brand() - Detects multi-brand rows
#     * get_brand_from_mis_id() - CSV lookup for brand ownership
#     * match_mis_ids_to_brands() - Maps MIS IDs to brands
#     * format_brand_mis_ids() - Formats tagged IDs back to string
#   - NEW: parse_mis_id_cell() all_tagged field
#     * Captures ALL (tag, id) pairs in order including duplicates
#     * Supports multi-brand with duplicate tags: W1: 12345, W1: 67890
#   - NEW: ID Matcher Multi-Brand Display
#     * Each brand in multi-brand rows gets separate entry
#     * Visual badge shows brand index (e.g., "1/2", "2/2")
#     * Dashed border separates multi-brand entries
#     * current_sheet_id shows only this brand's MIS IDs
#     * enhanced_match_mis_ids() creates separate matches per brand
#   - NEW: ID Matcher Clickable MIS ID Tags
#     * Current ID column shows [W1: 12345] [W2: 67890] buttons
#     * Tags displayed in small gray text, ID in bold
#     * Matching IDs get green border, non-matching get gray
#     * Each button calls lookupMisId() to search MIS browser
# v12 CHANGELOG (TAB RESTRUCTURE + MULTI-ACCOUNT):
#   - Renamed "MIS" main tab to "Audit"
#   - Renamed "CSV Generator - Google Sheet" to "Creation Checklist"
#   - Renamed "Split Audit" to "Up-Down Planning"
#   - Removed "Google Sheet - Audit" sub-tab (no longer needed)
#   - Removed "Audit Google Sheet vs MIS .CSV" sub-tab (no longer needed)
#   - Reordered sub-tabs: Creation Checklist, ID Matcher, Up-Down Planning, Conflict Audit
#   - Replaced corrupted emoji characters with [EMOJI] placeholder
#   - NEW: Multi-Account System with GUI profile management
#     * Profile dropdown in header (Google Chrome colors)
#     * Auto-loads last used profile on startup (no CMD menu)
#     * "Register New Profile" modal with step-by-step wizard
#     * First-run modal prompts to register when no profiles exist
#     * Profile switching with restart banner
#     * "Restart Now" button for seamless profile changes
#   - NEW: Profile API endpoints:
#     * /api/profiles - List all profiles
#     * /api/profile/current - Get active profile
#     * /api/profile/switch - Switch profile (requires restart)
#     * /api/profile/register - Register new profile
#     * /api/profile/check-credentials/<handle> - Check credentials file
#     * /api/restart - Restart application
#   - NEW: Reorganized folder structure:
#     * config/google_credentials/ - OAuth JSON files
#     * config/tokens/ - Google auth tokens per profile
#     * config/blaze_configs/ - MIS/Blaze credentials per profile
#     * config/last_profile.json - Remembers last used profile
#     * chrome_profiles/ - Isolated browser profiles
#     * reports/ - All report outputs
#   - NEW: Enhanced Help modal with tabs:
#     * Troubleshooting tab with common fixes
#     * New Account Setup tab with step-by-step guide
#     * Folder Structure tab with directory layout
# v10.9 CHANGELOG (ID MATCHER SECTION-AWARE TAGS):
#   - ID MATCHER now uses section-aware tags (W1, M1, S1) instead of "Part 1:"
#   - enhanced_match_mis_ids(): Added 'section' field to each match object
#   - Frontend approveSingleMatch(): Now stores {mis_id, section} for each approval
#   - /api/mis/apply-matches: Updated to detect section and use correct tag prefix
#     * Weekly deals [EMOJI] W1:
#     * Monthly deals [EMOJI] M1:
#     * Sale deals [EMOJI] S1:
#   - /api/mis/apply-split-id: Updated to use section-based tags
#     * Accepts 'section' parameter to determine prefix
#     * Converts legacy tags (part1, part2, gap, patch) to new format
#   - Backward compatible: Legacy format (just MIS ID string) defaults to weekly
# v10.8.1 CHANGELOG (REGEX-BASED PARSING FIX):
#   - FIXED: Phase 2 not finding Original/Continuation MIS IDs
#   - Root cause: Google Sheets may return newlines as literal '\n' strings
#     which broke the line-by-line parsing
#   - Solution: Rewrote parse_mis_id_cell() to use regex patterns
#     * Finds W1:, W2:, WP:, M1:, M2:, MP:, S1:, S2:, SP: anywhere in text
#     * Works regardless of separator (newlines, commas, spaces, literal \n)
#   - Added extensive debug output: [PARSE] prefix in console logs
#   - Handles edge cases: W1 at position 1, W2 at position 2, etc.
#   - Backward compatible with legacy Part 1/Part 2/GAP/Patch format
# v10.8 CHANGELOG (SECTION-BASED TAG FORMAT):
#   - NEW TAG FORMAT: Section-based prefixes replace old Part/GAP/Patch
#     * Weekly: W1 (Original), W2 (Cont.), WP (Patch)
#     * Monthly: M1 (Original), M2 (Cont.), MP (Patch)
#     * Sale: S1 (Original), S2 (Cont.), SP (Patch)
#   - parse_mis_id_cell(): Rewritten to parse new format
#     * Returns: {weekly: {parts: [], patch: null}, monthly: {...}, sale: {...}}
#     * Backward compatible with legacy Part 1/Part 2/GAP/Patch format
#   - format_tagged_mis_cell(): Section-aware formatting
#   - update_tagged_mis_cell(): Supports w1, w2, wp, m1, m2, mp, s1, s2, sp tags
#   - formatActionLabel(): Dynamic labels based on section
#     * CREATE_PART1 [EMOJI] "Weekly (Original)" / "Monthly (Original)" / "Sale (Original)"
#     * GAP [EMOJI] Shows interrupting section name ("Monthly" / "Sale")
#     * CREATE_PART2 [EMOJI] "Weekly (Cont.)" / "Monthly (Cont.)" / "Sale (Cont.)"
#     * PATCH [EMOJI] "Weekly (Patch)" / "Monthly (Patch)" / "Sale (Patch)"
#   - Phase 1 display: Updated to use section-based IDs and labels
#   - Phase 2 verification: Uses section-aware MIS ID lookup
#   - Split data now includes 'section' field (weekly/monthly/sale)
#   - Interrupting deal MIS ID now pulled from its own row correctly
# v10.7 CHANGELOG (CRITICAL BUG FIXES):
#   - Issue 1 FIX: Disabled auto-sync Blaze on browser ready (was crashing browser)
#     * checkBrowserStatus() no longer calls fetchBlazeData(true) automatically
#     * User must manually click Initialize or Sync buttons
#   - Issue 2 FIX: Pull MIS CSV debugging enhanced
#     * Added more console output for debugging
#   - Issue 3 FIX: Added MIS Reports folder access
#     * New button to open MIS Reports folder in file explorer
#     * Shows folder path in Setup tab for easy reference
#     * API endpoints: /api/get-mis-reports-folder, /api/open-mis-reports-folder
#   - Issue 4 FIX: Phase 2 verification improvements
#     * find_mis_entry_by_id() now tries multiple ID column names
#     * Calls strip_mis_id_tag() to remove prefixes before lookup
#     * Added extensive debug output to console for troubleshooting
#     * Shows parsed MIS IDs in console for verification
# v10.6 CHANGELOG (PHASE 1/2 IMPROVEMENTS):
#   - Location NaN handling: compare_deal_attributes() now treats
#     NaN/empty/blank as "All Locations" for matching
#   - Phase 2 improvements:
#     * MIS ID column now shows clickable buttons with automation
#     * Actual (CSV) column shows tooltip with suggestions when missing
#     * Suggestion confidence colors: green 80%+, yellow 60%+, gray below
#   - Phase 1 Part 1/Part 2 assignment fix:
#     * Backend now includes parsed_mis_ids in split data
#     * Frontend correctly shows Part 1 ID for Part 1 row
#     * Part 2 row shows existing Part 2 ID (if present) or input field
#     * Same for GAP and PATCH - shows existing or input
#     * Approve/Apply buttons hidden when ID already exists (shows "Done")
# v10.5 CHANGELOG (MIS ID BROWSER FIX + AUDIT TAB FIX):
#   - MIS ID Browser Lookup: Now strips tag prefixes before searching
#     * api_mis_lookup_mis_id: Calls strip_mis_id_tag() before search
#     * api_mis_review_discrepancy: Also strips tags
#     * renderClickableMisId(): Handles newline format, strips tags for lookup
#     * renderMisIdCell(): Same updates for consistency
#   - Audit Tab Sheet Selection: Now uses current dropdown value
#     * runAudit(): Uses document.getElementById('mis-tab').value
#     * No longer relies on stale misData.tabName
#     * Added validation for empty tab selection
# v10.4 CHANGELOG (VALUE NORMALIZATION + EMOJI FIX):
#   - compare_deal_attributes(): Improved normalize_numeric_value()
#     * Handles '50%' vs '50' comparison correctly
#     * Strips 'off', 'discount' text from values
#     * Converts decimal percentages (0.50 -> 50)
#     * Added values_match() helper with tolerance
#   - Fixed all corrupted emoji characters throughout script
#     * Replaced with HTML entities or ASCII equivalents
#     * [OK] for checkmarks, [X] for errors, [!] for warnings
# v10.3 CHANGELOG (TAGGED MIS ID FORMAT):
#   - New tagged format: "Part 1: 12345\nGAP: 67890\nPart 2: 54321"
#   - parse_mis_id_cell() - Now returns 'parts', 'gaps', 'patches' as lists
#   - format_tagged_mis_cell() - Format IDs into tagged newline format
#   - update_tagged_mis_cell() - Smart merge: update tag while preserving others
#   - strip_mis_id_tag() - Strip tag prefix for display/lookup
#   - /api/mis/apply-split-id - Now accepts 'tag' param (part1, part2, gap, patch)
#   - /api/mis/apply-matches - Uses "Part 1:" tag, preserves existing content
#   - Frontend Apply buttons now send tag parameter
#   - Phase 2 verification updated for list-based parsed_ids
#   - GAP MIS ID auto-pulls from interrupting Tier 1 deal's row
#   - Backward compatible with old comma-separated format
# v10.2 CHANGELOG (PHASE 2 CSV FIX):
#   - Fixed pullMisCsvForPhase2() - now uses correct endpoint /api/mis/pull-csv
#   - Added updatePhase2CsvStatus() - syncs CSV status when switching to Phase 2
#   - Backend: Added local_csv_path check in final-check endpoint
#   - Frontend: Added pulledCSVPath fallback in runPhase2FinalCheck()
#   - Phase 2 now properly recognizes CSV loaded from Setup tab
# v10.1 CHANGELOG (PHASE 2 FINAL VERIFICATION):
#   - Added Phase 2: Final Verification tab (replaces Gap Check)
#   - Backend: parse_mis_id_cell() - Parse MIS IDs with Gap:/Patch: prefixes
#   - Backend: find_mis_entry_by_id() - Find deals in CSV by ID
#   - Backend: compare_deal_attributes() - Compare expected vs actual
#   - Backend: generate_fuzzy_suggestions() - Fallback matching when ID missing
#   - Backend: /api/mis/split-audit/final-check endpoint
#   - Frontend: runPhase2FinalCheck(), renderPhase2Results()
#   - Frontend: Fuzzy suggestion selection and approval workflow
#   - Removed Phase 3 tab (consolidated into Phase 2)
# v94 CHANGELOG (LOCATION-AWARE CONFLICT DETECTION + PATCH):
#   - Added location-aware conflict detection with store name normalization
#   - Implemented PATCH entries for partial location conflicts
#   - PATCH maintains weekly deal at non-conflicting stores during conflict
#   - Handles "All Locations", "All Locations Except:", and specific store lists
#   - Added approvePatchId() and applyPatchIdToSheet() functions
#   - Changed Conflict Deal header from yellow to RED (text-danger)
#   - Fixed column widths across all three tables (Weekly/Conflict/MIS Entry Plan)
#   - Tables now use table-layout:fixed for consistent alignment
# # v93 CHANGELOG (STABLE REBUILD):
#   - Rebuilt from V33 (last known working version)
#   - Applied ONLY backend MIS ID changes (safe Python code)
#   - NO JavaScript changes - all buttons working
#   - Emojis intact from V33
# v89 CHANGELOG (EMOJI FIX + VERIFICATION):
#   - All corrupted emojis fixed using safe character-level replacement
#   - All Phase 1 enhancements verified present and working
#   - No structural changes to preserve button/file functionality
# v88 CHANGELOG (ID MATCHER FIX + SPLIT AUDIT ENHANCEMENTS):
#   FIX: ID MATCHER - Approval now works for Sale and Monthly sections (not just Weekly)
#     - Fixed global indexing issue where approvedMatches failed for non-Weekly sections
#   ENHANCED: Split Audit Phase 1 - Conflict Groups now show additional columns:
#     - Discount Value, Vendor %, Location columns added to conflict group display
#     - MIS IDs are now clickable buttons (triggers lookupMisId like ID MATCHER)
#   ENHANCED: Split Audit Phase 1 - Part 2 MIS ID Entry:
#     - Green checkmark "Approve" button for Part 2 MIS ID input
#     - "Apply" button writes MIS ID to Google Sheet (appends comma-separated if existing)
#   ENHANCED: Split Audit Phase 1 - Clean Deals section:
#     - Now shows full column layout matching ID MATCHER tab
#     - Includes: Row, Brand, Weekday, Notes, Deal Info, Discount, Vendor %, Locations, Categories, MIS ID
# v87 (Previous): LOGIC GAP & SPLIT AUDIT
# v86 (Previous): DATE-AWARE CONFLICT DETECTION
# v85 (Previous): Google Sheet - Audit tab (pre-flight check)
# v84 (Previous): Sub-tabs for deal types in CSV Generator, ID Matcher, Audit, Conflict tabs
# Dependencies: pip install flask pandas google-auth google-auth-oauthlib google-api-python-client fuzzywuzzy python-Levenshtein openpyxl selenium undetected-chromedriver requests python-docx --break-system-packages




import os
import sys
import json
import socket
import time
import glob
import threading
import traceback
import urllib.parse as urlparse
import subprocess
import re
import hashlib
import zipfile
from pathlib import Path
from datetime import datetime, timedelta, date
from typing import Dict, List, Optional, Tuple, Any

# ============================================================================
# DEPENDENCY MANAGEMENT
# ============================================================================
def check_network() -> bool:
    try:
        socket.create_connection(("8.8.8.8", 53), timeout=3)
        return True
    except OSError:
        return False

def install_dependencies():
    required = {
        'flask': 'flask',
        'pandas': 'pandas',
        'google.auth': 'google-auth',
        'google_auth_oauthlib': 'google-auth-oauthlib',
        'googleapiclient': 'google-api-python-client',
        'fuzzywuzzy': 'fuzzywuzzy',
        'openpyxl': 'openpyxl',
        'selenium': 'selenium',
        'undetected_chromedriver': 'undetected-chromedriver',
        'requests': 'requests',
        'docx': 'python-docx'
    }
    
    missing = []
    print("[CHECK] Checking dependencies...")
    
    for import_name, pkg_name in required.items():
        try:
            __import__(import_name)
        except ImportError:
            missing.append(pkg_name)
    
    if missing:
        print(f"[INSTALL] Missing packages: {', '.join(missing)}")
        print(f"[INSTALL] Attempting auto-install...")
        
        try:
            # Try installing with --break-system-packages (for newer pip)
            subprocess.check_call(
                [sys.executable, "-m", "pip", "install"] + missing + ["--break-system-packages"]
            )
            print("[SUCCESS] Installation complete!")
        except subprocess.CalledProcessError:
            # Try without --break-system-packages (for older pip or venv)
            try:
                subprocess.check_call(
                    [sys.executable, "-m", "pip", "install"] + missing
                )
                print("[SUCCESS] Installation complete!")
            except subprocess.CalledProcessError as e:
                print(f"[ERROR] Auto-install failed. Please install manually:")
                print(f"pip install {' '.join(missing)}")
                input("Press Enter to exit...")
                sys.exit(1)

try:
    install_dependencies()
except Exception as e:
    print(f"[CRITICAL ERROR] {e}")
    traceback.print_exc()
    input("Press Enter to exit...")
    sys.exit(1)


# ============================================================================
# WINDOWS CONSOLE UTF-8 FIX
# ============================================================================
# Force UTF-8 encoding for Windows consoles to prevent mojibake
if sys.platform.startswith('win'):
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# ============================================================================
# SELF-INITIALIZATION & MULTI-ACCOUNT SYSTEM
# ============================================================================
BASE_DIR = Path(__file__).resolve().parent.parent

# Directory structure for multi-account support
CONFIG_DIR = BASE_DIR / 'config'
GOOGLE_CREDS_DIR = CONFIG_DIR / 'google_credentials'
TOKENS_DIR = CONFIG_DIR / 'tokens'
BLAZE_CONFIGS_DIR = CONFIG_DIR / 'blaze_configs'
CHROME_PROFILES_DIR = BASE_DIR / 'chrome_profiles'
REPORTS_DIR = BASE_DIR / 'reports'

# Template for blaze config
BLAZE_CONFIG_TEMPLATE = {
    "mis_username": "",
    "mis_password": "",
    "blaze_email": "",
    "blaze_password": "",
    "default_spreadsheet_id": "",
    "notes": "Fill in your MIS and Blaze credentials here"
}

def setup_environment():
    """
    Self-initialization: Create required directory structure and template files.
    Called on every startup to ensure environment is ready.
    """
    print("="*70)
    print("[INIT] Checking environment setup...")
    
    # Create all required directories
    directories = [
        CONFIG_DIR,
        GOOGLE_CREDS_DIR,
        TOKENS_DIR,
        BLAZE_CONFIGS_DIR,
        CHROME_PROFILES_DIR,
        REPORTS_DIR,
        REPORTS_DIR / 'MIS_CSV_REPORTS',
        REPORTS_DIR / 'BLAZE_CSV_REPORTS',
        REPORTS_DIR / 'BLAZE_CSV_REPORTS' / 'INVENTORY'
    ]
    
    created_dirs = []
    for dir_path in directories:
        if not dir_path.exists():
            dir_path.mkdir(parents=True, exist_ok=True)
            created_dirs.append(str(dir_path.relative_to(BASE_DIR)))
    
    if created_dirs:
        print(f"[INIT] Created directories: {', '.join(created_dirs)}")
    else:
        print("[INIT] All directories present.")
    
    # Create template blaze config if configs folder is empty
    template_file = BLAZE_CONFIGS_DIR / 'template_blaze_config.json'
    existing_configs = list(BLAZE_CONFIGS_DIR.glob('*.json'))
    
    if not existing_configs:
        with open(template_file, 'w') as f:
            json.dump(BLAZE_CONFIG_TEMPLATE, f, indent=4)
        print(f"[INIT] Created template config: {template_file.relative_to(BASE_DIR)}")
    
    print("[INIT] Environment ready.")
    print("="*70)

def get_available_profiles() -> list:
    """
    Scan tokens directory to find existing profiles.
    Returns list of email handles (e.g., ['john.doe', 'jane.smith'])
    """
    profiles = []
    if TOKENS_DIR.exists():
        for token_file in TOKENS_DIR.glob('token_*.json'):
            # Extract handle from "token_john.doe.json" -> "john.doe"
            handle = token_file.stem.replace('token_', '')
            if handle:
                profiles.append(handle)
    return sorted(profiles)

def check_credentials_for_handle(handle: str) -> bool:
    """Check if credentials file exists for the given handle."""
    creds_file = GOOGLE_CREDS_DIR / f'credentials_{handle}.json'
    return creds_file.exists()

def wait_for_credentials(handle: str):
    """Wait for user to place credentials file in the correct location."""
    creds_file = GOOGLE_CREDS_DIR / f'credentials_{handle}.json'
    
    print("\n" + "="*70)
    print(f"[SETUP] Credentials file not found for '{handle}'")
    print("="*70)
    print(f"\nPlease complete these steps:")
    print(f"  1. Download your OAuth JSON from Google Cloud Console")
    print(f"  2. Rename it to: credentials_{handle}.json")
    print(f"  3. Place it in: {GOOGLE_CREDS_DIR.relative_to(BASE_DIR)}/")
    print(f"\nExpected path: {creds_file.relative_to(BASE_DIR)}")
    print("="*70)
    return False

def get_last_used_profile() -> str:
    """Read last used profile from config file."""
    last_profile_file = CONFIG_DIR / 'last_profile.json'
    if last_profile_file.exists():
        try:
            with open(last_profile_file, 'r') as f:
                data = json.load(f)
                return data.get('last_profile', '')
        except:
            pass
    return ''

def save_last_used_profile(handle: str):
    """Save last used profile to config file."""
    last_profile_file = CONFIG_DIR / 'last_profile.json'
    try:
        with open(last_profile_file, 'w') as f:
            json.dump({'last_profile': handle}, f)
    except Exception as e:
        print(f"[WARN] Could not save last profile: {e}")

def auto_select_profile() -> dict:
    """
    Auto-select profile on startup (no interactive menu).
    Priority: last_profile.json > first available > None (first-run mode)
    """
    profiles = get_available_profiles()
    
    # Try last used profile
    last_profile = get_last_used_profile()
    if last_profile and last_profile in profiles:
        if check_credentials_for_handle(last_profile):
            print(f"[PROFILE] Auto-loaded last used profile: {last_profile}")
            save_last_used_profile(last_profile)
            return build_profile_config(last_profile)
    
    # Try first available profile with valid credentials
    for profile in profiles:
        if check_credentials_for_handle(profile):
            print(f"[PROFILE] Auto-loaded first available profile: {profile}")
            save_last_used_profile(profile)
            return build_profile_config(profile)
    
    # No valid profiles - first-run mode
    print("[PROFILE] No profiles found - running in first-run mode")
    print("[PROFILE] Please register a profile via the web interface")
    return {
        'handle': None,
        'credentials_file': None,
        'token_file': None,
        'blaze_config_file': None,
        'chrome_profile_dir': CHROME_PROFILES_DIR / 'chrome_default',
    }

def register_profile_api(handle: str) -> dict:
    """
    Register a new profile (called from API).
    Returns dict with success status and message.
    """
    import re
    
    # Validate handle
    handle = handle.strip().lower()
    if not handle:
        return {'success': False, 'error': 'Handle cannot be empty'}
    
    if not re.match(r'^[a-z0-9._-]+$', handle):
        return {'success': False, 'error': 'Handle can only contain: letters, numbers, dots, underscores, hyphens'}
    
    # Check if profile already exists
    existing = get_available_profiles()
    if handle in existing:
        return {'success': False, 'error': f'Profile "{handle}" already exists'}
    
    # Check for credentials file
    if not check_credentials_for_handle(handle):
        return {
            'success': False, 
            'error': 'credentials_not_found',
            'expected_path': str(GOOGLE_CREDS_DIR / f'credentials_{handle}.json')
        }
    
    # Create placeholder blaze config
    config_file = BLAZE_CONFIGS_DIR / f'blaze_config_{handle}.json'
    if not config_file.exists():
        with open(config_file, 'w') as f:
            config = BLAZE_CONFIG_TEMPLATE.copy()
            config['profile_handle'] = handle
            json.dump(config, f, indent=4)
    
    # Create empty token file to register the profile
    token_file = TOKENS_DIR / f'token_{handle}.json'
    if not token_file.exists():
        with open(token_file, 'w') as f:
            json.dump({}, f)
    
    return {'success': True, 'message': f'Profile "{handle}" registered successfully'}

def build_profile_config(handle: str) -> dict:
    """
    Build configuration paths for a given profile handle.
    Returns dict with all paths needed for the profile.
    """
    if handle is None:
        return {
            'handle': None,
            'credentials_file': None,
            'token_file': None,
            'blaze_config_file': None,
            'chrome_profile_dir': CHROME_PROFILES_DIR / 'chrome_default',
        }
    return {
        'handle': handle,
        'credentials_file': GOOGLE_CREDS_DIR / f'credentials_{handle}.json',
        'token_file': TOKENS_DIR / f'token_{handle}.json',
        'blaze_config_file': BLAZE_CONFIGS_DIR / f'blaze_config_{handle}.json',
        'chrome_profile_dir': CHROME_PROFILES_DIR / f'chrome_{handle}',
    }

# Run environment setup
setup_environment()

# Auto-select profile (no interactive menu)
ACTIVE_PROFILE = auto_select_profile()
if ACTIVE_PROFILE['handle']:
    print(f"[PROFILE] Active: {ACTIVE_PROFILE['handle']}")
    print(f"[PROFILE] Token: {ACTIVE_PROFILE['token_file'].name}")
    print(f"[PROFILE] Chrome: {ACTIVE_PROFILE['chrome_profile_dir'].name}")

# Dynamic path variables based on selected profile
TOKEN_FILE = ACTIVE_PROFILE['token_file']
CREDENTIALS_FILE = ACTIVE_PROFILE['credentials_file']
CHROME_PROFILE_DIR = ACTIVE_PROFILE['chrome_profile_dir']
BLAZE_CONFIG_FILE = ACTIVE_PROFILE['blaze_config_file']

# Ensure chrome profile directory exists
if CHROME_PROFILE_DIR:
    CHROME_PROFILE_DIR.mkdir(parents=True, exist_ok=True)

# ============================================================================
# CREDENTIALS LOADING (Profile-Aware)
# ============================================================================
def load_credentials_config() -> dict:
    """Load credentials from profile-specific blaze config file."""
    # v12.24.8: Guard against None config file (no profile detected)
    if BLAZE_CONFIG_FILE is None:
        print(f"[INFO] No profile configured - credentials not available")
        return {}
    if BLAZE_CONFIG_FILE.exists():
        try:
            with open(BLAZE_CONFIG_FILE, 'r') as f:
                config = json.load(f)
                print(f"[CONFIG] Loaded profile config: {BLAZE_CONFIG_FILE.name}")
                return config
        except Exception as e:
            print(f"[WARN] Failed to load profile config: {e}")
            return {}
    else:
        print(f"[INFO] No profile config found: {BLAZE_CONFIG_FILE.name}")
        return {}

# Safe imports
from flask import Flask, render_template_string, request, jsonify, send_file
import pandas as pd
import requests
from fuzzywuzzy import fuzz
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

# Selenium imports
try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException, StaleElementReferenceException
    from selenium.webdriver.support.ui import Select
    from selenium.webdriver.common.action_chains import ActionChains
    
    try:
        import undetected_chromedriver as uc
        USE_UNDETECTED = True
    except:
        USE_UNDETECTED = False
    
    SELENIUM_AVAILABLE = True
except ImportError:
    SELENIUM_AVAILABLE = False
    print("[WARN] Selenium not available")

# ============================================================================
# ADDITIONAL CONFIGURATION (Profile-Independent)
# ============================================================================
# Note: BASE_DIR, CREDENTIALS_FILE, TOKEN_FILE, CHROME_PROFILE_DIR 
# are defined dynamically above based on selected profile

BRAND_LIST_FILE = BASE_DIR / 'brand_list.txt'

# Blaze-specific (shared across profiles)
FILTERS_DIR = BASE_DIR / 'Custom_Filters'
GROUPS_FILE = BASE_DIR / 'promotion_groups.json'
BLAZE_TOKEN_FILE = BASE_DIR / 'blaze_token.json'


# Store Name Normalization Map (Google Sheet -> MIS CSV)
STORE_NAME_MAP = {
    "Beverly Hills": "Beverly",
    "Davis": "Davis",
    "Dixon": "Dixon",
    "El Sobrante": "El Sobrante",
    "Fresno (Palm)": "Fresno",
    "Fresno (Shaw)": "Fresno Shaw",
    "Hawthorne": "Hawthorne",
    "Koreatown": "Koreatown",
    "Laguna Woods": "Laguna Woods",
    "Oxnard": "Oxnard",
    "Riverside": "Riverside",
    "West Hollywood": "West Hollywood"
}

# All locations list
ALL_LOCATIONS = list(STORE_NAME_MAP.keys())

def parse_locations(location_str):
    """
    Parse location string into a set of store names.
    Handles: "All Locations", "All Locations Except: X, Y", "Store1, Store2, Store3"
    Returns: (store_set, is_all_except, excluded_stores)
    """
    if not location_str or location_str == '-':
        return set(), False, set()
    
    location_str = str(location_str).strip()
    
    # Handle "All Locations Except: X, Y, Z"
    if location_str.startswith("All Locations Except:"):
        excluded_part = location_str.replace("All Locations Except:", "").strip()
        excluded_stores = set()
        if excluded_part:
            excluded_stores = {s.strip() for s in excluded_part.split(',') if s.strip()}
        included_stores = set(ALL_LOCATIONS) - excluded_stores
        return included_stores, True, excluded_stores
    
    # Handle "All Locations"
    if location_str == "All Locations":
        return set(ALL_LOCATIONS), False, set()
    
    # Handle comma-separated list
    stores = {s.strip() for s in location_str.split(',') if s.strip()}
    return stores, False, set()

def calculate_location_conflict(weekly_locations, tier1_locations):
    """
    Calculate if locations overlap and return conflict type and details.
    Returns: (has_conflict, conflict_stores, non_conflict_stores, conflict_type)
    conflict_type: 'FULL' or 'PARTIAL' or 'NONE'
    """
    weekly_set, weekly_is_except, weekly_excluded = parse_locations(weekly_locations)
    tier1_set, tier1_is_except, tier1_excluded = parse_locations(tier1_locations)
    
    # Calculate intersection
    conflicting_stores = weekly_set & tier1_set
    
    if not conflicting_stores:
        # No overlap
        return False, set(), set(), 'NONE'
    
    # Non-conflicting stores (where weekly continues during conflict)
    non_conflicting_stores = weekly_set - tier1_set
    
    if non_conflicting_stores:
        # Partial conflict - need PATCH
        return True, conflicting_stores, non_conflicting_stores, 'PARTIAL'
    else:
        # Full conflict - all weekly locations affected
        return True, conflicting_stores, set(), 'FULL'

def format_location_set(stores, original_weekly_locations=""):
    """
    Format a set of stores back into a display string.
    If it matches "All Locations", return that. Otherwise list stores.
    """
    if not stores:
        return "-"
    
    stores_set = set(stores)
    all_locations_set = set(ALL_LOCATIONS)
    
    # If it's all locations, just say "All Locations"
    if stores_set == all_locations_set:
        return "All Locations"
    
    # If it's "All Locations Except" format
    excluded = all_locations_set - stores_set
    if excluded and len(excluded) < len(stores_set):
        # More efficient to show as "except"
        return f"All Locations Except: {', '.join(sorted(excluded))}"
    
    # Just list the stores
    return ", ".join(sorted(stores))

# MIS Exports Directory (for CSV downloads from MIS)
MIS_REPORTS_DIR = REPORTS_DIR / 'MIS_CSV_REPORTS'
MIS_REPORTS_DIR.mkdir(parents=True, exist_ok=True)

# v12.25.0: Audit Reports Directory (for audit state files and exports)
AUDIT_REPORTS_DIR = REPORTS_DIR / 'AUDIT_REPORTS'
AUDIT_REPORTS_DIR.mkdir(parents=True, exist_ok=True)

# Blaze Exports Directory (for Blaze-generated inventory reports)
BLAZE_REPORTS_DIR = REPORTS_DIR / 'BLAZE_CSV_REPORTS'
INVENTORY_DIR = BLAZE_REPORTS_DIR / 'INVENTORY'
INVENTORY_DIR.mkdir(parents=True, exist_ok=True)

TAX_CONFIG_FILE = BASE_DIR / 'tax_config.json'

# Inventory Reporter Config
INVENTORY_KEYS_FILE = BASE_DIR / 'blaze_inventory_keys.json'

# v12.24.0: Ecom Sync Keys File (for Tymber integration)
# Note: secrets/ lives at project root level (sibling to TAT-Dashboard/, not inside it)
SYNC_KEYS_FILE = BASE_DIR.parent / 'secrets' / 'sync_keys.json'


def load_sync_keys(store_name: str) -> dict | None:
    """
    v12.24.1: Load store UUID for Blaze Ecom Sync from secrets/sync_keys.json.
    
    Args:
        store_name: The store name (e.g., 'DAVIS', 'DIXON')
    
    Returns:
        dict with 'store_uuid' if found, None otherwise
    
    JSON Structure Expected:
        {
            "DAVIS": {"store_uuid": "e70c671b-8954-4524-a021-cd00a5e6b3a0"},
            "DIXON": {"store_uuid": "a6122a4f-47c9-44b9-b50b-3c1e4934c72f"}
        }
    """
    try:
        if not SYNC_KEYS_FILE.exists():
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â Sync keys file not found: {SYNC_KEYS_FILE}")
            return None
        
        with open(SYNC_KEYS_FILE, 'r') as f:
            all_keys = json.load(f)
        
        # Normalize store name for lookup (uppercase)
        store_upper = store_name.upper().strip()
        
        if store_upper not in all_keys:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â No UUID found for store: {store_name}")
            return None
        
        store_data = all_keys[store_upper]
        
        # Validate required field
        if 'store_uuid' not in store_data:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â Missing store_uuid for store: {store_name}")
            return None
        
        print(f"[ECOM-SYNC] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Loaded UUID for store: {store_name}")
        return store_data
    
    except json.JSONDecodeError as e:
        print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Invalid JSON in sync_keys.json: {e}")
        return None
    except Exception as e:
        print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Error loading sync keys: {e}")
        return None


def get_ecom_token(email: str, password: str) -> tuple[str | None, str | None]:
    """
    v12.24.3: Authenticate with Blaze Ecom Mission Control API and retrieve JWT token.
    
    Args:
        email: Blaze account email
        password: Blaze account password
    
    Returns:
        Tuple of (token, error_message). Token is None if auth fails.
    
    API Endpoint: POST https://ecom-api.blaze.me/api/v1/auth/login
    Content-Type: application/vnd.api+json (JSON:API spec)
    
    Token Location: May be in Response Headers OR Body (JSON:API varies)
    """
    login_url = "https://ecom-api.blaze.me/api/v1/auth/login"
    
    headers = {
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
    }
    
    payload = {
        "data": {
            "type": "auth",  # MUST be "auth", not "login"
            "attributes": {
                "email_or_phone": email,
                "password": password
            }
        }
    }
    
    try:
        # Debug logging (password redacted)
        debug_payload = {
            "data": {
                "type": payload["data"]["type"],
                "attributes": {
                    "email_or_phone": email,
                    "password": "***REDACTED***"
                }
            }
        }
        print(f"[ECOM-AUTH] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
        print(f"[ECOM-AUTH] Authenticating as: {email}")
        print(f"[ECOM-AUTH] Endpoint: {login_url}")
        print(f"[ECOM-AUTH] Content-Type: {headers['Content-Type']}")
        print(f"[ECOM-AUTH] Accept: {headers['Accept']}")
        print(f"[DEBUG] Auth Payload: {json.dumps(debug_payload)}")
        
        # CRITICAL: Use data=json.dumps() NOT json= to preserve Content-Type header
        response = requests.post(
            login_url, 
            headers=headers, 
            data=json.dumps(payload),
            timeout=30
        )
        
        print(f"[ECOM-AUTH] Response Status: {response.status_code}")
        print(f"[ECOM-AUTH] Response Headers: {dict(response.headers)}")
        
        if response.status_code == 200 or response.status_code == 201:
            token = None
            
            # ===== METHOD 1: Check Response Headers FIRST (Common in JSON:API) =====
            auth_header = response.headers.get('Authorization')
            if auth_header:
                token = auth_header.replace('Bearer ', '') if auth_header.startswith('Bearer ') else auth_header
                print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found in Authorization header")
            
            # Check Access-Token header (alternate pattern)
            if not token:
                access_token = response.headers.get('Access-Token')
                if access_token:
                    token = access_token
                    print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found in Access-Token header")
            
            # ===== METHOD 2: Check Response Body (multiple paths) =====
            if not token and response.text:
                print(f"[ECOM-AUTH] Response Body: {response.text[:1000]}")
                try:
                    response_data = response.json()
                    
                    # PRIORITY: Check for "jwt" key (Blaze Ecom specific)
                    if 'jwt' in response_data:
                        token = response_data['jwt']
                        print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found in: jwt key")
                    
                    # Path 1: data.attributes.token
                    if not token and 'data' in response_data:
                        data = response_data['data']
                        if isinstance(data, dict):
                            if 'attributes' in data and isinstance(data['attributes'], dict):
                                token = data['attributes'].get('token')
                                if token:
                                    print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found in data.attributes.token")
                            
                            # Path 2: data.id (some APIs return token as ID)
                            if not token and 'id' in data:
                                potential_token = data['id']
                                # Token IDs are typically long strings
                                if isinstance(potential_token, str) and len(potential_token) > 20:
                                    token = potential_token
                                    print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found in data.id")
                            
                            # Path 3: data.token
                            if not token and 'token' in data:
                                token = data['token']
                                print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found in data.token")
                    
                    # Path 4: meta.token
                    if not token and 'meta' in response_data:
                        meta = response_data['meta']
                        if isinstance(meta, dict) and 'token' in meta:
                            token = meta['token']
                            print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found in meta.token")
                    
                    # Path 5: top-level token
                    if not token and 'token' in response_data:
                        token = response_data['token']
                        print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found at top level")
                    
                    # Path 6: access_token (OAuth style)
                    if not token and 'access_token' in response_data:
                        token = response_data['access_token']
                        print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token found in access_token")
                        
                except json.JSONDecodeError as e:
                    print(f"[ECOM-AUTH] ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â Could not parse JSON response: {e}")
            
            if token:
                print(f"[ECOM-AUTH] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Token acquired (length: {len(token)})")
                print(f"[ECOM-AUTH] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
                return token, None
            else:
                print(f"[ECOM-AUTH] ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â 200 OK but no token found anywhere!")
                print(f"[ECOM-AUTH] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
                return None, "Authentication succeeded but no token in response"
        
        elif response.status_code == 401:
            print(f"[ECOM-AUTH] ÃƒÂ¢Ã‚ÂÃ…â€™ Invalid credentials (401)")
            print(f"[ECOM-AUTH] Response: {response.text[:500] if response.text else 'empty'}")
            print(f"[ECOM-AUTH] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
            return None, "Invalid Blaze credentials"
        
        elif response.status_code == 403:
            print(f"[ECOM-AUTH] ÃƒÂ¢Ã‚ÂÃ…â€™ Access forbidden")
            print(f"[ECOM-AUTH] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
            return None, "Access forbidden - check account permissions"
        
        elif response.status_code == 422:
            print(f"[ECOM-AUTH] ÃƒÂ¢Ã‚ÂÃ…â€™ Unprocessable Entity (422) - payload format issue")
            print(f"[ECOM-AUTH] Response: {response.text[:500] if response.text else 'empty'}")
            print(f"[ECOM-AUTH] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
            return None, "Payload format rejected by API"
        
        else:
            error_text = response.text[:300] if response.text else 'No response body'
            print(f"[ECOM-AUTH] ÃƒÂ¢Ã‚ÂÃ…â€™ Auth failed: {response.status_code} - {error_text}")
            print(f"[ECOM-AUTH] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
            return None, f"Auth failed ({response.status_code})"
    
    except requests.exceptions.Timeout:
        print("[ECOM-AUTH] ÃƒÂ¢Ã‚ÂÃ…â€™ Request timed out")
        return None, "Authentication timed out"
    except requests.exceptions.ConnectionError as e:
        print(f"[ECOM-AUTH] ÃƒÂ¢Ã‚ÂÃ…â€™ Connection error: {e}")
        return None, "Unable to connect to Blaze Ecom API"
    except Exception as e:
        print(f"[ECOM-AUTH] ÃƒÂ¢Ã‚ÂÃ…â€™ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        return None, f"Auth error: {str(e)}"


def trigger_ecom_sync(store_uuid: str, token: str) -> tuple[bool, str]:
    """
    v12.24.2: Trigger inventory sync to Tymber via Blaze Ecom Mission Control API.
    
    Args:
        store_uuid: The store's UUID from sync_keys.json
        token: JWT Bearer token from get_ecom_token()
    
    Returns:
        Tuple of (success, message)
    
    API Endpoint: POST https://ecom-api.blaze.me/api/v1/store/sync-requests
    Content-Type: application/vnd.api+json (JSON:API spec)
    """
    sync_url = "https://ecom-api.blaze.me/api/v1/store/sync-requests"
    
    headers = {
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json',
        'Authorization': f'Bearer {token}',
        'X-Store': store_uuid
    }
    
    payload = {
        "data": {
            "type": "store_sync_requests",
            "attributes": {
                "request_type": "on_demand"
            }
        }
    }
    
    try:
        print(f"[ECOM-SYNC] Triggering sync for store UUID: {store_uuid[:8]}...")
        print(f"[ECOM-SYNC] POST {sync_url}")
        print(f"[ECOM-SYNC] Content-Type: {headers['Content-Type']}")
        
        # CRITICAL: Use data=json.dumps() NOT json= to preserve Content-Type header
        response = requests.post(
            sync_url, 
            headers=headers, 
            data=json.dumps(payload),  # Preserve application/vnd.api+json
            timeout=60
        )
        
        print(f"[ECOM-SYNC] Response Status: {response.status_code}")
        
        if response.status_code in [200, 201, 202]:
            response_data = response.json() if response.text else {}
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Sync triggered successfully")
            return True, "Sync request accepted"
        
        elif response.status_code == 401:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Token expired or invalid")
            return False, "Token expired - try again"
        
        elif response.status_code == 403:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Forbidden - no permission for this store")
            return False, "No permission for this store"
        
        elif response.status_code == 404:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Store not found")
            return False, "Store UUID not found"
        
        elif response.status_code == 429:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Rate limited")
            return False, "Rate limited - wait before retrying"
        
        else:
            error_text = response.text[:300] if response.text else 'No details'
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Sync failed: {response.status_code} - {error_text}")
            return False, f"Sync failed ({response.status_code})"
    
    except requests.exceptions.Timeout:
        print("[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Request timed out")
        return False, "Sync request timed out"
    except requests.exceptions.ConnectionError as e:
        print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Connection error: {e}")
        return False, "Unable to connect to Blaze Ecom API"
    except Exception as e:
        print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Unexpected error: {e}")
        return False, f"Sync error: {str(e)}"

# Default Tax Rates (Hardcoded - can be overridden via tax_config.json)
DEFAULT_TAX_RATES = {
    "Beverly Hills": 1.402361,
    "Davis": 1.3820125,
    "Dixon": 1.3086281,
    "El Sobrante": 1.33816875,
    "Fresno (Palm)": 1.295866,
    "Fresno Shaw": 1.295866,
    "Hawthorne": 1.3342875,
    "Koreatown": 1.402361,
    "Laguna Woods": 1.3630375,
    "Oxnard": 1.336783,
    "Riverside": 1.30108125,
    "West Hollywood": 1.36605625
}

# Google Sheets SCOPES
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']

# Note: CHROME_PROFILE_DIR is defined dynamically based on selected profile above

# ============================================================================
# GLOBAL DATA STORE
# ============================================================================
GLOBAL_DATA = {
    'config': {
        'spreadsheet_id': '',
        'source_tab': '',
        'tax_rates': DEFAULT_TAX_RATES.copy()
    },
    'browser_instance': None,
    'browser_ready': False,
    'sheets_service': None,
    'mis': {
        'credentials': {'username': '', 'password': ''},
        'deals_data': None,
        'audit_results': [],
        'filters': {},
        'filter_groups': {}
    },
    'blaze': {
        'credentials': {'username': '', 'password': ''},
        'promotions_data': None,
        'token': None,
        'inventory_running': False,
        'inventory_start_time': None,  # Track when operation started
        'inventory_logs': [],
        'inventory_data': None,  # Legacy: Full dataset (kept for backward compatibility)
        'inventory_cache': {},  # NEW: Per-store cache { 'store_name': { 'data': df, 'timestamp': datetime } }
        'inventory_brands': {}
    }
}

# Additional tax rates (these were in the original file but after the GLOBAL_DATA definition)


# Blaze Priority Mapping (rank -> human-readable)
PRIORITY_MAP = {
    1: "1 - Highest",
    2: "2 - High",
    3: "3 - Medium",
    4: "4 - Low",
    5: "5 - Lowest"
}

# MIS Store Mapping - UPDATED
STORE_MAPPING = {
    "West Hollywood": "West Hollywood",
    "Beverly": "Beverly Hills",
    "Beverly Hills": "Beverly Hills",
    "Koreatown": "Koreatown",
    "Riverside": "Riverside",
    "Fresno": "Fresno",
    "Fresno (Palm)": "Fresno",
    "Fresno Shaw": "Fresno Shaw",
    "Oxnard": "Oxnard",
    "El Sobrante": "El Sobrante",
    "Laguna Woods": "Laguna Woods",
    "Hawthorne": "Hawthorne",
    "Dixon": "Dixon",
    "Davis": "Davis"
}

# The strict list of stores that appear in the CSV (for 'All Except' logic)
CSV_TARGET_STORES = [
    "Dixon", "Davis", "Beverly Hills", "El Sobrante", "Fresno", 
    "Fresno Shaw", "Hawthorne", "Koreatown", "Laguna Woods", 
    "Oxnard", "Riverside", "West Hollywood"
]

ALL_STORES = list(set(STORE_MAPPING.values()))

# Strict list of categories for 'All Categories' expansion
ALL_CATEGORIES = [
    "Flowers", "Smalls Flower", "Prerolls", "Preroll Packs", 
    "Infused Prerolls", "Accessories", "AIO", "Capsules", 
    "Clones", "Drinks", "Edibles", "Infused Blnt Packs", 
    "Infused Blunts", "Infused Preroll Packs", "Solvent Extracts", 
    "Solventless Extracts", "Tinctures", "Topicals", "Vape Carts 1G"
]

FILTERS_DIR.mkdir(exist_ok=True)
if not GROUPS_FILE.exists():
    with open(GROUPS_FILE, 'w') as f:
        json.dump({}, f)

# MIS Store Mapping - UPDATED
STORE_MAPPING = {
    "West Hollywood": "West Hollywood",
    "Beverly": "Beverly Hills",
    "Beverly Hills": "Beverly Hills",
    "Koreatown": "Koreatown",
    "Riverside": "Riverside",
    "Fresno": "Fresno", # Updated per request
    "Fresno (Palm)": "Fresno",
    "Fresno Shaw": "Fresno Shaw",
    "Oxnard": "Oxnard",
    "El Sobrante": "El Sobrante",
    "Laguna Woods": "Laguna Woods",
    "Hawthorne": "Hawthorne",
    "Dixon": "Dixon",
    "Davis": "Davis"
}

# The strict list of stores that appear in the CSV (for 'All Except' logic)
CSV_TARGET_STORES = [
    "Dixon", "Davis", "Beverly Hills", "El Sobrante", "Fresno", 
    "Fresno Shaw", "Hawthorne", "Koreatown", "Laguna Woods", 
    "Oxnard", "Riverside", "West Hollywood"
]

ALL_STORES = list(set(STORE_MAPPING.values()))

# Strict list of categories for 'All Categories' expansion
ALL_CATEGORIES = [
    "Flowers", "Smalls Flower", "Prerolls", "Preroll Packs", 
    "Infused Prerolls", "Accessories", "AIO", "Capsules", 
    "Clones", "Drinks", "Edibles", "Infused Blnt Packs", 
    "Infused Blunts", "Infused Preroll Packs", "Solvent Extracts", 
    "Solventless Extracts", "Tinctures", "Topicals", "Vape Carts 1G"
]

# ============================================================================
# GLOBAL STATE (UNIFIED)
# ============================================================================

# ============================================================================
# BROWSER OPERATION LOCK (Thread Safety)
# ============================================================================
BROWSER_LOCK = threading.Lock()

# ============================================================================
# LOGIN DETECTION & BACKGROUND HELPERS
# ============================================================================
def check_login_state(driver, tab_type: str) -> str:
    """
    Check if user is logged in to MIS or Blaze.
    Returns: 'logged_in', 'logged_out', or 'unknown'
    """
    try:
        if tab_type == 'mis':
            # Layer 1: URL check
            if '/login' in driver.current_url:
                return 'logged_out'
            
            # Layer 2: Form check
            try:
                driver.find_element(By.NAME, 'email')
                return 'logged_out'
            except:
                pass
            
            # Layer 3: Logged-in element check (look for daily discount page)
            try:
                driver.find_element(By.CSS_SELECTOR, '#daily-discount, .daily-discount')
                return 'logged_in'
            except:
                pass
            
            # If no indicators, assume logged in
            return 'logged_in'
                
        elif tab_type == 'blaze':
            # Layer 1: Logout URL check
            if 'action=logout' in driver.current_url:
                return 'logged_out'
            
            # Layer 2: Login form check
            try:
                driver.find_element(By.CSS_SELECTOR, 'input[type="password"]')
                return 'logged_out'
            except:
                pass
            
            # Assume logged in if no logout indicators
            return 'logged_in'
            
    except Exception as e:
        print(f"[WARN] Login state check failed: {e}")
        return 'unknown'

def find_tab_by_url(driver, url_fragment: str):
    """Find browser tab by URL fragment. Returns window handle or None."""
    try:
        original = driver.current_window_handle
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if url_fragment in driver.current_url:
                driver.switch_to.window(original)
                return handle
        driver.switch_to.window(original)
    except:
        pass
    return None

def ensure_logged_in(driver, tab_type: str, gui_username: str = '', gui_password: str = '') -> bool:
    """
    Check login state and auto-login if needed.
    Completely silent unless error occurs.
    Raises exception with user-friendly message on failure.
    
    Priority: 
    1. Try GUI credentials (from Setup tab fields)
    2. If GUI fails or empty, try JSON credentials
    3. Only try JSON if different from GUI
    """
    state = check_login_state(driver, tab_type)
    
    if state == 'logged_in':
        return True  # All good
    
    if state == 'logged_out':
        # Try GUI credentials first
        username = gui_username.strip() if gui_username else ''
        password = gui_password.strip() if gui_password else ''
        
        # If GUI credentials empty, fall back to JSON
        if not username or not password:
            creds = load_credentials_config()
            if tab_type == 'mis':
                username = creds.get('mis_username', '')
                password = creds.get('mis_password', '')
            elif tab_type == 'blaze':
                username = creds.get('blaze_username', '')
                password = creds.get('blaze_password', '')
        
        # Check if we have any credentials at all
        if not username or not password:
            if tab_type == 'mis':
                raise Exception("[!] [EMOJI][EMOJI][EMOJI][EMOJI] MIS Login Required\n\nPlease enter MIS credentials in Setup tab before using this feature.")
            elif tab_type == 'blaze':
                raise Exception("[!] [EMOJI][EMOJI][EMOJI][EMOJI] Blaze Login Required\n\nPlease enter Blaze credentials in Setup tab before using this feature.")
        
        # Attempt login
        if tab_type == 'mis':
            try:
                print(f"[AUTO-LOGIN] Attempting MIS login with {'GUI' if gui_username else 'JSON'} credentials...")
                mis_login_silent(driver, username, password)
                time.sleep(3)
                
                # Verify login succeeded
                new_state = check_login_state(driver, 'mis')
                if new_state != 'logged_in':
                    # If GUI credentials failed, try JSON if different
                    if gui_username:
                        json_creds = load_credentials_config()
                        json_user = json_creds.get('mis_username', '')
                        json_pass = json_creds.get('mis_password', '')
                        
                        if json_user and json_pass and (json_user != gui_username or json_pass != gui_password):
                            print("[AUTO-LOGIN] GUI credentials failed, trying JSON credentials...")
                            mis_login_silent(driver, json_user, json_pass)
                            time.sleep(3)
                            
                            if check_login_state(driver, 'mis') != 'logged_in':
                                raise Exception("Login verification failed with both GUI and JSON credentials")
                        else:
                            raise Exception("Login verification failed - still on login page")
                    else:
                        raise Exception("Login verification failed")
                
                print("[AUTO-LOGIN] [OK] MIS login successful")
                return True
                
            except Exception as e:
                error_msg = str(e)
                if "still on login page" in error_msg or "verification failed" in error_msg:
                    raise Exception(f"[X] MIS Login Failed\n\nCredentials did not work. Please check your username/password in Setup tab.")
                else:
                    raise Exception(f"[X] MIS Login Failed\n\n{error_msg}")
        
        elif tab_type == 'blaze':
            # For Blaze, just raise exception - token-based login handled elsewhere
            raise Exception("[!] [EMOJI][EMOJI][EMOJI][EMOJI] Blaze Session Expired\n\nPlease click 'Initialize Blaze Browser' to refresh your session.")
    
    # Unknown state - proceed cautiously
    return True

def execute_in_background(tab_type: str, operation_func, *args, **kwargs):
    """
    Execute browser operation without switching user's visible tab.
    
    Args:
        tab_type: 'mis' or 'blaze'
        operation_func: Function to execute (receives driver as first arg)
        *args, **kwargs: Additional arguments for operation_func
        gui_username: Optional GUI username from Setup tab
        gui_password: Optional GUI password from Setup tab
    
    Returns:
        dict with 'success' and either 'result' or 'error'
    """
    print(f"[BG-EXEC] Starting background operation for: {tab_type}")
    
    if not GLOBAL_DATA['browser_instance']:
        print(f"[BG-EXEC] ERROR: Browser not initialized")
        return {'success': False, 'error': 'Browser not initialized'}
    
    driver = GLOBAL_DATA['browser_instance']
    original_tab = None
    
    # Extract GUI credentials if provided
    gui_username = kwargs.pop('gui_username', '')
    gui_password = kwargs.pop('gui_password', '')
    
    try:
        original_tab = driver.current_window_handle
        print(f"[BG-EXEC] Original tab saved: {original_tab}")
    except:
        pass  # Might fail if no tabs open
    
    try:
        # Find or create target tab
        if tab_type == 'mis':
            # Use the new intelligent MIS session manager
            print(f"[BG-EXEC] Using ensure_mis_ready for MIS tab...")
            ensure_mis_ready(driver, gui_username, gui_password)
            # ensure_mis_ready leaves us on MIS tab, so get current handle
            target_tab = driver.current_window_handle
            print(f"[BG-EXEC] MIS ready, target tab: {target_tab}")
        elif tab_type == 'blaze':
            target_tab = find_tab_by_url(driver, 'blaze.me')
            if not target_tab:
                # Create new tab in background using JavaScript
                if original_tab:
                    driver.switch_to.window(original_tab)
                driver.execute_script("window.open('https://app.blaze.me', '_blank');")
                time.sleep(1)
                target_tab = driver.window_handles[-1]
            
            # Switch to target tab
            driver.switch_to.window(target_tab)
            
            # Check login for Blaze
            print(f"[BG-EXEC] Checking Blaze login status...")
            ensure_logged_in(driver, 'blaze', gui_username, gui_password)
        else:
            target_tab = original_tab
            if target_tab:
                driver.switch_to.window(target_tab)
        
        # Execute operation
        print(f"[BG-EXEC] Executing operation...")
        result = operation_func(driver, *args, **kwargs)
        print(f"[BG-EXEC] Operation complete, result: {result}")
        
        return {'success': True, 'result': result}
        
    except Exception as e:
        return {'success': False, 'error': str(e)}
        
    finally:
        # ALWAYS return to user's original tab
        if original_tab:
            try:
                driver.switch_to.window(original_tab)
            except:
                pass  # Tab might have closed

def mis_login_silent(driver, username: str, password: str):
    """Silent MIS login without tab switching visibility."""
    try:
        # Wait for login page to load
        time.sleep(1)
        
        # Find and fill email
        email_field = driver.find_element(By.NAME, 'email')
        email_field.clear()
        email_field.send_keys(username)
        
        # Find and fill password
        password_field = driver.find_element(By.NAME, 'password')
        password_field.clear()
        password_field.send_keys(password)
        
        # Submit
        password_field.submit()
        time.sleep(3)
        
        # Check if login successful
        if '/login' in driver.current_url:
            raise Exception("Still on login page after submission")
            
    except Exception as e:
        raise Exception(f"Login failed: {str(e)}")

# ============================================================================
# ============================================================================
# BLAZE HELPER FUNCTIONS
# ============================================================================
def load_groups():
    try:
        with open(GROUPS_FILE, 'r') as f:
            return json.load(f)
    except:
        return {}

def save_groups(groups_data):
    with open(GROUPS_FILE, 'w') as f:
        json.dump(groups_data, f, indent=2)

def load_stored_token() -> Optional[str]:
    """Reads the Blaze token from a local JSON file."""
    try:
        if BLAZE_TOKEN_FILE.exists():
            with open(BLAZE_TOKEN_FILE, 'r') as f:
                data = json.load(f)
                token = data.get('token')
                if token:
                    return str(token).strip()
    except Exception as e:
        print(f"[WARN] Failed to load stored token: {e}")
    return None

def save_stored_token(token: str):
    """Saves the Blaze token to a local JSON file."""
    try:
        with open(BLAZE_TOKEN_FILE, 'w') as f:
            json.dump({'token': token, 'updated': str(datetime.now())}, f)
        print("[INFO] Blaze token saved to file.")
    except Exception as e:
        print(f"[WARN] Failed to save token: {e}")

def validate_token(token: str) -> bool:
    """
    Checks if a token is valid by making a lightweight API call.
    Returns True if valid (200 OK), False otherwise.
    """
    if not token: return False
    headers = {"Authorization": f"Token {token}"}
    try:
        # We fetch 1 shop just to see if the server accepts the token
        r = requests.get("https://api.blaze.me/api/v1/mgmt/shops?start=0&limit=1", headers=headers, timeout=5)
        return r.status_code == 200
    except:
        return False

def robust_login(email: str, password: str) -> Optional[str]:
    """
    Blaze login with 'Session Check' optimization.
    1. Tries to go directly to Promotions.
    2. If redirected to Login/Logout, performs full login.
    3. Always returns 'LOGIN_SUCCESSFUL' if we end up on the right page.
    """
    driver = GLOBAL_DATA['browser_instance']
    if not driver: return None
    
    target_url = "https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=100"
    
    try:
        # 1. OPTIMIZATION: Try to access the page directly (Session Check)
        print("[LOGIN] Checking for existing session...")
        # Create tab in background
        original_handle = driver.current_window_handle
        driver.execute_script(f"window.open('{target_url}', '_blank');")
        time.sleep(1)
        # Switch to new tab
        driver.switch_to.window(driver.window_handles[-1])
        time.sleep(2) # Wait for page load
        
        current_url = driver.current_url.lower()
        
        # If we are STILL on the promotions page (or similar internal page), we are good!
        if "company-promotions" in current_url and "login" not in current_url:
            print("[LOGIN] Session active! Skipping credentials.")
            return "LOGIN_SUCCESSFUL"
            
        # 2. If we got bounced to login/logout, proceed with full login
        print("[LOGIN] Session expired or invalid. Logging in...")
        driver.get("https://retail.blaze.me/login")
        
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.NAME, "email")))
        driver.find_element(By.NAME, "email").send_keys(email)
        driver.find_element(By.NAME, "password").send_keys(password + Keys.RETURN)
        
        time.sleep(5)
        
        print("[INFO] Navigating to Promotions page to capture token...")
        driver.get(target_url)
        time.sleep(8)
        
        return "LOGIN_SUCCESSFUL"

    except Exception as e:
        print(f"[ERROR] Blaze login failed: {e}")
        return None

def analyze_blaze_network_traffic():
    """
    DIAGNOSTIC: Analyzes browser network logs to find the actual Collections API endpoint.
    Call this after navigating to Smart Collections page.
    """
    driver = GLOBAL_DATA['browser_instance']
    if not driver:
        print("[DIAG] No browser instance")
        return
    
    print("\n" + "="*70)
    print("[DIAGNOSTIC] Analyzing Blaze Network Traffic...")
    print("="*70)
    
    try:
        logs = driver.get_log('performance')
        collections_requests = []
        
        for entry in logs:
            try:
                msg = json.loads(entry['message'])['message']
                if msg['method'] == 'Network.requestWillBeSent':
                    req = msg['params']['request']
                    url = req.get('url', '')
                    
                    # Look for any request that might be collections-related
                    if 'api.blaze.me' in url and any(keyword in url.lower() for keyword in ['collection', 'smart', 'group', 'category']):
                        collections_requests.append({
                            'url': url,
                            'method': req.get('method', 'GET'),
                            'headers': req.get('headers', {}),
                            'postData': req.get('postData', None)
                        })
            except:
                continue
        
        if collections_requests:
            print(f"\n[DIAG] Found {len(collections_requests)} potential Collections API calls:")
            for idx, req in enumerate(collections_requests, 1):
                print(f"\n--- Request #{idx} ---")
                print(f"URL: {req['url']}")
                print(f"Method: {req['method']}")
                if req['postData']:
                    print(f"POST Data: {req['postData'][:200]}")
        else:
            print("[DIAG] No collections-related API calls found in logs")
            print("[DIAG] Try manually clicking around the Smart Collections page first")
        
        print("="*70 + "\n")
        
    except Exception as e:
        print(f"[DIAG] Error analyzing logs: {e}")
        traceback.print_exc()

def get_api_data(token_input):
    """
    Fetch Blaze API data with FLEXIBLE token input.
    Accepts: Dict {'promo_token': '...', 'group_token': '...'} OR single string token
    Routes requests to appropriate token based on endpoint.
    """
    # --- FLEXIBLE INPUT HANDLING ---
    if isinstance(token_input, dict):
        promo_token = token_input.get('promo_token', '')
        group_token = token_input.get('group_token', '')
        
        # Fallback if one is missing
        if not promo_token:
            promo_token = group_token
        if not group_token:
            group_token = promo_token
            
        print(f"[API] Using dual tokens: Promo={promo_token[:10]}... | Group={group_token[:10]}...")
    else:
        # Legacy single-token mode
        promo_token = str(token_input)
        group_token = str(token_input)
        print(f"[API] Using single token mode: {promo_token[:10]}...")
    
    # 1. Fetch Shops (uses promo_token)
    shops = {}
    try:
        headers = {"Authorization": f"Token {promo_token}"}
        r = requests.get("https://api.blaze.me/api/v1/mgmt/shops?start=0&limit=500", 
                        headers=headers, timeout=10)
        if r.ok:
            for s in r.json().get('values', []):
                shops[s['id']] = s['name']
        print(f"[API] [OK] Fetched {len(shops)} shops")
    except Exception as e:
        print(f"[API] [ERROR] Shops fetch failed: {e}")
    
    # 2. Fetch Collections (uses group_token)
    colls = {}
    skip = 0  # [SUCCESS] CHANGE 1: Use 'skip' instead of 'start'
    try:
        headers = {"Authorization": f"Token {group_token}"}
        
        while True:
            # [SUCCESS] CHANGE 2: Add '/search' to endpoint
            # [SUCCESS] CHANGE 3: Use 'skip=' parameter instead of 'start='
            url = f"https://api.blaze.me/api/v1/mgmt/smartcollections/search?skip={skip}&limit=200"
            r = requests.get(url, headers=headers, timeout=10)
            
            if not r.ok:
                print(f"[API] [ERROR] Collections endpoint returned {r.status_code}: {r.text[:100]}")
                break
            
            data = r.json()
            vals = data if isinstance(data, list) else data.get('values', [])
            
            if not vals:
                break
            
            for c in vals:
                c_id = c.get('id', c.get('_id'))
                c_name = c.get('name')
                if c_id and c_name:
                    colls[c_id] = c_name
            
            if len(vals) < 200:
                break
            skip += 200  # [SUCCESS] CHANGE 3b: Increment 'skip' not 'start'
        
        print(f"[API] [OK] Fetched {len(colls)} collections")
        
        # DEBUG: Print first 3 collections to verify
        if colls:
            sample = list(colls.items())[:3]
            print(f"[API] Sample collections: {sample}")
        else:
            print("[API] [!] [EMOJI][EMOJI][EMOJI][EMOJI] WARNING: Zero collections returned!")
            
    except Exception as e:
        print(f"[API] [ERROR] Collections fetch failed: {e}")
        traceback.print_exc()
    
    # 3. Fetch Promotions (uses promo_token)
    promos = []
    start = 0
    try:
        headers = {"Authorization": f"Token {promo_token}"}
        
        while True:
            r = requests.get(
                f"https://api.blaze.me/api/v1/mgmt/company/promotions?start={start}&limit=100",
                headers=headers, timeout=10
            )
            if not r.ok:
                print(f"[API] [ERROR] Promotions endpoint returned {r.status_code}")
                break
            
            vals = r.json().get('values', [])
            if not vals:
                break
            
            promos.extend(vals)
            
            if len(promos) >= r.json().get('total', 0):
                break
            start += 100
        
        print(f"[API] [OK] Fetched {len(promos)} promotions")
    except Exception as e:
        print(f"[API] [ERROR] Promotions fetch failed: {e}")
    
    return shops, colls, promos


def scrape_blaze_data_from_browser():
    """
    Retrieves Blaze Data with "Smart Collection" Page Redirect.
    UPDATED: Uses a temporary background tab for token sniffing to avoid hijacking the Dashboard.
    LOGIC UPDATE: Strictly enforces fetching fresh Smart Collections to ensure new groups appear.
    """
    driver = GLOBAL_DATA.get('browser_instance')
    if not driver:
        return None, "Browser not initialized - cannot sniff token."

    # --- HELPER: LOG SNIFFER ---
    def sniff_token_from_logs(target_endpoint):
        print(f"[TOKEN] Sniffing logs for endpoint: {target_endpoint}...")
        try:
            logs = driver.get_log('performance')
            for entry in logs:
                try:
                    message_obj = json.loads(entry['message'])
                    message = message_obj.get('message', {})
                    if message.get('method') == 'Network.requestWillBeSent':
                        req = message['params']['request']
                        url = req.get('url', '')
                        if 'api.blaze.me' in url and target_endpoint in url:
                            headers = req.get('headers', {})
                            auth = next((v for k, v in headers.items() if k.lower() == 'authorization'), None)
                            if auth and 'Token' in auth:
                                return auth.replace('Token ', '').strip()
                except: continue
        except Exception as e:
            print(f"[WARN] Log sniff error: {e}")
        return None

    # --- STEP 1: TEST EXISTING TOKEN ---
    current_token = load_stored_token() or GLOBAL_DATA['blaze'].get('token')
    shops, raw_promos = {}, []
    colls = load_groups() # Load cache first
    
    # Check if we already have a token that works for EVERYTHING
    if current_token:
        print(f"[TOKEN] Verifying current token...")
        shops, new_colls, raw_promos = get_api_data(current_token)
        
        # Merge new groups into cache
        if new_colls: 
            colls.update(new_colls)
            save_groups(colls)
        
        # LOGIC UPDATE: Ensure we actually fetched groups if we have a token
        # If new_colls is empty but we have cached groups, it implies the token 
        # failed to fetch groups (Limited Scope). We should force a refresh.
        groups_valid = False
        if new_colls and len(new_colls) > 0:
            groups_valid = True
        elif len(colls) == 0:
            # If cache is empty and API is empty, allow it (maybe truly 0 groups)
            groups_valid = True 
        
        if groups_valid and len(raw_promos) > 0:
            print("[TOKEN] Current token is VALID for both Groups and Promos. No redirect needed.")
            GLOBAL_DATA['blaze']['token'] = current_token
        else:
            print("[TOKEN] Token is PARTIAL or INVALID (Groups missing). Initiating re-scrape sequence...")
            current_token = None # Trigger scrape
            # We don't wipe 'colls' here so we preserve old names if scrape fails, 
            # but we force the scrape to try and get new ones.

    # --- STEP 2: REDIRECT SEQUENCE (If needed) ---
    if not current_token:
        print("[NAV] Token invalid or missing. Opening background tab to sniff...")
        
        # SAVE CURRENT TAB
        try:
            original_handle = driver.current_window_handle
        except:
            original_handle = driver.window_handles[0]

        # OPEN NEW TAB & SWITCH
        driver.execute_script("window.open('about:blank', '_blank');")
        time.sleep(0.5)
        new_handle = driver.window_handles[-1]
        driver.switch_to.window(new_handle)
        
        try:
            # A. Go to Smart Collections to generate the right traffic
            print("[NAV] Redirecting to Smart Collections page (Background)...")
            driver.get("https://retail.blaze.me/company-promotions/smart-collections")
            time.sleep(6) # Wait for page load & API calls
            
            # B. Sniff specifically for the smartcollections endpoint
            collections_token = sniff_token_from_logs('smartcollections')
            
            if collections_token:
                print("[TOKEN] captured fresh Collections Token!")
                current_token = collections_token
                save_stored_token(current_token)
            else:
                print("[WARN] Failed to capture token even after redirect.")
        
        except Exception as e:
            print(f"[ERROR] Background sniff failed: {e}")
            
        finally:
            # C. CLOSE TAB & RETURN
            print("[NAV] Closing background tab and returning...")
            try:
                driver.close()
                driver.switch_to.window(original_handle)
            except:
                print("[WARN] Could not switch back to original tab")

        # D. Fetch Data with new token
        if current_token:
            shops, new_colls, raw_promos = get_api_data(current_token)
            if new_colls:
                colls.update(new_colls)
                save_groups(colls)

    # --- STEP 3: PARSE DATA ---
    GLOBAL_DATA['blaze']['token'] = current_token
    
    if not raw_promos: 
        return None, "Token expired or missing. Please Login to Blaze in a new tab."

    parsed = []
    
    # Map Collection IDs to Names
    def get_group_name(gid):
        return colls.get(gid, gid) 
    
    # Helper: Format buy requirements from criteria
    def parse_buy_requirements(criteria_groups):
        requirements = []
        for cg in criteria_groups:
            rules = []
            if isinstance(cg, list): 
                rules = cg 
            elif isinstance(cg, dict): 
                rules = cg.get('criteria', [])
            
            for rule in rules:
                qty = rule.get('minimum', 1)
                items = []
                
                # Check products
                if rule.get('products'):
                    items.extend([p.get('name', 'Product') for p in rule.get('products', [])])
                
                # Check smart collections
                if rule.get('smartCollectionIds'):
                    items.extend([get_group_name(cid) for cid in rule.get('smartCollectionIds', [])])
                
                # Check categories
                if rule.get('categories'):
                    items.extend([c.get('name', 'Category') for c in rule.get('categories', [])])
                
                if items:
                    requirements.append({
                        'quantity': qty,
                        'items': items
                    })
        
        return requirements
    
    # Helper: Format time constraint
    def parse_time_constraint(tc):
        if not tc:
            return None
        return {
            'days': tc.get('daysOfWeek', []),
            'start_time': tc.get('startTime', ''),
            'end_time': tc.get('endTime', '')
        }
    
    # Helper: Parse priority with robust error handling
    def parse_priority(promo_data):
        try:
            raw_rank = int(promo_data.get('rank', 5))  # Force integer conversion
        except (ValueError, TypeError):
            raw_rank = 5  # Default safe fallback
        return PRIORITY_MAP.get(raw_rank, f"{raw_rank} (Unknown)")

    for p in raw_promos:
        try:
            target = p.get('target', {})
            shop_ids = p.get('shopIds', [])
            
            names = []
            for sid in shop_ids:
                raw_name = shops.get(sid, sid)
                # Updated Regex to remove "Davisville Business Enterprises, Inc." as well
                clean_name = re.sub(r"^(The Artist Tree|Davisville Business Enterprises, Inc\.|Club 420)\s*[--]?\s*", "", str(raw_name), flags=re.IGNORECASE).strip()
                names.append(clean_name)

            if len(names) >= 12:
                loc_display = "All Locations"
            else:
                loc_display = ', '.join(sorted(names)) if names else "Unknown"

            buy_groups = []
            c_groups = p.get('criteriaGroups', [])
            for cg in c_groups:
                rules = []
                if isinstance(cg, list): rules = cg 
                elif isinstance(cg, dict): rules = cg.get('criteria', [])
                for rule in rules:
                    for cid in rule.get('smartCollectionIds', []):
                        buy_groups.append({'id': cid, 'name': get_group_name(cid)})
            
            get_groups = []
            for cid in target.get('smartCollectionIds', []): 
                get_groups.append({'id': cid, 'name': get_group_name(cid)})

            auto_apply = p.get('autoApply', False)
            buy_requirements = parse_buy_requirements(c_groups)
            restrictions = {
                'member_groups': p.get('memberGroups', []),
                'consumer_types': p.get('consumerTypes', []),
                'sales_channels': p.get('salesChannels', [])
            }
            time_constraint = parse_time_constraint(p.get('timeConstraint'))

            parsed.append({
                'ID': p.get('id'),
                'Name': p.get('name'),
                'Status': 'Active' if p.get('active') else 'Inactive',
                'Locations': loc_display,
                'buy_groups': buy_groups, 
                'get_groups': get_groups,
                'Discount Value Type': target.get('discountType'),
                'Discount Value': target.get('discountAmt'),
                'Start Date': datetime.fromtimestamp(p.get('startDate', 0)/1000).strftime('%Y-%m-%d') if p.get('startDate') else '',
                'End Date': datetime.fromtimestamp(p.get('endDate', 0)/1000).strftime('%Y-%m-%d') if p.get('endDate') else '',
                'auto_apply': auto_apply,
                'description': p.get('description', ''),
                'buy_requirements': buy_requirements,
                'target_type': target.get('discountType', ''),
                'target_value': target.get('discountAmt', ''),
                'stackable': p.get('stackable', False),
                'apply_lowest_price_first': p.get('applyLowestPriceFirst', False),
                'priority': parse_priority(p),
                'enable_promo_code': p.get('enablePromoCode', False),
                'promo_code': p.get('promoCode', ''),
                'max_uses': p.get('maxUses', 'Unlimited'),
                'max_uses_per_consumer': p.get('maxUsesPerConsumer', 'Unlimited'),
                'restrictions': restrictions,
                'time_constraint': time_constraint,
            })
        except Exception as inner_e:
            print(f"[ERROR] Parsing promotion failed: {inner_e}")
            continue

    return parsed, None

def update_single_promotion_in_memory(promo_id: str):
    """
    Fetches a single promotion by ID and updates the global DataFrame.
    """
    # Try global memory first, then file storage
    token = GLOBAL_DATA['blaze'].get('token') or load_stored_token()
    
    if not token:
        print("[WARN] No token available for single-row update.")
        return

    headers = {"Authorization": f"Token {token}"}
    try:
        # Fetch just the one item
        url = f"https://api.blaze.me/api/v1/mgmt/company/promotions/{promo_id}"
        print(f"[SYNC] Fetching single row: {promo_id}...")
        r = requests.get(url, headers=headers)
        
        if not r.ok:
            print(f"[WARN] Failed to fetch row {promo_id}: {r.status_code}")
            return

        p = r.json()
        target = p.get('target', {})
        
        # Construct the row update (Matches structure of full scrape)
        new_row = {
            'ID': p.get('id'),
            'Name': p.get('name'),
            'Status': 'Active' if p.get('active') else 'Inactive',
            # We keep existing location/group data to avoid complex parsing in this lightweight update
            # or you can fetch shops if strictly needed. For speed, we update the core edit fields.
            'Discount Value Type': target.get('discountType'),
            'Discount Value': target.get('discountAmt'),
            'Start Date': datetime.fromtimestamp(p.get('startDate', 0)/1000).strftime('%Y-%m-%d') if p.get('startDate') else '',
            'End Date': datetime.fromtimestamp(p.get('endDate', 0)/1000).strftime('%Y-%m-%d') if p.get('endDate') else '',
        }
        
        # UPDATE THE DATAFRAME IN MEMORY
        df = GLOBAL_DATA['blaze'].get('df_raw')
        if df is not None and not df.empty and 'ID' in df.columns:
            # Check if ID exists
            idx = df.index[df['ID'] == promo_id].tolist()
            if idx:
                row_idx = idx[0]
                # Update specific fields
                df.at[row_idx, 'Name'] = new_row['Name']
                df.at[row_idx, 'Status'] = new_row['Status']
                df.at[row_idx, 'Discount Value Type'] = new_row['Discount Value Type']
                df.at[row_idx, 'Discount Value'] = new_row['Discount Value']
                df.at[row_idx, 'Start Date'] = new_row['Start Date']
                df.at[row_idx, 'End Date'] = new_row['End Date']
                
                print(f"[SYNC] Successfully updated row {promo_id} in memory.")
                
                # Signal Frontend to refresh
                GLOBAL_DATA['blaze']['last_update_ts'] = time.time()
            else:
                print("[SYNC] ID not found in cache. Full refresh recommended.")
    except Exception as e:
        print(f"[ERROR] Single row sync failed: {e}")

def monitor_browser_return(promo_id: str):
    """
    Watches the browser URL. When it returns to the list page, triggers a single-row sync.
    """
    driver = GLOBAL_DATA.get('browser_instance')
    if not driver: return

    print(f"[WATCHER] Monitoring browser for return from {promo_id}...")
    
    # Wait loop (Timeout after 60 seconds to save resources)
    max_wait = 60
    for _ in range(max_wait):
        try:
            current_url = driver.current_url
            # If we are back on the main list page
            if "company-promotions/promotions" in current_url and promo_id not in current_url:
                print("[WATCHER] Detected return to list! Waiting 300ms...")
                time.sleep(0.3) # User requested delay
                
                # Trigger Update
                update_single_promotion_in_memory(promo_id)
                return
            time.sleep(1)
        except:
            break
    print("[WATCHER] Timed out or browser closed.")

# ============================================================================
# GOOGLE SHEETS AUTHENTICATION (SHARED)
# ============================================================================
def authenticate_google_sheets() -> Optional[object]:
    """Authenticate with Google Sheets API."""
    creds = None
    
    # v12.24.8: Guard against None config files (no profile detected)
    if TOKEN_FILE is None or CREDENTIALS_FILE is None:
        print(f"[INFO] No profile configured - Google Sheets auth not available")
        return None
    
    if TOKEN_FILE.exists():
        try:
            creds = Credentials.from_authorized_user_file(str(TOKEN_FILE), SCOPES)
        except Exception as e:
            print(f"[WARN] Token corrupted: {e}")
    
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            except:
                creds = None
        
        if not creds:
            if not CREDENTIALS_FILE.exists():
                return None
            
            max_wait = 10
            waited = 0
            while not GLOBAL_DATA['browser_ready'] and waited < max_wait:
                time.sleep(1)
                waited += 1
            
            if not GLOBAL_DATA['browser_ready']:
                flow = InstalledAppFlow.from_client_secrets_file(str(CREDENTIALS_FILE), SCOPES)
                creds = flow.run_local_server(port=8080, prompt='consent')
            else:
                driver = GLOBAL_DATA['browser_instance']
                flow = InstalledAppFlow.from_client_secrets_file(str(CREDENTIALS_FILE), SCOPES)
                flow.redirect_uri = 'http://localhost:8080/'
                auth_url, _ = flow.authorization_url(prompt='consent')
                
                driver.execute_script(f"window.open('{auth_url}', '_blank');")
                driver.switch_to.window(driver.window_handles[-1])
                
                try:
                    WebDriverWait(driver, 120).until(
                        lambda d: 'localhost:8080' in d.current_url or 'code=' in d.current_url
                    )
                    
                    current_url = driver.current_url
                    if 'code=' in current_url:
                        parsed = urlparse.urlparse(current_url)
                        code = urlparse.parse_qs(parsed.query).get('code', [None])[0]
                        if code:
                            flow.fetch_token(code=code)
                            creds = flow.credentials
                    
                    driver.close()
                    driver.switch_to.window(driver.window_handles[0])
                except TimeoutException:
                    driver.close()
                    driver.switch_to.window(driver.window_handles[0])
                    return None
        
        with open(TOKEN_FILE, 'w') as token:
            token.write(creds.to_json())
    
    try:
        service = build('sheets', 'v4', credentials=creds)
        return service
    except Exception as e:
        print(f"[ERROR] Failed to build service: {e}")
        return None

# ============================================================================
# BLAZE TOKEN MANAGER (BACKGROUND API CALLS)
# ============================================================================
class BlazeTokenManager:
    """
    Manages Blaze API authentication tokens with caching and validation.
    Supports headless and GUI fallback login for background API operations.
    Does NOT interfere with the main browser instance used for MIS automation.
    """
    TOKEN_FILE = BASE_DIR / 'blaze_token_cache.json'
    
    @staticmethod
    def validate(token):
        """Validate token by making a test API call."""
        if not token:
            return False
        try:
            r = requests.get(
                "https://api.blaze.me/api/v1/mgmt/shops?start=0&limit=1",
                headers={"Authorization": f"Token {token}"},
                timeout=5
            )
            return r.status_code == 200
        except:
            return False

    @classmethod
    def get_token(cls):
        """
        Get a valid token using this priority:
        1. Try cached token from file
        2. If expired, sniff new token (headless first, GUI fallback)
        3. Save and return new token
        """
        # 1. Try Cache
        if cls.TOKEN_FILE.exists():
            try:
                with open(cls.TOKEN_FILE, 'r') as f:
                    cached = json.load(f).get('token')
                    if cls.validate(cached):
                        print("[TOKEN] Using cached session.")
                        return cached
            except:
                pass
        
        # 2. Sniff new token (Headless -> GUI Fallback)
        creds = load_credentials_config().get('blaze', {})
        email = creds.get('email')
        password = creds.get('password')
        
        if not email or not password:
            print("[TOKEN] No credentials found in config.")
            return None

        print("[TOKEN] Cache expired. Sniffing new token...")
        token = cls._sniff_login(email, password, headless=True)
        
        if not token:
            print("[TOKEN] Headless failed. Trying visible browser...")
            token = cls._sniff_login(email, password, headless=False)
            
        if token:
            cls._save(token)
            return token
        
        print("[TOKEN] Failed to obtain token.")
        return None

    @staticmethod
    def _sniff_login(email, password, headless=True):
        """
        Login to Blaze and sniff the Authorization token from network logs.
        Uses a separate browser instance to avoid interfering with main GUI.
        """
        driver = None
        try:
            from selenium import webdriver
            from selenium.webdriver.common.by import By
            from selenium.webdriver.common.keys import Keys
            from selenium.webdriver.support.ui import WebDriverWait
            from selenium.webdriver.support import expected_conditions as EC
            
            options = webdriver.ChromeOptions()
            if headless:
                options.add_argument('--headless=new')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.set_capability('goog:loggingPrefs', {'performance': 'ALL'})
            
            driver = webdriver.Chrome(options=options)
            driver.get("https://retail.blaze.me/login")
            
            # Wait for login form
            WebDriverWait(driver, 15).until(
                EC.presence_of_element_located((By.NAME, "email"))
            )
            
            # Login
            driver.find_element(By.NAME, "email").send_keys(email)
            driver.find_element(By.NAME, "password").send_keys(password + Keys.RETURN)
            
            time.sleep(5)  # Wait for login to complete
            
            # Navigate to promotions page to trigger API calls
            driver.get("https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=20")
            time.sleep(5)  # Wait for API calls
            
            # Sniff logs for token
            logs = driver.get_log('performance')
            for entry in logs:
                try:
                    msg = json.loads(entry['message'])['message']
                    if 'Network.requestWillBeSent' in msg.get('method', ''):
                        req = msg['params']['request']
                        if 'api.blaze.me' in req.get('url', ''):
                            headers = req.get('headers', {})
                            auth = next(
                                (v for k, v in headers.items() if k.lower() == 'authorization'),
                                None
                            )
                            if auth:
                                token = auth.replace('Token ', '').replace('Bearer ', '').strip()
                                print(f"[TOKEN] Successfully captured token!")
                                return token
                except:
                    pass
                    
        except Exception as e:
            print(f"[TOKEN] Login Error: {e}")
        finally:
            if driver:
                driver.quit()
        
        return None

    @classmethod
    def _save(cls, token):
        """Save token to cache file."""
        try:
            with open(cls.TOKEN_FILE, 'w') as f:
                json.dump({
                    'token': token,
                    'updated': str(datetime.now())
                }, f)
            print(f"[TOKEN] Saved to cache: {cls.TOKEN_FILE}")
        except Exception as e:
            print(f"[TOKEN] Failed to save cache: {e}")

    @classmethod
    def fetch_global_brands(cls, token=None) -> Dict[str, str]:
        """
        Fetch the master brand list from Blaze API.
        Returns: {brandId: brandName}
        """
        if not token:
            token = cls.get_token()
        if not token:
            print("[BRANDS] No token available for brand fetch.")
            return {}

        headers = {"Authorization": f"Token {token}"}
        brands_map = {}
        start = 0
        limit = 500  # Blaze API max per page
        
        try:
            print("[BRANDS] Fetching global brand list...")
            while True:
                url = f"https://api.blaze.me/api/v1/mgmt/brands?start={start}&limit={limit}"
                
                try:
                    r = requests.get(url, headers=headers, timeout=10)
                    
                    if r.status_code == 404:
                        print("[BRANDS] WARNING: Global brand endpoint not available (404). Using fallback methods.")
                        break  # Not an error, just not available
                    
                    if r.status_code != 200:
                        print(f"[BRANDS] API Error {r.status_code}: {r.text[:100]}")
                        break
                    
                    data = r.json()
                    items = data.get('values', [])
                    
                    if not items:
                        break
                    
                    for brand in items:
                        brand_id = brand.get('id')
                        brand_name = brand.get('name')
                        if brand_id and brand_name:
                            brands_map[brand_id] = brand_name
                    
                    # Check if we got all brands
                    total = data.get('total', 0)
                    if len(brands_map) >= total or len(items) < limit:
                        break
                    
                    start += limit
                    
                except requests.exceptions.RequestException as req_err:
                    print(f"[BRANDS] WARNING: Network error: {req_err}")
                    break
            
            if brands_map:
                print(f"[BRANDS] SUCCESS: Fetched {len(brands_map)} brands")
            else:
                print(f"[BRANDS] WARNING: No brands fetched (will use brandName fallback)")
            return brands_map
            return brands_map
            
        except Exception as e:
            print(f"[BRANDS] ERROR: Fetch failed: {e}")
            return {}

# ============================================================================
# BROWSER AUTOMATION (UNIFIED)
# ============================================================================
def init_browser():
    """Initialize unified browser using Standard Selenium with Download Prefs."""
    if not SELENIUM_AVAILABLE:
        return None
    
    try:
        print("[INIT] Launching Standard Chrome for Token Sniffing & Downloads...")
        
        options = webdriver.ChromeOptions()
        options.add_argument(f'user-data-dir={CHROME_PROFILE_DIR}')
        options.add_argument('profile-directory=Default')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--start-maximized')
        options.add_argument('--remote-allow-origins=*')
        
        # Hide automation indicators
        options.add_argument('--disable-blink-features=AutomationControlled')
        options.add_experimental_option("excludeSwitches", ["enable-automation", "enable-logging"])
        options.add_experimental_option('useAutomationExtension', False)
        
        # Suppress console errors (QUOTA_EXCEEDED, google_apis warnings)
        options.add_argument('--log-level=3')  # Only show fatal errors
        options.add_argument('--silent')
        options.add_argument('--disable-logging')
        
        # NEW: Configure Download Directory
        prefs = {
            "download.default_directory": str(MIS_REPORTS_DIR),
            "download.prompt_for_download": False,
            "download.directory_upgrade": True,
            "safebrowsing.enabled": True,
            "credentials_enable_service": False,
            "profile.password_manager_enabled": False,
            # Suppress quota warnings
            "profile.default_content_setting_values.notifications": 2,
            "profile.default_content_settings.popups": 0
        }
        options.add_experimental_option("prefs", prefs)
        options.set_capability('goog:loggingPrefs', {'performance': 'ALL'})
        
        driver = webdriver.Chrome(options=options)
        
        GLOBAL_DATA['browser_instance'] = driver
        GLOBAL_DATA['browser_ready'] = True
        
        return driver
    except Exception as e:
        print(f"[ERROR] Browser init failed: {e}")
        traceback.print_exc()
        return None

def mis_login(driver, username: str, password: str, new_tab: bool = True) -> bool:
    """MIS login automation."""
    try:
        target_url = "https://mis.theartisttree.com/daily-discount"
        
        mis_tab_found = False
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if "daily-discount" in driver.current_url or "mis.theartisttree.com" in driver.current_url:
                mis_tab_found = True
                break
        
        if not mis_tab_found:
            if new_tab:
                # Create tab in background
                original_handle = driver.current_window_handle
                driver.execute_script(f"window.open('{target_url}', '_blank');")
                time.sleep(1)
                driver.switch_to.window(driver.window_handles[-1])
            else:
                driver.get(target_url)
        
        try:
            WebDriverWait(driver, 5).until(
                lambda d: d.find_elements(By.ID, "daily-discount") or d.find_elements(By.NAME, "email")
            )
        except:
            pass
        
        if len(driver.find_elements(By.ID, "daily-discount")) > 0:
            print("[OK] Already logged in to MIS")
            login_success = True
        else:
            login_success = False
        
        if not login_success:
            try:
                email_field = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.NAME, "email"))
                )
                password_field = driver.find_element(By.NAME, "password")
                submit_btn = driver.find_element(By.CSS_SELECTOR, "button[type='submit']")
                
                email_field.click()
                email_field.send_keys(Keys.CONTROL + "a")
                email_field.send_keys(Keys.DELETE)
                email_field.send_keys(username)
                
                password_field.click()
                password_field.send_keys(Keys.CONTROL + "a")
                password_field.send_keys(Keys.DELETE)
                password_field.send_keys(password)
                
                submit_btn.click()
                
                WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "daily-discount"))
                )
                login_success = True
            except Exception as e:
                print(f"[ERROR] MIS login failed: {e}")
                return False
        
        if login_success:
            try:
                search_input = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
                )
                search_input.click()
                search_input.send_keys(Keys.CONTROL + "a")
                search_input.send_keys(Keys.DELETE)
                try:
                    driver.find_element(By.NAME, "daily-discount_length").send_keys("All")
                except:
                    pass
            except:
                pass
        
        return True
    except Exception as e:
        print(f"[ERROR] MIS login error: {e}")
        return False

def ensure_mis_ready(driver, gui_username: str = '', gui_password: str = '') -> bool:
    """
    INTELLIGENT MIS SESSION MANAGER
    
    Ensures MIS browser tab is open and logged in before any automation.
    Call this at the start of any MIS automation function.
    
    Steps:
    1. Find existing MIS tab OR create new one
    2. Switch to MIS tab
    3. Hard refresh the page
    4. Check login state (look for email field = logged out)
    5. If logged out, perform login using Setup tab credentials
    6. Verify login succeeded
    7. Return True when ready, raise Exception on failure
    
    Args:
        driver: Selenium WebDriver instance
        gui_username: Username from Setup tab (optional, will load from config if empty)
        gui_password: Password from Setup tab (optional, will load from config if empty)
    
    Returns:
        True if MIS is ready for automation
        
    Raises:
        Exception with user-friendly message on failure
    """
    MIS_URL = "https://mis.theartisttree.com/daily-discount"
    MIS_URL_FRAGMENT = "mis.theartisttree.com"
    
    print("[MIS-READY] Ensuring MIS session is ready...")
    
    try:
        # Store original tab to return to later if needed
        original_handle = driver.current_window_handle
        
        # Step 1: Find existing MIS tab
        mis_tab = None
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if MIS_URL_FRAGMENT in driver.current_url:
                mis_tab = handle
                print(f"[MIS-READY] Found existing MIS tab")
                break
        
        # Step 2: If no MIS tab exists, create one
        if not mis_tab:
            print(f"[MIS-READY] No MIS tab found, creating new tab...")
            driver.execute_script(f"window.open('{MIS_URL}', '_blank');")
            time.sleep(2)
            # Switch to the new tab (last one)
            mis_tab = driver.window_handles[-1]
            driver.switch_to.window(mis_tab)
            print(f"[MIS-READY] Created new MIS tab")
        
        # Step 3: Hard refresh the page
        print(f"[MIS-READY] Refreshing page to check session...")
        driver.refresh()
        time.sleep(2)
        
        # Step 4: Wait for page to load (either login form or daily-discount table)
        try:
            WebDriverWait(driver, 10).until(
                lambda d: d.find_elements(By.NAME, "email") or d.find_elements(By.ID, "daily-discount")
            )
        except:
            # Page might be slow, give it more time
            time.sleep(3)
        
        # Step 5: Check if logged out (email field present)
        is_logged_out = len(driver.find_elements(By.NAME, "email")) > 0
        is_logged_in = len(driver.find_elements(By.ID, "daily-discount")) > 0
        
        if is_logged_in:
            print(f"[MIS-READY] [EMOJI] Already logged in to MIS")
            return True
        
        if is_logged_out:
            print(f"[MIS-READY] Session expired, performing login...")
            
            # Get credentials - prefer GUI credentials, fallback to JSON config
            username = gui_username.strip() if gui_username else ''
            password = gui_password.strip() if gui_password else ''
            
            if not username or not password:
                # Try loading from config file
                try:
                    creds = load_credentials_config()
                    username = creds.get('mis_username', '')
                    password = creds.get('mis_password', '')
                except:
                    pass
            
            # Verify we have credentials
            if not username or not password:
                raise Exception(
                    "[EMOJI] MIS Login Required\n\n"
                    "MIS session has expired and no credentials are saved.\n\n"
                    "Please enter your MIS credentials in the Setup tab and try again."
                )
            
            # Perform login
            try:
                email_field = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.NAME, "email"))
                )
                password_field = driver.find_element(By.NAME, "password")
                submit_btn = driver.find_element(By.CSS_SELECTOR, "button[type='submit']")
                
                # Clear and enter email
                email_field.click()
                email_field.send_keys(Keys.CONTROL + "a")
                email_field.send_keys(Keys.DELETE)
                email_field.send_keys(username)
                
                # Clear and enter password
                password_field.click()
                password_field.send_keys(Keys.CONTROL + "a")
                password_field.send_keys(Keys.DELETE)
                password_field.send_keys(password)
                
                # Submit
                submit_btn.click()
                print(f"[MIS-READY] Login submitted, waiting for verification...")
                
                # Wait for login to complete
                WebDriverWait(driver, 15).until(
                    EC.presence_of_element_located((By.ID, "daily-discount"))
                )
                
                print(f"[MIS-READY] [EMOJI] Login successful!")
                
                # Set table to show all records
                try:
                    length_select = driver.find_element(By.NAME, "daily-discount_length")
                    length_select.send_keys("All")
                    time.sleep(1)
                except:
                    pass
                
                return True
                
            except Exception as login_error:
                raise Exception(
                    f"[EMOJI] MIS Login Failed\n\n"
                    f"Could not log in to MIS. Please check your credentials in the Setup tab.\n\n"
                    f"Error: {str(login_error)}"
                )
        
        # If we get here, page state is unknown - try navigating to MIS URL directly
        print(f"[MIS-READY] Unknown page state, navigating to MIS...")
        driver.get(MIS_URL)
        time.sleep(3)
        
        # Check again
        if len(driver.find_elements(By.ID, "daily-discount")) > 0:
            print(f"[MIS-READY] [EMOJI] MIS is ready")
            return True
        elif len(driver.find_elements(By.NAME, "email")) > 0:
            # Recursively call self to handle login
            return ensure_mis_ready(driver, gui_username, gui_password)
        else:
            raise Exception("[EMOJI] Could not determine MIS page state. Please try Initialize again.")
            
    except Exception as e:
        print(f"[MIS-READY] Error: {e}")
        raise

def filter_and_open_mis_id(driver, mis_id: str) -> bool:
    """Filter MIS table and open edit popup."""
    try:
        try:
            close_buttons = driver.find_elements(By.CSS_SELECTOR, "button.close[data-dismiss='modal']")
            for btn in close_buttons:
                if btn.is_displayed():
                    btn.click()
                    time.sleep(0.5)
                    break
        except:
            pass
        
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "daily-discount"))
        )
        
        try:
            length_select = WebDriverWait(driver, 3).until(
                EC.presence_of_element_located((By.NAME, "daily-discount_length"))
            )
            length_select.send_keys("All")
        except:
            pass
        
        search_input = driver.find_element(By.CSS_SELECTOR, "input[type='search']")
        search_input.click()
        search_input.send_keys(Keys.CONTROL + "a")
        search_input.send_keys(Keys.DELETE)
        search_input.send_keys(str(mis_id))
        time.sleep(1)
        
        edit_btn = WebDriverWait(driver, 5).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, f"a.btn-table-dialog[data-id='{mis_id}']"))
        )
        edit_btn.click()
        time.sleep(1)
        return True
    except Exception as e:
        print(f"[ERROR] Failed to filter/open MIS ID {mis_id}: {e}")
        return False

def open_google_sheet_in_browser(spreadsheet_id: str, sheet_name: str, row_number: int = None) -> bool:
    """Open Google Sheet with native tab management."""
    try:
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return False
        
        gid = get_sheet_gid(spreadsheet_id, sheet_name)
        base_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}/edit"
        
        target_url = base_url
        if gid:
            target_url += f"#gid={gid}"
        if row_number:
            target_url += f"&range={row_number}:{row_number}"
        
        sheet_tab_found = False
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if spreadsheet_id in driver.current_url:
                sheet_tab_found = True
                if row_number or gid:
                    driver.get(target_url)
                break
        
        if not sheet_tab_found:
            driver.switch_to.new_window('tab')
            driver.get(target_url)
        
        return True
    except Exception as e:
        print(f"[ERROR] Failed to open Google Sheet: {e}")
        return False

def get_sheet_gid(spreadsheet_id: str, sheet_name: str) -> Optional[str]:
    """Get GID for specific sheet."""
    try:
        service = GLOBAL_DATA['sheets_service']
        if not service:
            return None
        metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        sheets = metadata.get('sheets', [])
        for sheet in sheets:
            if sheet['properties']['title'] == sheet_name:
                return str(sheet['properties']['sheetId'])
        return None
    except:
        return None

# ============================================================================
# MIS HELPER FUNCTIONS
# ============================================================================
def extract_spreadsheet_id(url: str) -> Optional[str]:
    match = re.search(r'/spreadsheets/d/([a-zA-Z0-9-_]+)', url)
    return match.group(1) if match else None

def get_available_tabs(spreadsheet_id: str) -> List[str]:
    try:
        service = GLOBAL_DATA['sheets_service']
        if not service:
            return []
        metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        return [sheet['properties']['title'] for sheet in metadata.get('sheets', [])]
    except:
        return []

def detect_header_row(sheet_data: List[List[str]]) -> int:
    """
    Detects the header row index by scanning for key column names.
    Scans first 10 rows for keywords like 'Brand', 'Deal', 'Discount'.
    """
    key_columns = ['Brand', 'Weekday', 'Deal', 'Discount', 'Location']
    for row_idx, row in enumerate(sheet_data[:10]):
        row_str = ' '.join([str(cell).strip() for cell in row]).lower()
        matches = sum(1 for keyword in key_columns if keyword.lower() in row_str)
        # If we find at least 3 matching keywords, we assume this is the header row
        if matches >= 3:
            return row_idx
    return 0

def fetch_google_sheet_data(tab_name: str) -> Dict[str, pd.DataFrame]:
    """
    Fetch Google Sheet data and split into sections: Weekly, Monthly, Sale.
    Returns: {'weekly': df, 'monthly': df, 'sale': df}
    """
    try:
        service = GLOBAL_DATA['sheets_service']
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        
        if not service or not spreadsheet_id:
            raise ValueError("Service not available")
        
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{tab_name}'!A1:AZ2000"
        ).execute()
        
        values = result.get('values', [])
        empty_ret = {'weekly': pd.DataFrame(), 'monthly': pd.DataFrame(), 'sale': pd.DataFrame()}
        if not values:
            return empty_ret
        
        header_row_idx = detect_header_row(values)
        GLOBAL_DATA['mis']['header_row_idx'] = header_row_idx
        
        # Get standardized headers from the first section (Weekly)
        headers = [str(cell).strip() for cell in values[header_row_idx]]
        headers.append('_SHEET_ROW_NUM')
        expected_cols = len(headers)
        
        # Cleanup column names
        clean_cols = [col if col == '_SHEET_ROW_NUM' else col.strip().replace('\n', ' ') for col in headers]
        
        sections = {'weekly': [], 'monthly': [], 'sale': []}
        current_section = 'weekly'
        
        # Start scanning AFTER the first header
        i = header_row_idx + 1
        while i < len(values):
            row = values[i]
            row_str = " ".join([str(cell).strip() for cell in row]).upper()
            
            # --- SECTION SWITCHING LOGIC ---
            if "END420" in row_str:
                print(f"[SHEET-PARSE] Found END420 at row {i+1}, stopping parse")
                break # Stop parsing completely
            
            if "MONTHLYSTART" in row_str:
                print(f"[SHEET-PARSE] Found MONTHLYSTART at row {i+1}, switching to monthly section")
                current_section = 'monthly'
                i += 2 # Skip this flag row AND the next row (the new header)
                continue
                
            if "SALESTART" in row_str:
                print(f"[SHEET-PARSE] Found SALESTART at row {i+1}, switching to sale section")
                current_section = 'sale'
                i += 2 # Skip this flag row AND the next row (the new header)
                continue
                
            if "BREAK420" in row_str:
                i += 1
                continue
            
            # Process Data Row
            if len(row) >= 2 and str(row[1]).strip():
                # Pad/Slice to match header length exactly
                padded_row = row + [''] * (expected_cols - len(row))
                padded_row = padded_row[:expected_cols - 1] 
                padded_row.append(i + 1) # Add 1-based row number
                
                sections[current_section].append(padded_row)
            
            i += 1
            
        # Convert lists to DataFrames
        print(f"[SHEET-PARSE] Section summary: weekly={len(sections['weekly'])}, monthly={len(sections['monthly'])}, sale={len(sections['sale'])}")
        final_dfs = {}
        for sec, rows in sections.items():
            if rows:
                df = pd.DataFrame(rows, columns=clean_cols)
            else:
                df = pd.DataFrame(columns=clean_cols)
            final_dfs[sec] = df
            
        GLOBAL_DATA['mis']['current_sheet'] = tab_name
        return final_dfs

    except Exception as e:
        print(f"[ERROR] Failed to fetch sheet: {e}")
        traceback.print_exc()
        return {'weekly': pd.DataFrame(), 'monthly': pd.DataFrame(), 'sale': pd.DataFrame()}

def fetch_tax_rates() -> dict:
    """
    Fetch tax rates with priority: DEFAULT_TAX_RATES < tax_config.json overrides
    No longer depends on Google Sheets for reliability.
    Returns: dict mapping store names to tax rates
    """
    # Start with hardcoded defaults
    tax_rates = DEFAULT_TAX_RATES.copy()
    
    # Try to load local overrides from tax_config.json
    if TAX_CONFIG_FILE.exists():
        try:
            with open(TAX_CONFIG_FILE, 'r') as f:
                local_overrides = json.load(f)
                # Merge: local overrides take precedence
                tax_rates.update(local_overrides)
                print(f"[TAX] Loaded {len(tax_rates)} tax rates (default + local overrides)")
        except Exception as e:
            print(f"[TAX] Failed to load tax_config.json: {e}")
            print(f"[TAX] Using {len(tax_rates)} default tax rates")
    else:
        print(f"[TAX] Using {len(tax_rates)} default tax rates (no local overrides)")
    
    return tax_rates

def get_col(row: pd.Series, possible_names: List[str], default: Any = '') -> Any:
    for name in possible_names:
        if name in row.index and pd.notna(row[name]):
            return row[name]
    return default

def manage_brand_list(mis_df: pd.DataFrame) -> List[str]:
    """Manage brand list."""
    stored_brands = set()
    if BRAND_LIST_FILE.exists():
        try:
            with open(BRAND_LIST_FILE, 'r', encoding='utf-8') as f:
                stored_brands = {line.strip() for line in f if line.strip()}
        except:
            pass
    
    mis_brands = set()
    if 'Brand' in mis_df.columns:
        mis_brands = {str(b).strip() for b in mis_df['Brand'].dropna().unique() if str(b).strip()}
    
    new_brands = mis_brands - stored_brands
    if new_brands:
        updated_brands = stored_brands.union(new_brands)
        try:
            with open(BRAND_LIST_FILE, 'w', encoding='utf-8') as f:
                for brand in sorted(updated_brands, key=str.lower):
                    f.write(f"{brand}\n")
        except:
            pass
        return list(updated_brands)
    return list(stored_brands)

def parse_percentage(value: Any) -> float:
    if pd.isna(value):
        return 0.0
    val_str = str(value).strip().replace('%', '').replace(',', '')
    try:
        return float(val_str)
    except:
        return 0.0

def parse_end_date(contracted_duration: str, default: str = '') -> Tuple[str, str]:
    if not contracted_duration or pd.isna(contracted_duration):
        return (default, default)
    parts = str(contracted_duration).split('-')
    if len(parts) == 2:
        return (parts[0].strip(), parts[1].strip())
    return (default, default)

def format_location_display(locations: str, exceptions: str) -> str:
    if pd.isna(locations) or not str(locations).strip():
        return "Not Specified"
    loc_str = str(locations).strip()
    exc_str = str(exceptions).strip() if pd.notna(exceptions) else ""
    if exc_str:
        if "except" in loc_str.lower():
            loc_str = "All Locations"
        return f"{loc_str} (Except: {exc_str})"
    return loc_str

def format_category_display(categories: str, exceptions: str) -> str:
    if pd.isna(categories) or not str(categories).strip():
        return "Not Specified"
    cat_str = str(categories).strip()
    exc_str = str(exceptions).strip() if pd.notna(exceptions) else ""
    return f"{cat_str} (Except: {exc_str})" if exc_str else cat_str

# ============================================================================
# DATE-AWARE CONFLICT DETECTION HELPERS
# ============================================================================
def parse_tab_month_year(tab_name: str) -> Tuple[int, int]:
    """
    Parse tab name (e.g., "December 2025", "Jan 2026", "Dec 25") to extract month and year.
    Returns: (month_number, year) or (current_month, current_year) as fallback
    """
    import calendar
    from datetime import datetime
    
    # Default to current month/year
    now = datetime.now()
    default_month, default_year = now.month, now.year
    
    if not tab_name:
        return (default_month, default_year)
    
    tab_clean = tab_name.strip()
    
    # Month name mappings (full and abbreviated)
    month_names = {
        'january': 1, 'jan': 1,
        'february': 2, 'feb': 2,
        'march': 3, 'mar': 3,
        'april': 4, 'apr': 4,
        'may': 5,
        'june': 6, 'jun': 6,
        'july': 7, 'jul': 7,
        'august': 8, 'aug': 8,
        'september': 9, 'sep': 9, 'sept': 9,
        'october': 10, 'oct': 10,
        'november': 11, 'nov': 11,
        'december': 12, 'dec': 12
    }
    
    # Try to extract month and year
    import re
    
    # Pattern 1: "December 2025" or "Dec 2025"
    match = re.search(r'([a-zA-Z]+)\s*(\d{4})', tab_clean)
    if match:
        month_str = match.group(1).lower()
        year = int(match.group(2))
        if month_str in month_names:
            return (month_names[month_str], year)
    
    # Pattern 2: "Dec 25" or "December 25" (assume 20XX)
    match = re.search(r'([a-zA-Z]+)\s*(\d{2})$', tab_clean)
    if match:
        month_str = match.group(1).lower()
        year_short = int(match.group(2))
        year = 2000 + year_short if year_short < 100 else year_short
        if month_str in month_names:
            return (month_names[month_str], year)
    
    # Pattern 3: Just month name (use current or next year)
    for month_str, month_num in month_names.items():
        if month_str in tab_clean.lower():
            # If the month is in the past this year, assume next year
            if month_num < now.month:
                return (month_num, now.year + 1)
            return (month_num, now.year)
    
    return (default_month, default_year)

def expand_weekday_to_dates(weekday_str: str, target_month: int, target_year: int) -> List[date]:
    """
    For Weekly deals: Convert day name (e.g., "Monday", "Tue") to all dates in the target month.
    Returns: List of datetime.date objects for all occurrences of that weekday in the month.
    """
    import calendar
    from datetime import date
    
    if not weekday_str or weekday_str.strip().lower() in ['', 'nan', 'none', '-']:
        return []
    
    # Weekday mappings (0=Monday, 6=Sunday)
    weekday_map = {
        'monday': 0, 'mon': 0, 'mo': 0,
        'tuesday': 1, 'tue': 1, 'tu': 1, 'tues': 1,
        'wednesday': 2, 'wed': 2, 'we': 2,
        'thursday': 3, 'thu': 3, 'th': 3, 'thur': 3, 'thurs': 3,
        'friday': 4, 'fri': 4, 'fr': 4,
        'saturday': 5, 'sat': 5, 'sa': 5,
        'sunday': 6, 'sun': 6, 'su': 6
    }
    
    day_key = weekday_str.strip().lower()
    if day_key not in weekday_map:
        return []
    
    target_weekday = weekday_map[day_key]
    
    # Get all days in the target month
    num_days = calendar.monthrange(target_year, target_month)[1]
    result_dates = []
    
    for day in range(1, num_days + 1):
        d = date(target_year, target_month, day)
        if d.weekday() == target_weekday:
            result_dates.append(d)
    
    return result_dates

def parse_monthly_dates(date_str: str, target_month: int, target_year: int) -> List[date]:
    """
    For Monthly deals: Parse ordinals ("10th", "1st, 15th") or date formats ("12/25/25").
    Returns: List of datetime.date objects.
    """
    import re
    from datetime import date
    import calendar
    
    if not date_str or date_str.strip().lower() in ['', 'nan', 'none', '-']:
        return []
    
    result_dates = []
    date_clean = date_str.strip()
    
    # Split by common delimiters: comma, &, "and"
    parts = re.split(r'[,&]|\band\b', date_clean, flags=re.IGNORECASE)
    
    for part in parts:
        part = part.strip()
        if not part:
            continue
        
        # Pattern 1: Ordinal numbers ("1st", "2nd", "3rd", "10th", "21st")
        ordinal_match = re.search(r'(\d+)(?:st|nd|rd|th)', part, re.IGNORECASE)
        if ordinal_match:
            day = int(ordinal_match.group(1))
            num_days = calendar.monthrange(target_year, target_month)[1]
            if 1 <= day <= num_days:
                result_dates.append(date(target_year, target_month, day))
            continue
        
        # Pattern 2: Full date "MM/DD/YY" or "MM/DD/YYYY" or "MM-DD-YY"
        date_match = re.search(r'(\d{1,2})[/\-](\d{1,2})[/\-](\d{2,4})', part)
        if date_match:
            month = int(date_match.group(1))
            day = int(date_match.group(2))
            year = int(date_match.group(3))
            if year < 100:
                year = 2000 + year
            try:
                result_dates.append(date(year, month, day))
            except ValueError:
                pass  # Invalid date
            continue
        
        # Pattern 3: Just a number (assume day of target month)
        num_match = re.search(r'^(\d+)$', part)
        if num_match:
            day = int(num_match.group(1))
            num_days = calendar.monthrange(target_year, target_month)[1]
            if 1 <= day <= num_days:
                result_dates.append(date(target_year, target_month, day))
    
    return result_dates

def parse_sale_dates(date_str: str, target_month: int, target_year: int) -> List[date]:
    """
    For Sale deals: Parse formats like "12/24/25 - Wednesday", "12/31/25 - Wednesday".
    Extracts the date portion, ignoring the day name suffix.
    Returns: List of datetime.date objects.
    """
    import re
    from datetime import date
    
    if not date_str or date_str.strip().lower() in ['', 'nan', 'none', '-']:
        return []
    
    result_dates = []
    date_clean = date_str.strip()
    
    # Split by common delimiters: comma, &, "and"
    parts = re.split(r'[,&]|\band\b', date_clean, flags=re.IGNORECASE)
    
    for part in parts:
        part = part.strip()
        if not part:
            continue
        
        # Pattern 1: "MM/DD/YY - DayName" or "MM/DD/YYYY - DayName"
        # Extract just the date portion before the dash+day
        date_match = re.search(r'(\d{1,2})[/\-](\d{1,2})[/\-](\d{2,4})', part)
        if date_match:
            month = int(date_match.group(1))
            day = int(date_match.group(2))
            year = int(date_match.group(3))
            if year < 100:
                year = 2000 + year
            try:
                result_dates.append(date(year, month, day))
            except ValueError:
                pass  # Invalid date
            continue
        
        # Pattern 2: Ordinal ("25th", "1st") - treat as target month
        ordinal_match = re.search(r'(\d+)(?:st|nd|rd|th)', part, re.IGNORECASE)
        if ordinal_match:
            day_num = int(ordinal_match.group(1))
            import calendar
            num_days = calendar.monthrange(target_year, target_month)[1]
            if 1 <= day_num <= num_days:
                result_dates.append(date(target_year, target_month, day_num))
    
    return result_dates

def get_all_weekdays_for_multiday_group(group_data: Dict, section_df: pd.DataFrame, section_key: str, target_month: int, target_year: int) -> List[date]:
    """
    For a multi-day group (e.g., Stiiizy Mon/Tue/Wed), expand ALL weekdays to actual dates.
    Returns: Combined list of dates from all weekdays in the group.
    """
    all_dates = []
    weekdays = group_data.get('weekdays', [])
    
    for weekday in weekdays:
        if weekday and weekday != '[!] [EMOJI][EMOJI]  MISSING':
            dates = expand_weekday_to_dates(weekday, target_month, target_year)
            all_dates.extend(dates)
    
    return list(set(all_dates))  # Remove duplicates

# ============================================================================
# MULTI-DAY DEAL DETECTION (NEW)
# ============================================================================
def detect_multi_day_groups(google_df: pd.DataFrame, section_type: str = 'weekly') -> Tuple[Dict[str, Dict], Dict[int, str]]:
    """
    Detect deals that span multiple days.
    UPDATED: Handles Column Swap for 'sale' section.
    """
    groups = {}
    row_to_group = {}
    
    for g_idx, g_row in google_df.iterrows():
        # Standard Logic for all sections (Removed Sale Swap)
        brand_raw = str(g_row.get('Brand', '')).strip()
        # v12.22.4: Weekly uses Column A ('Weekday'), Monthly/Sale use Column K ('Weekday/ Day of Month')
        if section_type == 'weekly':
            weekday_raw = str(get_col(g_row, ['Weekday', 'Day of Week'], '')).strip().title()
        else:
            weekday_raw = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip().title()

        if not brand_raw:
            continue
        
        true_sheet_row = int(g_row['_SHEET_ROW_NUM']) if '_SHEET_ROW_NUM' in g_row else g_idx + 2
        
        discount = parse_percentage(get_col(g_row, ['Deal Discount Value/Type', 'Deal Discount'], ''))
        vendor_contrib = parse_percentage(get_col(g_row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
        loc_raw, exc_raw = resolve_location_columns(g_row)
        locations = format_location_display(loc_raw, exc_raw)
        categories = format_category_display(g_row.get('Categories', ''), g_row.get('Category Exceptions', ''))
        special_notes = str(g_row.get('SPECIAL NOTES', '')).strip()
        deal_info = str(get_col(g_row, ['Deal Information', 'Deal Info'], '')).strip()
        
        contracted_duration = get_col(g_row, ['Contracted Duration (MM/DD/YY - MM/DD/YY)', 'Contracted Duration'], '')
        start_date, end_date = parse_end_date(contracted_duration)
        
        group_key = f"{brand_raw}|{discount}|{vendor_contrib}|{locations}|{categories}|{special_notes}|{deal_info}|{start_date}|{end_date}"
        group_id = hashlib.md5(group_key.encode()).hexdigest()[:12]
        
        has_missing_weekday = not weekday_raw or weekday_raw.lower() in ['', 'nan', 'none']
        
        if group_id not in groups:
            groups[group_id] = {
                'rows': [],
                'weekdays': [],
                'brand': brand_raw,
                'has_missing_weekday': has_missing_weekday
            }
        
        groups[group_id]['rows'].append(true_sheet_row)
        groups[group_id]['weekdays'].append(weekday_raw if weekday_raw else '[!] [EMOJI][EMOJI]  MISSING')
        
        if has_missing_weekday:
            groups[group_id]['has_missing_weekday'] = True
        
        row_to_group[true_sheet_row] = group_id
    
    multi_day_groups = {gid: gdata for gid, gdata in groups.items() if len(gdata['rows']) > 1}
    
    return multi_day_groups, row_to_group

def should_skip_end420_row(row_dict: Dict) -> bool:
    """
    Check if a row should be skipped because it contains "END420" exactly in 2+ columns.
    This marks the end of valid data.
    
    Args:
        row_dict: Dictionary representing a row (can be from DataFrame.to_dict('records'))
    
    Returns:
        True if row should be skipped (has END420 in 2+ columns), False otherwise
    """
    end420_count = 0
    for value in row_dict.values():
        # Check for exact match "END420" (case-insensitive, strip whitespace)
        if isinstance(value, str) and value.strip().upper() == "END420":
            end420_count += 1
            if end420_count > 1:
                return True
    return False

def enhanced_match_mis_ids(google_df: pd.DataFrame, mis_df: pd.DataFrame, brand_list: List[str] = None, brand_settings: Dict[str, str] = None, section_type: str = 'weekly') -> List[Dict]:
    """
    V6 COMPATIBLE: Enhanced fuzzy matching with restored V1 SUGGESTIONS logic.
    - Generates confidence scores based on Brand, Discount, and Vendor %.
    - Returns top 5 suggestions for every row.
    - Handles Multi-Day Groups (Weekly only).
    - [FIX] Robust ID Column detection (ID vs MIS ID) and float cleanup.
    """
    matches = []
    header_offset = GLOBAL_DATA['mis'].get('header_row_idx', 0)
    
    if brand_settings is None:
        brand_settings = {}

    # --- [FIX] ROBUST ID COLUMN DETECTION ---
    # Find which column actually contains the ID in the CSV
    id_col_name = 'ID' # Default
    possible_cols = ['ID', 'id', 'MIS ID', 'Mis Id', 'MIS_ID', 'mis_id']
    for col in possible_cols:
        if col in mis_df.columns:
            id_col_name = col
            break
            
    # Helper to get clean ID string (removes .0 from floats, handles NaN)
    def get_clean_mis_id(row):
        val = row.get(id_col_name)
        if pd.isna(val): return ''
        # Convert to string, strip whitespace, remove decimal if float (12345.0 -> 12345)
        s = str(val).strip()
        if s.endswith('.0'):
            return s[:-2]
        return s
    
    # 1. Detect Multi-Day Groups (ONLY for Weekly section)
    if section_type == 'weekly':
        multi_day_groups, row_to_group = detect_multi_day_groups(google_df, section_type)
    else:
        multi_day_groups, row_to_group = {}, {}
    
    def get_target_day(d):
        d = str(d).strip().lower()
        if 'mon' in d: return 'monday'
        if 'tue' in d: return 'tuesday'
        if 'wed' in d: return 'wednesday'
        if 'thu' in d: return 'thursday'
        if 'fri' in d: return 'friday'
        if 'sat' in d: return 'saturday'
        if 'sun' in d: return 'sunday'
        return ''
    
    for g_idx, g_row in google_df.iterrows():
        if should_skip_end420_row(g_row.to_dict()):
            continue
        
        # v12.13 FIX: NO COLUMN SWAPPING - use columns as-is for ALL sections
        brand_raw = str(g_row.get('Brand', '')).strip()
        # v12.22.4: Weekly uses Column A ('Weekday'), Monthly/Sale use Column K ('Weekday/ Day of Month')
        if section_type == 'weekly':
            weekday_raw = str(get_col(g_row, ['Weekday', 'Day of Week'], '')).strip()
        else:
            weekday_raw = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()

        if not brand_raw:
            continue
        
        true_sheet_row = int(g_row['_SHEET_ROW_NUM']) if '_SHEET_ROW_NUM' in g_row else header_offset + g_idx + 2
        
        # --- MULTI-DAY METADATA (base - will be extended per brand) ---
        base_group_metadata = None
        group_id = None
        if true_sheet_row in row_to_group:
            group_id = row_to_group[true_sheet_row]
            if group_id in multi_day_groups:
                group_data = multi_day_groups[group_id]
                current_idx = group_data['rows'].index(true_sheet_row)
                base_group_metadata = {
                    'group_id': group_id,
                    'total_days': len(group_data['rows']),
                    'row_numbers': group_data['rows'],
                    'weekdays': group_data['weekdays'],
                    'current_index': current_idx,
                    'has_missing_weekday': group_data['has_missing_weekday']
                }

        weekday_target = get_target_day(weekday_raw)
        
        discount = parse_percentage(get_col(g_row, ['Deal Discount Value/Type', 'Deal Discount'], ''))
        vendor_contrib = parse_percentage(get_col(g_row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
        category_raw = str(g_row.get('Categories', '')).strip()
        current_sheet_id = str(get_col(g_row, ['MIS ID', 'ID'], '')).strip()
        
        # v12.1: Parse multi-brand - create separate entries for each brand
        individual_brands = parse_multi_brand(brand_raw)
        is_multi_brand_row = len(individual_brands) > 1
        
        # For multi-brand, map existing MIS IDs to brands
        brand_to_ids = {}
        if is_multi_brand_row and current_sheet_id:
            brand_to_ids = match_mis_ids_to_brands(current_sheet_id, individual_brands, mis_df)
        
        # Process each brand separately (or just one if single brand)
        brands_to_process = individual_brands if individual_brands else [brand_raw]
        
        for brand_idx, current_brand in enumerate(brands_to_process):
            # v12.1: Create per-brand group_metadata with correct is_first flag
            group_metadata = None
            if base_group_metadata:
                current_idx = base_group_metadata['current_index']
                # is_first is True ONLY when first in day group AND first brand
                is_first_entry = (current_idx == 0) and (brand_idx == 0)
                total_entries = base_group_metadata['total_days'] * len(brands_to_process)
                
                group_metadata = {
                    'group_id': base_group_metadata['group_id'],
                    'total_days': base_group_metadata['total_days'],
                    'total_entries': total_entries,  # v12.1: Total entries (days * brands)
                    'row_numbers': base_group_metadata['row_numbers'],
                    'weekdays': base_group_metadata['weekdays'],
                    'current_index': current_idx,
                    'is_first': is_first_entry,  # v12.1: True only for first day + first brand
                    'is_first_brand': brand_idx == 0,  # v12.1: Track if first brand
                    'has_missing_weekday': base_group_metadata['has_missing_weekday'],
                    'brand_raw': brand_raw,  # v12.1: Full brand string for header
                    'is_multi_brand': is_multi_brand_row,  # v12.1: Flag for multi-brand group
                    'total_brands': len(brands_to_process)  # v12.1: Number of brands
                }
            
            # Filter candidates by Weekday (if applicable)
            try:
                if weekday_target:
                    candidates = mis_df[
                        mis_df['Weekday'].astype(str).str.lower().str.contains(weekday_target, regex=False, na=False)
                    ]
                else:
                    candidates = mis_df.copy()
            except:
                candidates = mis_df.copy()
            
            # --- SUGGESTION LOGIC FOR THIS SPECIFIC BRAND ---
            suggestions = []
            
            # v12.1: For multi-brand, get this brand's specific MIS IDs
            brand_specific_ids = []
            if is_multi_brand_row and current_brand in brand_to_ids:
                brand_specific_ids = [mis_id for (tag, mis_id) in brand_to_ids.get(current_brand, [])]
            
            # Current sheet ID for this brand
            if is_multi_brand_row:
                # For multi-brand, show this brand's IDs or empty if none
                brand_current_id = ', '.join([f"{tag}: {mid}" for tag, mid in brand_to_ids.get(current_brand, [])])
            else:
                brand_current_id = current_sheet_id

            for c_idx, c_row in candidates.iterrows():
                mis_brand = str(c_row.get('Brand', '')).strip()
                if not mis_brand:
                    continue
                
                best_brand_ratio = 0
                match_type = 'fuzzy'
                linked_brand_match = False  # v12.1: Track if linked brands match
                
                # v12.1: Match against this specific brand
                brand_part_clean = current_brand.strip()
                brand_lower = brand_part_clean.lower()
                mis_brand_lower = mis_brand.lower()
                
                # v12.1: Get MIS Linked Brand for comparison
                mis_linked_brand = str(c_row.get('Linked Brand (if applicable)', '')).strip()
                mis_linked_lower = mis_linked_brand.lower() if mis_linked_brand and mis_linked_brand.lower() not in ['n/a', 'nan', ''] else ''
                
                # v12.1: Get Google Sheet Linked Brand from Settings
                google_linked_brand = brand_settings.get(brand_part_clean, '')
                google_linked_lower = google_linked_brand.lower() if google_linked_brand else ''
                
                # STRICT MATCHING LOGIC:
                # 1. Exact Match (case-insensitive) - highest priority
                if brand_lower == mis_brand_lower:
                    best_brand_ratio = 100
                    match_type = 'exact'
                    # Check linked brand match for bonus
                    if google_linked_lower and mis_linked_lower:
                        if google_linked_lower == mis_linked_lower:
                            linked_brand_match = True
                
                # 2. Check for "contains but not exact" - PENALIZE this case
                # e.g., "Stiiizy" vs "Stiiizy Accessories" - one contains the other but not equal
                elif brand_lower in mis_brand_lower or mis_brand_lower in brand_lower:
                    # This is a partial containment - NOT a good match
                    # Give low score to prevent confusion between "Stiiizy" and "Stiiizy Accessories"
                    best_brand_ratio = 40  # Low score - will likely be filtered out
                    match_type = 'partial_contains'
                
                # 3. Linked Brand Match (from Settings)
                elif google_linked_lower:
                    # Check if MIS brand matches Google's linked brand
                    if google_linked_lower == mis_brand_lower:
                        best_brand_ratio = 90
                        match_type = 'linked_brand_match'
                        linked_brand_match = True
                    # Check if MIS linked brand matches Google's linked brand
                    elif mis_linked_lower and google_linked_lower == mis_linked_lower:
                        # Both have same linked brand - might be related
                        fuzzy_ratio = fuzz.token_set_ratio(brand_lower, mis_brand_lower)
                        if fuzzy_ratio > 80:
                            best_brand_ratio = fuzzy_ratio
                            match_type = 'linked_brand_partial'
                            linked_brand_match = True
                        else:
                            best_brand_ratio = fuzzy_ratio * 0.7  # Reduce score
                            match_type = 'linked_brand_weak'
                    else:
                        # Linked brand doesn't match - use fuzzy but reduced
                        fuzzy_ratio = fuzz.token_set_ratio(brand_lower, mis_brand_lower)
                        best_brand_ratio = fuzzy_ratio * 0.6  # Significant reduction
                        match_type = 'fuzzy_no_linked'
                
                # 4. Fuzzy Match as fallback (no linked brand configured)
                else:
                    fuzzy_ratio = fuzz.token_set_ratio(brand_lower, mis_brand_lower)
                    # Additional check: if fuzzy is high but it's a "contains" situation, penalize
                    if fuzzy_ratio > 85 and (brand_lower in mis_brand_lower or mis_brand_lower in brand_lower):
                        best_brand_ratio = 50  # Penalize high fuzzy that's actually partial
                        match_type = 'fuzzy_partial'
                    else:
                        best_brand_ratio = fuzzy_ratio
                        match_type = 'fuzzy'
            
                if best_brand_ratio < 60:
                    continue
            
                # Base Score
                score_brand = (best_brand_ratio / 100) * 50
                apply_bonuses = best_brand_ratio >= 75
                
                # v12.1: Linked brand match bonus
                if linked_brand_match:
                    score_brand += 5  # Bonus for matching linked brands
            
                # 2. Discount Match Score
                mis_discount = float(c_row.get('Daily Deal Discount', 0))
                score_discount = 0
                if apply_bonuses:
                    if abs(discount - mis_discount) < 0.01:
                        score_discount = 30
                    elif abs(discount - mis_discount) <= 5:
                        score_discount = 15
            
                # 3. Vendor Contribution Match Score
                mis_vendor = float(c_row.get('Discount paid by vendor', 0))
                score_vendor = 0
                if apply_bonuses:
                    if abs(vendor_contrib - mis_vendor) < 0.01:
                        score_vendor = 15
            
                # 4. Category Match Score
                mis_category = str(c_row.get('Category', '')).strip()
                score_category = 0
                if category_raw and mis_category:
                    google_cats = set(c.strip().lower() for c in category_raw.split(',') if c.strip())
                    mis_cats = set(c.strip().lower() for c in mis_category.split(',') if c.strip())
                    if google_cats == mis_cats: score_category = 5
                    elif google_cats.issubset(mis_cats): score_category = 5
                    elif len(google_cats & mis_cats) > 0: score_category = 3
                elif not category_raw and not mis_category:
                    score_category = 5
            
                # Final Confidence Calculation
                final_confidence = min(round(score_brand + score_discount + score_vendor + score_category), 100)
            
                # Build Display Data
                locs = str(c_row.get('Store', '')).strip()
                if not locs or locs.lower() == 'nan': locs = "All Locations"
            
                # [FIX] USE ROBUST ID GETTER HERE
                clean_mis_id = get_clean_mis_id(c_row)

                # v12.1: Capture all raw CSV data for "More Info" popup
                raw_csv_data = {}
                for col in c_row.index:
                    try:
                        val = c_row[col]
                        # Handle Series (duplicate columns) by taking first value
                        if hasattr(val, 'iloc'):
                            val = val.iloc[0] if len(val) > 0 else ''
                        # Convert to string and check for empty/nan
                        val_str = str(val).strip() if val is not None else ''
                        if val_str and val_str.lower() not in ['', 'nan', 'none', 'nat']:
                            raw_csv_data[col] = val_str
                    except:
                        pass  # Skip problematic columns

                mis_data_pack = {
                    'id': clean_mis_id,
                    'brand': mis_brand,
                    'linked_brand': str(c_row.get('Linked Brand (if applicable)', 'N/A')),
                    'locations': locs,
                    'weekdays': str(c_row.get('Weekday', 'N/A')),
                    'start_date': str(c_row.get('Start date', 'N/A')),
                    'end_date': str(c_row.get('End date', 'N/A')),
                    'category': mis_category or 'N/A',
                    'discount': mis_discount,
                    'vendor_contribution': mis_vendor,
                    'raw_csv_data': raw_csv_data,  # v12.1: All MIS CSV columns for More Info
                    'linked_brand_match': linked_brand_match,  # v12.1: Whether linked brands matched
                    'match_type': match_type  # v12.1: Type of brand match
                }

                # v12.1: Enhanced reasoning with match type details
                reasoning_parts = [f"Brand: {int(best_brand_ratio)}%"]
                if match_type == 'exact': 
                    reasoning_parts.append("(exact)")
                elif match_type == 'linked_brand_match': 
                    reasoning_parts.append("(linked)")
                elif match_type == 'partial_contains':
                    reasoning_parts.append("(partial - similar name)")
                elif match_type == 'fuzzy_partial':
                    reasoning_parts.append("(fuzzy - similar name)")
                if linked_brand_match:
                    reasoning_parts.append("[LB[EMOJI]]")  # Linked Brand matched
            
                suggestions.append({
                    'mis_id': clean_mis_id,
                    'confidence': final_confidence,
                    'reasoning': ' '.join(reasoning_parts),
                    'mis_data': mis_data_pack
                })
        
            # Sort by confidence (Highest first) and take top 5
            suggestions = sorted(suggestions, key=lambda x: x['confidence'], reverse=True)[:5]
        
            # Determine Match Status based on top suggestion
            matched_mis_id = ''
            status = 'LOW'
            if suggestions:
                top_conf = suggestions[0]['confidence']
                if top_conf >= 85: 
                    matched_mis_id = suggestions[0]['mis_id']
                
                if top_conf >= 95: status = 'HIGH'
                elif top_conf >= 70: status = 'MEDIUM'
            
            # v12.1: Add to results with multi-brand metadata
            # Look up linked brand from brand_settings (same as Creation Checklist)
            linked_brand_from_settings = ''
            lookup_key = current_brand.lower().strip()
            if lookup_key in brand_settings:
                target_linked = brand_settings[lookup_key]
                if target_linked.lower() != current_brand.lower():
                    linked_brand_from_settings = target_linked
            
            # v12.1: Capture all raw row data for "More Info" popup
            raw_row_data = {}
            for col in g_row.index:
                try:
                    val = g_row[col]
                    # Handle Series (duplicate columns) by taking first value
                    if hasattr(val, 'iloc'):
                        val = val.iloc[0] if len(val) > 0 else ''
                    # Convert to string and check for empty/nan
                    val_str = str(val).strip() if val is not None else ''
                    # Include FALSE/True values for checkboxes - only exclude truly empty/invalid values
                    if val_str and val_str.lower() not in ['', 'nan', 'none', 'nat', '<na>']:
                        raw_row_data[col] = val_str
                except:
                    pass  # Skip problematic columns
            
            matches.append({
                'google_row': true_sheet_row,
                'brand': current_brand,  # v12.1: Individual brand, not full multi-brand string
                'brand_raw': brand_raw,  # v12.1: Original multi-brand string
                'linked_brand': linked_brand_from_settings,  # v12.1: From Settings tab (same as Creation Checklist)
                'is_multi_brand': is_multi_brand_row,  # v12.1: Flag for multi-brand
                'multi_brand_index': brand_idx if is_multi_brand_row else None,  # v12.1: Index in multi-brand list
                'multi_brand_total': len(brands_to_process) if is_multi_brand_row else 1,  # v12.1: Total brands in row
                'weekday': weekday_raw,
                'section': section_type,
                'discount': discount,
                'vendor_contrib': vendor_contrib,
                'current_sheet_id': brand_current_id,  # v12.1: This brand's MIS IDs only
                'current_sheet_id_raw': current_sheet_id,  # v12.1: Full MIS ID cell
                'matched_mis_id': matched_mis_id,
                'confidence': suggestions[0]['confidence'] if suggestions else 0,
                'status': status,
                'suggestions': suggestions,
                'locations': format_location_display(*resolve_location_columns(g_row)),
                'categories': format_category_display(g_row.get('Categories'), g_row.get('Category Exceptions')),
                'special_notes': str(g_row.get('SPECIAL NOTES', '')),
                'deal_info': str(get_col(g_row, ['Deal Information', 'Deal Info'], '')),
                'blaze_discount_title': str(get_col(g_row, ['Blaze Discount Title'], '')),  # v12.7: For auto-loading
                'multi_day_group': group_metadata,
                'raw_row_data': raw_row_data,  # v12.1: All Google Sheet columns for More Info
                # v12.17: Add fields for Rebate Type auto-fill in Create popup
                'retail': str(get_col(g_row, ['Retail'], '')).strip(),
                'wholesale': str(get_col(g_row, ['Wholesale'], '')).strip(),
                'after_wholesale': str(get_col(g_row, ['Rebate After Wholesale', 'After Wholesale', 'After Wholesale Discount', 'Rebate after Wholesale?'], '')).strip(),
                'min_weight': str(get_col(g_row, ['Min Weight', 'Minimum Weight', 'Min'], '')).strip(),
                'max_weight': str(get_col(g_row, ['Max Weight', 'Maximum Weight', 'Max'], '')).strip(),
                # v12.17: Add date_raw for Sale section date auto-fill
                'date_raw': str(get_col(g_row, ['Contracted Duration (MM/DD/YY - MM/DD/YY)', 'Contracted Duration', 'Sale Runs:'], '')).strip()
            })
    
    return matches

def audit_google_vs_mis(google_df: pd.DataFrame, mis_df: pd.DataFrame, section_type: str = 'weekly') -> List[Dict]:
    """Audit with multi-day deal detection and section awareness."""
    results = []
    
    # 1. Detect Groups (ONLY for Weekly)
    if section_type == 'weekly':
        multi_day_groups, row_to_group = detect_multi_day_groups(google_df, section_type)
    else:
        multi_day_groups, row_to_group = {}, {}
    
    for g_idx, g_row in google_df.iterrows():
        if should_skip_end420_row(g_row.to_dict()):
            continue
        
        # v12.13 FIX: NO COLUMN SWAPPING - use columns as-is for ALL sections
        brand = str(g_row.get('Brand', '')).strip()
        # v12.22.4: Weekly uses Column A ('Weekday'), Monthly/Sale use Column K ('Weekday/ Day of Month')
        if section_type == 'weekly':
            weekday = str(get_col(g_row, ['Weekday', 'Day of Week'], '')).strip()
        else:
            weekday = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()

        if not brand:
            continue
        
        true_sheet_row = int(g_row['_SHEET_ROW_NUM']) if '_SHEET_ROW_NUM' in g_row else GLOBAL_DATA['mis'].get('header_row_idx', 0) + g_idx + 2
        
        discount = parse_percentage(get_col(g_row, ['Deal Discount Value/Type', 'Deal Discount'], ''))
        special_notes = str(g_row.get('SPECIAL NOTES', '')).strip()
        deal_info = str(get_col(g_row, ['Deal Information', 'Deal Info'], '')).strip()
        vendor_contrib = parse_percentage(get_col(g_row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
        
        loc_raw, exc_raw = resolve_location_columns(g_row)
        locations = format_location_display(loc_raw, exc_raw)
        categories = format_category_display(g_row.get('Categories', ''), g_row.get('Category Exceptions', ''))
        
        mis_ids_str = str(get_col(g_row, ['MIS ID', 'ID'], '')).strip()
        
        # --- MULTI-DAY METADATA ---
        group_metadata = None
        if true_sheet_row in row_to_group:
            group_id = row_to_group[true_sheet_row]
            if group_id in multi_day_groups:
                group_data = multi_day_groups[group_id]
                current_idx = group_data['rows'].index(true_sheet_row)
                group_metadata = {
                    'group_id': group_id,
                    'total_days': len(group_data['rows']),
                    'row_numbers': group_data['rows'],
                    'weekdays': group_data['weekdays'],
                    'current_index': current_idx,
                    'is_first': current_idx == 0,
                    'has_missing_weekday': group_data['has_missing_weekday']
                }
        
        if mis_ids_str:
            mis_ids = [id.strip() for id in mis_ids_str.split(',') if id.strip()]
            
            for mis_id in mis_ids:
                try:
                    matches = mis_df[mis_df['ID'].astype(str).str.strip() == mis_id]
                except KeyError:
                    results.append({
                        'google_row': true_sheet_row,
                        'mis_id': mis_id,
                        'brand': brand,
                        'status': 'ERROR',
                        'discrepancies': ['MIS CSV missing ID column'],
                        'weekday': weekday,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'categories': categories,
                        'special_notes': special_notes,
                        'deal_info': deal_info,
                        'multi_day_group': group_metadata
                    })
                    continue
                
                if matches.empty:
                    results.append({
                        'google_row': true_sheet_row,
                        'mis_id': mis_id,
                        'brand': brand,
                        'status': 'ID NOT FOUND IN MIS',
                        'discrepancies': [],
                        'weekday': weekday,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'categories': categories,
                        'special_notes': special_notes,
                        'deal_info': deal_info,
                        'multi_day_group': group_metadata
                    })
                    continue
                
                m_row = matches.iloc[0]
                discrepancies = []
                
                mis_discount = float(m_row.get('Daily Deal Discount', 0))
                if abs(discount - mis_discount) > 0.01:
                    discrepancies.append(f"Discount: Google={discount}% vs MIS={mis_discount}%")
                
                results.append({
                    'google_row': true_sheet_row,
                    'mis_id': mis_id,
                    'brand': brand,
                    'weekday': weekday,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'categories': categories,
                    'special_notes': special_notes,
                    'deal_info': deal_info,
                    'status': 'DISCREPANCIES' if discrepancies else 'MATCH',
                    'discrepancies': discrepancies,
                    'multi_day_group': group_metadata
                })
        else:
            try:
                def check_weekday_match(target, candidate):
                    if not target: return True
                    t = target.lower()
                    c = str(candidate).lower()
                    for d in ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']:
                        if d in t and d in c: return True
                    return False

                candidates = mis_df[mis_df.apply(lambda x: check_weekday_match(weekday, x['Weekday']), axis=1)] if weekday else mis_df.copy()
                
                best_match = None
                best_score = 0
                
                for c_idx, c_row in candidates.iterrows():
                    mis_brand = str(c_row.get('Brand', '')).strip()
                    if not mis_brand: continue
                    score = fuzz.token_set_ratio(brand.lower(), mis_brand.lower())
                    if score > best_score:
                        best_score = score
                        best_match = c_row
                
                if best_match is not None and best_score >= 60:
                    mis_discount = float(best_match.get('Daily Deal Discount', 0))
                    discrepancies = []
                    if abs(discount - mis_discount) > 0.01:
                        discrepancies.append(f"Discount: Google={discount}% vs MIS={mis_discount}%")
                    
                    results.append({
                        'google_row': true_sheet_row,
                        'mis_id': f"{best_match.get('ID', '')} (Estimated)",
                        'brand': brand,
                        'weekday': weekday,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'categories': categories,
                        'special_notes': special_notes,
                        'deal_info': deal_info,
                        'status': f'ESTIMATED MATCH ({best_score}%)',
                        'discrepancies': discrepancies,
                        'multi_day_group': group_metadata
                    })
                else:
                    results.append({
                        'google_row': true_sheet_row,
                        'mis_id': '-',
                        'brand': brand,
                        'status': 'NO MIS ID ASSIGNED',
                        'discrepancies': ['Run ID Matcher'],
                        'weekday': weekday,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'categories': categories,
                        'special_notes': special_notes,
                        'deal_info': deal_info,
                        'multi_day_group': group_metadata
                    })
            except KeyError as e:
                results.append({
                    'google_row': true_sheet_row,
                    'mis_id': '-',
                    'brand': brand,
                    'status': 'ERROR',
                    'discrepancies': [str(e)],
                    'weekday': weekday,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'categories': categories,
                    'special_notes': special_notes,
                    'deal_info': deal_info,
                    'multi_day_group': group_metadata
                })
    
    return results

def format_csv_locations(locations_raw: str, exceptions_raw: str) -> str:
    """
    Parses Google Sheet location columns and returns the CSV-formatted string.
    Logic:
    1. If 'All Locations' and no exceptions -> Return "" (Blank)
    2. If 'All Locations' AND exceptions -> Return All CSV Stores minus exceptions.
    3. If specific stores -> Return mapped stores comma-separated.
    """
    loc_str = str(locations_raw).strip()
    exc_str = str(exceptions_raw).strip()
    
    # Normalize input
    is_all_locs = "all locations" in loc_str.lower()
    
    final_stores = set()
    
    if is_all_locs:
        if not exc_str or exc_str.lower() in ['nan', 'none', '']:
            return "" # Return blank if All Locations with no exceptions
        
        # All Locations EXCEPT...
        # 1. Start with all target stores
        final_stores = set(CSV_TARGET_STORES)
        
        # 2. Identify exceptions
        exceptions = [e.strip() for e in exc_str.split(',') if e.strip()]
        mapped_exceptions = []
        for e in exceptions:
            mapped = STORE_MAPPING.get(e, e) # Try to map, else use raw
            mapped_exceptions.append(mapped)
            
        # 3. Remove exceptions
        for exc in mapped_exceptions:
            if exc in final_stores:
                final_stores.remove(exc)
    else:
        # Specific locations listed
        raw_list = [l.strip() for l in loc_str.split(',') if l.strip()]
        for r in raw_list:
            if r in STORE_MAPPING:
                final_stores.add(STORE_MAPPING[r])
            else:
                # Fallback: check if it's already a valid target store
                if r in CSV_TARGET_STORES:
                    final_stores.add(r)
    
    # Return comma-separated string sorted alphabetically
    return ", ".join(sorted(list(final_stores)))

def format_csv_categories(cat_raw: str, exc_raw: str) -> str:
    """
    Parses Categories.
    If 'All Categories' is detected:
      - Returns "All Categories" (or "All Categories (Except: X)") for the UI.
      - The CSV generator loop will handle converting this to BLANK for the file.
    """
    cat_str = str(cat_raw).strip()
    exc_str = str(exc_raw).strip()
    
    # Check if we need to handle 'All Categories'
    if "all categories" in cat_str.lower():
        if exc_str and exc_str.lower() not in ['nan', 'none', '']:
            # Return a special string we can use for display, 
            # but we will need to detect this specific phrase to blank it out for the CSV.
            return f"All Categories (Except: {exc_str})"
        else:
            return "All Categories"
        
    else:
        # Just specific categories listed, return as-is (cleaned)
        if not cat_str or cat_str.lower() in ['nan', 'none']:
            return ""
        
        # Clean up spacing between commas
        return ", ".join([c.strip() for c in cat_str.split(',') if c.strip()])

def load_brand_settings(spreadsheet_id: str) -> Dict[str, str]:
    """
    Reads a Settings tab to build a map of Brand -> Linked Brand.
    ROBUSTNESS UPGRADES:
    1. Scans first 10 rows for headers (Fuzzy Match).
    2. Handles "Short Rows" (Google API trimming empty trailing cells).
    3. SANITIZATION: Strips whitespace from keys/values for clean matching.
    """
    settings_map = {}
    try:
        service = GLOBAL_DATA['sheets_service']
        if not service: return {}
        
        # 1. Find the Settings tab
        metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        settings_tab_name = None
        
        print("\n[DEBUG] --- Loading Brand Settings ---")
        for s in metadata.get('sheets', []):
            title = s['properties']['title']
            if 'setting' in title.lower():
                settings_tab_name = title
                print(f"[DEBUG] Found settings tab: '{title}'")
                break
        
        if not settings_tab_name:
            print("[WARN] Could not find any tab with 'Settings' in the name.")
            return {}

        # 2. Fetch data
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{settings_tab_name}'!A1:Z1000" 
        ).execute()
        rows = result.get('values', [])
        if not rows: return {}

        # 3. SCAN FOR HEADERS (Fuzzy Logic)
        brand_idx = -1
        linked_idx = -1
        start_row_index = 0
        
        for i, row in enumerate(rows[:10]):
            row_lower = [str(x).strip().lower() for x in row]
            
            # Find 'Linked Brand' first
            for col_i, cell_val in enumerate(row_lower):
                if 'linked' in cell_val and 'brand' in cell_val:
                    linked_idx = col_i
                    break
            
            # Find 'Brand' second (Generic but NOT linked)
            for col_i, cell_val in enumerate(row_lower):
                if 'brand' in cell_val and 'linked' not in cell_val and 'contribution' not in cell_val:
                    brand_idx = col_i
                    break
            
            if brand_idx != -1 and linked_idx != -1:
                start_row_index = i + 1
                print(f"[DEBUG] Headers found on Row {i+1}: Brand (Col {brand_idx}), Linked (Col {linked_idx})")
                break
        
        if brand_idx == -1 or linked_idx == -1:
            print(f"[WARN] Failed to find headers in '{settings_tab_name}'.")
            return {}

        # 4. Build Map (With SAFE FETCHING)
        count = 0
        for r in rows[start_row_index:]:
            # We only strictly require the BRAND index to exist. 
            # If the row is too short for the Linked Brand index, we assume Linked is empty.
            if len(r) > brand_idx:
                b_name = str(r[brand_idx]).strip()
                
                # SAFE FETCH: Check if row is long enough for linked_idx, else empty string
                l_name = ""
                if len(r) > linked_idx:
                    l_name = str(r[linked_idx]).strip()
                
                if b_name:
                    # Store lowercase key for matching, but keep value clean
                    settings_map[b_name.lower()] = l_name
                    count += 1
                    
        print(f"[INFO] Successfully loaded {count} brand rules.")
        return settings_map

    except Exception as e:
        print(f"[ERROR] Failed to load settings: {e}")
        traceback.print_exc()
        return {}


def load_settings_dropdown_data(spreadsheet_id: str) -> Dict[str, any]:
    """
    v12.17: Load dropdown options from Settings tab for Enhanced Create Popup.
    Fetches: Stores (Column A), Categories (Column C), Brand->LinkedBrand map.
    """
    result = {
        'stores': [],
        'categories': [],
        'brand_linked_map': {}
    }
    
    # Special values to filter out (not actual stores/categories)
    STORE_SKIP = ['all locations', 'all locations except:', 'all locations except', 'store name', 'store', '']
    CATEGORY_SKIP = ['all categories', 'all categories except:', 'all categories except', 'categories', 'category', '']
    
    try:
        service = GLOBAL_DATA.get('sheets_service')
        if not service:
            print("[WARN] No sheets_service available for dropdown data")
            return result
        
        # 1. Find the Settings tab
        metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        settings_tab_name = None
        
        for s in metadata.get('sheets', []):
            title = s['properties']['title']
            if 'setting' in title.lower():
                settings_tab_name = title
                break
        
        if not settings_tab_name:
            print("[WARN] Could not find Settings tab for dropdown data")
            return result
        
        # 2. Fetch entire Settings tab
        fetch_result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{settings_tab_name}'!A1:Z500"
        ).execute()
        rows = fetch_result.get('values', [])
        if not rows:
            return result
        
        print(f"[SETTINGS-DROPDOWN] Fetched {len(rows)} rows from Settings tab")
        
        # 3. Find column indices from header (row 1)
        # Settings tab structure: A=Store Name, C=Categories, G=Brand, H=Linked Brand
        header = rows[0] if rows else []
        header_lower = [str(h).lower().strip() for h in header]
        
        store_col_idx = -1
        category_col_idx = -1
        brand_col_idx = -1
        linked_brand_col_idx = -1
        
        for idx, h in enumerate(header_lower):
            if 'store name' in h or h == 'store':
                store_col_idx = idx
            elif 'categor' in h and category_col_idx == -1:
                category_col_idx = idx
            elif 'linked' in h and 'brand' in h:
                linked_brand_col_idx = idx
            elif 'brand' in h and 'linked' not in h and 'contribution' not in h and brand_col_idx == -1:
                brand_col_idx = idx
        
        print(f"[SETTINGS-DROPDOWN] Columns - Store:{store_col_idx}, Category:{category_col_idx}, Brand:{brand_col_idx}, LinkedBrand:{linked_brand_col_idx}")
        
        # 4. Extract Stores (skip header row, filter special values)
        if store_col_idx >= 0:
            for row in rows[1:]:  # Skip header
                if store_col_idx < len(row):
                    store_name = str(row[store_col_idx]).strip()
                    store_lower = store_name.lower()
                    if store_name and store_lower not in STORE_SKIP and store_lower not in ['nan', 'none', '-']:
                        if store_name not in result['stores']:
                            result['stores'].append(store_name)
        
        # 5. Extract Categories (skip header row, filter special values)
        if category_col_idx >= 0:
            for row in rows[1:]:  # Skip header
                if category_col_idx < len(row):
                    category = str(row[category_col_idx]).strip()
                    cat_lower = category.lower()
                    if category and cat_lower not in CATEGORY_SKIP and cat_lower not in ['nan', 'none', '-']:
                        if category not in result['categories']:
                            result['categories'].append(category)
        
        # 6. Extract Brand -> Linked Brand map
        if brand_col_idx >= 0 and linked_brand_col_idx >= 0:
            for row in rows[1:]:
                brand_name = ''
                linked_name = ''
                if brand_col_idx < len(row):
                    brand_name = str(row[brand_col_idx]).strip()
                if linked_brand_col_idx < len(row):
                    linked_name = str(row[linked_brand_col_idx]).strip()
                
                if brand_name and brand_name.lower() not in ['', 'nan', 'none', '-', 'brand', '* all *', '#hashtag']:
                    result['brand_linked_map'][brand_name.lower()] = linked_name
        
        print(f"[SETTINGS-DROPDOWN] Loaded {len(result['stores'])} stores, {len(result['categories'])} categories, {len(result['brand_linked_map'])} brand mappings")
        return result
        
    except Exception as e:
        print(f"[ERROR] Failed to load settings dropdown data: {e}")
        traceback.print_exc()
        return result


def resolve_location_columns(row: pd.Series) -> Tuple[str, str]:
    """
    Logic Router for Location Columns.
    Prioritizes 'Locations (Discount Applies at)' column using FUZZY matching.
    Falls back to 'Locations (Marketing)' if needed.
    """
    # 1. FUZZY FIND the "Master Switch" column (Column N)
    # We scan the row's index (headers) for the column that contains 'discount' and 'applies'
    master_col_name = None
    for col in row.index:
        c_lower = str(col).lower()
        if 'discount' in c_lower and 'applies' in c_lower:
            master_col_name = col
            break
            
    # Read value if column found, else empty
    master_col_val = str(row[master_col_name]).strip() if master_col_name else ""
    master_clean = master_col_val.lower()
    
    # --- LOGIC BRANCH 1: "SAME AS MARKETING" FALLBACK ---
    # If explicitly "Same as Marketing" -> Look at Marketing column
    if "same as market" in master_clean:
        # Find Marketing column
        marketing_col_name = None
        for col in row.index:
            c_lower = str(col).lower()
            if 'marketing' in c_lower and 'location' in c_lower:
                marketing_col_name = col
                break
        
        if marketing_col_name:
            marketing_val = str(row[marketing_col_name]).strip()
            marketing_clean = marketing_val.lower()
            
            # ERROR CHECK: Circular reference
            if "same as market" in marketing_clean:
                print(f"[ERROR] Circular 'Same as Marketing' reference detected at row {row.name + 1}")
                print(f"[ERROR] Both 'Discount Applies at' and 'Marketing' columns say 'Same as Marketing'")
                return "", ""  # Return empty to skip this row
            
            # Recursively apply logic to Marketing column value
            # Create a temporary row with the marketing value
            temp_row = row.copy()
            temp_row[master_col_name] = marketing_val
            return resolve_location_columns(temp_row)
        else:
            print(f"[ERROR] 'Same as Marketing' specified but Marketing column not found at row {row.name + 1}")
            return "", ""

    # --- LOGIC BRANCH 2: EMPTY OR NAN ---
    if not master_col_val or master_clean == 'nan':
        return "", ""

    # --- LOGIC BRANCH 3: "ALL LOCATIONS EXCEPT" ---
    # If the phrase exists anywhere in the cell, ALL locations become exceptions
    if "all locations except" in master_clean:
        # Remove the trigger phrase to extract location names
        cleaned = master_col_val.replace("All Locations Except:", "").replace("all locations except:", "")
        # Split by comma and extract all location names
        exceptions = [loc.strip() for loc in cleaned.split(',') if loc.strip()]
        
        return "All Locations", ", ".join(exceptions)

    # --- LOGIC BRANCH 4: "ALL LOCATIONS" (Exact or Clean Match) ---
    if master_clean == "all locations":
        return "All Locations", ""

    # --- LOGIC BRANCH 5: SPECIFIC LIST ---
    # If we are here, it's just a list of stores (e.g. "Dixon, Davis")
    return master_col_val, ""

def generate_mis_csv_with_multiday(google_df: pd.DataFrame, section_type: str = 'weekly') -> Tuple[List[Dict], Dict]:
    """
    Generate MIS CSV. 
    UPDATED: Handles column swap for 'sale' section.
    """
    brand_settings = load_brand_settings(GLOBAL_DATA['mis']['spreadsheet_id'])
    multi_day_groups, row_to_group = detect_multi_day_groups(google_df, section_type)
    
    # Weekday ordering helper
    weekday_order = {
        'monday': 1, 'mon': 1, 'tuesday': 2, 'tue': 2, 'wednesday': 3, 'wed': 3,
        'thursday': 4, 'thu': 4, 'friday': 5, 'fri': 5, 'saturday': 6, 'sat': 6, 'sunday': 7, 'sun': 7
    }
    
    def get_weekday_sort_key(weekday_str):
        if not weekday_str: return 999
        # Basic check for day names in string
        d = weekday_str.lower()
        for k, v in weekday_order.items():
            if k in d: return v
        return 999
    
    csv_rows = []
    processed_groups = set()
    retail_alert_details = []
    multi_day_details = []
    
    for g_idx, g_row in google_df.iterrows():
        if should_skip_end420_row(g_row.to_dict()):
            continue
        
        # Standard Logic for all sections (Removed Sale Swap)
        brand_raw = str(g_row.get('Brand', '')).strip()
        # v12.22.4: Weekly uses Column A ('Weekday'), Monthly/Sale use Column K ('Weekday/ Day of Month')
        if section_type == 'weekly':
            weekday_val_input = str(get_col(g_row, ['Weekday', 'Day of Week'], '')).strip().title()
        else:
            weekday_val_input = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip().title()

        if not brand_raw:
            continue
        
        true_sheet_row = int(g_row['_SHEET_ROW_NUM']) if '_SHEET_ROW_NUM' in g_row else g_idx + 2
        
        is_in_group = true_sheet_row in row_to_group and row_to_group[true_sheet_row] in multi_day_groups
        
        special_notes_package = []
        deal_info_package = []
        
        if is_in_group:
            group_id = row_to_group[true_sheet_row]
            if group_id in processed_groups:
                continue 
            
            processed_groups.add(group_id)
            group_data = multi_day_groups[group_id]
            ref_row_num = group_data['rows'][0]
            ref_row = google_df[google_df['_SHEET_ROW_NUM'] == ref_row_num].iloc[0]
            
            # Combine weekdays
            raw_weekdays = [w for w in group_data['weekdays'] if w and w != '[!] [EMOJI][EMOJI]  MISSING']
            # For sale dates, sort by date logic? For now, keep simple sort.
            unique_weekdays = sorted(list(set(raw_weekdays)), key=get_weekday_sort_key)
            weekday_val = ', '.join(unique_weekdays)
            
            sort_key = min([get_weekday_sort_key(w) for w in unique_weekdays]) if unique_weekdays else 999
            multi_day_flag = f'YES ({len(unique_weekdays)} days)'
            google_rows_track = ', '.join([str(r) for r in group_data['rows']])
            
            data_source = ref_row
            
            # Summary Data
            row_day_combo = []
            for i, r_num in enumerate(group_data['rows']):
                d_name = group_data['weekdays'][i] if i < len(group_data['weekdays']) else "?"
                row_day_combo.append(f"(Row {r_num}) ({d_name})")
            
            multi_day_details.append({
                'brand': str(ref_row.get('Brand', '')).strip(), # Note: This might need swap logic if ref_row used directly
                'title_meta': f"({len(unique_weekdays)} Days)",
                'body_data': ", ".join(row_day_combo)
            })
            
            for r_num in group_data['rows']:
                sub_row = google_df[google_df['_SHEET_ROW_NUM'] == r_num].iloc[0]
                
                # Handle swap for notes
                if section_type == 'sale':
                    day_val = str(sub_row.get('Brand', '')).strip()
                elif section_type == 'weekly':
                    # v12.22.4: Weekly uses Column A ('Weekday')
                    day_val = str(get_col(sub_row, ['Weekday', 'Day of Week'], '')).strip()
                else:
                    day_val = str(get_col(sub_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                
                note_val = str(sub_row.get('SPECIAL NOTES', '')).strip()
                if note_val: special_notes_package.append({'row': r_num, 'day': day_val, 'note': note_val})
                    
                info_val = str(get_col(sub_row, ['Deal Information', 'Deal Info'], '')).strip()
                if info_val: deal_info_package.append({'row': r_num, 'day': day_val, 'info': info_val})
                    
        else:
            data_source = g_row
            weekday_val = weekday_val_input
            sort_key = get_weekday_sort_key(weekday_val)
            multi_day_flag = 'NO'
            google_rows_track = str(true_sheet_row)
            
            note_val = str(g_row.get('SPECIAL NOTES', '')).strip()
            if note_val: special_notes_package.append({'row': true_sheet_row, 'day': weekday_val, 'note': note_val})
                
            info_val = str(get_col(g_row, ['Deal Information', 'Deal Info'], '')).strip()
            if info_val: deal_info_package.append({'row': true_sheet_row, 'day': weekday_val, 'info': info_val})
            
        discount = parse_percentage(get_col(data_source, ['Deal Discount Value/Type', 'Deal Discount'], ''))
        vendor_contrib = parse_percentage(get_col(data_source, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
        
        cat_raw = str(data_source.get('Categories', ''))
        cat_exc = str(data_source.get('Category Exceptions', ''))
        categories = format_csv_categories(cat_raw, cat_exc)
        
        start_date, end_date = parse_end_date(get_col(data_source, ['Contracted Duration (MM/DD/YY - MM/DD/YY)', 'Contracted Duration'], ''))
        
        loc_raw, exc_raw = resolve_location_columns(data_source)
        store_str = format_csv_locations(loc_raw, exc_raw)
        
        display_store_str = store_str
        is_all_locs = "all locations" in loc_raw.lower()
        if is_all_locs:
            if exc_raw and exc_raw.lower() not in ['nan', 'none', '']:
                 display_store_str = f"All Locations Except: {exc_raw}" 
            else:
                 display_store_str = "All Locations"
        
        is_wholesale = str(get_col(data_source, ['Wholesale?', 'Wholesale'], '')).upper() == 'TRUE'
        is_retail = str(get_col(data_source, ['Retail?', 'Retail'], '')).upper() == 'TRUE'
        
        rebate_type_csv = ""
        notes_csv = ""
        ui_rebate_display = "-"
        
        if is_retail:
            rebate_type_csv = "" 
            notes_csv += "[ACTION: CHECK RETAIL TOGGLE] "
            ui_rebate_display = "Retail"
            retail_alert_details.append({
                'brand': brand_raw,
                'title_meta': "", 
                'body_data': f"Row {google_rows_track} ({weekday_val})"
            })
        elif is_wholesale:
            rebate_type_csv = "Wholesale"
            ui_rebate_display = "Wholesale"
            
        brands_list = [b.strip() for b in brand_raw.split(',') if b.strip()]
        split_group_id = f"split_{g_idx}_{int(time.time())}" if len(brands_list) > 1 else ""
        
        for b_idx, current_brand in enumerate(brands_list):
            final_brand_val = current_brand
            linked_brand_val = "" 

            lookup_key = current_brand.lower()
            if lookup_key in brand_settings:
                target_linked = brand_settings[lookup_key]
                if target_linked.lower() == current_brand.lower():
                    linked_brand_val = ""
                else:
                    linked_brand_val = target_linked

            row_ui_class = ""
            if len(brands_list) > 1:
                if b_idx == 0: row_ui_class = "split-group-start"
                elif b_idx == len(brands_list) - 1: row_ui_class = "split-group-end"
                else: row_ui_class = "split-group-middle"
                
            csv_category_val = categories
            if "All Categories" in categories:
                csv_category_val = ""

            row = {
                'ID': '',
                'Weekday': weekday_val,
                'Store': store_str,
                'Brand': final_brand_val,
                'Linked Brand (if applicable)': linked_brand_val,
                'Category': csv_category_val,
                'Daily Deal Discount': f"{discount:.2f}",
                'Rebate type': rebate_type_csv,
                'Discount paid by vendor': f"{vendor_contrib:.2f}",
                'Rebate After Wholesale Discount?': '',
                'Include clearance items?': '',
                'Specialty Discount (non-daily deal)?': '',
                'Start date': start_date,
                'End date': end_date,
                'Minimum Weight': '0',
                'Maximum Weight': '0',
                'Actions': 'Edit Archive',
                
                'GOOGLE_ROWS': google_rows_track,
                'MULTI_DAY_FLAG': multi_day_flag,
                'WEEKDAY_SORT_KEY': sort_key,
                'NOTES': notes_csv,
                'SPLIT_GROUP_ID': split_group_id,
                'ROW_UI_CLASS': row_ui_class,
                'DISPLAY_CATEGORY': categories,
                'DISPLAY_STORE': display_store_str,
                'UI_SPECIAL_NOTES': special_notes_package,
                'UI_DEAL_INFO': deal_info_package,
                'UI_REBATE_DISPLAY': ui_rebate_display
            }
            csv_rows.append(row)
    
    csv_rows_sorted = sorted(csv_rows, key=lambda x: x['WEEKDAY_SORT_KEY'])
    
    multi_day_summary = {
        'total_rows': len(csv_rows_sorted),
        'multi_day_deals': len([r for r in csv_rows_sorted if r['MULTI_DAY_FLAG'] != 'NO']),
        'single_day_deals': len([r for r in csv_rows_sorted if r['MULTI_DAY_FLAG'] == 'NO']),
        'groups_detected': len(multi_day_groups),
        'retail_alerts': len(retail_alert_details),
        'retail_details': retail_alert_details,
        'multiday_details': multi_day_details
    }
    
    return csv_rows_sorted, multi_day_summary

# ============================================================================
# NEW HELPER: DATE FILTERING
# ============================================================================
def filter_mis_by_date(df: pd.DataFrame, date_str: str, expand_month: bool) -> pd.DataFrame:
    """
    Filters the MIS DataFrame based on the 'Start date' column.
    Args:
        df: The dataframe to filter.
        date_str: The target date string (YYYY-MM-DD from HTML input).
        expand_month: If True, matches Month/Year. If False, matches exact Date.
    """
    if df.empty or 'Start date' not in df.columns:
        return df
    
    try:
        # Parse user input
        target_date = datetime.strptime(date_str, '%Y-%m-%d')
        
        # Convert DF column to datetime objects (handling errors gracefully)
        temp_dates = pd.to_datetime(df['Start date'], errors='coerce')
        
        if expand_month:
            # Filter by Month AND Year
            mask = (temp_dates.dt.month == target_date.month) & \
                   (temp_dates.dt.year == target_date.year)
            filter_desc = f"Month: {target_date.strftime('%B %Y')}"
        else:
            # Filter by exact Date
            mask = (temp_dates.dt.date == target_date.date())
            filter_desc = f"Date: {target_date.strftime('%Y-%m-%d')}"
            
        filtered_df = df[mask]
        print(f"[FILTER] Applied Focus. Criteria: {filter_desc}. Rows: {len(df)} -> {len(filtered_df)}")
        
        return filtered_df
        
    except Exception as e:
        print(f"[ERROR] Date filtering failed: {e}")
        traceback.print_exc()
        return df

# ============================================================================
# BLAZE INVENTORY REPORTER (INTEGRATED)
# ============================================================================
class BlazeInventoryReporter:
    def __init__(self):
        self.keys = self.load_keys()
        self.store_data = {}
        self.brand_map = {}  # Will store {brandId: brandName}
        # Clear previous logs
        GLOBAL_DATA['blaze']['inventory_logs'] = []
        GLOBAL_DATA['blaze']['inventory_running'] = True
        GLOBAL_DATA['blaze']['inventory_start_time'] = datetime.now()  # NEW: Track start time

    def log(self, message):
        """Log to console and Global State for UI"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        full_msg = f"[{timestamp}] {message}"
        print(full_msg)
        GLOBAL_DATA['blaze']['inventory_logs'].append(full_msg)

    def load_keys(self):
        self.log(f"Loading keys from: {INVENTORY_KEYS_FILE}")
        if not INVENTORY_KEYS_FILE.exists():
            self.log("[X] CRITICAL: blaze_inventory_keys.json missing!")
            return {}
        try:
            with open(INVENTORY_KEYS_FILE, 'r') as f:
                keys = json.load(f)
                self.log(f"[OK] Successfully loaded {len(keys)} store configurations")
                return keys
        except Exception as e:
            self.log(f"[X] Error loading keys: {e}")
            return {}
    def fetch_global_brands(self):
        """Fetch and cache the global brand mapping."""
        self.log("Fetching global brand list...")
        try:
            # Try active session token first to avoid re-sniffing
            token = GLOBAL_DATA['blaze'].get('token')
            if not token:
                self.log("No cached token found, fetching new token...")
                token = BlazeTokenManager.get_token()
            else:
                self.log("Using cached session token")
            
            if not token:
                self.log("WARNING: No token available for brand fetch. Using brandId as fallback.")
                return
            
            self.brand_map = BlazeTokenManager.fetch_global_brands(token)
            
            if self.brand_map:
                self.log(f"SUCCESS: Loaded {len(self.brand_map)} brands")
                # Cache in global state for UI use
                GLOBAL_DATA['blaze']['inventory_brands'] = self.brand_map
            else:
                self.log("WARNING: Brand list empty. Products will show brandId instead.")
                
        except Exception as e:
            self.log(f"ERROR: Brand fetch error: {e}")
            return {}

    def fetch_store_products(self, store_name, headers):
        all_products = []
        limit = 1000
        start = 0
        page_num = 1
        
        self.log(f" PROCESSING: {store_name}")
        
        while True:
            if not GLOBAL_DATA['blaze']['inventory_running']: break # Stop flag

            url = "https://api.blaze.me/api/v1/mgmt/products"
            params = {"start": start, "limit": limit, "active": "true"}
            
            try:
                self.log(f"    Fetching Page {page_num} (Items {start}-{start+limit})...")
                r = requests.get(url, headers=headers, params=params, timeout=30)
                
                if r.status_code == 200:
                    data = r.json()
                    items = data.get('values', [])
                    
                    if not items:
                        self.log("      [SUCCESS] Page empty (Done).")
                        break
                        
                    all_products.extend(items)
                    
                    total_server = data.get('total', 0)
                    start += limit
                    page_num += 1
                    
                    if start > total_server and total_server > 0:
                        break
                else:
                    self.log(f"[!] [EMOJI][EMOJI] API Error {r.status_code}: {r.text[:50]}")
                    break
                    
            except Exception as e:
                self.log(f"[!] [EMOJI][EMOJI] Connection Error: {e}")
                break
                
        return all_products

    def normalize_products(self, products: List[Dict], store_name: str = "") -> pd.DataFrame:
        """Normalize products with brand name resolution."""
        clean_rows = []
        for p in products:
            total_qty = sum(float(q.get('quantity', 0)) for q in p.get('quantities', []))
            
            # BRAND RESOLUTION LOGIC (Multi-level fallback)
            brand_obj = p.get('brand', {})
            brand_name = None
            
            # STEP 1: Check brand.name
            if isinstance(brand_obj, dict):
                brand_name = brand_obj.get('name')
                # If name is missing, try resolving from brandId in global map
                if not brand_name:
                    brand_id = brand_obj.get('id')
                    if brand_id and self.brand_map:
                        brand_name = self.brand_map.get(brand_id, f"ID:{brand_id}")
            
            # STEP 2: CRITICAL FIX - Check root-level brandName key
            if not brand_name:
                brand_name = p.get('brandName')
            
            # STEP 3: Final fallback
            if not brand_name:
                brand_name = "N/A"
            
            row = {
                "BLAZE ID": p.get('id'),
                "Product Name": p.get('name'),
                "SKU": p.get('sku'),
                "Category": p.get('category', {}).get('name') if p.get('category') else "N/A",
                "Brand": brand_name,
                "Type": p.get('productType'),
                "Unit Price ($)": p.get('unitPrice', 0),
                "Total Quantity": total_qty,
                "Cannabis Type": p.get('cannabisType'),
                "Weight / Unit": p.get('weightPerUnit'),
                "Active": p.get('active'),
                "Low Threshold": p.get('lowInventoryThreshold'),
                "Potency (THC)": p.get('thc'),
                "Potency (CBD)": p.get('cbd'),
                "Created Date": datetime.fromtimestamp(p.get('created', 0)/1000).strftime('%Y-%m-%d') if p.get('created') else "",
                "Store": store_name  # Add store name for multi-store tracking
            }
            clean_rows.append(row)
        return pd.DataFrame(clean_rows)

    def run_report(self, target_store=None):
        """
        Run inventory report with GUARANTEED state reset using try/finally.
        This prevents the inventory_running flag from getting stuck if an exception occurs.
        """
        try:
            # Early validation
            if not self.keys:
                self.log("ERROR: No keys loaded. Aborting.")
                return False

            # Step 1: Fetch global brands FIRST
            self.fetch_global_brands()

            targets = self.keys if target_store == 'ALL' else {k: v for k, v in self.keys.items() if k == target_store}
            
            if not targets:
                self.log(f"ERROR: Store '{target_store}' not found in keys file.")
                return False

            all_data_frames = []  # Collect all store data
            
            for store_name, info in targets.items():
                if not GLOBAL_DATA['blaze']['inventory_running']: 
                    self.log("STOPPED: Operation cancelled by user")
                    break
                
                headers = info.get('full_headers_dump', {})
                headers['Accept'] = 'application/json, text/plain, */*'
                
                raw = self.fetch_store_products(store_name, headers)
                if raw:
                    df = self.normalize_products(raw, store_name)
                    self.store_data[store_name] = df
                    all_data_frames.append(df)
                else:
                    self.log(f"WARNING: No data found for {store_name}")

            # Combine all stores into single DataFrame for UI
            if all_data_frames:
                combined_df = pd.concat(all_data_frames, ignore_index=True)
                GLOBAL_DATA['blaze']['inventory_data'] = combined_df
                self.log(f"SUCCESS: Loaded {len(combined_df)} total products into memory")

            # Generate timestamped files
            if self.store_data:
                timestamp = datetime.now().strftime('%Y_%m_%d_%H_%M_%S')
                
                if len(self.store_data) == 1:
                    # Single store CSV export
                    store_name = list(self.store_data.keys())[0]
                    df = list(self.store_data.values())[0]
                    safe_store = store_name.replace("The Artist Tree - ", "").replace("/", "-").replace(":", "")
                    filename = f"{safe_store}_BLAZE_INVENTORY_{timestamp}.csv"
                    filepath = INVENTORY_DIR / filename
                    
                    self.log(f"Saving CSV: {filename}...")
                    try:
                        df.to_csv(filepath, index=False)
                        self.log(f"SUCCESS: Saved to: {filepath}")
                    except Exception as e:
                        self.log(f"ERROR: Write Error: {e}")
                else:
                    # Multi-store Excel export
                    filename = f"ALL_STORES_BLAZE_INVENTORY_{timestamp}.xlsx"
                    filepath = INVENTORY_DIR / filename
                    
                    self.log(f"Saving Multi-Store Excel: {filename}...")
                    try:
                        with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
                            for store_name, df in self.store_data.items():
                                safe_name = store_name.replace("The Artist Tree - ", "").replace("/", "-")[:30]
                                df.to_excel(writer, sheet_name=safe_name, index=False)
                        self.log(f"SUCCESS: Saved to: {filepath}")
                    except Exception as e:
                        self.log(f"ERROR: Write Error: {e}")
                        
                self.log("COMPLETE: Report generated successfully.")
            else:
                self.log("ERROR: No data collected to write.")
            
            return True
            
        except Exception as e:
            # Log the error but don't re-raise
            self.log(f"[X] CRITICAL ERROR: {str(e)}")
            self.log(f"Stack trace: {traceback.format_exc()}")
            return False
            
        finally:
            # CRITICAL: Always reset the running flag, no matter what
            GLOBAL_DATA['blaze']['inventory_running'] = False
            GLOBAL_DATA['blaze']['inventory_start_time'] = None
            self.log("[OK] State reset complete (inventory_running = False)")

# ============================================================================
# FLASK APPLICATION
# ============================================================================
app = Flask(__name__)

# v12.12.5 FIX: Global JSON error handlers prevent HTML error pages
@app.errorhandler(500)
def handle_500_error(error):
    """Return JSON instead of HTML for 500 errors"""
    return jsonify({
        'success': False,
        'error': f'Internal Server Error: {str(error)}'
    }), 500

@app.errorhandler(Exception)
def handle_exception(error):
    """Catch-all exception handler - return JSON"""
    import traceback
    tb = traceback.format_exc()
    print(f"[FLASK-ERROR] Unhandled exception: {error}")
    print(tb)
    return jsonify({
        'success': False,
        'error': f'Server Error: {str(error)}'
    }), 500

# v12.12.5 FIX: CORS support for requests from MIS browser tab
@app.after_request
def add_cors_headers(response):
    """Add CORS headers to allow requests from MIS browser tab"""
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response

# HTML TEMPLATE (COMPLETE WITH MULTI-DAY SUPPORT)
HTML_TEMPLATE = r"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIS + Blaze Dashboard</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdn.datatables.net/1.13.6/css/dataTables.bootstrap5.min.css" rel="stylesheet">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container-main {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { font-size: 1.1em; opacity: 0.9; }
        
        .main-nav {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
        }
        .main-nav-btn {
            flex: 1;
            padding: 20px;
            background: none;
            border: none;
            font-size: 1.3em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            color: #495057;
        }
        .main-nav-btn:hover { background: #e9ecef; }
        .main-nav-btn.active {
            background: white;
            color: #667eea;
            border-bottom: 4px solid #667eea;
        }
        
        .sub-nav {
            display: none;
            background: #ffffff;
            border-bottom: 1px solid #dee2e6;
            padding: 10px 20px;
        }
        .sub-nav.active { display: flex; }
        .sub-nav-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: #6c757d;
            border-radius: 8px;
            margin-right: 5px;
        }
        .sub-nav-btn:hover { background: #f8f9fa; }
        .sub-nav-btn.active {
            background: #667eea;
            color: white;
        }
        
        /* DEAL TYPE SUB-TABS (Weekly/Monthly/Sale/All) */
        .deal-type-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f1f3f5;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .deal-type-btn {
            padding: 8px 16px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #495057;
        }
        .deal-type-btn:hover {
            background: #e9ecef;
            border-color: #667eea;
        }
        .deal-type-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        .deal-type-btn .badge {
            margin-left: 6px;
            font-size: 0.75em;
            padding: 2px 6px;
        }
        .deal-type-content {
            display: none;
        }
        .deal-type-content.active {
            display: block;
        }
        
        .content {
            padding: 40px;
            min-height: 500px;
        }
        
        .main-section { display: none; }
        .main-section.active { display: block; }
        
        .sub-section { display: none; }
        .sub-section.active { display: block; }

        /* Split Audit Phase Styles (V29) */
        .split-phase-content { display: none; }
        .split-phase-content.active { display: block; }
        .split-phase-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: white !important;
            border-color: transparent !important;
        }
        
        .btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 5px;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        
        /* v12.5: Updated button styles - compact versions used in ID Matcher */
        .btn-approve { background: #28a745; padding: 8px 16px; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .btn-reject { background: #dc3545; padding: 8px 16px; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .btn-review { background: #17a2b8; padding: 8px 16px; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .btn-blaze { color: #0d6efd; }
        
        .input-group {
            margin-bottom: 20px;
        }
        .input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
        }
        
        .config-section {
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            background: #f8f9fa;
        }
        .config-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .table-container {
            overflow-y: auto; /* Enable vertical scrolling */
            overflow-x: auto; /* Enable horizontal scrolling if needed */
            margin-top: 20px;
            max-height: 70vh; /* CRITICAL: Give the container a fixed height so it CAN scroll */
            border: 1px solid #dee2e6; /* Optional: Adds a border around the scrollable area */
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        /* Debug Log Panel Styles */
        .debug-log-panel {
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            background: #f8f9fa;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .debug-messages {
            flex: 1;
            overflow-y: auto;
            max-height: 60px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.3;
        }
        .debug-messages .log-entry {
            margin-bottom: 2px;
            color: #495057;
        }
        .debug-messages .log-entry.success {
            color: #28a745;
        }
        .debug-messages .log-entry.error {
            color: #dc3545;
        }
        .debug-messages .log-entry.warning {
            color: #ffc107;
        }
        
        table {
            width: 100%;
            border-collapse: separate; /* Required for sticky headers to work properly in some browsers */
            border-spacing: 0;
            font-size: 0.9em;
        }
        th, td {
            padding: 12px 10px; /* Increased padding for readability */
            text-align: left;
            border-bottom: 1px solid #dee2e6;
            vertical-align: middle;
        }
        th {
            background: #667eea;
            color: white;
            font-weight: 600;
            position: sticky; /* The magic property */
            top: 0;           /* Sticks to the top of .table-container */
            z-index: 10;      /* Ensures it stays on top of content */
            box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4); /* Optional: Adds a shadow under header */
        }
        /* Fix for corner borders */
        th:first-child { border-top-left-radius: 4px; }
        th:last-child { border-top-right-radius: 4px; }
        tr:hover { background: #f8f9fa; }
        
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }
        .status-match { background: #d4edda; color: #155724; }
        .status-warning { background: #fff3cd; color: #856404; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-high { background: #d1ecf1; color: #0c5460; }
        .status-medium { background: #fff3cd; color: #856404; }
        .status-low { background: #f8d7da; color: #721c24; }
        
        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .alert-success { background: #d4edda; color: #155724; }
        .alert-warning { background: #fff3cd; color: #856404; }
        .alert-error { background: #f8d7da; color: #721c24; }
        .alert-info { background: #d1ecf1; color: #0c5460; }
        
        .row-approved { background: #d4edda !important; }
        .row-rejected { background: #f8d7da !important; opacity: 0.6; }
        
        .suggestion-indicator {
            display: inline-block;
            margin-left: 8px;
            cursor: pointer;
            font-size: 1.2em;
            vertical-align: middle;
        }
        .tooltip-container {
            position: absolute;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 600px;
            max-width: 800px;
            display: none;
        }
        .tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #dee2e6;
        }
        .tooltip-close {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        .suggestion-row {
            padding: 10px;
            margin: 8px 0;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .suggestion-row:hover { background: #f8f9fa; }
        .suggestion-data {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 0.9em;
        }
        .confidence-badge {
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 5px;
            min-width: 50px;
            text-align: center;
        }
        .confidence-high { background: #d4edda; color: #155724; }
        .confidence-medium { background: #fff3cd; color: #856404; }
        .confidence-low { background: #f8d7da; color: #721c24; }
        
        .brand-multi {
            background-color: #fff3cd !important;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            padding: 2px 6px;
            display: inline-block;
        }
        .brand-single {
            cursor: pointer;
            text-decoration: underline;
            color: #495057;
        }
        .brand-single:hover { color: #667eea; }
        
        .brand-popup {
            position: absolute;
            background: white;
            border: 1px solid #ced4da;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 2000;
            display: none;
            width: 200px;
            overflow: hidden;
        }
        .brand-popup-header {
            background: #f8f9fa;
            padding: 8px 12px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            font-size: 0.85em;
        }
        .brand-popup-close { cursor: pointer; color: #dc3545; font-weight: bold; }
        .brand-popup-body { padding: 5px; display: flex; flex-direction: column; gap: 4px; }
        .brand-select-btn {
            text-align: left;
            background: none;
            border: 1px solid transparent;
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .brand-select-btn:hover { background: #e9ecef; color: #667eea; }
        
        /* MULTI-DAY DEAL GROUPING */
        .group-container {
            border-left: 4px solid #ffc107;
            margin-bottom: 2px;
        }
        
        .group-header-row {
            background: #fff3cd !important;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .group-header-row:hover {
            background: #ffe69c !important;
        }
        
        .group-member-row {
            background: #fff3cd !important;  /* Match main definition - consistent yellow */
        }
        
        .group-member-row td {
            background: #fff3cd !important;  /* Ensure cells show yellow too */
        }
        
        .group-member-row.collapsed {
            display: none;
        }
        
        .group-toggle-icon {
            display: inline-block;
            margin-right: 8px;
            font-weight: bold;
            color: #856404;
            transition: transform 0.2s;
        }
        
        .group-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }
        
        .multi-day-badge {
            display: inline-block;
            background: #ffc107;
            color: #000;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
        }
        
        /* v12.2: Weekly Breakdown View - Weekday Section Headers */
        .weekday-header-row {
            background: #f0f4ff !important;
            border-top: 2px solid #007bff !important;
            font-weight: 500;
            cursor: default;
        }
        
        .weekday-header-row td {
            background: #f0f4ff !important;
            padding: 8px 10px !important;
        }
        
        .weekday-header-row:hover {
            background: #e3ecff !important;
        }
        
        .missing-weekday-warning {
            background: #f8d7da !important;
            border-left: 4px solid #dc3545 !important;
        }
        
        .weekday-missing-icon {
            color: #dc3545;
            font-weight: bold;
            margin-right: 4px;
        }
        
        .bulk-approve-btn {
            background: #28a745;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .bulk-approve-btn:hover {
            background: #218838;
        }
        
        .multi-day-banner {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .multi-day-banner a {
            color: #667eea;
            text-decoration: underline;
            cursor: pointer;
            margin: 0 4px;
        }
        
        .multi-day-banner strong {
            color: #000;
            font-weight: bold;
        }

/* New Focus Styles */
        .focus-panel {
            background: #f1f3f5;
            border: 2px solid #ced4da;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .focus-panel.active {
            border-color: #667eea;
            background: #e7f5ff;
        }
        
        /* Search Enhancement Styles */
        .bi-search, .fa-search, [class*="search-icon"] {
            cursor: pointer;
            transition: color 0.2s;
        }

        .bi-search:hover, .fa-search:hover, [class*="search-icon"]:hover {
            color: #667eea;
        }

        .search-trigger-btn {
            transition: all 0.2s;
        }

        .search-trigger-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        input[type="search"] {
            transition: border-color 0.2s;
        }

        input[type="search"]:focus {
            border-color: #667eea !important;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

/* FIX: WIDER TOOLTIPS */
        .tooltip-inner {
            max-width: 800px !important;  /* Allow wide content */
            text-align: left !important;  /* Align text left for readability */
            white-space: pre-wrap;       /* Preserve formatting */
        }

/* ==================================================================
   FREEZE PANES - Excel-Style Sticky Headers
   ================================================================== */
        .scrollable-table-container {
            max-height: 65vh;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            position: relative;
        }
        
        .scrollable-table-container table {
            width: 100%;
            margin-bottom: 0;
        }
        
        .scrollable-table-container thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: white;
        }
        
        .scrollable-table-container thead th {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            font-weight: 600;
            padding: 12px 8px;
            text-align: left;
            position: sticky;
            top: 0;
        }
        
        .scrollable-table-container tbody tr:hover {
            background-color: #f5f5f5;
        }

/* ==================================================================
   BLAZE TABLE - Column Width Adjustments
   ================================================================== */
        /* DataTables wrapper fix - ensure proper height and visibility */
        #promotionsTableWrapper {
            width: 100%;
        }
        #promotionsTableWrapper .dataTables_scrollBody {
            min-height: 200px;
        }
        #promotionsTable_wrapper {
            width: 100%;
        }
        
        /* Detail column - compact for emoji */
        #promotionsTable th:nth-child(1),
        #promotionsTable td:nth-child(1) {
            max-width: 50px;
            text-align: center;
        }
        
        /* Name column - reduced width by 30% */
        #promotionsTable th:nth-child(3),
        #promotionsTable td:nth-child(3) {
            max-width: 200px;  /* Reduced from ~285px (30% narrower) */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Auto/Manual column - compact */
        #promotionsTable th:nth-child(5),
        #promotionsTable td:nth-child(5) {
            max-width: 100px;
            text-align: center;
        }
        
        /* Groups columns - controlled by badge width */
        #promotionsTable th:nth-child(8),
        #promotionsTable td:nth-child(8),
        #promotionsTable th:nth-child(9),
        #promotionsTable td:nth-child(9) {
            max-width: 150px;
        }

/* ==================================================================
   AUDIT TAB - Multi-Day Group Background Shading
   ================================================================== */
        /* All multi-day group rows are ALWAYS yellow for consistency */
        .group-member-row {
            background-color: #fff3cd !important;  /* Light yellow - ALWAYS */
        }
        
        /* CRITICAL: Force td cells to inherit row background (Bootstrap applies white to cells) */
        .group-member-row td,
        .group-member-row > td,
        tr.group-member-row td {
            background-color: #fff3cd !important;  /* Match parent row */
            background: #fff3cd !important;
        }
        
        /* Ensure table-striped doesn't override group row colors */
        .table-striped tbody tr.group-member-row,
        .table-striped tbody tr.group-member-row:nth-of-type(odd),
        .table-striped tbody tr.group-member-row:nth-of-type(even) {
            background-color: #fff3cd !important;  /* Light yellow - ALWAYS */
        }
        
        .table-striped tbody tr.group-member-row td,
        .table tbody tr.group-member-row td {
            background-color: #fff3cd !important;
            background: #fff3cd !important;
        }
        
        /* Hover state for group rows - slightly darker yellow */
        .group-member-row:hover,
        .group-member-row:hover td {
            background-color: #ffe5b4 !important;  /* Peach on hover */
            background: #ffe5b4 !important;
        }
        
        /* Scrollable container override for group rows */
        .scrollable-table-container tbody tr.group-member-row,
        .scrollable-table-container tbody tr.group-member-row td {
            background-color: #fff3cd !important;
            background: #fff3cd !important;
        }
        
        .scrollable-table-container tbody tr.group-member-row:hover,
        .scrollable-table-container tbody tr.group-member-row:hover td {
            background-color: #ffe5b4 !important;
            background: #ffe5b4 !important;
        }

/* ==================================================================
   BLAZE DETAIL MODAL - Dual-State (Hover + Pin)
   ================================================================== */
        /* Modal Backdrop */
        #detailModalBackdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }
        
        /* Modal Container */
        #detailModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 9999;
            padding: 20px;
        }
        
        /* Modal Header */
        #detailModal .modal-header {
            border-bottom: 2px solid #0066cc;
            padding-bottom: 15px;
            margin-bottom: 20px;
            position: relative;
        }
        
        #detailModal .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        #detailModal .modal-id {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        #detailModal .modal-type {
            font-size: 1rem;
            color: #0066cc;
            font-weight: bold;
        }
        
        /* Close Button */
        #detailModal .close-btn {
            position: absolute;
            top: 0;
            right: 0;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            font-weight: bold;
        }
        
        #detailModal .close-btn:hover {
            background: #c82333;
        }
        
        /* Modal Body */
        #detailModal .modal-body {
            line-height: 1.6;
        }
        
        #detailModal .section-header {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        
        #detailModal .data-row {
            margin-bottom: 8px;
            padding-left: 10px;
        }
        
        #detailModal .data-label {
            font-weight: bold;
            color: #555;
        }
        
        #detailModal .data-value {
            color: #333;
        }

        /* v63: TAX CALCULATOR MODAL STYLES */
        #calcModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        #calcModal.show {
            display: flex;
        }
        
        #calcModal .calc-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        #calcModal .calc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #667eea;
        }
        
        #calcModal .calc-header h2 {
            margin: 0;
            color: #667eea;
        }
        
        #calcModal .calc-close {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 20px;
            cursor: pointer;
            line-height: 1;
        }
        
        #calcModal .calc-close:hover {
            background: #c82333;
        }
        
        #calcModal .store-selector {
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        #calcModal .store-selector label {
            font-weight: bold;
            display: block;
            margin-bottom: 8px;
            color: #495057;
        }
        
        #calcModal .store-selector select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 1em;
        }
        
        #calcModal .store-selector .tax-rate-display {
            margin-top: 8px;
            padding: 8px;
            background: #e7f5ff;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            font-weight: bold;
            color: #495057;
        }
        
        #calcModal .calc-section {
            margin-bottom: 25px;
            padding: 20px;
            background: #ffffff;
            border: 2px solid #e9ecef;
            border-radius: 8px;
        }
        
        #calcModal .calc-section h3 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.2em;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        
        #calcModal .calc-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        #calcModal .calc-row label {
            flex: 0 0 140px;
            font-weight: 600;
            color: #6c757d;
        }
        
        #calcModal .calc-row input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 1em;
        }
        
        #calcModal .calc-row .result {
            flex: 1;
            padding: 8px 12px;
            background: #e7f5ff;
            border: 2px solid #667eea;
            border-radius: 4px;
            font-weight: bold;
            color: #667eea;
        }
        
        #calcModal .calc-row button {
            padding: 8px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }
        
        #calcModal .calc-row button:hover {
            background: #5568d3;
        }


        /* Waterfall Filter Styles */
        .filter-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        .filter-group {
            flex: 1;
        }

        .filter-label {
            font-weight: 600;
            font-size: 0.9rem;
            color: #495057;
            margin-bottom: 5px;
        }

        .filter-select {
            width: 100%;
            padding: 8px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }

        .filter-select:focus {
            border-color: #667eea;
            outline: none;
        }

        /* Paperclip Tooltip Styles */
        .paperclip-tooltip {
            position: absolute;
            background: #2c3e50;
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
            min-width: 200px;
        }

        .paperclip-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .paperclip-item:last-child {
            border-bottom: none;
        }

        .paperclip-label {
            font-weight: 600;
            margin-right: 10px;
        }

        .paperclip-value {
            flex: 1;
            margin-right: 10px;
            word-break: break-all;
        }

        .paperclip-icon {
            cursor: pointer;
            font-size: 1.1rem;
            transition: transform 0.2s;
        }

        .paperclip-icon:hover {
            transform: scale(1.2);
        }

        .name-with-tooltip {
            cursor: help;
            position: relative;
        }

        /* Clickable Product Names */
        .clickable-name {
            cursor: pointer;
            transition: color 0.2s ease, text-decoration 0.2s ease;
        }

        .clickable-name:hover {
            color: #0d6efd;
            text-decoration: underline;
        }

        /* SKU Buttons */
        .sku-button {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            padding: 2px 8px;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .sku-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .sku-button:active {
            transform: translateY(0);
        }

        /* Spin animation for loading icon */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spin {
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        /* Zombie Cleanup Styles */
        .zombie-toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .zombie-toggle-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #495057;
            white-space: nowrap;
        }

        .zombie-toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
        }

        .zombie-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .zombie-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 20px;
        }

        .zombie-toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .zombie-toggle-switch input:checked + .zombie-toggle-slider {
            background-color: #dc3545;
        }

        .zombie-toggle-switch input:checked + .zombie-toggle-slider:before {
            transform: translateX(20px);
        }

        #zombieCleanupBtn {
            transition: all 0.3s ease;
        }

        #zombieCleanupBtn.cleanup-mode {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
            border-color: #28a745 !important;
        }

        /* Zombie Cleanup Modal */
        .zombie-modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10000;
            display: none;
        }

        .zombie-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 25px;
            width: 500px;
            max-width: 90%;
            z-index: 10001;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .zombie-modal h3 {
            margin: 0 0 15px 0;
            color: #dc3545;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zombie-modal p {
            color: #495057;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .zombie-modal .btn-group-vertical {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .zombie-modal .btn {
            padding: 12px 20px;
            font-weight: 600;
            border-radius: 8px;
        }

        .zombie-progress-container {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .zombie-progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .zombie-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545, #fd7e14);
            width: 0%;
            transition: width 0.3s ease;
        }

        .zombie-progress-text {
            font-size: 0.85rem;
            color: #6c757d;
            text-align: center;
        }

        /* Download Filtered Button */
        #downloadFilteredBtn {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container-main">
<div class="header">
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <!-- Profile Selector (Google Chrome Colors) -->
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="display: flex; align-items: center; background: linear-gradient(135deg, #4285F4 0%, #34A853 50%, #FBBC05 75%, #EA4335 100%); padding: 2px; border-radius: 8px;">
                        <select id="profile-selector" class="form-select form-select-sm" 
                                style="font-weight: 600; border: none; border-radius: 6px; min-width: 160px; cursor: pointer;"
                                onchange="onProfileChange(this.value)">
                            <option value="">Loading profiles...</option>
                        </select>
                    </div>
                    <button class="btn btn-sm" onclick="openRegisterModal()" 
                            style="background: linear-gradient(135deg, #34A853 0%, #4285F4 100%); color: white; border: none; font-weight: 600; padding: 6px 12px;">
                        <i class="bi bi-plus-lg"></i> New
                    </button>
                </div>
                
                <!-- Tax Calculator Button -->
                <button id="calcDropdownBtn" class="btn btn-primary" onclick="toggleCalcModal()" 
                        style="font-size: 1.2em; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none;">
                     Tax Calculator
                </button>
            </div>
        </div>
        
        <!-- Restart Required Banner (hidden by default) -->
        <div id="restart-banner" style="display: none; background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%); color: white; padding: 12px 20px; text-align: center;">
            <strong><i class="bi bi-arrow-repeat"></i> Profile Changed!</strong> 
            <span id="restart-banner-text">Restart required to apply changes.</span>
            <button class="btn btn-light btn-sm ms-3" onclick="restartApplication()" style="font-weight: 600;">
                <i class="bi bi-power"></i> Restart Now
            </button>
            <button class="btn btn-outline-light btn-sm ms-2" onclick="hideRestartBanner()">
                Later
            </button>
        </div>
        
        <div class="main-nav" style="display: flex; background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
            <button class="main-nav-btn active" onclick="switchMainTab('setup', this)">&#x2699; Setup</button>
            <button class="main-nav-btn" onclick="switchMainTab('mis', this)"> Audit</button>
            <button class="main-nav-btn" onclick="switchMainTab('blaze', this)"> BLAZE</button>
        </div>
        
        <div id="mis-sub-nav" class="sub-nav" style="display:none; padding:10px 20px; background:#fff; border-bottom:1px solid #dee2e6;">
            <button class="sub-nav-btn active" onclick="switchMISTab('csv-gen', this)">Creation Checklist</button>
            <button class="sub-nav-btn" onclick="switchMISTab('id-match', this)">ID Matcher - Google Sheet > MIS CSV</button>
            <button class="sub-nav-btn" onclick="switchMISTab('cleanup-audit', this)" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none;">&#x1F9F9; Cleanup Audit</button>
            <button class="sub-nav-btn" onclick="switchMISTab('split-audit', this)" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none;">&#x2702; Up-Down Planning</button>
            <button class="sub-nav-btn" onclick="switchMISTab('comp-audit', this)" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; border: none;"><i class="bi bi-clipboard-check"></i> Comprehensive Audit</button>
            <button class="sub-nav-btn" onclick="switchMISTab('conflict', this)">Conflict Audit - Active</button>
            <button id="reinject-validation-btn" onclick="reinjectValidation()" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; border: none; padding: 8px 16px; border-radius: 4px; font-weight: bold; cursor: pointer; margin-left: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" title="Re-inject validation code into MIS browser tab after page refresh">&#x1F504; Re-inject Validation</button>
        </div>

        <div class="content" style="padding:40px;">
            <!-- SETUP TAB -->
            <div id="setup-section" class="main-section active">
                
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h2>Setup & Configuration</h2>
                    <div id="browser-ready-status" class="alert alert-secondary py-1 px-3 mb-0" style="font-size: 0.9em;">
                        <strong>Browser:</strong> <span id="browser-ready-text">Initializing...</span>
                    </div>
                </div>

                <div class="row g-3 mb-3">
                    
                    <div class="col-lg-7">
                        <div class="card h-100 shadow-sm">
                            <div class="card-header bg-light fw-bold text-uppercase text-muted small d-flex justify-content-between align-items-center">
                                <span><i class="bi bi-shield-lock"></i> System Credentials</span>
                                <button class="btn btn-danger btn-sm py-0" style="font-size: 0.8em;" data-bs-toggle="modal" data-bs-target="#helpModal">
                                    <i class="bi bi-question-circle-fill"></i> HELP!
                                </button>
                            </div>
                            <div class="card-body d-flex flex-column justify-content-center">
                                
                                <div class="d-flex align-items-center gap-3 mb-3 pb-3 border-bottom">
                                    <button class="btn btn-outline-primary btn-sm" onclick="authenticateGoogle()">Authenticate Google Sheets</button>
                                    <div id="auth-status" class="d-inline-block small"></div> 
                                </div>

                                <div class="row g-2 align-items-center mb-3">
                                    <div class="col-9">
                                        <div class="input-group">
                                            <span class="input-group-text bg-white"><i class="bi bi-link-45deg"></i></span>
                                            <input type="text" id="mis-sheet-url" class="form-control" placeholder="Google Sheet URL">
                                        </div>
                                    </div>
                                    <div class="col-3">
                                        <button class="btn btn-secondary w-100" onclick="loadMISSheetTabs(this)">Load Tabs</button>
                                    </div>
                                </div>

                                <div class="row g-2 align-items-center">
                                    <div class="col-md-6">
                                        <select id="mis-tab" class="form-select form-select-sm">
                                            <option value="">-- No tabs loaded --</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6 d-flex align-items-center gap-2">
                                        <div class="form-check form-switch mb-0" style="white-space: nowrap;">
                                            <input class="form-check-input" type="checkbox" id="mis-show-all-tabs" onchange="renderTabOptions()">
                                            <label class="form-check-label small" for="mis-show-all-tabs">All Tabs</label>
                                        </div>
                                        <button class="btn btn-primary btn-sm flex-grow-1" onclick="initializeSheetPage(this)">Open Sheet</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="col-lg-5">
                        <div class="card h-100 shadow-sm">
                            <div class="card-header bg-light fw-bold text-uppercase text-muted small">
                                <i class="bi bi-shield-lock"></i> System Credentials
                            </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6 border-end">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <div class="d-flex align-items-center gap-2">
                                        <h6 class="text-muted fw-bold mb-0">MIS Config</h6>
                                        <button class="btn btn-outline-success py-0 px-2" style="font-size: 0.75em; height: 20px; line-height: 1;" onclick="pullMisCsv(this)">
                                            <i class="bi bi-download"></i> MIS CSV
                                        </button>
                                        <button class="btn btn-outline-secondary py-0 px-2" style="font-size: 0.75em; height: 20px; line-height: 1;" onclick="openMisReportsFolder()" title="Open MIS Reports folder">
                                            <i class="bi bi-folder2-open"></i>
                                        </button>
                                    </div>
                                    <div style="width: 50%;">
                                        <input type="file" id="mis-csv" accept=".csv" class="form-control form-control-sm" style="font-size: 0.8em;" onchange="handleMISCSV(this)">
                                    </div>
                                </div>
                                <div id="mis-csv-status" class="small text-success text-end mb-2" style="min-height: 1.2em; font-size: 0.75em; margin-top:-5px;"></div>
                                <div id="mis-csv-folder-path" class="small text-muted text-end" style="font-size: 0.65em; margin-top:-10px; word-break: break-all;"></div>

                                <div class="mb-2">
                                    <input type="text" id="mis-username" class="form-control form-control-sm mb-1" placeholder="MIS Username">
                                    <input type="password" id="mis-password" class="form-control form-control-sm" placeholder="MIS Password">
                                </div>
                            </div>

                            <div class="col-md-6">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <div class="d-flex align-items-center gap-2">
                                        <h6 class="text-muted fw-bold mb-0">Blaze Config</h6>
                                        <button class="btn btn-outline-warning py-0 px-2" 
                                                style="font-size: 0.75em; height: 20px; line-height: 1; font-weight: bold; color: #d39e00; border-color: #ffc107;" 
                                                onclick="runTierUpdate(this)"
                                                title="Run automated tag updates for T1/T2/T3 Bag Days">
                                            Update Tier Promos
                                        </button>
                                    </div>
                                </div>
                                
                                <div id="blaze-sync-status" class="small mb-1" style="min-height:18px; font-size: 0.8em;"></div>

                                <div class="mb-2 mt-1">
                                    <input type="text" id="blaze-email" class="form-control form-control-sm mb-1" placeholder="Blaze Email">
                                    <input type="password" id="blaze-password" class="form-control form-control-sm" placeholder="Blaze Password">
                                </div>
                                
                                <!-- v12.24.0: Blaze Ecom Sync to Tymber -->
                                <div class="mt-2 pt-2 border-top">
                                    <div class="d-flex align-items-center gap-2 mb-1">
                                        <h6 class="text-muted fw-bold mb-0" style="font-size: 0.75em;">Ecom Sync</h6>
                                    </div>
                                    <div class="d-flex align-items-center gap-2">
                                        <select id="ecom-sync-store" class="form-select form-select-sm" style="flex: 1; font-size: 0.8em;">
                                            <option value="">Select Store...</option>
                                            <option value="DAVIS">DAVIS</option>
                                            <option value="DIXON">DIXON</option>
                                            <option value="NAPA">NAPA</option>
                                            <option value="SANTA ROSA">SANTA ROSA</option>
                                            <option value="OAKLAND">OAKLAND</option>
                                            <option value="SAN FRANCISCO">SAN FRANCISCO</option>
                                            <option value="LOS ANGELES">LOS ANGELES</option>
                                            <option value="SAN DIEGO">SAN DIEGO</option>
                                            <option value="SAN JOSE">SAN JOSE</option>
                                            <option value="SACRAMENTO">SACRAMENTO</option>
                                            <option value="FRESNO">FRESNO</option>
                                            <option value="LONG BEACH">LONG BEACH</option>
                                        </select>
                                        <button class="btn btn-outline-primary btn-sm" 
                                                onclick="syncToTymber(this)"
                                                title="Sync inventory to Tymber menu for selected store">
                                            <i class="bi bi-cloud-upload"></i> SYNC TO TYMBER
                                        </button>
                                    </div>
                                    <div id="ecom-sync-status" class="small mt-1" style="min-height: 18px; font-size: 0.75em; color: #6c757d;">Ready</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                </div>  <!-- Close col-lg-5 -->
            </div>  <!-- Close row g-3 mb-3 -->


                <div class="d-grid gap-2">
                    <button class="btn btn-success btn-lg fw-bold" onclick="initializeAllSystems(this)">
                        <i class="bi bi-play-circle-fill"></i> Initialize Browser & Login to Both Systems
                    </button>
                    <div id="init-status" class="text-center mt-2"></div>
                </div>

                <!-- TAX RATES CONFIGURATION -->
                <div class="row g-3 mt-3">
                    <div class="col-12">
                        <div class="card shadow-sm">
                            <div class="card-header bg-light fw-bold text-uppercase text-muted small">
                                <i class="bi bi-calculator"></i> &#x1F5A9; Tax Rates Configuration
                            </div>
                            <div class="card-body">
                                <p class="text-muted small mb-3">
                                    Edit tax rates below. Default values are hardcoded. Changes are saved to <code>tax_config.json</code>.
                                </p>
                                <div class="row g-2" id="tax-rates-container">
                                    <!-- Tax rate inputs will be populated by JavaScript -->
                                </div>
                                <div class="d-flex justify-content-end gap-2 mt-3">
                                    <button class="btn btn-secondary" onclick="loadTaxRatesForEdit()">
                                        <i class="bi bi-arrow-clockwise"></i> Reload
                                    </button>
                                    <button class="btn btn-primary" onclick="saveTaxRates()">
                                        <i class="bi bi-save"></i> Save Tax Rates
                                    </button>
                                </div>
                                <div id="tax-save-status" class="mt-2 text-center small"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="setup-summary"></div>
            </div>
            
            <!-- MIS TAB -->
            <div id="mis-section" class="main-section">
                
                <!-- Creation Checklist -->
                <div id="csv-gen-section" class="sub-section active">
                    <h2>Creation Checklist</h2>
                    <button class="btn" onclick="generateCSV()">Generate CSV</button>
                    <div id="gen-results">
                        <!-- Deal type sub-tabs will be injected here by displayGeneratedCSV() -->
                    </div>
                </div>
                
                <!-- ID Matcher -->
                <div id="id-match-section" class="sub-section">
                    <h2>ID Matcher</h2>
                    
                    <!-- v12.1: Subtabs for ID Matcher and MAudit -->
                    <ul class="nav nav-tabs mb-3" id="idMatcherSubTabs">
                        <li class="nav-item">
                            <a class="nav-link active" href="#" onclick="switchIdMatcherSubTab('matcher', this); return false;">ID Matcher</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#" onclick="switchIdMatcherSubTab('maudit', this); return false;">Google > MAudit</a>
                        </li>
                    </ul>
                    
                    <!-- ID Matcher Subtab Content -->
                    <div id="id-matcher-subtab-matcher" class="id-matcher-subtab-content">
                        <div class="focus-panel" id="matcher-focus-panel">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="matcher-focus-enable" onchange="toggleFocus('matcher')">
                                <label class="form-check-label fw-bold" for="matcher-focus-enable"> Enable Focus</label>
                            </div>
                            <div id="matcher-focus-controls" style="display:flex; gap:15px; opacity:0.5; pointer-events:none;">
                                <input type="date" id="matcher-focus-date" class="form-control" style="width:auto;">
                                <div class="form-check form-switch pt-2">
                                    <input class="form-check-input" type="checkbox" id="matcher-focus-expand">
                                    <label class="form-check-label" for="matcher-focus-expand"> Expand to Month</label>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; margin-left: auto;">
                                <button class="btn" onclick="runMatcher()">Run Matcher</button>
                                <div id="apply-btns-container" style="display:none;">
                                    <button id="apply-mis-btn" class="btn btn-success btn-sm" onclick="applyMatches('mis')" title="Apply only MIS IDs to Google Sheet">
                                        <i class="bi bi-file-earmark-plus"></i> Apply MIS IDs
                                    </button>
                                    <button id="apply-blaze-btn" class="btn btn-primary btn-sm" onclick="applyMatches('blaze')" title="Apply only Blaze Titles to Google Sheet">
                                        <i class="bi bi-lightning-charge"></i> Apply Blaze Titles
                                    </button>
                                    <button id="apply-all-btn" class="btn btn-warning btn-sm" onclick="applyMatches('all')" title="Apply both MIS IDs and Blaze Titles">
                                        <i class="bi bi-check2-all"></i> Apply All
                                    </button>
                                </div>
                                <span id="matcher-status" style="color: #666; font-style: italic; font-size: 0.9em;"></span>
                            </div>
                        </div>
                        <div id="match-results">
                            <!-- Deal type sub-tabs will be injected here by displayMatchResults() -->
                        </div>
                    </div>
                    
                    <!-- MAudit Subtab Content (v12.1) -->
                    <div id="id-matcher-subtab-maudit" class="id-matcher-subtab-content" style="display:none;">
                        <div class="alert alert-info mb-3">
                            <i class="bi bi-info-circle"></i> 
                            <strong>Google > MAudit:</strong> Verify Google Sheet deals against MIS CSV data.
                            <br><small class="text-muted">Compares: Discount, Vendor %, Start/End Dates, Brand, Locations. Groups by verification status.</small>
                        </div>
                        
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div>
                                <button class="btn btn-primary" onclick="runMAudit()">
                                    <i class="bi bi-check2-circle"></i> Run MAudit Verification
                                </button>
                                <span id="maudit-status" class="ms-2" style="color: #666; font-style: italic;"></span>
                            </div>
                        </div>
                        
                        <div id="maudit-results">
                            <!-- MAudit results will be injected here by renderMAuditResults() -->
                            <p class="text-muted">Click "Run MAudit Verification" to compare Google Sheet against MIS CSV.</p>
                        </div>
                    </div>
                </div>
                <div id="conflict-section" class="sub-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h2>[!] [EMOJI][EMOJI] Conflict Audit</h2>
                        <div>
                            <span id="conflict-stats" class="badge bg-secondary fs-6 me-2">Ready to Scan</span>
                            <button class="btn btn-warning fw-bold" onclick="runConflictAudit()">
                                <i class="bi bi-radioactive"></i> Run Conflict Check
                            </button>
                        </div>
                    </div>
                    
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle"></i> 
                        Scans <strong>Active Deals</strong> (running today) in MIS .CSV for duplicates/potential conflicts based on 
                        <strong>Brand and Weekday</strong>, ignores store location for now.
                    </div>

                    <div id="conflict-results">
                        <!-- Conflict results will be injected here by renderConflictResults() -->
                    </div>
                </div> 

                <!-- ============================================ -->
                <!-- CLEANUP AUDIT - Find stale MIS entries -->
                <!-- ============================================ -->
                <div id="cleanup-audit-section" class="sub-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h2 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                            &#x1F9F9; Cleanup Audit
                        </h2>
                        <div>
                            <span id="cleanup-audit-stats" class="badge bg-secondary fs-6 me-2">Ready</span>
                            <button class="btn btn-primary fw-bold" onclick="runCleanupAudit()">
                                <i class="bi bi-search"></i> Run Cleanup Audit
                            </button>
                        </div>
                    </div>

                    <div class="alert alert-info mb-3">
                        <strong><i class="bi bi-lightbulb"></i> Purpose:</strong> Find active MIS entries that should be turned off.
                        <br><small class="text-muted">
                            Identifies MIS entries that are <strong>active</strong> (no end date or end date in future) 
                            but are <strong>NOT</strong> found in the Google Sheet. These are potential stragglers from old deals.
                        </small>
                    </div>

                    <!-- Detection Method Sub-Tabs -->
                    <ul class="nav nav-tabs mb-3" id="cleanupMethodTabs">
                        <li class="nav-item">
                            <a class="nav-link active" href="#" onclick="switchCleanupMethod('full-match', this); return false;">
                                <i class="bi bi-check2-all"></i> Full Field Match
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#" onclick="switchCleanupMethod('id-only', this); return false;">
                                <i class="bi bi-hash"></i> MIS ID Only
                            </a>
                        </li>
                    </ul>

                    <!-- Method 1: Full Field Match -->
                    <div id="cleanup-method-full-match" class="cleanup-method-content" style="display:block;">
                        <div class="alert alert-secondary mb-3">
                            <strong>Full Field Match:</strong> Finds active MIS entries where Brand + Weekday + Discount + Vendor% + Locations 
                            do NOT match any row in the Google Sheet.
                        </div>
                        
                        <!-- Section Sub-Tabs (Weekly/Monthly/Sale) -->
                        <ul class="nav nav-pills mb-3" id="cleanupFullMatchSectionTabs">
                            <li class="nav-item">
                                <a class="nav-link active" href="#" onclick="filterCleanupSection('full-match', 'all', this); return false;">All</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('full-match', 'weekly', this); return false;">Weekly</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('full-match', 'monthly', this); return false;">Monthly</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('full-match', 'sale', this); return false;">Sale</a>
                            </li>
                        </ul>
                        
                        <div id="cleanup-full-match-results">
                            <p class="text-muted">Click "Run Cleanup Audit" to scan for stale MIS entries.</p>
                        </div>
                    </div>

                    <!-- Method 2: MIS ID Only -->
                    <div id="cleanup-method-id-only" class="cleanup-method-content" style="display:none;">
                        <div class="alert alert-secondary mb-3">
                            <strong>MIS ID Only:</strong> Finds active MIS entries whose ID does NOT appear anywhere 
                            in the Google Sheet's MIS ID column.
                        </div>
                        
                        <!-- Section Sub-Tabs (Weekly/Monthly/Sale) -->
                        <ul class="nav nav-pills mb-3" id="cleanupIdOnlySectionTabs">
                            <li class="nav-item">
                                <a class="nav-link active" href="#" onclick="filterCleanupSection('id-only', 'all', this); return false;">All</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('id-only', 'weekly', this); return false;">Weekly</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('id-only', 'monthly', this); return false;">Monthly</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('id-only', 'sale', this); return false;">Sale</a>
                            </li>
                        </ul>
                        
                        <div id="cleanup-id-only-results">
                            <p class="text-muted">Click "Run Cleanup Audit" to scan for stale MIS entries.</p>
                        </div>
                    </div>
                </div>

                <!-- ============================================ -->
                <!-- UP-DOWN PLANNING (formerly Split Audit) -->
                <!-- ============================================ -->
                <div id="split-audit-section" class="sub-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h2 style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                            &#x2702; Up-Down Planning
                        </h2>
                        <span id="split-audit-stats" class="badge bg-secondary fs-6">Ready</span>
                    </div>

                    <div class="alert alert-info mb-3">
                        <strong><i class="bi bi-lightbulb"></i> Purpose:</strong> Manage Weekly Deal splits when interrupted by Sale/Monthly deals.
                        <br><small class="text-muted">
                            <strong>Dominance Hierarchy:</strong> Sale/Monthly (Tier 1) > Weekly (Tier 2). 
                            Weekly deals must be <em>split</em> in MIS to avoid overlap on conflict dates.
                        </small>
                    </div>

                    <!-- Phase Sub-Tabs -->
                    <div class="btn-group mb-3" role="group" style="width: 100%;">
                        <button type="button" class="btn btn-outline-primary active split-phase-btn" 
                                onclick="switchSplitPhase('planning', this)" style="flex: 1;">
                            <i class="bi bi-list-task"></i> Phase 1: Planning
                        </button>
                        <button type="button" class="btn btn-outline-success split-phase-btn" 
                                onclick="switchSplitPhase('final-check', this)" style="flex: 1;">
                            <i class="bi bi-check2-all"></i> Phase 2: Final Verification
                        </button>
                    </div>

                    <!-- Phase 1: Planning -->
                    <div id="split-phase-planning" class="split-phase-content active">
                        <div class="card shadow-sm">
                            <div class="card-header bg-primary text-white">
                                <strong><i class="bi bi-list-task"></i> Phase 1: Planning (Google Sheet Only)</strong>
                            </div>
                            <div class="card-body">
                                <p class="text-muted mb-3">
                                    <strong>Goal:</strong> Analyze your Google Sheet and generate a <em>To-Do List</em> for MIS entries.
                                    <br>If a Weekly deal conflicts with a Sale/Monthly deal on specific dates, you'll see exactly how to split it.
                                </p>
                                
                                <div class="text-center mb-4">
                                    <button class="btn btn-primary btn-lg fw-bold shadow" onclick="runSplitPlanningAudit()" style="padding: 15px 40px;">
                                        <i class="bi bi-calendar-check"></i> Generate Split Plan
                                    </button>
                                </div>

                                <div id="split-planning-results">
                                    <!-- Planning results will be injected here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Phase 2: Final Verification -->
                    <div id="split-phase-final-check" class="split-phase-content" style="display: none;">
                        <div class="card shadow-sm">
                            <div class="card-header bg-success text-white">
                                <strong><i class="bi bi-check2-all"></i> Phase 2: Final Verification (Sheet + MIS CSV)</strong>
                            </div>
                            <div class="card-body">
                                <p class="text-muted mb-3">
                                    <strong>Goal:</strong> Verify that deals created in MIS match the expected entry plans from Phase 1.
                                    <br>Compares MIS IDs logged in Google Sheet against actual CSV data.
                                </p>

                                <div class="alert alert-success">
                                    <i class="bi bi-info-circle"></i> 
                                    <strong>Prerequisites:</strong>
                                    <ul class="mb-0 mt-2">
                                        <li>Complete Phase 1 to generate split plans</li>
                                        <li>Create all deals in MIS (Part 1, GAP, PATCH, Part 2)</li>
                                        <li>Log MIS IDs in Google Sheet using Apply buttons (with prefixes: "Gap: ", "Patch: ")</li>
                                        <li>Pull the latest MIS CSV after creating all deals</li>
                                    </ul>
                                </div>
                                
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <div class="card border-secondary">
                                            <div class="card-body text-center">
                                                <div class="mb-2 text-muted small">MIS CSV Status</div>
                                                <div id="phase2-csv-status" class="fw-bold text-secondary">
                                                    <i class="bi bi-file-earmark-x"></i> No CSV Loaded
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card border-secondary">
                                            <div class="card-body text-center">
                                                <button class="btn btn-outline-primary btn-sm" onclick="pullMisCsvForPhase2()">
                                                    <i class="bi bi-cloud-download"></i> Pull MIS CSV
                                                </button>
                                                <span class="text-muted small ms-2">(Updates global CSV)</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="text-center mb-4">
                                    <button class="btn btn-success btn-lg fw-bold shadow" onclick="runPhase2FinalCheck()" style="padding: 15px 40px;">
                                        <i class="bi bi-shield-check"></i> Run Final Verification
                                    </button>
                                </div>

                                <div id="split-final-check-results">
                                    <!-- Final verification results will be injected here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ============================================ -->
                <!-- v12.25.0: COMPREHENSIVE AUDIT -->
                <!-- ============================================ -->
                <div id="comp-audit-section" class="sub-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h2 style="color: #1a1a1a; font-weight: bold;">
                            <i class="bi bi-clipboard-check" style="color: #11998e;"></i> Comprehensive Audit
                        </h2>
                        <span id="comp-audit-stats" class="badge bg-secondary fs-6">Ready</span>
                    </div>

                    <div class="alert alert-info mb-3">
                        <i class="bi bi-clipboard-check"></i> 
                        <strong>Comprehensive Audit:</strong> Systematic verification of Google Sheet deals against MIS CSV and Blaze discounts.
                        <br><small class="text-muted">Sequential audit workflow with progress tracking, notes, and export capability.</small>
                    </div>
                    
                    <!-- Audit Controls -->
                    <div class="card mb-3 shadow-sm">
                        <div class="card-header bg-light">
                            <strong><i class="bi bi-sliders"></i> Audit Configuration</strong>
                        </div>
                        <div class="card-body">
                            <!-- Audit Mode Toggle -->
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <label class="form-label fw-bold">Audit Mode</label>
                                    <div class="btn-group w-100" role="group">
                                        <input type="radio" class="btn-check" name="auditMode" id="auditModeFull" value="full" checked onchange="toggleAuditMode()">
                                        <label class="btn btn-outline-primary" for="auditModeFull">Full Audit</label>
                                        <input type="radio" class="btn-check" name="auditMode" id="auditModeCustom" value="custom" onchange="toggleAuditMode()">
                                        <label class="btn btn-outline-primary" for="auditModeCustom">Custom Audit</label>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Custom Audit Options (hidden by default) -->
                            <div id="customAuditOptions" style="display:none;">
                                <hr>
                                <div class="row mb-3">
                                    <!-- Section Filter -->
                                    <div class="col-md-4">
                                        <label class="form-label fw-bold">Sections</label>
                                        <div class="d-flex gap-3">
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" id="auditSectionWeekly" value="weekly" checked>
                                                <label class="form-check-label" for="auditSectionWeekly">Weekly</label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" id="auditSectionMonthly" value="monthly" checked>
                                                <label class="form-check-label" for="auditSectionMonthly">Monthly</label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" id="auditSectionSale" value="sale" checked>
                                                <label class="form-check-label" for="auditSectionSale">Sale</label>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Weekday Filter -->
                                    <div class="col-md-5">
                                        <label class="form-label fw-bold">Weekdays</label>
                                        <div class="d-flex gap-2 flex-wrap">
                                            <div class="form-check form-check-inline">
                                                <input class="form-check-input audit-weekday-check" type="checkbox" id="auditWeekMon" value="mon">
                                                <label class="form-check-label" for="auditWeekMon">Mon</label>
                                            </div>
                                            <div class="form-check form-check-inline">
                                                <input class="form-check-input audit-weekday-check" type="checkbox" id="auditWeekTue" value="tue">
                                                <label class="form-check-label" for="auditWeekTue">Tue</label>
                                            </div>
                                            <div class="form-check form-check-inline">
                                                <input class="form-check-input audit-weekday-check" type="checkbox" id="auditWeekWed" value="wed">
                                                <label class="form-check-label" for="auditWeekWed">Wed</label>
                                            </div>
                                            <div class="form-check form-check-inline">
                                                <input class="form-check-input audit-weekday-check" type="checkbox" id="auditWeekThu" value="thu">
                                                <label class="form-check-label" for="auditWeekThu">Thu</label>
                                            </div>
                                            <div class="form-check form-check-inline">
                                                <input class="form-check-input audit-weekday-check" type="checkbox" id="auditWeekFri" value="fri">
                                                <label class="form-check-label" for="auditWeekFri">Fri</label>
                                            </div>
                                            <div class="form-check form-check-inline">
                                                <input class="form-check-input audit-weekday-check" type="checkbox" id="auditWeekSat" value="sat">
                                                <label class="form-check-label" for="auditWeekSat">Sat</label>
                                            </div>
                                            <div class="form-check form-check-inline">
                                                <input class="form-check-input audit-weekday-check" type="checkbox" id="auditWeekSun" value="sun">
                                                <label class="form-check-label" for="auditWeekSun">Sun</label>
                                            </div>
                                        </div>
                                        <button class="btn btn-outline-secondary btn-sm mt-2" onclick="toggleWeekendAudit()">
                                            <i class="bi bi-calendar-weekend"></i> Weekend Toggle
                                        </button>
                                    </div>
                                    
                                    <!-- Date Picker -->
                                    <div class="col-md-3">
                                        <label class="form-label fw-bold">Specific Date</label>
                                        <input type="date" id="auditSpecificDate" class="form-control">
                                        <small class="text-muted">Filter deals active on this date</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Load/Start Buttons -->
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div class="d-flex gap-2">
                            <button class="btn btn-primary" onclick="loadAuditDeals()">
                                <i class="bi bi-arrow-repeat"></i> Load Deals
                            </button>
                            <button id="startAuditBtn" class="btn btn-success" onclick="startSequentialAudit()" disabled>
                                <i class="bi bi-play-fill"></i> Start Audit
                            </button>
                        </div>
                        <div class="d-flex gap-2 align-items-center">
                            <span id="auditDealCount" class="badge bg-secondary fs-6">No deals loaded</span>
                            <button id="exportAuditBtn" class="btn btn-outline-info btn-sm" onclick="exportAuditReport()" disabled>
                                <i class="bi bi-download"></i> Export Report
                            </button>
                        </div>
                    </div>
                    
                    <!-- Audit Overview/Deal Table -->
                    <div id="auditOverviewContainer" style="display:none;">
                        <!-- Summary Counts -->
                        <div class="row mb-3" id="auditSummaryCounts">
                            <!-- Will be populated by JS -->
                        </div>
                        
                        <!-- Scrollable Deal Table -->
                        <div class="scrollable-table-container" style="max-height:600px; overflow-y:auto;">
                            <table class="table table-sm table-hover table-bordered" id="auditDealsTable" style="font-size:0.85em;">
                                <thead class="sticky-top" style="background:#e9ecef; color:#212529;">
                                    <tr>
                                        <th>Row</th>
                                        <th>Brand</th>
                                        <th style="color:#6c757d;">Linked</th>
                                        <th>Weekday</th>
                                        <th>Notes</th>
                                        <th>Deal Info</th>
                                        <th>Discount</th>
                                        <th>Vendor %</th>
                                        <th>Locations</th>
                                        <th>Categories</th>
                                        <th>Status</th>
                                        <th>MIS ID</th>
                                        <th>Audit Status</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="auditDealsTableBody">
                                    <!-- Populated by loadAuditDeals() -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Initial placeholder -->
                    <div id="auditPlaceholder">
                        <div class="text-center p-4 border rounded bg-light">
                            <i class="bi bi-clipboard-check" style="font-size: 3em; color: #6c757d;"></i>
                            <h5 class="mt-3">Ready to Audit</h5>
                            <p class="text-muted mb-0">Click "Load Deals" to populate the audit table from ID Matcher data.</p>
                            <small class="text-muted">Make sure you've run the ID Matcher first to load deal data.</small>
                        </div>
                    </div>
                </div>

            </div> <div id="blaze-section" class="main-section">
                
                <div class="mb-3" style="border-bottom: 1px solid #dee2e6; padding-bottom: 10px;">
                    <div class="btn-group">
                        <button class="btn btn-outline-primary active" id="btn-blaze-promo" onclick="switchBlazeTab('promo')">
                            &#x1F5A9; Company Promotions
                        </button>
                        <button class="btn btn-outline-primary" id="btn-blaze-inv" onclick="switchBlazeTab('inv')">
                             Inventory Report
                        </button>
                    </div>
                </div>

                <div id="blaze-promo-content">
                    <div class="card shadow-sm">
                        <div class="card-header bg-white">
                            <div class="d-flex justify-content-between align-items-start gap-3">
                                <div style="flex: 1; min-width: 250px;">
                                    <div class="fw-bold mb-2"><i class="bi bi-table"></i> Live Promotions Data</div>
                                    <div class="input-group input-group-sm mb-2">
                                        <span class="input-group-text bg-light"><i class="bi bi-search"></i></span>
                                        <input type="text" id="blazeNameSearch" class="form-control" placeholder="Filter by Name..." onkeyup="handlePrimaryInput()">
                                    </div>
                                    <div class="input-group input-group-sm" id="subSearchContainer" style="display: none;">
                                        <span class="input-group-text bg-light"><i class="bi bi-filter"></i></span>
                                        <input type="text" id="blazeSubSearch" class="form-control" placeholder="Search within results..." onkeyup="applyBlazeFilters()">
                                    </div>
                                </div>
                                
                                <div style="font-size: 0.85em; display: flex; gap: 15px; flex: 1;">
                                    <div id="filteredStatsGroup" style="text-align: right; border-right: 1px solid #dee2e6; padding-right: 15px; display: none;">
                                        <div class="text-muted small fw-bold text-uppercase" style="font-size: 0.75em;">Filtered Results</div>
                                        <span class="badge bg-primary" id="filteredCount">0 Visible</span>
                                        <span class="badge bg-white text-success border border-success" id="filteredActive">0 Active</span>
                                        <span class="badge bg-white text-danger border border-danger" id="filteredInactive">0 Inactive</span>
                                        <span class="badge bg-danger" id="filteredZombie" title="Active deals past end date"> 0 Zombie</span>
                                    </div>

                                    <div style="text-align: right;">
                                        <div class="text-muted small fw-bold text-uppercase" style="font-size: 0.75em;">Total Count</div>
                                        <span class="badge bg-secondary" id="totalCount">0 Total Promotions</span>
                                        <span class="badge bg-white text-success border border-success" id="totalActive">0 Active</span>
                                        <span class="badge bg-white text-danger border border-danger" id="totalInactive">0 Inactive</span>
                                        <span class="badge bg-danger" id="totalZombie" title="Active deals past end date"> 0 Zombie</span>
                                    </div>
                                </div>
                                
                                <div style="min-width: 200px;">
                                    <div class="d-grid gap-2">
                                        <button onclick="fetchBlazeData()" class="btn btn-primary btn-sm fw-bold">
                                            <i class="bi bi-arrow-clockwise"></i> Refresh / Sync Data
                                        </button>
                                        <button onclick="exportData('full')" class="btn btn-primary btn-sm">
                                            <i class="bi bi-database"></i> Full Report
                                        </button>
                                        <button id="downloadFilteredBtn" onclick="exportFilteredData()" class="btn btn-info btn-sm">
                                            <i class="bi bi-funnel"></i> Download Filtered
                                        </button>
                                    </div>
                                    <div class="mt-2 d-flex gap-2 align-items-center">
                                        <div class="zombie-toggle-container">
                                            <span class="zombie-toggle-label"> Cleanup</span>
                                            <label class="zombie-toggle-switch">
                                                <input type="checkbox" id="zombieCleanupToggle" onchange="toggleZombieCleanupMode()">
                                                <span class="zombie-toggle-slider"></span>
                                            </label>
                                        </div>
                                        <button id="zombieCleanupBtn" onclick="startZombieCleanup()" class="btn btn-danger btn-sm" style="display: none;">
                                             Zombie Cleanup
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-body p-0">
                            <div id="promotionsTableWrapper">
                                <table id="promotionsTable" class="table table-striped table-hover w-100 mb-0" style="font-size: 0.8rem;">
                                    <thead>
                                        <tr>
                                            <th>Detail</th>
                                            <th>ID</th>
                                            <th>Name</th>
                                            <th>Status</th>
                                            <th>Auto/Manual</th>
                                            <th>Locations</th>
                                            <th>Groups (Buy)</th>
                                            <th>Groups (Get)</th>
                                            <th>Type</th>
                                            <th>Value</th>
                                            <th>Start</th>
                                            <th>End</th>
                                            <th>Days Until End</th>
                                        </tr>
                                    </thead>
                                    <tbody></tbody>
                                </table>
                            </div> 
                        </div> 
                    </div> 
                </div>

                <div id="blaze-inv-content" style="display:none;">
                    <!-- Control Bar -->
                    <div class="card shadow-sm mb-3">
                        <div class="card-body py-2">
                            <div class="row g-2">
                                <!-- Left Column: Fetch & Load (Stacked) -->
                                <div class="col-md-4">
                                    <!-- Fetch Fresh Section -->
                                    <div class="mb-2">
                                        <div class="input-group input-group-sm">
                                            <span class="input-group-text fw-bold"> Fetch Fresh</span>
                                            <select id="invStoreSelect" class="form-select">
                                                <option value="">-- Select Store --</option>
                                                <option value="The Artist Tree - West Hollywood">West Hollywood</option>
                                                <option value="The Artist Tree - Beverly Hills">Beverly Hills</option>
                                                <option value="The Artist Tree - Koreatown">Koreatown</option>
                                                <option value="The Artist Tree - Riverside">Riverside</option>
                                                <option value="The Artist Tree - Fresno">Fresno (Palm)</option>
                                                <option value="The Artist Tree - Fresno Shaw">Fresno Shaw</option>
                                                <option value="The Artist Tree - Oxnard">Oxnard</option>
                                                <option value="The Artist Tree - El Sobrante">El Sobrante</option>
                                                <option value="The Artist Tree - Laguna Woods">Laguna Woods</option>
                                                <option value="The Artist Tree - Hawthorne">Hawthorne</option>
                                                <option value="The Artist Tree - Dixon">Dixon</option>
                                                <option value="The Artist Tree - Davis">Davis</option>
                                            </select>
                                            <button id="btnFetchFresh" class="btn btn-primary btn-sm fw-bold" onclick="fetchInventoryData()">
                                                <i class="bi bi-cloud-download"></i> Fetch
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <!-- Load Saved Section -->
                                    <div>
                                        <div class="input-group input-group-sm">
                                            <span class="input-group-text fw-bold"> Load Saved</span>
                                            <select id="savedReportsDropdown" class="form-select">
                                                <option value="">-- Select Report --</option>
                                            </select>
                                            <button class="btn btn-info btn-sm fw-bold" onclick="loadSavedReport()">
                                                <i class="bi bi-folder-open"></i> Load
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Middle Column: Debug Log -->
                                <div class="col-md-6">
                                    <div class="debug-log-panel" id="debugLogPanel" style="display: none;">
                                        <div class="d-flex justify-content-between align-items-center mb-1">
                                            <span class="fw-bold text-primary small"> FETCH DEBUG LOG</span>
                                            <span class="small text-muted">
                                                <i class="bi bi-clock"></i> <span id="debugTimer">00:00</span> | 
                                                ETA: <span id="debugETA">--</span>
                                            </span>
                                        </div>
                                        <div class="progress mb-1" style="height: 8px;">
                                            <div id="debugProgress" class="progress-bar progress-bar-striped progress-bar-animated" 
                                                 role="progressbar" style="width: 0%"></div>
                                        </div>
                                        <div id="debugMessages" class="debug-messages small">
                                            <!-- Log messages appear here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- Right Column: Export Button -->
                                <div class="col-md-2 d-flex align-items-center justify-content-end">
                                    <button class="btn btn-success btn-sm fw-bold" onclick="openInventoryExportModal()">
                                        <i class="bi bi-file-earmark-excel"></i> Export
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    

                    <!-- Status Bar (shows current data info) -->
                    <div class="card shadow-sm mb-2" id="inventoryStatusCard" style="display: none;">
                        <div class="card-body py-1 bg-light">
                            <span id="inventoryStatusText" class="text-muted small"></span>
                        </div>
                    </div>

                    <!-- Filter Bar -->
                    <div class="card shadow-sm mb-2">
                        <div class="card-body py-2 bg-light">
                            <div class="row g-2">
                                <!-- First Row: Search Bars -->
                                <div class="col-md-3">
                                    <div class="input-group input-group-sm">
                                        <span class="input-group-text"></span>
                                        <input type="text" id="invSearchName" class="form-control form-control-sm" 
                                               placeholder="Search Name (Primary)..." 
                                               onkeyup="debouncedInventorySearch()">
                                        <button class="btn btn-outline-secondary btn-sm" onclick="clearSearchField('invSearchName')" title="Clear">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="input-group input-group-sm">
                                        <span class="input-group-text"></span>
                                        <input type="text" id="invSearchName2" class="form-control form-control-sm" 
                                               placeholder="Search Name (Secondary)..." 
                                               onkeyup="debouncedInventorySearch()">
                                        <button class="btn btn-outline-secondary btn-sm" onclick="clearSearchField('invSearchName2')" title="Clear">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </div>
                                </div>
                                <!-- Second Row: Dropdowns & Checkbox -->
                                <div class="col-md-2">
                                    <select id="invFilterBrand" class="form-select form-select-sm" onchange="applyInventoryFilters()">
                                        <option value="">All Brands</option>
                                    </select>
                                </div>
                                <div class="col-md-2">
                                    <select id="invFilterCategory" class="form-select form-select-sm" onchange="applyInventoryFilters()">
                                        <option value="">All Categories</option>
                                    </select>
                                </div>
                                <div class="col-md-2">
                                    <div class="form-check" style="padding-top: 6px;">
                                        <input class="form-check-input" type="checkbox" id="invHideZeroQty" 
                                               onchange="applyInventoryFilters()">
                                        <label class="form-check-label small" for="invHideZeroQty">
                                            &#x261E;[EMOJI][EMOJI] Hide 0 Qty
                                        </label>
                                    </div>
                                </div>
                                <!-- Third Row: Action Buttons & Count -->
                                <div class="col-md-12 text-end">
                                    <button class="btn btn-outline-secondary btn-sm" onclick="clearInventoryFilters()">
                                        <i class="bi bi-x-circle"></i> Clear All Filters
                                    </button>
                                    <span id="invRowCount" class="badge bg-secondary ms-2">0 Items</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Data Table -->
                    <div class="card shadow-sm">
                        <div class="card-body p-0">
                            <div class="table-responsive scrollable-table-container" style="height: 65vh;">
                                <table id="inventoryTable" class="table table-striped table-hover w-100 mb-0 table-sm" style="font-size: 0.85rem;">
                                    <thead class="sticky-top bg-white" style="z-index: 10;">
                                        <tr>
                                            <th style="width: 120px;">SKU</th>
                                            <th style="width: 300px;">Name</th>
                                            <th>Brand</th>
                                            <th>Category</th>
                                            <th class="text-end">Price</th>
                                            <th class="text-end">Qty</th>
                                            <th class="text-end">Weight</th>
                                        </tr>
                                    </thead>
                                    <tbody id="inventoryTableBody">
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Status Log -->
                    <div id="inventory-status-log" class="small text-muted mt-2 ps-2"></div>
                </div>

            </div>
    
    <div id="suggestion-tooltip" class="tooltip-container"></div>
    <div id="brand-sticky-popup" class="brand-popup">
        <div class="brand-popup-header">
            <span>Select Brand</span>
            <span class="brand-popup-close" onclick="closeBrandPopup()">X[EMOJI][EMOJI]</span>
        </div>
        <div class="brand-popup-body" id="brand-popup-list"></div>
    </div>
    
    <!-- Paperclip Tooltip (Hidden, shown on hover) -->
    <div id="paperclip-tooltip" class="paperclip-tooltip"></div>

    <!-- Inventory Export Modal -->
    <div class="modal fade" id="inventoryExportModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"> Export Inventory Report</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="exportNoTabs" class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i> No data tabs are currently open. Please fetch or load data first.
                    </div>
                    
                    <div id="exportTabsSection" style="display: none;">
                        <label class="fw-bold mb-2">Select Tabs to Export:</label>
                        <div class="form-check mb-2">
                            <input class="form-check-input" type="checkbox" id="exportAllTabs" onchange="toggleAllTabsExport(this)" checked>
                            <label class="form-check-label fw-bold" for="exportAllTabs">
                                All Open Tabs
                            </label>
                        </div>
                        <hr class="my-2">
                        <div id="exportTabsList">
                            <!-- Checkboxes for open tabs will be dynamically added here -->
                        </div>
                        <div class="alert alert-info mt-3 small">
                            <strong>&#x1F4A1; Export Format:</strong><br>
                            &#x2022; 1 tab selected ->[EMOJI] CSV file<br>
                            &#x2022; Multiple tabs ->[EMOJI] Excel workbook (.xlsx) with separate sheets
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-success" onclick="generateInventoryReport()" id="exportDownloadBtn" disabled>
                        <i class="bi bi-download"></i> Download
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.0.js"></script>
    <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.6/js/dataTables.bootstrap5.min.js"></script>
    
    <script>
        let currentMainTab = 'setup';
        let currentMISTab = 'csv-gen';
        let approvedMatches = {};
        let matchesData = [];
        let misData = { tabName: '', csvFile: null, csvFilename: '', allLoadedTabs: [], localPath: null };
        let blazeData = { rawData: [], filteredData: [], table: null };
        
        // v12.17: Settings cache for Enhanced Create Popup
        let settingsCache = {
            stores: [],
            categories: [],
            brandLinkedMap: {},
            loaded: false,
            loading: false
        };
        
        // v12.17: Load settings dropdown data from API
        async function loadSettingsDropdownData(forceRefresh = false) {
            if (settingsCache.loaded && !forceRefresh) {
                console.log('[SETTINGS] Using cached settings data');
                return settingsCache;
            }
            if (settingsCache.loading) {
                console.log('[SETTINGS] Already loading, waiting...');
                while (settingsCache.loading) {
                    await new Promise(r => setTimeout(r, 100));
                }
                return settingsCache;
            }
            
            settingsCache.loading = true;
            try {
                console.log('[SETTINGS] Fetching dropdown data from API...');
                const response = await fetch('/api/get-settings-dropdowns');
                const data = await response.json();
                
                if (data.success) {
                    settingsCache.stores = data.stores || [];
                    settingsCache.categories = data.categories || [];
                    settingsCache.brandLinkedMap = data.brand_linked_map || {};
                    settingsCache.loaded = true;
                    console.log('[SETTINGS] Loaded:', settingsCache.stores.length, 'stores,', settingsCache.categories.length, 'categories');
                } else {
                    console.error('[SETTINGS] Failed:', data.error);
                }
            } catch (err) {
                console.error('[SETTINGS] Error:', err);
            }
            settingsCache.loading = false;
            return settingsCache;
        }

        const STRICT_OTD_STORES = ["Davis", "Dixon"];   
        const VALID_MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
        
        function switchMainTab(tabName, btnElement) {
            // 1. Hide all main sections
            document.querySelectorAll('.main-section').forEach(s => {
                s.style.display = 'none';
                s.classList.remove('active');
            });
            
            // 2. Deactivate all main buttons
            document.querySelectorAll('.main-nav-btn').forEach(b => b.classList.remove('active'));
            
            // 3. Show Target Section (Force Display Block)
            const target = document.getElementById(tabName + '-section');
            if (target) {
                target.style.display = 'block';
                target.classList.add('active');
            }
            
            // 4. Activate Button (Use 'this' if passed, else fallback)
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            currentMainTab = tabName;
            
            // 5. Handle MIS Sub-Nav Visibility
            const misNav = document.getElementById('mis-sub-nav');
            if (tabName === 'mis') {
                misNav.style.display = 'flex'; // Force Flex
            } else {
                misNav.style.display = 'none';
            }

            // 6. Blaze Tab Fix (Recalculate Table Widths)
            if (tabName === 'blaze') {
                setTimeout(function() {
                    if ($.fn.DataTable.isDataTable('#promotionsTable')) {
                        const table = $('#promotionsTable').DataTable();
                        table.columns.adjust();
                        table.draw(false); // false = don't reset paging
                        // Force scroll body to recalculate
                        $(window).trigger('resize');
                    }
                }, 100);
            }
        }
        
        function switchMISTab(tabName, btnElement) {
            // 1. Hide all sub-sections
            document.querySelectorAll('.sub-section').forEach(s => {
                s.style.display = 'none';
                s.classList.remove('active');
            });
            
            // 2. Deactivate all sub-nav buttons
            document.querySelectorAll('.sub-nav-btn').forEach(b => b.classList.remove('active'));
            
            // 3. Show Target (Force Display Block)
            const target = document.getElementById(tabName + '-section');
            if (target) {
                target.style.display = 'block';
                target.classList.add('active');
            }
            
            // 4. Activate Button
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            currentMISTab = tabName;
        }
        
        // ============================================
        // TOAST NOTIFICATION (v12.12.11)
        // ============================================
        function showToast(message, type = 'info') {
            // Add animation styles if not exists
            if (!document.getElementById('toast-styles')) {
                const style = document.createElement('style');
                style.id = 'toast-styles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove existing toast if any
            const existingToast = document.getElementById('app-toast');
            if (existingToast) existingToast.remove();
            
            // Create toast element
            const toast = document.createElement('div');
            toast.id = 'app-toast';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                border-radius: 8px;
                font-weight: bold;
                z-index: 999999;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideIn 0.3s ease;
                max-width: 400px;
            `;
            
            // Set colors based on type
            if (type === 'success') {
                toast.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                toast.style.color = 'white';
            } else if (type === 'error') {
                toast.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                toast.style.color = 'white';
            } else {
                toast.style.background = 'linear-gradient(135deg, #17a2b8 0%, #138496 100%)';
                toast.style.color = 'white';
            }
            
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Auto-remove after 4 seconds
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 4000);
        }
        
        // ============================================
        // RE-INJECT VALIDATION (v12.12.11)
        // ============================================
        async function reinjectValidation() {
            const btn = document.getElementById('reinject-validation-btn');
            const originalText = btn.innerHTML;
            
            try {
                // Update button to show loading state
                btn.innerHTML = '[EMOJI] Injecting...';
                btn.disabled = true;
                btn.style.opacity = '0.7';
                
                const response = await fetch('/api/mis/inject-validation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Success - flash green
                    btn.innerHTML = '[EMOJI] Injected!';
                    btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                    
                    // Show notification
                    showToast('Validation code re-injected successfully! Open a Daily Discount modal to see it.', 'success');
                    
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    }, 2000);
                } else {
                    // Error
                    btn.innerHTML = '[EMOJI] Failed';
                    btn.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                    
                    showToast(result.error || 'Failed to inject validation code', 'error');
                    
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                        btn.disabled = false;
                        btn.style.opacity = '1';
                    }, 3000);
                }
            } catch (error) {
                console.error('Re-inject validation error:', error);
                btn.innerHTML = '[EMOJI] Error';
                btn.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                
                showToast('Failed to connect to server. Is the browser initialized?', 'error');
                
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }, 3000);
            }
        }
        
        // ============================================
        // DEAL TYPE SUB-TAB SWITCHING (Weekly/Monthly/Sale/All)
        // ============================================
        function switchDealTypeTab(containerId, dealType, btnElement) {
            // Find the parent container
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // v88: Special handling for match-results which uses unified table with filtering
            if (containerId === 'match-results') {
                // Just filter rows by section, don't hide containers
                filterMatchResultsBySection(dealType);
                
                // Update button active state
                container.querySelectorAll('.deal-type-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                if (btnElement) {
                    btnElement.classList.add('active');
                }
                console.log(`[TAB] Filtered match-results to ${dealType}`);
                return;
            }
            
            // 1. Hide all deal-type-content sections within this container
            container.querySelectorAll('.deal-type-content').forEach(section => {
                section.style.display = 'none';
                section.classList.remove('active');
            });
            
            // 2. Deactivate all deal-type buttons within this container
            container.querySelectorAll('.deal-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 3. Show the target content
            const targetContent = container.querySelector(`#${containerId}-${dealType}`);
            if (targetContent) {
                targetContent.style.display = 'block';
                targetContent.classList.add('active');
            }
            
            // 4. Activate the clicked button
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            console.log(`[TAB] Switched to ${dealType} in ${containerId}`);
        }
        
        // Helper to generate deal-type sub-tab HTML structure
        function generateDealTypeTabsHTML(containerId, counts = {weekly: 0, monthly: 0, sale: 0}) {
            return `
                <div class="deal-type-tabs" style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                    <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'weekly', this)">
                        &#x1F4C5; Weekly Deals <span class="badge bg-primary">${counts.weekly}</span>
                    </button>
                    <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'monthly', this)">
                         Monthly Deals <span class="badge bg-info">${counts.monthly}</span>
                    </button>
                    <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'sale', this)">
                         Sale Deals <span class="badge bg-warning text-dark">${counts.sale}</span>
                    </button>
                    <button class="deal-type-btn active" onclick="switchDealTypeTab('${containerId}', 'all', this)">
                         All Deals <span class="badge bg-secondary">${counts.weekly + counts.monthly + counts.sale}</span>
                    </button>
                    
                    <div style="margin-left:auto; display:flex; align-items:center; gap:8px; padding:8px 12px; background:#f8f9fa; border-radius:6px; border:1px solid #dee2e6;">
                        <span style="font-size:0.85em; font-weight:500; color:#6c757d;">Weekly View:</span>
                        <div class="btn-group btn-group-sm" role="group">
                            <button type="button" class="btn btn-outline-secondary" id="weekly-view-breakdown" onclick="toggleWeeklyView('breakdown')" style="font-size:0.85em; padding:4px 12px;">
                                Breakdown List
                            </button>
                            <button type="button" class="btn btn-outline-secondary" id="weekly-view-full" onclick="toggleWeeklyView('full')" style="font-size:0.85em; padding:4px 12px;">
                                Full List
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // v12.2: Weekly view mode tracker (default: breakdown)
        let weeklyViewMode = 'breakdown';
        let originalTableState = null; // Store original table HTML before breakdown modifies it
        
        // v12.2: Toggle between Breakdown List and Full List for Weekly deals
        function toggleWeeklyView(mode) {
            weeklyViewMode = mode;
            
            // Update button states
            const breakdownBtn = document.getElementById('weekly-view-breakdown');
            const fullBtn = document.getElementById('weekly-view-full');
            if (breakdownBtn) breakdownBtn.classList.toggle('active', mode === 'breakdown');
            if (fullBtn) fullBtn.classList.toggle('active', mode === 'full');
            
            console.log('[TOGGLE] Switching to:', mode);
            
            if (mode === 'full') {
                // RESTORE ORIGINAL TABLE STATE
                const table = document.getElementById('match-results-unified-table');
                if (table && originalTableState) {
                    const tbody = table.querySelector('tbody');
                    if (tbody) {
                        console.log('[TOGGLE] Restoring original table state');
                        tbody.innerHTML = originalTableState;
                        
                        // Re-apply section filter
                        const activeBtn = document.querySelector('.deal-type-btn.active');
                        if (activeBtn) {
                            const btnText = activeBtn.textContent.toLowerCase();
                            if (btnText.includes('weekly')) {
                                filterMatchResultsBySection('weekly');
                            } else if (btnText.includes('all')) {
                                filterMatchResultsBySection('all');
                            }
                        }
                    }
                }
            } else {
                // Re-trigger the current filter to rebuild breakdown view
                const activeBtn = document.querySelector('.deal-type-btn.active');
                if (activeBtn) {
                    const btnText = activeBtn.textContent.toLowerCase();
                    if (btnText.includes('weekly')) {
                        filterMatchResultsBySection('weekly');
                    } else if (btnText.includes('all')) {
                        filterMatchResultsBySection('all');
                    }
                }
            }
        }
        
        // v12.2: Insert weekday headers - works from LIVE visible rows in Full List
        function insertWeekdayHeaders() {
            console.log('[BREAKDOWN] === STARTING BREAKDOWN LIST BUILD ===');
            
            const table = document.getElementById('match-results-unified-table');
            if (!table) {
                console.log('[BREAKDOWN] ERROR: Table not found');
                return;
            }
            
            const tbody = table.querySelector('tbody');
            if (!tbody) {
                console.log('[BREAKDOWN] ERROR: tbody not found');
                return;
            }
            
            // Get ALL currently visible rows from tbody
            const allVisibleRows = Array.from(tbody.querySelectorAll('tr[data-section="weekly"]'));
            console.log('[BREAKDOWN] Found', allVisibleRows.length, 'total weekly rows');
            
            if (allVisibleRows.length === 0) {
                console.log('[BREAKDOWN] No weekly rows found!');
                return;
            }
            
            // Find section header
            const sectionHeader = allVisibleRows.find(r => r.classList.contains('section-header-row'));
            if (!sectionHeader) {
                console.log('[BREAKDOWN] ERROR: No section header found');
                return;
            }
            
            // Get data rows (everything except section header)
            const dataRows = allVisibleRows.filter(r => !r.classList.contains('section-header-row'));
            console.log('[BREAKDOWN] Found', dataRows.length, 'data rows to organize');
            
            // STEP 1: Initialize Buckets
            const weekdayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const buckets = {};
            weekdayOrder.forEach(day => {
                buckets[day] = [];
            });
            
            // STEP 2: Sort rows into buckets
            const processedGroups = new Set();
            
            dataRows.forEach((row, idx) => {
                const isGroupMember = row.classList.contains('group-member-row');
                const isGroupHeader = row.classList.contains('group-header-row');
                
                console.log(`[BREAKDOWN] Row ${idx}: groupHeader=${isGroupHeader}, groupMember=${isGroupMember}`);
                
                // Skip group members - they'll be collected with their header
                if (isGroupMember) {
                    console.log(`[BREAKDOWN]   Skipping group member`);
                    return;
                }
                
                // Variables for processing
                let weekdayText = '';
                let groupId = null;
                let memberRows = [];
                
                if (isGroupHeader) {
                    // GROUP HEADER: Extract groupId, find members, detect multi-day
                    const toggleIcon = row.querySelector('[id^="toggle-"]');
                    if (!toggleIcon) {
                        console.log(`[BREAKDOWN]   ERROR: Group header has no toggle icon`);
                        return;
                    }
                    
                    groupId = toggleIcon.id.replace('toggle-', '');
                    
                    if (processedGroups.has(groupId)) {
                        console.log(`[BREAKDOWN]   Already processed group ${groupId}`);
                        return;
                    }
                    processedGroups.add(groupId);
                    
                    // Find all member rows for this group
                    memberRows = dataRows.filter(r => r.classList.contains(`group-${groupId}`));
                    
                    if (memberRows.length === 0) {
                        console.log(`[BREAKDOWN]   ERROR: No members found for group ${groupId}`);
                        return;
                    }
                    
                    console.log(`[BREAKDOWN]   Group ${groupId}: Found ${memberRows.length} members`);
                    
                    // Collect ALL unique weekdays from ALL member rows
                    const allWeekdaysSet = new Set();
                    memberRows.forEach(member => {
                        const memberCells = member.getElementsByTagName('td');
                        if (memberCells.length > 3) {
                            const memberWeekdayText = memberCells[3].textContent.trim();
                            if (memberWeekdayText && !memberWeekdayText.includes('MISSING')) {
                                // Normalize to proper case
                                const normalized = memberWeekdayText.trim().toLowerCase();
                                const properCase = normalized.charAt(0).toUpperCase() + normalized.slice(1);
                                allWeekdaysSet.add(properCase);
                            }
                        }
                    });
                    
                    const weekdays = Array.from(allWeekdaysSet);
                    weekdays.sort((a, b) => {
                        const order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                        return order.indexOf(a) - order.indexOf(b);
                    });
                    
                    console.log(`[BREAKDOWN]   All weekdays in group:`, weekdays);
                    
                    if (weekdays.length === 0) {
                        console.log(`[BREAKDOWN]   ERROR: No valid weekdays found`);
                        return;
                    }
                    
                    const firstWeekday = weekdays[0];
                    const isMultiDay = weekdays.length > 1;
                    
                    // FIRST WEEKDAY: Add full group
                    if (buckets[firstWeekday]) {
                        buckets[firstWeekday].push({
                            type: 'dom',
                            element: row,
                            members: memberRows
                        });
                        console.log(`[BREAKDOWN]   [EMOJI] Added group to ${firstWeekday} bucket`);
                    } else {
                        console.log(`[BREAKDOWN]   ERROR: Bucket "${firstWeekday}" not found!`);
                    }
                    
                    // SUBSEQUENT WEEKDAYS: Add multi-day reference rows + header notes
                    if (isMultiDay) {
                        // Extract group data for notes
                        const firstMember = memberRows[0];
                        const memberCells = firstMember.getElementsByTagName('td');
                        const brand = memberCells[1] ? memberCells[1].textContent.trim() : '';
                        const discountText = memberCells[6] ? memberCells[6].textContent.trim() : '';
                        const discount = discountText.replace('%', '').replace('EMPTY', '');
                        const vendorText = memberCells[7] ? memberCells[7].textContent.trim() : '';
                        const vendor = vendorText.replace('%', '').replace('-', '');
                        
                        // Collect brands and row numbers for dropdown
                        const brandRowMap = {}; // {brandName: {Monday: rowNum, Thursday: rowNum}}
                        memberRows.forEach(member => {
                            const mCells = member.getElementsByTagName('td');
                            const mBrand = mCells[1] ? mCells[1].textContent.trim() : '';
                            const mWeekdayText = mCells[3] ? mCells[3].textContent.trim() : '';
                            const mWeekday = mWeekdayText.trim().toLowerCase().charAt(0).toUpperCase() + mWeekdayText.trim().toLowerCase().slice(1);
                            const rowBtn = mCells[0] ? mCells[0].querySelector('button') : null;
                            const rowNum = rowBtn ? rowBtn.textContent.replace('Row ', '').trim() : '';
                            
                            // Extract just brand name (remove multi-brand badge like "1/4")
                            let cleanBrand = mBrand.replace(/^\d+\/\d+\s+/, '');
                            
                            if (!brandRowMap[cleanBrand]) {
                                brandRowMap[cleanBrand] = {};
                            }
                            brandRowMap[cleanBrand][mWeekday] = rowNum;
                        });
                        
                        const abbrDays = weekdays.map(d => d.substring(0, 3)).join(', ');
                        
                        // Add header note to ALL weekdays (including first)
                        weekdays.forEach(day => {
                            if (buckets[day]) {
                                buckets[day].push({
                                    type: 'header_note',
                                    brand: brand,
                                    discount: discount,
                                    vendor: vendor,
                                    days: abbrDays,
                                    brandRowMap: brandRowMap
                                });
                                console.log(`[BREAKDOWN]   [EMOJI] Added header note to ${day} bucket`);
                            }
                        });
                        
                        // Add multi-day reference rows to subsequent weekdays
                        weekdays.slice(1).forEach(day => {
                            if (buckets[day]) {
                                // Find members that match this specific weekday
                                const dayMembers = memberRows.filter(member => {
                                    const mCells = member.getElementsByTagName('td');
                                    const mWeekdayText = mCells[3] ? mCells[3].textContent.trim() : '';
                                    const mWeekday = mWeekdayText.trim().toLowerCase().charAt(0).toUpperCase() + mWeekdayText.trim().toLowerCase().slice(1);
                                    return mWeekday === day;
                                });
                                
                                if (dayMembers.length > 0) {
                                    buckets[day].push({
                                        type: 'grey_reference',
                                        members: dayMembers,
                                        firstWeekday: firstWeekday
                                    });
                                    console.log(`[BREAKDOWN]   [EMOJI] Added multi-day reference to ${day} bucket (${dayMembers.length} members)`);
                                }
                            }
                        });
                    }
                } else {
                    // SINGLE ROW: Get weekday from the row itself
                    const cells = row.getElementsByTagName('td');
                    if (cells.length <= 3) {
                        console.log(`[BREAKDOWN]   Not enough cells (${cells.length})`);
                        return;
                    }
                    
                    const weekdayText = cells[3].textContent.trim();
                    console.log(`[BREAKDOWN]   Weekday text: "${weekdayText}"`);
                    
                    if (!weekdayText || weekdayText.includes('MISSING')) {
                        console.log(`[BREAKDOWN]   Skipping - missing weekday`);
                        return;
                    }
                    
                    // Normalize to proper case
                    const normalized = weekdayText.trim().toLowerCase();
                    const firstWeekday = normalized.charAt(0).toUpperCase() + normalized.slice(1);
                    console.log(`[BREAKDOWN]   First weekday: "${firstWeekday}"`);
                    console.log(`[BREAKDOWN]   Single row - adding to ${firstWeekday}`);
                    
                    if (buckets[firstWeekday]) {
                        buckets[firstWeekday].push({
                            type: 'dom',
                            element: row
                        });
                        console.log(`[BREAKDOWN]   [EMOJI] Added single row to ${firstWeekday} bucket`);
                    } else {
                        console.log(`[BREAKDOWN]   ERROR: Bucket "${firstWeekday}" not found!`);
                    }
                }
            });
            
            // Log final bucket counts
            console.log('[BREAKDOWN] === BUCKET SUMMARY ===');
            weekdayOrder.forEach(day => {
                const domCount = buckets[day].filter(item => item.type === 'dom').length;
                const noteCount = buckets[day].filter(item => item.type === 'header_note').length;
                const greyCount = buckets[day].filter(item => item.type === 'grey_reference').length;
                console.log(`  ${day}: ${domCount} deals, ${noteCount} header notes, ${greyCount} multi-day refs`);
            });
            
            // STEP 3: Rebuild table (PRESERVE Monthly and Sale sections!)
            console.log('[BREAKDOWN] Rebuilding table...');
            
            // v12.5 FIX: Save monthly and sale rows BEFORE clearing tbody
            const monthlyRows = Array.from(tbody.querySelectorAll('tr[data-section="monthly"]'));
            const saleRows = Array.from(tbody.querySelectorAll('tr[data-section="sale"]'));
            console.log(`[BREAKDOWN] Preserving ${monthlyRows.length} monthly rows and ${saleRows.length} sale rows`);
            
            tbody.innerHTML = '';
            tbody.appendChild(sectionHeader);
            
            weekdayOrder.forEach(day => {
                const dayBucket = buckets[day];
                const domItems = dayBucket.filter(item => item.type === 'dom');
                const headerNotes = dayBucket.filter(item => item.type === 'header_note');
                const greyRefs = dayBucket.filter(item => item.type === 'grey_reference');
                
                // Calculate deal count and brands
                const dealCount = domItems.length + greyRefs.length;
                const brands = new Set();
                
                domItems.forEach(item => {
                    if (item.element) {
                        const cells = item.element.getElementsByTagName('td');
                        const brandText = cells[1] ? cells[1].textContent.trim() : '';
                        if (brandText) brands.add(brandText);
                    }
                    if (item.members) {
                        item.members.forEach(member => {
                            const memberCells = member.getElementsByTagName('td');
                            const memberBrand = memberCells[1] ? memberCells[1].textContent.trim() : '';
                            if (memberBrand) brands.add(memberBrand);
                        });
                    }
                });
                
                // Add brands from multi-day reference rows
                greyRefs.forEach(item => {
                    if (item.members) {
                        item.members.forEach(member => {
                            const memberCells = member.getElementsByTagName('td');
                            const memberBrand = memberCells[1] ? memberCells[1].textContent.trim() : '';
                            if (memberBrand) brands.add(memberBrand);
                        });
                    }
                });
                
                // Create weekday header
                const headerRow = createWeekdayHeaderRow(day, dealCount, Array.from(brands), headerNotes);
                tbody.appendChild(headerRow);
                console.log(`[BREAKDOWN] Added header for ${day}`);
                
                // v12.6: Wrap multi-day reference rows in collapsible section with summary
                if (greyRefs.length > 0) {
                    // Collect brands from all reference rows
                    const refBrands = new Set();
                    greyRefs.forEach(item => {
                        if (item.members) {
                            item.members.forEach(member => {
                                const memberCells = member.getElementsByTagName('td');
                                const memberBrand = memberCells[1] ? memberCells[1].textContent.trim() : '';
                                if (memberBrand) refBrands.add(memberBrand);
                            });
                        }
                    });
                    
                    const brandsList = Array.from(refBrands).join(', ');
                    
                    // Create collapsible header for multi-day references
                    const multiDayHeader = document.createElement('tr');
                    multiDayHeader.classList.add('multi-day-ref-header');
                    multiDayHeader.setAttribute('data-weekday', day);
                    multiDayHeader.innerHTML = `
                        <td colspan="14" style="padding:6px 10px; background:#ffe6f0; cursor:pointer; border:2px solid #ff69b4;" 
                            onclick="toggleMultiDayRefs('${day}')">
                            <div style="display:flex; align-items:center; gap:10px;">
                                <span id="multi-day-toggle-${day}" style="font-size:1em; color:#c2185b;">[EMOJI]</span>
                                <strong style="color:#c2185b; font-size:0.95em;">Multi Day Deals Present:</strong>
                                <span style="color:#c2185b; font-size:0.85em;">${brandsList}</span>
                            </div>
                        </td>
                    `;
                    tbody.appendChild(multiDayHeader);
                    
                    // Append all multi-day reference rows
                    const allGreyRows = [];
                    greyRefs.forEach(item => {
                        if (item.members) {
                            item.members.forEach(member => {
                                const greyRow = createMultiDayReferenceRow(member, item.firstWeekday);
                                greyRow.classList.add(`multi-day-ref-${day}`);
                                allGreyRows.push(greyRow);
                            });
                        }
                    });
                    
                    // Add border styling to first and last reference rows
                    if (allGreyRows.length > 0) {
                        allGreyRows[0].style.borderTop = '2px solid #ff69b4';
                        allGreyRows[allGreyRows.length - 1].style.borderBottom = '2px solid #ff69b4';
                        allGreyRows.forEach((row, idx) => {
                            row.style.borderLeft = '2px solid #ff69b4';
                            row.style.borderRight = '2px solid #ff69b4';
                            tbody.appendChild(row);
                            console.log(`[BREAKDOWN] Added multi-day reference row to ${day}`);
                        });
                    }
                }
                
                // Append DOM rows (groups and singles)
                domItems.forEach(item => {
                    tbody.appendChild(item.element);
                    if (item.members) {
                        item.members.forEach(member => tbody.appendChild(member));
                    }
                    console.log(`[BREAKDOWN] Added deal row to ${day}`);
                });
            });
            
            // v12.5 FIX: Re-append Monthly and Sale sections
            if (monthlyRows.length > 0) {
                console.log(`[BREAKDOWN] Re-appending ${monthlyRows.length} monthly rows`);
                monthlyRows.forEach(row => tbody.appendChild(row));
            }
            if (saleRows.length > 0) {
                console.log(`[BREAKDOWN] Re-appending ${saleRows.length} sale rows`);
                saleRows.forEach(row => tbody.appendChild(row));
            }
            
            // v12.6: Collapse all weekday sections by default
            console.log('[BREAKDOWN] Collapsing all weekday sections by default...');
            weekdayOrder.forEach(day => {
                const allRows = Array.from(tbody.querySelectorAll('tr'));
                const headerIndex = allRows.findIndex(r => 
                    r.classList.contains('weekday-header-row') && 
                    r.getAttribute('data-weekday-header') === day
                );
                
                if (headerIndex !== -1) {
                    // Find next weekday header or end
                    let nextHeaderIndex = allRows.length;
                    for (let i = headerIndex + 1; i < allRows.length; i++) {
                        if (allRows[i].classList.contains('weekday-header-row') && 
                            allRows[i].getAttribute('data-weekday-header')) {
                            nextHeaderIndex = i;
                            break;
                        }
                    }
                    
                    // Hide all rows between this header and next header
                    const rowsToHide = allRows.slice(headerIndex + 1, nextHeaderIndex);
                    rowsToHide.forEach(row => {
                        if (!row.classList.contains('section-header-row') && 
                            !row.classList.contains('weekday-header-row')) {
                            row.style.display = 'none';
                        }
                    });
                    
                    console.log(`[BREAKDOWN] Collapsed ${day} section (${rowsToHide.length} rows)`);
                }
                
                // v12.6: Also collapse multi-day reference sections by default
                const multiDayRows = tbody.querySelectorAll(`.multi-day-ref-${day}`);
                if (multiDayRows.length > 0) {
                    multiDayRows.forEach(row => row.style.display = 'none');
                    console.log(`[BREAKDOWN] Collapsed multi-day refs for ${day} (${multiDayRows.length} rows)`);
                }
            });
            
            console.log('[BREAKDOWN] === BREAKDOWN LIST BUILD COMPLETE ===');
        }
        
        // v12.6: Create collapsible weekday header row with cyan background and multi-day notes
        function createWeekdayHeaderRow(weekday, dealCount, brands, headerNotes) {
            const row = document.createElement('tr');
            row.classList.add('weekday-header-row');
            row.setAttribute('data-section', 'weekly');
            row.setAttribute('data-weekday-header', weekday);
            
            const statusText = dealCount === 0 ? 'No deals' : `${dealCount} deal${dealCount > 1 ? 's' : ''}`;
            
            // Build brands HTML (vertical stack)
            let brandsHtml = '<div style="color:#003366; font-size:0.85em; max-height:150px; overflow-y:auto;">';
            if (brands.length === 0) {
                brandsHtml += 'None';
            } else {
                brandsHtml += brands.map((b, i) => `${i + 1}. ${b}`).join('<br>');
            }
            brandsHtml += '</div>';
            
            // Build notes HTML with [Rows] button (vertical stack)
            let notesHtml = '<div style="color:#003366; font-size:0.8em; max-height:150px; overflow-y:auto;">';
            if (headerNotes.length === 0) {
                notesHtml += '-';
            } else {
                const noteLines = headerNotes.map((note, idx) => {
                    // Extract clean brand names for display
                    const brandNames = Object.keys(note.brandRowMap);
                    let displayBrand = '';
                    
                    if (brandNames.length === 1) {
                        // Single brand: just show the brand name
                        displayBrand = brandNames[0];
                    } else {
                        // Multi-brand: show first brand + "...+"
                        const firstName = brandNames[0];
                        displayBrand = firstName + '...+';
                    }
                    
                    // Create dropdown ID for this note
                    const dropdownId = `note-dropdown-${weekday}-${idx}`;
                    
                    // Build dropdown content
                    let dropdownHtml = '<div class="note-dropdown" id="' + dropdownId + '" style="display:none; position:absolute; background:white; border:1px solid #ccc; padding:8px; z-index:1000; box-shadow:0 2px 8px rgba(0,0,0,0.15); min-width:200px;">';
                    brandNames.forEach(brandName => {
                        const rowMap = note.brandRowMap[brandName];
                        dropdownHtml += '<div style="margin-bottom:4px;"><strong>' + brandName + '</strong> ';
                        Object.keys(rowMap).forEach(day => {
                            const rowNum = rowMap[day];
                            dropdownHtml += '<button class="btn btn-sm btn-outline-primary py-0 px-1" onclick="openSheetRow(' + rowNum + ')" style="font-size:0.7em; margin-left:2px;" title="Go to row ' + rowNum + '">Row ' + rowNum + ' ' + day.substring(0, 3) + '</button> ';
                        });
                        dropdownHtml += '</div>';
                    });
                    dropdownHtml += '</div>';
                    
                    // Append dropdown to body (we'll position it later)
                    setTimeout(() => {
                        if (!document.getElementById(dropdownId)) {
                            document.body.insertAdjacentHTML('beforeend', dropdownHtml);
                        }
                    }, 10);
                    
                    return `<div class="multi-day-note" style="margin-bottom:4px;">` +
                           `<button class="btn btn-sm btn-outline-secondary py-0 px-1" onclick="toggleNoteDropdown('${dropdownId}', event)" style="font-size:0.75em;" title="Click to see all brands/rows">[Rows]</button> ` +
                           `${displayBrand} - D: ${note.discount}% V: ${note.vendor}% ${note.days}` +
                           `</div>`;
                }).join('');
                notesHtml += noteLines;
            }
            notesHtml += '</div>';
            
            // v12.6: Add collapse/expand indicator
            row.innerHTML = `
                <td colspan="14" style="padding:8px 10px; background:#00ffff; cursor:pointer;" onclick="toggleWeekdaySection('${weekday}')">
                    <div style="display:flex; align-items:flex-start; gap:15px;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <span id="weekday-toggle-${weekday}" style="font-size:1.2em; color:#003366;">[EMOJI]</span>
                            <strong style="font-size:1.4em; color:#003366; min-width:120px;">${weekday}</strong>
                        </div>
                        <span style="color:#003366; font-size:0.9em; align-self:center;">${statusText}</span>
                        <div style="flex:1; min-width:200px;">
                            <strong style="color:#003366; font-size:0.85em;">Brands:</strong>
                            ${brandsHtml}
                        </div>
                        <div style="flex:1; min-width:250px;">
                            <strong style="color:#003366; font-size:0.85em;">Notes:</strong>
                            ${notesHtml}
                        </div>
                    </div>
                </td>
            `;
            
            return row;
        }
        
        // v12.6: Toggle weekday section visibility
        function toggleWeekdaySection(weekday) {
            const tbody = document.querySelector('#match-results-unified-table tbody');
            if (!tbody) return;
            
            // Find all rows for this weekday (until next weekday header or end)
            const allRows = Array.from(tbody.querySelectorAll('tr'));
            const headerIndex = allRows.findIndex(r => 
                r.classList.contains('weekday-header-row') && 
                r.getAttribute('data-weekday-header') === weekday
            );
            
            if (headerIndex === -1) return;
            
            // Find next weekday header or end
            let nextHeaderIndex = allRows.length;
            for (let i = headerIndex + 1; i < allRows.length; i++) {
                if (allRows[i].classList.contains('weekday-header-row') && 
                    allRows[i].getAttribute('data-weekday-header')) {
                    nextHeaderIndex = i;
                    break;
                }
            }
            
            // Toggle all rows between this header and next header
            const rowsToToggle = allRows.slice(headerIndex + 1, nextHeaderIndex);
            const isCurrentlyVisible = rowsToToggle.length > 0 && rowsToToggle[0].style.display !== 'none';
            const toggleIcon = document.getElementById(`weekday-toggle-${weekday}`);
            
            rowsToToggle.forEach(row => {
                // Don't hide section headers or other weekday headers
                if (!row.classList.contains('section-header-row') && 
                    !row.classList.contains('weekday-header-row')) {
                    row.style.display = isCurrentlyVisible ? 'none' : '';
                }
            });
            
            // Update toggle icon
            if (toggleIcon) {
                toggleIcon.textContent = isCurrentlyVisible ? '[EMOJI]' : '[EMOJI]';
            }
        }
        
        // v12.6: Toggle multi-day reference section visibility
        function toggleMultiDayRefs(weekday) {
            const tbody = document.querySelector('#match-results-unified-table tbody');
            if (!tbody) return;
            
            const rows = tbody.querySelectorAll(`.multi-day-ref-${weekday}`);
            const isCurrentlyVisible = rows.length > 0 && rows[0].style.display !== 'none';
            const toggleIcon = document.getElementById(`multi-day-toggle-${weekday}`);
            
            rows.forEach(row => {
                row.style.display = isCurrentlyVisible ? 'none' : '';
            });
            
            // Update toggle icon
            if (toggleIcon) {
                toggleIcon.textContent = isCurrentlyVisible ? '[EMOJI]' : '[EMOJI]';
            }
        }
        
        // v12.3: Toggle note dropdown visibility
        function toggleNoteDropdown(dropdownId, event) {
            event.stopPropagation();
            const dropdown = document.getElementById(dropdownId);
            if (!dropdown) return;
            
            // Close all other dropdowns first
            document.querySelectorAll('.note-dropdown').forEach(d => {
                if (d.id !== dropdownId) d.style.display = 'none';
            });
            
            // Toggle this dropdown
            if (dropdown.style.display === 'none') {
                // Position dropdown near the button
                const rect = event.target.getBoundingClientRect();
                dropdown.style.display = 'block';
                dropdown.style.left = rect.left + 'px';
                dropdown.style.top = (rect.bottom + 5) + 'px';
            } else {
                dropdown.style.display = 'none';
            }
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.btn-outline-secondary')) {
                document.querySelectorAll('.note-dropdown').forEach(d => {
                    d.style.display = 'none';
                });
            }
        });
        
        // v12.6: Create multi-day reference row (PINK background with orange border)
        function createMultiDayReferenceRow(memberRow, firstWeekday) {
            const newRow = memberRow.cloneNode(true);
            newRow.style.backgroundColor = '#ffe6f0'; // v12.6: PINK background instead of yellow
            newRow.classList.add('multi-day-reference-row');
            newRow.classList.remove('group-member-row'); // Remove group styling
            
            // Update row button to pink/magenta theme
            const cells = newRow.getElementsByTagName('td');
            if (cells.length > 0) {
                const rowBtn = cells[0].querySelector('button');
                if (rowBtn) {
                    rowBtn.classList.remove('btn-outline-primary');
                    rowBtn.classList.add('btn-outline-danger');
                    rowBtn.style.backgroundColor = '#ffe6f0';
                    rowBtn.style.borderColor = '#ff69b4';
                    rowBtn.style.color = '#c2185b';
                }
            }
            
            // Update Notes column to show "First instance: Monday"
            if (cells.length >= 5) {
                cells[4].innerHTML = `<span style="font-style:italic; color:#c2185b;">First instance: ${firstWeekday}</span>`;
            }
            
            return newRow;
        }
        
        // v12.2: Remove all weekday header rows
        function removeWeekdayHeaders() {
            document.querySelectorAll('tr.weekday-header-row[data-weekday-header]').forEach(row => row.remove());
        }
        
        
        // ============================================
        // SPLIT AUDIT FUNCTIONS (V29)
        // ============================================
        function switchSplitPhase(phaseName, btnElement) {
            document.querySelectorAll('.split-phase-content').forEach(el => {
                el.style.display = 'none';
                el.classList.remove('active');
            });
            document.querySelectorAll('.split-phase-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const target = document.getElementById('split-phase-' + phaseName);
            if (target) {
                target.style.display = 'block';
                target.classList.add('active');
            }
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            // Update Phase 2 CSV status when switching to that tab
            if (phaseName === 'final-check') {
                updatePhase2CsvStatus();
            }
            
            console.log('[SPLIT AUDIT] Switched to phase:', phaseName);
        }

        async function runSplitPlanningAudit() {
            const resultsDiv = document.getElementById('split-planning-results');
            const statsEl = document.getElementById('split-audit-stats');
            const tabName = document.getElementById('mis-tab').value;
            
            if (!tabName) {
                alert('Please select a Google Sheet tab in Setup first.');
                return;
            }
            
            resultsDiv.innerHTML = '<div class="text-center"><div class="spinner-border text-primary"></div><p>Analyzing sheet for split requirements...</p></div>';
            statsEl.textContent = 'Analyzing...';
            statsEl.className = 'badge bg-warning fs-6';
            
            try {
                const response = await fetch('/api/mis/split-audit/planning', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ tab: tabName })
                });
                const data = await response.json();
                
                if (!data.success) {
                    resultsDiv.innerHTML = '<div class="alert alert-danger">' + data.error + '</div>';
                    statsEl.textContent = 'Error';
                    statsEl.className = 'badge bg-danger fs-6';
                    return;
                }
                
                renderSplitPlanningResults(data, resultsDiv);
                const splitCount = data.splits_required ? data.splits_required.length : 0;
                const noConflictCount = data.no_conflict ? data.no_conflict.length : 0;
                statsEl.textContent = splitCount + ' Splits | ' + noConflictCount + ' Clean';
                statsEl.className = splitCount > 0 ? 'badge bg-warning fs-6' : 'badge bg-success fs-6';
            } catch (err) {
                resultsDiv.innerHTML = '<div class="alert alert-danger">Error: ' + err.message + '</div>';
                statsEl.textContent = 'Error';
                statsEl.className = 'badge bg-danger fs-6';
            }
        }

        // v88: Store split planning data for apply functionality
        var splitPlanningData = {};
        var approvedSplitIds = {};
        
        function renderSplitPlanningResults(data, container) {
            // Store data for later use
            splitPlanningData = data;
            approvedSplitIds = {};
            
            var html = '<div class="alert alert-info mb-3"><strong>Analysis Complete:</strong> ' + (data.date_context || 'Unknown Month') +
                '<br>Weekly Deals: ' + (data.summary?.weekly_count || 0) + ' | Tier 1 Deals: ' + ((data.summary?.monthly_count || 0) + (data.summary?.sale_count || 0)) + '</div>';
            
            if (data.splits_required && data.splits_required.length > 0) {
                html += '<h5 class="text-danger mb-3"><i class="bi bi-exclamation-triangle"></i> Splits Required (' + data.splits_required.length + ')</h5>';
                data.splits_required.forEach(function(split, idx) {
                    var conflictType = split.conflict_type || 'FULL';
                    var badgeClass = conflictType === 'LOCATION_PARTIAL' ? 'bg-info' : 'bg-danger';
                    
                    // v88: Enhanced header with Row button
                    html += '<div class="card mb-3 border-danger">';
                    html += '<div class="card-header bg-danger text-white d-flex justify-content-between align-items-center">';
                    html += '<span>';
                    if (split.google_row) {
                        html += '<button class="btn btn-sm btn-light me-2" onclick="openSheetRow(' + split.google_row + ')">Row ' + split.google_row + '</button>';
                    }
                    html += '<strong>' + split.brand + '</strong> - Weekly (' + split.weekday + ')';
                    html += '</span>';
                    html += '<span class="badge ' + badgeClass + '">' + (conflictType === 'LOCATION_PARTIAL' ? 'Location-Partial' : 'Full Conflict') + '</span>';
                    html += '</div>';
                    
                    html += '<div class="card-body">';
                    
                    // v93: Stacked comparison tables with horizontal headers
                    
                    // TABLE 1: Weekly Deal
                    html += '<h6 class="text-primary mb-2"> Weekly Deal</h6>';
                    html += '<div class="table-responsive mb-3">';
                    html += '<table class="table table-sm table-bordered" style="font-size:0.85em; table-layout:fixed; width:100%;">';
                    html += '<thead class="table-light"><tr>';
                    html += '<th style="width:80px;">Row</th><th style="width:120px;">Brand</th><th style="width:100px;">Weekday</th><th style="width:100px;">Discount</th><th style="width:90px;">Vendor %</th>';
                    html += '<th style="width:140px;">Locations</th><th style="width:120px;">Deal Info</th><th style="width:120px;">Categories</th><th style="width:120px;">Notes</th><th style="width:110px;">MIS ID</th>';
                    html += '</tr></thead>';
                    html += '<tbody><tr>';
                    
                    // Row button
                    html += '<td>';
                    if (split.google_row) {
                        html += '<button class="btn btn-sm btn-outline-primary" onclick="openSheetRow(' + split.google_row + ')">Row ' + split.google_row + '</button>';
                    } else {
                        html += '-';
                    }
                    html += '</td>';
                    
                    // Brand
                    html += '<td><strong>' + (split.brand || '-') + '</strong></td>';
                    
                    // Weekday
                    html += '<td>' + (split.weekday || '-') + '</td>';
                    
                    // Discount
                    html += '<td>' + (split.discount || '-') + '</td>';
                    
                    // Vendor %
                    html += '<td>' + (split.vendor_contrib || '-') + '</td>';
                    
                    // Locations
                    html += '<td title="' + (split.locations || '') + '">' + truncateText(split.locations || '-', 25) + '</td>';
                    
                    // Deal Info
                    html += '<td title="' + (split.deal_info || '') + '">' + truncateText(split.deal_info || '-', 25) + '</td>';
                    
                    // Categories
                    html += '<td title="' + (split.categories || '') + '">' + truncateText(split.categories || '-', 20) + '</td>';
                    
                    // Notes
                    html += '<td title="' + (split.special_notes || '') + '">' + truncateText(split.special_notes || '-', 20) + '</td>';
                    
                    // MIS ID
                    html += '<td>';
                    if (split.original_mis_id) {
                        html += renderClickableMisId(split.original_mis_id, split);
                    } else {
                        html += '<span style="color:#999; font-style:italic;">No ID</span>';
                    }
                    html += '</td>';
                    
                    html += '</tr></tbody></table>';
                    html += '</div>';
                    
                    // TABLE 2: Conflict Deal (Interrupting)
                    html += '<h6 class="text-danger mb-2">[!][EMOJI] Conflict Deal (' + split.interrupting_deal_type + ')</h6>';
                    html += '<div class="table-responsive mb-3">';
                    html += '<table class="table table-sm table-bordered" style="font-size:0.85em; table-layout:fixed; width:100%;">';
                    html += '<thead class="table-warning"><tr>';
                    html += '<th style="width:80px;">Row</th><th style="width:120px;">Brand</th><th style="width:100px;">Date(s)</th><th style="width:100px;">Discount</th><th style="width:90px;">Vendor %</th>';
                    html += '<th style="width:140px;">Locations</th><th style="width:120px;">Deal Info</th><th style="width:120px;">Categories</th><th style="width:120px;">Notes</th><th style="width:110px;">MIS ID</th>';
                    html += '</tr></thead>';
                    html += '<tbody>';
                    
                    if (split.interrupting_deal) {
                        html += '<tr>';
                        
                        // Row button
                        html += '<td>';
                        if (split.interrupting_deal.google_row) {
                            html += '<button class="btn btn-sm btn-warning" onclick="openSheetRow(' + split.interrupting_deal.google_row + ')">Row ' + split.interrupting_deal.google_row + '</button>';
                        } else {
                            html += '-';
                        }
                        html += '</td>';
                        
                        // Brand
                        html += '<td><strong>' + (split.interrupting_deal.brand || split.brand || '-') + '</strong></td>';
                        
                        // Date(s)
                        html += '<td>' + (split.conflict_dates ? split.conflict_dates.join(', ') : '-') + '</td>';
                        
                        // Discount
                        html += '<td>' + (split.interrupting_deal.discount || '-') + '</td>';
                        
                        // Vendor %
                        html += '<td>' + (split.interrupting_deal.vendor_contrib || '-') + '</td>';
                        
                        // Locations
                        html += '<td title="' + (split.interrupting_deal.locations || '') + '">' + truncateText(split.interrupting_deal.locations || '-', 25) + '</td>';
                        
                        // Deal Info
                        html += '<td title="' + (split.interrupting_deal.deal_info || '') + '">' + truncateText(split.interrupting_deal.deal_info || '-', 25) + '</td>';
                        
                        // Categories
                        html += '<td title="' + (split.interrupting_deal.categories || '') + '">' + truncateText(split.interrupting_deal.categories || '-', 20) + '</td>';
                        
                        // Notes
                        html += '<td title="' + (split.interrupting_deal.special_notes || '') + '">' + truncateText(split.interrupting_deal.special_notes || '-', 20) + '</td>';
                        
                        // MIS ID
                        html += '<td>';
                        if (split.interrupting_deal.mis_id) {
                            html += renderClickableMisId(split.interrupting_deal.mis_id, split.interrupting_deal);
                        } else {
                            html += '<span style="color:#999; font-style:italic;">No ID</span>';
                        }
                        html += '</td>';
                        
                        html += '</tr>';
                    } else {
                        html += '<tr><td colspan="10" class="text-muted text-center">No conflict deal data available</td></tr>';
                    }
                    
                    html += '</tbody></table>';
                    html += '</div>';
                    
                                        if (conflictType === 'LOCATION_PARTIAL') {
                        html += '<p class="mb-2 text-info"><i class="bi bi-geo-alt"></i> <strong>Overlap Locations:</strong> ' + (split.overlap_locations?.join(', ') || 'N/A') + '<br><small>Weekly continues at other locations without split.</small></p>';
                    }
                    
                    // v88: MIS Entry Plan table with Discount, Vendor %, Location columns
                    // v12.12.14: Added Automate column for Create/End Date buttons
                    html += '<hr><p class="mb-1"><strong>MIS Entry Plan:</strong></p>';
                    html += '<table class="table table-sm table-bordered" style="table-layout:fixed; width:100%;"><thead class="table-light"><tr>';
                    html += '<th style="width:90px;">Action</th><th style="width:140px;">Date Range</th><th style="width:100px;">Discount</th><th style="width:90px;">Vendor %</th><th style="width:140px;">Location</th><th style="width:110px;">MIS ID</th><th style="width:90px;">Automate</th><th style="width:80px;">Approve</th><th style="width:80px;">Apply</th><th style="width:150px;">Notes</th>';
                    html += '</tr></thead><tbody>';
                    
                    split.plan.forEach(function(step, stepIdx) {
                        var rowClass = step.action === 'GAP' ? 'table-warning' : (step.action === 'PATCH' ? 'table-info' : '');
                        html += '<tr class="' + rowClass + '" id="split-row-' + idx + '-' + stepIdx + '">';
                        
                        // v10.8: Action column with dynamic labels based on section
                        const dealSection = split.section || 'weekly';
                        const intSection = split.interrupting_deal_type || '';
                        html += '<td>';
                        if (step.action === 'CREATE_PART1') {
                            html += '<span class="badge bg-primary">' + formatActionLabel(step.action, dealSection, intSection) + '</span>';
                        }
                        if (step.action === 'GAP') {
                            html += '<span class="badge bg-warning text-dark">' + formatActionLabel(step.action, dealSection, intSection) + '</span>';
                        }
                        if (step.action === 'PATCH') {
                            html += '<span class="badge bg-info text-dark">' + formatActionLabel(step.action, dealSection, intSection) + '</span>';
                        }
                        if (step.action === 'CREATE_PART2') {
                            html += '<span class="badge bg-success">' + formatActionLabel(step.action, dealSection, intSection) + '</span>';
                        }
                        html += '</td>';
                        
                        // Date Range column
                        html += '<td>' + (step.dates || '-') + '</td>';
                        
                        // v94: Discount column - PATCH uses Weekly discount
                        html += '<td>';
                        if (step.action === 'GAP' && split.interrupting_deal) {
                            html += '<span class="text-warning">' + (split.interrupting_deal.discount || '-') + '</span>';
                        } else if (step.action === 'PATCH') {
                            html += '<span class="text-info">' + (step.discount || split.discount || '-') + '</span>';
                        } else {
                            html += (split.discount || '-');
                        }
                        html += '</td>';
                        
                        // v94: Vendor % column - PATCH uses Weekly vendor %
                        html += '<td>';
                        if (step.action === 'GAP' && split.interrupting_deal) {
                            html += '<span class="text-warning">' + (split.interrupting_deal.vendor_contrib || '-') + '</span>';
                        } else if (step.action === 'PATCH') {
                            html += '<span class="text-info">' + (step.vendor_contrib || split.vendor_contrib || '-') + '</span>';
                        } else {
                            html += (split.vendor_contrib || '-');
                        }
                        html += '</td>';
                        
                        // v94: Location column - PATCH shows non-conflicting stores
                        html += '<td title="' + (step.action === 'GAP' && split.interrupting_deal ? (split.interrupting_deal.locations || '') : (step.action === 'PATCH' ? (step.locations || '') : (split.locations || ''))) + '">';
                        if (step.action === 'GAP' && split.interrupting_deal) {
                            html += '<span class="text-warning">' + truncateText(split.interrupting_deal.locations || '-', 20) + '</span>';
                        } else if (step.action === 'PATCH') {
                            html += '<span class="text-info">' + truncateText(step.locations || '-', 20) + '</span>';
                        } else {
                            html += truncateText(split.locations || '-', 20);
                        }
                        html += '</td>';
                        
                        // v94: MIS ID column - PATCH needs input like Part 2
                        // v10.8: Use section-based parsed MIS IDs (W1, W2, WP, M1, M2, MP, S1, S2, SP)
                        html += '<td>';
                        const parsedIds = split.parsed_mis_ids || {weekly: {parts: [], patch: null}, monthly: {parts: [], patch: null}, sale: {parts: [], patch: null}};
                        const sectionKey = (dealSection || 'weekly').toLowerCase();
                        const sectionIds = parsedIds[sectionKey] || {parts: [], patch: null};
                        const sectionPrefix = sectionKey === 'monthly' ? 'M' : (sectionKey === 'sale' ? 'S' : 'W');
                        
                        if (step.action === 'CREATE_PART1') {
                            // Show Original ID from parsed parts (first in list)
                            if (sectionIds.parts && sectionIds.parts.length > 0) {
                                // v12.22.7: Pass split data for validation
                                html += renderClickableMisId(sectionPrefix + '1: ' + sectionIds.parts[0], split);
                            } else if (split.original_mis_id && !split.original_mis_id.includes(':')) {
                                // Legacy: no tags, use as-is
                                html += renderClickableMisId(split.original_mis_id, split);
                            } else {
                                html += '<em>From Sheet</em>';
                            }
                        }
                        if (step.action === 'CREATE_PART2') {
                            // v10.8: Check if Continuation already exists in parsed IDs
                            if (sectionIds.parts && sectionIds.parts.length > 1) {
                                // Continuation already entered - show clickable ID
                                // v12.22.7: Pass split data for validation
                                html += renderClickableMisId(sectionPrefix + '2: ' + sectionIds.parts[1], split);
                            } else {
                                // No Continuation yet - show input field
                                html += '<input type="text" class="form-control form-control-sm" placeholder="New MIS ID" id="split-id-' + idx + '-' + stepIdx + '" style="width:100px;" data-split-idx="' + idx + '" data-step-idx="' + stepIdx + '" data-google-row="' + (split.google_row || '') + '" data-section="' + sectionKey + '">';
                            }
                        }
                        if (step.action === 'GAP') {
                            // v10.8: GAP ID comes from interrupting deal's row, not the split row
                            // Check the interrupting deal's MIS ID first
                            if (split.interrupting_deal && split.interrupting_deal.mis_id) {
                                html += renderClickableMisId(split.interrupting_deal.mis_id, split.interrupting_deal);
                            } else {
                                html += '<input type="text" class="form-control form-control-sm" placeholder="New MIS ID" id="split-gap-id-' + idx + '-' + stepIdx + '" style="width:100px;" data-split-idx="' + idx + '" data-step-idx="' + stepIdx + '" data-google-row="' + (split.interrupting_deal?.google_row || '') + '" data-section="' + (intSection || '').toLowerCase() + '">';
                            }
                        }
                        if (step.action === 'PATCH') {
                            // v10.8: Check for Patch ID using section prefix (WP, MP, SP)
                            if (sectionIds.patch) {
                                // v12.22.7: Pass split data for validation
                                html += renderClickableMisId(sectionPrefix + 'P: ' + sectionIds.patch, split);
                            } else {
                                html += '<input type="text" class="form-control form-control-sm" placeholder="New MIS ID" id="split-patch-id-' + idx + '-' + stepIdx + '" style="width:100px;" data-split-idx="' + idx + '" data-step-idx="' + stepIdx + '" data-google-row="' + (split.google_row || '') + '" data-section="' + sectionKey + '">';
                            }
                        }
                        html += '</td>';
                        
                        // v12.12.14: Automate column - Create/End Date buttons
                        html += '<td>';
                        const hasOriginalMisId = sectionIds.parts && sectionIds.parts.length > 0;
                        
                        if (step.action === 'CREATE_PART1') {
                            // Original row: End Date button if has MIS ID, Create if not
                            if (hasOriginalMisId) {
                                const originalId = sectionIds.parts[0];
                                html += '<button class="btn btn-warning btn-sm py-0 px-2" onclick="automateEndDate(' + idx + ', ' + stepIdx + ', \'' + originalId + '\', \'' + (step.dates || '') + '\', \'' + (split.google_row || '') + '\')" title="Automate End Date adjustment in MIS">End Date</button>';
                            } else {
                                html += '<button class="btn btn-success btn-sm py-0 px-2" onclick="automateCreateDeal(' + idx + ', ' + stepIdx + ', \'' + (step.dates || '') + '\', \'' + (split.google_row || '') + '\', \'' + sectionKey + '\')" title="Create new deal in MIS">Create</button>';
                            }
                        } else if (step.action === 'GAP') {
                            // Interrupting row: Create button
                            const intGoogleRow = split.interrupting_deal?.google_row || '';
                            const intSectionKey = (intSection || 'monthly').toLowerCase();
                            html += '<button class="btn btn-success btn-sm py-0 px-2" onclick="automateCreateDeal(' + idx + ', ' + stepIdx + ', \'' + (step.dates || '') + '\', \'' + intGoogleRow + '\', \'' + intSectionKey + '\')" title="Create interrupting deal in MIS">Create</button>';
                        } else if (step.action === 'PATCH') {
                            // Patch row: Create button
                            html += '<button class="btn btn-success btn-sm py-0 px-2" onclick="automateCreateDeal(' + idx + ', ' + stepIdx + ', \'' + (step.dates || '') + '\', \'' + (split.google_row || '') + '\', \'' + sectionKey + '\')" title="Create patch deal in MIS">Create</button>';
                        } else if (step.action === 'CREATE_PART2') {
                            // Continued row: Create button
                            html += '<button class="btn btn-success btn-sm py-0 px-2" onclick="automateCreateDeal(' + idx + ', ' + stepIdx + ', \'' + (step.dates || '') + '\', \'' + (split.google_row || '') + '\', \'' + sectionKey + '\')" title="Create continued deal in MIS">Create</button>';
                        } else {
                            html += '-';
                        }
                        html += '</td>';
                        
                        // v10.8: Approve column - use section-based checks
                        html += '<td>';
                        const hasExistingCont = sectionIds.parts && sectionIds.parts.length > 1;
                        const hasExistingPatch = sectionIds.patch !== null;
                        const hasExistingInterrupt = split.interrupting_deal && split.interrupting_deal.mis_id;
                        
                        if (step.action === 'CREATE_PART2') {
                            if (hasExistingCont) {
                                html += '<span class="text-success" title="Already entered">&#10003;</span>';
                            } else {
                                html += '<button class="btn btn-success btn-sm" onclick="approveSplitId(' + idx + ', ' + stepIdx + ', \'' + sectionKey + '\')" title="Approve this MIS ID">&#10003;</button>';
                            }
                        } else if (step.action === 'GAP') {
                            if (hasExistingInterrupt) {
                                html += '<span class="text-success" title="Already entered">&#10003;</span>';
                            } else {
                                html += '<button class="btn btn-success btn-sm" onclick="approveGapId(' + idx + ', ' + stepIdx + ', \'' + (intSection || '').toLowerCase() + '\')" title="Approve this MIS ID">&#10003;</button>';
                            }
                        } else if (step.action === 'PATCH') {
                            if (hasExistingPatch) {
                                html += '<span class="text-success" title="Already entered">&#10003;</span>';
                            } else {
                                html += '<button class="btn btn-success btn-sm" onclick="approvePatchId(' + idx + ', ' + stepIdx + ', \'' + sectionKey + '\')" title="Approve this MIS ID">&#10003;</button>';
                            }
                        } else {
                            html += '-';
                        }
                        html += '</td>';
                        
                        // v10.8: Apply column - use section-based checks
                        html += '<td>';
                        if (step.action === 'CREATE_PART2') {
                            if (hasExistingCont) {
                                html += '<span class="badge bg-success">Done</span>';
                            } else {
                                html += '<button class="btn btn-primary btn-sm" id="apply-split-btn-' + idx + '-' + stepIdx + '" onclick="applySplitIdToSheet(' + idx + ', ' + stepIdx + ', \'' + sectionKey + '\')" title="Apply to Google Sheet" disabled>Apply</button>';
                            }
                        } else if (step.action === 'GAP') {
                            if (hasExistingInterrupt) {
                                html += '<span class="badge bg-success">Done</span>';
                            } else {
                                html += '<button class="btn btn-primary btn-sm" id="apply-gap-btn-' + idx + '-' + stepIdx + '" onclick="applyGapIdToSheet(' + idx + ', ' + stepIdx + ', \'' + (intSection || '').toLowerCase() + '\')" title="Apply to Google Sheet" disabled>Apply</button>';
                            }
                        } else if (step.action === 'PATCH') {
                            if (hasExistingPatch) {
                                html += '<span class="badge bg-success">Done</span>';
                            } else {
                                html += '<button class="btn btn-primary btn-sm" id="apply-patch-btn-' + idx + '-' + stepIdx + '" onclick="applyPatchIdToSheet(' + idx + ', ' + stepIdx + ', \'' + sectionKey + '\')" title="Apply to Google Sheet" disabled>Apply</button>';
                            }
                        } else {
                            html += '-';
                        }
                        html += '</td>';
                        
                        // Notes column
                        html += '<td><small>' + (step.notes || '') + '</small></td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    
                    if (split.attribute_comparison) {
                        html += '<details class="mt-2"><summary class="text-muted" style="cursor:pointer;">View Attribute Comparison</summary><pre class="bg-light p-2 mt-1" style="font-size:0.8em;">' + JSON.stringify(split.attribute_comparison, null, 2) + '</pre></details>';
                    }
                    html += '</div></div>';
                });
            } else {
                html += '<div class="alert alert-success"><i class="bi bi-check-circle"></i> No splits required! All Weekly deals can run without interruption.</div>';
            }
            
            // v88: Enhanced Clean Deals section with full ID MATCHER columns
            if (data.no_conflict && data.no_conflict.length > 0) {
                html += '<details class="mt-4" open><summary class="h5 text-success" style="cursor:pointer;"><i class="bi bi-check-circle"></i> Clean Deals (' + data.no_conflict.length + ') - No Split Needed</summary>';
                html += '<div class="mt-2">';
                html += '<div class="scrollable-table-container" style="max-height:400px;">';
                html += '<table class="table table-sm table-striped" style="font-size:0.85em;">';
                html += '<thead class="table-light"><tr>';
                html += '<th>Row</th><th>Brand</th><th>Weekday</th><th>Notes</th><th>Deal Info</th>';
                html += '<th>Discount</th><th>Vendor %</th><th>Locations</th><th>Categories</th><th>MIS ID</th>';
                html += '</tr></thead><tbody>';
                
                data.no_conflict.forEach(function(deal, idx) {
                    html += '<tr>';
                    // Row button
                    html += '<td>';
                    if (deal.google_row) {
                        html += '<button class="btn btn-sm btn-outline-primary" onclick="openSheetRow(' + deal.google_row + ')">Row ' + deal.google_row + '</button>';
                    } else {
                        html += '-';
                    }
                    html += '</td>';
                    // Brand
                    html += '<td><strong>' + (deal.brand || '-') + '</strong></td>';
                    // Weekday
                    html += '<td>' + (deal.weekday || '-') + '</td>';
                    // Notes
                    html += '<td title="' + (deal.special_notes || '') + '">' + truncateText(deal.special_notes || '-', 20) + '</td>';
                    // Deal Info
                    html += '<td title="' + (deal.deal_info || '') + '">' + truncateText(deal.deal_info || '-', 20) + '</td>';
                    // Discount
                    html += '<td>' + (deal.discount || '-') + '</td>';
                    // Vendor %
                    html += '<td>' + (deal.vendor_contrib || '-') + '</td>';
                    // Locations
                    html += '<td title="' + (deal.locations || '') + '">' + truncateText(deal.locations || '-', 25) + '</td>';
                    // Categories
                    html += '<td title="' + (deal.categories || '') + '">' + truncateText(deal.categories || '-', 15) + '</td>';
                    // MIS ID - clickable
                    html += '<td>';
                    if (deal.mis_id) {
                        html += renderClickableMisId(deal.mis_id, deal);
                    } else {
                        html += '<span style="color:#999; font-style:italic;">No ID</span>';
                    }
                    html += '</td>';
                    html += '</tr>';
                });
                
                html += '</tbody></table></div></div></details>';
            }
            
            container.innerHTML = html;
        }
        
        // v88: Helper to truncate text
        function truncateText(text, maxLen) {
            if (!text) return '-';
            text = String(text);
            return text.length > maxLen ? text.substring(0, maxLen) + '...' : text;
        }
        
        // v88: Helper to render clickable MIS ID(s)
        function renderClickableMisId(misIdStr, rowData) {
            if (!misIdStr || misIdStr === '-') {
                return '<span style="color:#999; font-style:italic;">No ID</span>';
            }
            
            // Helper to strip tag prefix (Part 1:, GAP:, Patch:, etc.)
            function stripTag(str) {
                if (!str) return '';
                str = String(str).trim();
                if (str.indexOf(':') !== -1) {
                    return str.split(':').pop().trim();
                }
                return str;
            }
            
            // Handle both newline-separated (new format) and comma-separated (legacy)
            var rawStr = String(misIdStr);
            var ids = [];
            
            if (rawStr.indexOf('\n') !== -1) {
                // New tagged format with newlines
                ids = rawStr.split('\n').map(function(line) { return line.trim(); }).filter(function(line) { return line; });
            } else {
                // Legacy comma-separated format
                ids = rawStr.split(',').map(function(id) { return id.trim(); }).filter(function(id) { return id; });
            }
            
            if (ids.length === 0) {
                return '<span style="color:#999; font-style:italic;">No ID</span>';
            }
            
            // Prepare row data for validation (if provided)
            var rowDataJson = null;
            if (rowData) {
                var validationData = {
                    brand: rowData.brand || '',
                    linked_brand: rowData.linked_brand || '',
                    weekday: rowData.weekday || '',
                    categories: rowData.categories || '',
                    discount: rowData.discount || '',
                    vendor_contrib: rowData.vendor_contrib || rowData.vendor_percentage || '',
                    locations: rowData.locations || 'All Locations',
                    rebate_type: rowData.rebate_type || '',
                    after_wholesale: rowData.after_wholesale || false
                };
                rowDataJson = JSON.stringify(validationData).replace(/"/g, '&quot;');
            }
            
            return ids.map(function(id) {
                var cleanId = stripTag(id);  // Strip tag for lookup
                var displayId = id;  // Keep full display (with tag)
                
                // Use enhanced validation if row data is available
                if (rowDataJson) {
                    return '<span data-row=\'' + rowDataJson + '\' onclick="lookupMisIdWithValidation(this, \'' + cleanId + '\')" style="cursor:pointer; font-weight:bold; padding:2px 6px; border-radius:4px; background:#667eea; color:white; text-decoration:underline; display:inline-block; margin:1px;" title="Click to lookup and validate in MIS">' + displayId + '</span>';
                } else {
                    return '<span onclick="lookupMisIdWithValidation(this, \'' + cleanId + '\')" style="cursor:pointer; font-weight:bold; padding:2px 6px; border-radius:4px; background:#667eea; color:white; text-decoration:underline; display:inline-block; margin:1px;" title="Click to lookup in MIS (backend will search Google Sheet)">' + displayId + '</span>';
                }
            }).join(' ');
        }
        
        // v12.12.14: Automate End Date adjustment in MIS
        async function automateEndDate(splitIdx, stepIdx, misId, dateRange, googleRow) {
            console.log('[AUTOMATE END DATE] Starting...', {splitIdx, stepIdx, misId, dateRange, googleRow});
            
            // Parse the date range to get the end date (first date in range for Part 1/Original)
            // dateRange format: "01/01 - 01/15" or "01/15"
            let newEndDate = '';
            if (dateRange.includes(' - ')) {
                // Range format: take the end date (second part)
                const parts = dateRange.split(' - ');
                newEndDate = parts[1].trim();
            } else {
                newEndDate = dateRange.trim();
            }
            
            if (!newEndDate) {
                alert('Could not determine end date from: ' + dateRange);
                return;
            }
            
            // Add year if not present (use current tab year)
            if (newEndDate.split('/').length === 2) {
                // Get year from tab name
                const tabName = document.getElementById('mis-tab')?.value || '';
                const yearMatch = tabName.match(/\d{4}/);
                const year = yearMatch ? yearMatch[0] : new Date().getFullYear();
                newEndDate = newEndDate + '/' + year;
            }
            
            // Show loading overlay
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'automate-loading';
            loadingOverlay.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:10003; display:flex; justify-content:center; align-items:center; flex-direction:column;';
            loadingOverlay.innerHTML = '<div class="spinner-border text-light" style="width:3rem; height:3rem;"></div><div style="color:white; margin-top:15px; font-size:1.2em;">Updating End Date in MIS...</div><div id="automate-status" style="color:#aaa; margin-top:10px; font-size:0.9em;">Opening MIS entry ' + misId + '...</div>';
            document.body.appendChild(loadingOverlay);
            
            try {
                const response = await fetch('/api/mis/automate-end-date', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mis_id: misId,
                        new_end_date: newEndDate,
                        google_row: googleRow,
                        split_idx: splitIdx,
                        step_idx: stepIdx
                    })
                });
                
                const data = await response.json();
                document.getElementById('automate-loading')?.remove();
                
                if (data.success) {
                    alert('[EMOJI] End Date updated to ' + newEndDate + '\\n\\nPlease review and click Save in MIS if everything looks correct.\\n\\nValidation is active - check the banner for any warnings.');
                    
                    // Visual feedback on the row
                    const row = document.getElementById('split-row-' + splitIdx + '-' + stepIdx);
                    if (row) {
                        row.style.backgroundColor = '#fff3cd';
                    }
                } else {
                    alert('Error updating end date: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                document.getElementById('automate-loading')?.remove();
                alert('Error: ' + error.message);
            }
        }
        
// // v12.18.2: Automate Create Deal with PRE-FLIGHT CONFIRMATION POPUP
        async function automateCreateDeal(splitIdx, stepIdx, dateRange, googleRow, sectionType) {
            console.log('[AUTOMATE CREATE] Starting...', {splitIdx, stepIdx, dateRange, googleRow, sectionType});
            
            // 1. Retrieve the Source Data from Memory
            const split = splitPlanningData.splits_required[splitIdx];
            const step = split.plan[stepIdx];
            
            if (!split) {
                alert("Error: Could not find deal data in memory. Please re-run Phase 1 analysis.");
                return;
            }

            // 2. Determine Source Profile (Weekly vs Interrupting)
            let sourceData = split; 
            let dealType = 'CONTINUE';
            
            if (step.action === 'GAP' && split.interrupting_deal) {
                 sourceData = split.interrupting_deal;
                 dealType = 'GAP';
                 console.log('[AUTOMATE] Using Interrupting Deal profile for GAP');
            } else {
                 console.log('[AUTOMATE] Using Main Deal profile');
            }

            console.log('[AUTOMATE] Full sourceData:', JSON.stringify(sourceData, null, 2));

            // 3. Parse Dates
            let startDate = '', endDate = '';
            if (dateRange.includes(' - ')) {
                const parts = dateRange.split(' - ');
                startDate = parts[0].trim();
                endDate = parts[1].trim();
            } else {
                startDate = dateRange.trim();
                endDate = dateRange.trim();
            }
            
            const tabName = document.getElementById('mis-tab')?.value || '';
            const yearMatch = tabName.match(/\d{4}/);
            const year = yearMatch ? yearMatch[0] : new Date().getFullYear();
            
            if (startDate.split('/').length === 2) startDate = startDate + '/' + year;
            if (endDate.split('/').length === 2) endDate = endDate + '/' + year;

            // 4. Calculate weekday from dates if not specified
            let weekdayValue = sourceData.weekday || '';
            if (!weekdayValue && startDate && endDate) {
                weekdayValue = calculateWeekdaysFromDateRange(startDate, endDate);
                console.log('[AUTOMATE] Calculated weekday from dates:', weekdayValue);
            }

            // 5. Determine Rebate Type from checkboxes
            // v12.22.2: More robust detection - handle 'TRUE', 'true', true, etc.
            let rebateType = '';
            const wholesaleVal = String(sourceData.wholesale || '').toUpperCase();
            const retailVal = String(sourceData.retail || '').toUpperCase();
            if (wholesaleVal === 'TRUE') {
                rebateType = 'Wholesale';
            } else if (retailVal === 'TRUE') {
                rebateType = 'Retail';
            }
            console.log('[AUTOMATE] Rebate Type:', rebateType, '(W:', sourceData.wholesale, '->', wholesaleVal, ', R:', sourceData.retail, '->', retailVal, ')');

            // 6. Build Pre-Flight Data
            const preFlightData = {
                brand: sourceData.brand || '',
                linked_brand: sourceData.linked_brand || '',
                weekday: weekdayValue,
                categories: sourceData.categories || '',
                locations: sourceData.locations || '',
                discount: (sourceData.discount || '').replace('%', ''),
                vendor_contrib: (sourceData.vendor_contrib || '').replace('%', ''),
                rebate_type: rebateType,
                after_wholesale: sourceData.after_wholesale === 'TRUE',
                start_date: startDate,
                end_date: endDate
            };

            if (step.discount) preFlightData.discount = step.discount.replace('%', '');
            if (step.vendor_contrib) preFlightData.vendor_contrib = step.vendor_contrib.replace('%', '');

            console.log('[AUTOMATE] Pre-flight data:', preFlightData);

            // v12.21.3: Load settings before opening Pre-Flight popup
            await loadSettingsDropdownData();
            
            openUnifiedPreFlight(preFlightData, googleRow, sectionType, splitIdx, stepIdx);
        }

        function calculateWeekdaysFromDateRange(startStr, endStr) {
            const weekdayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const weekdaysFound = new Set();
            try {
                const startParts = startStr.split('/');
                const endParts = endStr.split('/');
                let startDate = new Date(startParts[2], startParts[0] - 1, startParts[1]);
                let endDate = new Date(endParts[2], endParts[0] - 1, endParts[1]);
                let currentDate = new Date(startDate);
                while (currentDate <= endDate) {
                    weekdaysFound.add(weekdayNames[currentDate.getDay()]);
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            } catch (e) {
                console.error('[AUTOMATE] Error calculating weekdays:', e);
            }
            return Array.from(weekdaysFound).join(', ');
        }

        // v12.21: Renamed from showPreFlightPopup to openUnifiedPreFlight
        // Enhanced with Smart Data parsing and Original Value tracking
        function openUnifiedPreFlight(data, googleRow, sectionType, splitIdx, stepIdx) {
            document.getElementById('preflight-popup')?.remove();
            
            // v12.21: Smart Location Code Mapping
            // Expands abbreviations to full store names
            const locationCodeMap = {
                'dv': 'Davis',
                'davis': 'Davis',
                'mod': 'Modesto',
                'modesto': 'Modesto',
                'sj': 'San Jose',
                'san jose': 'San Jose',
                'sc': 'Santa Cruz',
                'santa cruz': 'Santa Cruz',
                'fre': 'Fresno',
                'fresno': 'Fresno',
                'dtsj': 'DTSJ',
                'cb': 'Campbell',
                'campbell': 'Campbell',
                'bw': 'Brentwood',
                'brentwood': 'Brentwood',
                'ant': 'Antioch',
                'antioch': 'Antioch',
                'sf': 'San Francisco',
                'san francisco': 'San Francisco'
            };
            
            // v12.21: Smart Location Expansion
            // Convert location codes to full names
            function expandLocationCodes(locationStr) {
                if (!locationStr) return [];
                
                // Handle "All Locations Except:" logic
                // Example: "All Locations Except: Davis, Hawthorne" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Returns 10 stores (all except Davis, Hawthorne)
                if (locationStr.toLowerCase().includes('all locations')) {
                    if (locationStr.toLowerCase().includes('except')) {
                        // v12.21.4: FIXED - Return all stores EXCEPT the listed ones
                        
                        // Step 1: Start with Master List (all 12 stores from Settings tab)
                        const masterList = settingsCache.stores && settingsCache.stores.length > 0
                            ? settingsCache.stores
                            : ['Dixon', 'Davis', 'Beverly Hills', 'El Sobrante', 'Fresno (Palm)', 'Fresno (Shaw)', 
                               'Hawthorne', 'Koreatown', 'Laguna Woods', 'Oxnard', 'Riverside', 'West Hollywood'];
                        
                        // Step 2: Extract exceptions from "Except: X, Y, Z"
                        // Handle various formats: "Except:", "Except :", "(Except: X)", etc.
                        const exceptMatch = locationStr.match(/except[:\s]+([^)]+)/i) || 
                                          locationStr.match(/except[:\s]+(.*?)$/i);
                        if (exceptMatch) {
                            const exceptionsStr = exceptMatch[1].trim();
                            console.log('[SMART-LOCATION] Raw exception string:', JSON.stringify(exceptionsStr));
                            
                            const exceptionsRaw = exceptionsStr
                                .split(',')
                                .map(s => s.trim())
                                .filter(s => s.length > 0);  // Remove empty strings
                            
                            // Step 3: Expand exception codes (e.g., "DV" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ "Davis")
                            const exceptions = exceptionsRaw.map(code => 
                                locationCodeMap[code.toLowerCase()] || code
                            );
                            
                            console.log('[SMART-LOCATION] All Locations Except logic:');
                            console.log('  Input String:', locationStr);
                            console.log('  Master List:', masterList);
                            console.log('  Exceptions Raw:', exceptionsRaw);
                            console.log('  Exceptions Expanded:', exceptions);
                            
                            // Step 4: Subtract - Remove exceptions from master list
                            const result = masterList.filter(store => {
                                // Case-insensitive comparison
                                const storeLower = store.toLowerCase();
                                const isExcluded = exceptions.some(exc => {
                                    const excLower = exc.toLowerCase();
                                    const matches = excLower === storeLower;
                                    if (matches) {
                                        console.log(`  ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚ÂÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€Â¢ EXCLUDING: "${store}" (matches exception "${exc}")`);
                                    }
                                    return matches;
                                });
                                
                                if (!isExcluded) {
                                    console.log(`  ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ KEEPING: "${store}"`);
                                }
                                
                                return !isExcluded;
                            });
                            
                            console.log('  Final Result (Master - Exceptions):', result);
                            console.log(`  Summary: ${masterList.length} total ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ ${exceptions.length} excluded ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ ${result.length} remaining`);
                            return result;
                        }
                    }
                    // Just "All Locations" with no exceptions ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ return empty array (auto-selects all)
                    console.log('[SMART-LOCATION] All Locations (no exceptions) - returning empty array');
                    return [];
                }
                
                // Parse comma-separated codes (specific stores)
                const codes = locationStr.split(',').map(s => s.trim());
                const expanded = codes.map(code => {
                    const codeLower = code.toLowerCase();
                    return locationCodeMap[codeLower] || code; // Use mapping or original if not found
                });
                
                console.log('[SMART-LOCATION] Expanded:', locationStr, 'ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢', expanded);
                return expanded;
            }
            
            // v12.21: Apply smart expansion to incoming data
            const smartLocations = expandLocationCodes(data.locations);
            console.log('[PRE-FLIGHT v12.21] Smart locations:', smartLocations);
            console.log('[PRE-FLIGHT v12.21] Original data:', JSON.stringify(data, null, 2));
            
            // v12.21: Smart Rebate Type Detection
            // Detects "Rebate After Wholesale" vs plain "Retail"/"Wholesale"
            function detectSmartRebateType(rebateType, afterWholesale) {
                if (!rebateType) return '';
                
                // If Retail AND after_wholesale is true, it's "Rebate After Wholesale"
                if (rebateType.toLowerCase() === 'retail' && afterWholesale) {
                    return 'Rebate After Wholesale';
                }
                
                // Otherwise return the plain type
                return rebateType;
            }
            
            const smartRebateType = detectSmartRebateType(data.rebate_type, data.after_wholesale);
            console.log('[PRE-FLIGHT v12.21] Smart rebate type:', smartRebateType, '(raw:', data.rebate_type, ', after_wholesale:', data.after_wholesale, ')');
            
            const weekdayOptions = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            // v12.18.3: Dynamic category options from Settings tab
            const categoryOptions = splitPlanningData.category_list && splitPlanningData.category_list.length > 0 
                ? splitPlanningData.category_list 
                : ['Flower', 'Prerolls', 'Vapes', 'Edibles', 'Concentrates', 'Tinctures', 'Topicals', 'Accessories', 'Capsules', 'CBD', 'Other'];
            // v12.21.3: Use stores from Settings tab (loaded via settingsCache)
            const storeOptions = settingsCache.stores && settingsCache.stores.length > 0
                ? settingsCache.stores
                : ['San Jose', 'Santa Cruz', 'Fresno', 'DTSJ', 'Campbell', 'Brentwood', 'Antioch', 'San Francisco'];  // Fallback
            const rebateTypeOptions = ['', 'Retail', 'Wholesale'];
            
            // v12.21.4.1: Build brand options from Settings cache (includes both main brands and linked brands)
            // Extract all unique brand names from settingsCache.brandLinkedMap (keys = main brands, values = linked brands)
            function getBrandOptionsFromSettings() {
                if (!settingsCache.brandLinkedMap || Object.keys(settingsCache.brandLinkedMap).length === 0) {
                    // Fallback to splitPlanningData if settings not loaded
                    return splitPlanningData.brand_list || [];
                }
                
                const brandSet = new Set();
                
                // Add all main brands (keys in the map)
                Object.keys(settingsCache.brandLinkedMap).forEach(brand => {
                    // Keys are lowercase, so capitalize first letter for display
                    const displayBrand = brand.charAt(0).toUpperCase() + brand.slice(1);
                    brandSet.add(displayBrand);
                });
                
                // Add all linked brands (values in the map)
                Object.values(settingsCache.brandLinkedMap).forEach(linkedBrand => {
                    if (linkedBrand && linkedBrand.trim()) {
                        brandSet.add(linkedBrand.trim());
                    }
                });
                
                // Convert set to sorted array
                return Array.from(brandSet).sort();
            }
            
            const brandOptions = getBrandOptionsFromSettings();
            console.log('[PRE-FLIGHT] Brand options from Settings:', brandOptions.length, 'brands');
            
            const brandLinkedMap = splitPlanningData.brand_linked_map || {};
            
            const currentWeekdays = data.weekday ? data.weekday.split(',').map(s => s.trim()) : [];
            const currentCategories = data.categories ? data.categories.split(',').map(s => s.trim()) : [];
            // v12.21: Use smartLocations instead of parsing data.locations directly
            // currentStores is now replaced by smartLocations (already expanded above)
            
            const popup = document.createElement('div');
            popup.id = 'preflight-popup';
            popup.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:100000;display:flex;justify-content:center;align-items:center;font-family:Segoe UI,system-ui,sans-serif;';
            
            let weekdayOptionsHtml = weekdayOptions.map(opt => {
                const sel = currentWeekdays.some(cw => cw.toLowerCase() === opt.toLowerCase()) ? ' selected' : '';
                return '<option value="' + opt + '"' + sel + '>' + opt + '</option>';
            }).join('');
            
            let categoryOptionsHtml = categoryOptions.map(opt => {
                const sel = currentCategories.some(cc => cc.toLowerCase().includes(opt.toLowerCase()) || opt.toLowerCase().includes(cc.toLowerCase())) ? ' selected' : '';
                return '<option value="' + opt + '"' + sel + '>' + opt + '</option>';
            }).join('');
            
            // v12.21: Use smartLocations for automatic checkbox selection
            let storeOptionsHtml = storeOptions.map(opt => {
                const sel = smartLocations.some(sl => sl.toLowerCase() === opt.toLowerCase()) ? ' selected' : '';
                return '<option value="' + opt + '"' + sel + '>' + opt + '</option>';
            }).join('');
            
            let rebateTypeOptionsHtml = rebateTypeOptions.map(opt => {
                const sel = opt === data.rebate_type ? ' selected' : '';
                return '<option value="' + opt + '"' + sel + '>' + (opt || '-- Select --') + '</option>';
            }).join('');
            
            // v12.18.3: Brand dropdown options
            let brandOptionsHtml = '<option value="">-- Select Brand --</option>';
            if (brandOptions.length > 0) {
                brandOptionsHtml += brandOptions.map(opt => {
                    const sel = data.brand && opt.toLowerCase() === data.brand.toLowerCase() ? ' selected' : '';
                    return '<option value="' + opt + '"' + sel + '>' + opt + '</option>';
                }).join('');
            } else {
                // Fallback: show current brand as only option
                brandOptionsHtml = '<option value="' + (data.brand || '') + '" selected>' + (data.brand || '(No brands loaded)') + '</option>';
            }
            
            // v12.18.3: Linked Brand dropdown options (with empty option for "no linked brand")
            let linkedBrandOptionsHtml = '<option value="">(No Linked Brand)</option>';
            
            // v12.21.4.1: DEBUG - Log linked brand selection
            console.log('[LINKED-BRAND-DROPDOWN] data.linked_brand:', data.linked_brand);
            console.log('[LINKED-BRAND-DROPDOWN] brandOptions:', brandOptions);
            
            if (brandOptions.length > 0) {
                linkedBrandOptionsHtml += brandOptions.map(opt => {
                    const sel = data.linked_brand && opt.toLowerCase() === data.linked_brand.toLowerCase() ? ' selected' : '';
                    if (sel) {
                        console.log(`[LINKED-BRAND-DROPDOWN] ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã¢â‚¬Â¦ÃƒÂ¢Ã¢â€šÂ¬Ã…â€œÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¦ SELECTED: "${opt}" (matches data.linked_brand: "${data.linked_brand}")`);
                    }
                    return '<option value="' + opt + '"' + sel + '>' + opt + '</option>';
                }).join('');
            }
            
            console.log('[LINKED-BRAND-DROPDOWN] Final linkedBrandOptionsHtml length:', linkedBrandOptionsHtml.length);
            
            popup.innerHTML = '<div style="background:linear-gradient(135deg,#1a1a2e 0%,#16213e 100%);border:2px solid #4a90d9;border-radius:12px;padding:25px;max-width:600px;width:90%;max-height:90vh;overflow-y:auto;color:#fff;">' +
                '<h3 style="margin:0 0 20px 0;color:#4a90d9;">[EMOJI] Pre-Flight Confirmation <span style="font-size:12px;color:#888;">(Row ' + googleRow + ')</span></h3>' +
                '<p style="color:#aaa;font-size:13px;margin-bottom:20px;">Review and modify values. <strong style="color:#ffc107;">Ctrl+Click for multi-select</strong></p>' +
                '<div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;">' +
                '<div><label style="font-size:12px;color:#aaa;">Brand</label><select id="pf-brand" style="width:100%;padding:8px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;">' + brandOptionsHtml + '</select></div>' +
                '<div><label style="font-size:12px;color:#aaa;">Linked Brand</label><select id="pf-linked-brand" style="width:100%;padding:8px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;">' + linkedBrandOptionsHtml + '</select></div>' +
                '<div><label style="font-size:12px;color:#aaa;">Weekday <span style="color:#dc3545;">*</span></label><select id="pf-weekday" multiple size="4" style="width:100%;padding:4px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;">' + weekdayOptionsHtml + '</select></div>' +
                '<div><label style="font-size:12px;color:#aaa;">Rebate Type <span style="color:#dc3545;">*</span></label><select id="pf-rebate-type" style="width:100%;padding:8px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;">' + rebateTypeOptionsHtml + '</select></div>' +
                '<div><label style="font-size:12px;color:#aaa;">Category</label><select id="pf-categories" multiple size="4" style="width:100%;padding:4px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;">' + categoryOptionsHtml + '</select></div>' +
                '<div><label style="font-size:12px;color:#aaa;">Store/Locations</label><select id="pf-stores" multiple size="4" style="width:100%;padding:4px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;">' + storeOptionsHtml + '</select></div>' +
                '<div><label style="font-size:12px;color:#aaa;">Discount %</label><input type="text" id="pf-discount" value="' + data.discount + '" style="width:100%;padding:8px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;"></div>' +
                '<div><label style="font-size:12px;color:#aaa;">Vendor Rebate %</label><input type="text" id="pf-vendor" value="' + data.vendor_contrib + '" style="width:100%;padding:8px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;"></div>' +
                '<div><label style="font-size:12px;color:#aaa;">Start Date</label>' +
                '<div style="display:flex;gap:4px;">' +
                '<select id="pf-start-month" style="width:70px;padding:6px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;font-size:12px;">' +
                '<option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>' +
                '<option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>' +
                '<option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>' +
                '<option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>' +
                '</select>' +
                '<select id="pf-start-day" style="width:55px;padding:6px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;font-size:12px;"></select>' +
                '<select id="pf-start-year" style="width:75px;padding:6px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;font-size:12px;"></select>' +
                '</div></div>' +
                '<div><label style="font-size:12px;color:#aaa;">End Date</label>' +
                '<div style="display:flex;gap:4px;">' +
                '<select id="pf-end-month" style="width:70px;padding:6px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;font-size:12px;">' +
                '<option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>' +
                '<option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>' +
                '<option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>' +
                '<option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>' +
                '</select>' +
                '<select id="pf-end-day" style="width:55px;padding:6px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;font-size:12px;"></select>' +
                '<select id="pf-end-year" style="width:75px;padding:6px;border:1px solid #4a90d9;border-radius:4px;background:#2a2a4a;color:#fff;font-size:12px;"></select>' +
                '</div></div>' +
                '<div style="grid-column:span 2;"><label style="display:flex;align-items:center;gap:8px;"><input type="checkbox" id="pf-after-wholesale"' + (data.after_wholesale ? ' checked' : '') + ' style="width:18px;height:18px;"><span>After Wholesale Discount?</span></label></div>' +
                '</div>' +
                '<!-- v12.21: Hidden fields for original value tracking -->' +
                '<input type="hidden" id="pf-original-discount" value="' + (data.discount || '') + '">' +
                '<input type="hidden" id="pf-original-vendor" value="' + (data.vendor_contrib || '') + '">' +
                '<input type="hidden" id="pf-original-brand" value="' + (data.brand || '') + '">' +
                '<input type="hidden" id="pf-original-linked" value="' + (data.linked_brand || '') + '">' +
                '<input type="hidden" id="pf-original-weekday" value="' + (data.weekday || '') + '">' +
                '<input type="hidden" id="pf-original-categories" value="' + (data.categories || '') + '">' +
                '<input type="hidden" id="pf-original-locations" value="' + (data.locations || '') + '">' +
                '<input type="hidden" id="pf-original-rebate-type" value="' + (data.rebate_type || '') + '">' +
                '<input type="hidden" id="pf-original-after-wholesale" value="' + (data.after_wholesale ? 'true' : 'false') + '">' +
                '<div style="display:flex;gap:10px;justify-content:flex-end;margin-top:25px;padding-top:15px;border-top:1px solid #4a90d9;">' +
                '<button id="pf-cancel" style="padding:10px 25px;border:1px solid #dc3545;background:transparent;color:#dc3545;border-radius:6px;cursor:pointer;">[EMOJI] Cancel</button>' +
                '<button id="pf-continue" style="padding:10px 25px;border:none;background:linear-gradient(135deg,#28a745,#20c997);color:white;border-radius:6px;cursor:pointer;font-weight:600;">[EMOJI] Continue to MIS</button>' +
                '</div></div>';
            
            document.body.appendChild(popup);
            
            // v12.20: Initialize date dropdowns (Day: 1-31, Year: current ÃƒÆ’Ã†â€™ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â±2 years)
            const currentYear = new Date().getFullYear();
            const years = [currentYear - 1, currentYear, currentYear + 1, currentYear + 2];
            
            // Populate day dropdowns (1-31)
            const startDaySelect = document.getElementById('pf-start-day');
            const endDaySelect = document.getElementById('pf-end-day');
            for (let d = 1; d <= 31; d++) {
                const dayStr = String(d).padStart(2, '0');
                startDaySelect.add(new Option(dayStr, dayStr));
                endDaySelect.add(new Option(dayStr, dayStr));
            }
            
            // Populate year dropdowns
            const startYearSelect = document.getElementById('pf-start-year');
            const endYearSelect = document.getElementById('pf-end-year');
            years.forEach(function(y) {
                startYearSelect.add(new Option(y, y));
                endYearSelect.add(new Option(y, y));
            });
            
            // Parse and set initial date values from data.start_date and data.end_date
            // Expected format: MM/DD/YY or MM/DD/YYYY
            function parseAndSetDate(dateStr, monthId, dayId, yearId) {
                if (!dateStr) return;
                const parts = dateStr.split('/');
                if (parts.length >= 2) {
                    const month = parts[0].padStart(2, '0');
                    const day = parts[1].padStart(2, '0');
                    let year = parts[2];
                    if (year && year.length === 2) year = '20' + year; // Convert YY to YYYY
                    
                    const monthSel = document.getElementById(monthId);
                    const daySel = document.getElementById(dayId);
                    const yearSel = document.getElementById(yearId);
                    
                    if (monthSel) monthSel.value = month;
                    if (daySel) daySel.value = day;
                    if (yearSel && year) yearSel.value = year;
                }
            }
            
            parseAndSetDate(data.start_date, 'pf-start-month', 'pf-start-day', 'pf-start-year');
            parseAndSetDate(data.end_date, 'pf-end-month', 'pf-end-day', 'pf-end-year');
            
            // v12.18.3: Auto-update Linked Brand when Brand changes
            document.getElementById('pf-brand').onchange = function() {
                const selectedBrand = this.value.toLowerCase();
                const linkedBrandSelect = document.getElementById('pf-linked-brand');
                const linkedBrand = brandLinkedMap[selectedBrand] || '';
                if (linkedBrand) {
                    // Find and select the matching linked brand option
                    for (let i = 0; i < linkedBrandSelect.options.length; i++) {
                        if (linkedBrandSelect.options[i].value.toLowerCase() === linkedBrand.toLowerCase()) {
                            linkedBrandSelect.selectedIndex = i;
                            break;
                        }
                    }
                } else {
                    linkedBrandSelect.selectedIndex = 0; // Select "(No Linked Brand)"
                }
            };
            
            document.getElementById('pf-cancel').onclick = function() { popup.remove(); };
            
            document.getElementById('pf-continue').onclick = async function() {
                const selectedWeekdays = Array.from(document.getElementById('pf-weekday').selectedOptions).map(function(o) { return o.value; });
                const selectedCategories = Array.from(document.getElementById('pf-categories').selectedOptions).map(function(o) { return o.value; });
                const selectedStores = Array.from(document.getElementById('pf-stores').selectedOptions).map(function(o) { return o.value; });
                
                // v12.20: Read dates from dropdowns (Month/Day/Year format)
                const startMonth = document.getElementById('pf-start-month').value;
                const startDay = document.getElementById('pf-start-day').value;
                const startYear = document.getElementById('pf-start-year').value;
                const endMonth = document.getElementById('pf-end-month').value;
                const endDay = document.getElementById('pf-end-day').value;
                const endYear = document.getElementById('pf-end-year').value;
                
                // Format as MM/DD/YYYY
                const startDate = startMonth + '/' + startDay + '/' + startYear;
                const endDate = endMonth + '/' + endDay + '/' + endYear;
                
                const finalData = {
                    brand: document.getElementById('pf-brand').value.trim(),
                    linked_brand: document.getElementById('pf-linked-brand').value.trim(),
                    weekday: selectedWeekdays.join(', '),
                    categories: selectedCategories.join(', '),
                    locations: selectedStores.join(', '),
                    discount: document.getElementById('pf-discount').value.trim(),
                    vendor_contrib: document.getElementById('pf-vendor').value.trim(),
                    rebate_type: document.getElementById('pf-rebate-type').value,
                    after_wholesale: document.getElementById('pf-after-wholesale').checked,
                    start_date: startDate,
                    end_date: endDate
                };
                
                if (!finalData.weekday) { alert('Weekday is required!'); return; }
                if (!finalData.rebate_type) { alert('Rebate Type is required!'); return; }
                
                console.log('[PREFLIGHT] Final data:', finalData);
                popup.remove();
                
                const loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'automate-loading';
                loadingOverlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:10003;display:flex;justify-content:center;align-items:center;flex-direction:column;';
                loadingOverlay.innerHTML = '<div class="spinner-border text-light" style="width:3rem;height:3rem;"></div><div style="color:white;margin-top:15px;">Creating Deal in MIS...</div>';
                document.body.appendChild(loadingOverlay);
                
                try {
                    const sheetPayload = {
                        brand: finalData.brand,
                        linked_brand: finalData.linked_brand,
                        weekday: finalData.weekday,
                        categories: finalData.categories,
                        locations: finalData.locations,
                        discount: finalData.discount,
                        vendor_contrib: finalData.vendor_contrib,
                        retail: finalData.rebate_type === 'Retail' ? 'TRUE' : 'FALSE',
                        wholesale: finalData.rebate_type === 'Wholesale' ? 'TRUE' : 'FALSE',
                        after_wholesale: finalData.after_wholesale ? 'TRUE' : 'FALSE'
                    };
                    
                    const response = await fetch('/api/mis/automate-create-deal', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            google_row: googleRow,
                            start_date: finalData.start_date,
                            end_date: finalData.end_date,
                            section_type: sectionType,
                            split_idx: splitIdx,
                            step_idx: stepIdx,
                            sheet_data: sheetPayload
                        })
                    });
                    
                    const result = await response.json();
                    document.getElementById('automate-loading')?.remove();
                    
                    if (result.success) {
                        const row = document.getElementById('split-row-' + splitIdx + '-' + stepIdx);
                        if (row) row.style.backgroundColor = '#d4edda';
                    } else {
                        alert('Error: ' + (result.error || 'Unknown error'));
                    }
                } catch (error) {
                    document.getElementById('automate-loading')?.remove();
                    alert('Error: ' + error.message);
                }
            };
        }
        
        // v88: Approve split ID
        function approveSplitId(splitIdx, stepIdx) {
            var inputEl = document.getElementById('split-id-' + splitIdx + '-' + stepIdx);
            if (!inputEl) {
                alert('Input field not found');
                return;
            }
            
            var misId = inputEl.value.trim();
            if (!misId) {
                alert('Please enter a MIS ID first');
                return;
            }
            
            // Store the approved ID
            var key = splitIdx + '-' + stepIdx;
            approvedSplitIds[key] = {
                mis_id: misId,
                google_row: inputEl.getAttribute('data-google-row')
            };
            
            // Visual feedback
            var row = document.getElementById('split-row-' + splitIdx + '-' + stepIdx);
            if (row) {
                row.style.backgroundColor = '#d4edda';
            }
            inputEl.style.backgroundColor = '#d4edda';
            inputEl.style.fontWeight = 'bold';
            
            // Enable apply button
            var applyBtn = document.getElementById('apply-split-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) {
                applyBtn.disabled = false;
            }
            
            console.log('[SPLIT] Approved MIS ID:', misId, 'for row:', inputEl.getAttribute('data-google-row'));
        }
        
        // v88: Apply split ID to Google Sheet (appends if existing)
        // Updated v10.3: Uses tagged format (Part 2, Part 3, etc.)
        async function applySplitIdToSheet(splitIdx, stepIdx) {
            var key = splitIdx + '-' + stepIdx;
            var approvedData = approvedSplitIds[key];
            
            if (!approvedData || !approvedData.mis_id) {
                alert('Please approve a MIS ID first');
                return;
            }
            
            if (!approvedData.google_row) {
                alert('No Google Sheet row associated with this split');
                return;
            }
            
            var applyBtn = document.getElementById('apply-split-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) {
                applyBtn.disabled = true;
                applyBtn.textContent = 'Applying...';
            }
            
            // Determine the part number (Part 2, Part 3, etc.)
            var partNumber = approvedData.part_number || 2;
            var tag = 'part' + partNumber;
            
            try {
                // Call API to apply with tag
                var response = await fetch('/api/mis/apply-split-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        google_row: parseInt(approvedData.google_row),
                        new_mis_id: approvedData.mis_id,
                        tag: tag,
                        append: true
                    })
                });
                
                var data = await response.json();
                
                if (data.success) {
                    alert('Part ' + partNumber + ' applied!\n\nRow: ' + approvedData.google_row + '\nMIS ID: ' + approvedData.mis_id);
                    
                    // Update UI
                    if (applyBtn) {
                        applyBtn.textContent = 'Applied';
                        applyBtn.className = 'btn btn-outline-success btn-sm';
                    }
                    
                    // Make the ID clickable now
                    var inputEl = document.getElementById('split-id-' + splitIdx + '-' + stepIdx);
                    if (inputEl && inputEl.parentNode) {
                        inputEl.parentNode.innerHTML = renderClickableMisId(approvedData.mis_id);
                    }
                } else {
                    alert('Error: ' + data.error);
                    if (applyBtn) {
                        applyBtn.disabled = false;
                        applyBtn.textContent = 'Apply';
                    }
                }
            } catch (err) {
                alert('Error: ' + err.message);
                if (applyBtn) {
                    applyBtn.disabled = false;
                    applyBtn.textContent = 'Apply';
                }
            }
        }

        
        function approveGapId(splitIdx, stepIdx) {
            var inputEl = document.getElementById('split-gap-id-' + splitIdx + '-' + stepIdx);
            if (!inputEl) { alert('Input field not found'); return; }
            var misId = inputEl.value.trim();
            if (!misId) { alert('Please enter a MIS ID first'); return; }
            var key = 'gap-' + splitIdx + '-' + stepIdx;
            approvedSplitIds[key] = { mis_id: misId, google_row: inputEl.getAttribute('data-google-row') };
            var row = document.getElementById('split-row-' + splitIdx + '-' + stepIdx);
            if (row) row.style.backgroundColor = '#d4edda';
            inputEl.style.backgroundColor = '#d4edda';
            inputEl.style.fontWeight = 'bold';
            var applyBtn = document.getElementById('apply-gap-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) applyBtn.disabled = false;
        }
        
        async function applyGapIdToSheet(splitIdx, stepIdx) {
            var key = 'gap-' + splitIdx + '-' + stepIdx;
            var approvedData = approvedSplitIds[key];
            if (!approvedData || !approvedData.mis_id) { alert('Please approve a MIS ID first'); return; }
            if (!approvedData.google_row) { alert('No Google Sheet row associated'); return; }
            var applyBtn = document.getElementById('apply-gap-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) { applyBtn.disabled = true; applyBtn.textContent = 'Applying...'; }
            try {
                var response = await fetch('/api/mis/apply-split-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ google_row: parseInt(approvedData.google_row), new_mis_id: approvedData.mis_id, tag: 'gap', append: true })
                });
                var data = await response.json();
                if (data.success) {
                    alert('[OK] MIS ID applied successfully!\n\nRow: ' + approvedData.google_row + '\nNew Value: ' + data.new_value);
                    if (applyBtn) { applyBtn.textContent = '[OK] Applied'; applyBtn.className = 'btn btn-outline-success btn-sm'; }
                    var inputEl = document.getElementById('split-gap-id-' + splitIdx + '-' + stepIdx);
                    if (inputEl && inputEl.parentNode) inputEl.parentNode.innerHTML = renderClickableMisId(data.new_value);
                } else {
                    alert('Error: ' + data.error);
                    if (applyBtn) { applyBtn.disabled = false; applyBtn.textContent = 'Apply'; }
                }
            } catch (err) {
                alert('Error: ' + err.message);
                if (applyBtn) { applyBtn.disabled = false; applyBtn.textContent = 'Apply'; }
            }
        }

        // v94: PATCH approve and apply functions (for partial location conflicts)
        function approvePatchId(splitIdx, stepIdx) {
            var inputEl = document.getElementById('split-patch-id-' + splitIdx + '-' + stepIdx);
            if (!inputEl) { alert('Input field not found'); return; }
            var misId = inputEl.value.trim();
            if (!misId) { alert('Please enter a MIS ID first'); return; }
            var key = 'patch-' + splitIdx + '-' + stepIdx;
            approvedSplitIds[key] = { mis_id: misId, google_row: inputEl.getAttribute('data-google-row') };
            var row = document.getElementById('split-row-' + splitIdx + '-' + stepIdx);
            if (row) row.style.backgroundColor = '#d1ecf1';
            inputEl.style.backgroundColor = '#d1ecf1';
            inputEl.style.fontWeight = 'bold';
            var applyBtn = document.getElementById('apply-patch-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) applyBtn.disabled = false;
        }
        
        async function applyPatchIdToSheet(splitIdx, stepIdx) {
            var key = 'patch-' + splitIdx + '-' + stepIdx;
            var approvedData = approvedSplitIds[key];
            if (!approvedData || !approvedData.mis_id) { alert('Please approve a MIS ID first'); return; }
            if (!approvedData.google_row) { alert('No Google Sheet row associated'); return; }
            var applyBtn = document.getElementById('apply-patch-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) { applyBtn.disabled = true; applyBtn.textContent = 'Applying...'; }
            try {
                var response = await fetch('/api/mis/apply-split-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ google_row: parseInt(approvedData.google_row), new_mis_id: approvedData.mis_id, tag: 'patch', append: true })
                });
                var data = await response.json();
                if (data.success) {
                    alert('[OK] MIS ID applied successfully!\n\nRow: ' + approvedData.google_row + '\nNew Value: ' + data.new_value);
                    if (applyBtn) { applyBtn.textContent = '[OK] Applied'; applyBtn.className = 'btn btn-outline-success btn-sm'; }
                    var inputEl = document.getElementById('split-patch-id-' + splitIdx + '-' + stepIdx);
                    if (inputEl && inputEl.parentNode) inputEl.parentNode.innerHTML = renderClickableMisId(data.new_value);
                } else {
                    alert('Error: ' + data.error);
                    if (applyBtn) { applyBtn.disabled = false; applyBtn.textContent = 'Apply'; }
                }
            } catch (err) {
                alert('Error: ' + err.message);
                if (applyBtn) { applyBtn.disabled = false; applyBtn.textContent = 'Apply'; }
            }
        }

        // ============================================
        // PHASE 2: FINAL VERIFICATION FUNCTIONS
        // ============================================
        
        let phase2ApprovedSuggestions = {}; // Store approved suggestions: {splitIdx_actionIdx: {mis_id, ...}}
        
        // Update Phase 2 CSV status display (called when switching to Phase 2 tab)
        function updatePhase2CsvStatus() {
            const statusEl = document.getElementById('phase2-csv-status');
            if (!statusEl) return;
            
            if (misData.localPath || misData.csvFile || misData.pulledCSVPath) {
                const filename = misData.csvFilename || 'CSV Loaded';
                statusEl.innerHTML = '<span class="text-success"><i class="bi bi-check-circle"></i> ' + filename + '</span>';
            } else {
                statusEl.innerHTML = '<span class="text-secondary"><i class="bi bi-file-earmark-x"></i> No CSV Loaded</span>';
            }
        }
        
        async function pullMisCsvForPhase2() {
            // Same as Setup tab - uses /api/mis/pull-csv with credentials
            const statusEl = document.getElementById('phase2-csv-status');
            statusEl.innerHTML = '<span class="text-warning"><i class="bi bi-hourglass-split"></i> Pulling CSV...</span>';
            
            // Get credentials from Setup tab
            const misUsername = document.getElementById('mis-username').value;
            const misPassword = document.getElementById('mis-password').value;
            
            if (!misUsername || !misPassword) {
                statusEl.innerHTML = '<span class="text-danger"><i class="bi bi-x-circle"></i> Enter MIS credentials in Setup tab first</span>';
                return;
            }
            
            try {
                const response = await fetch('/api/mis/pull-csv', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mis_username: misUsername,
                        mis_password: misPassword
                    })
                });
                const data = await response.json();
                
                if (data.success) {
                    // Update global misData (same as Setup tab)
                    misData.localPath = data.path;
                    misData.csvFile = null;
                    misData.csvFilename = data.filename;
                    misData.pulledCSVPath = data.path;
                    
                    statusEl.innerHTML = '<span class="text-success"><i class="bi bi-check-circle"></i> ' + data.filename + '</span>';
                    
                    // Also update Setup tab status
                    const setupStatus = document.getElementById('mis-csv-status');
                    if (setupStatus) {
                        setupStatus.innerHTML = '<div class="alert alert-success p-2 mb-0" style="font-size: 0.9rem;"><strong>Active CSV:</strong> ' + data.filename + '<br><small class="text-muted">Pulled from Phase 2 tab</small></div>';
                    }
                    
                    console.log('[PHASE2-CSV] CSV pulled successfully:', data.filename);
                } else {
                    statusEl.innerHTML = '<span class="text-danger"><i class="bi bi-x-circle"></i> ' + data.error + '</span>';
                }
            } catch (err) {
                statusEl.innerHTML = '<span class="text-danger"><i class="bi bi-x-circle"></i> Error: ' + err.message + '</span>';
            }
        }
        
        async function runPhase2FinalCheck() {
            const resultsDiv = document.getElementById('split-final-check-results');
            const statsEl = document.getElementById('split-audit-stats');
            const csvStatusEl = document.getElementById('phase2-csv-status');
            const tabName = document.getElementById('mis-tab').value;
            
            if (!tabName) {
                alert('Please select a Google Sheet tab in Setup first.');
                return;
            }
            
            // CSV VALIDATION - check all possible sources
            const hasCSV = misData.csvFile || misData.localPath || misData.pulledCSVPath;
            if (!hasCSV) {
                alert('No MIS CSV found.\n\nPlease either:\n1. Upload a CSV in the Setup Tab\n2. Click "Pull MIS CSV" button above\n3. Use "MIS CSV" button in Setup tab');
                return;
            }
            
            resultsDiv.innerHTML = '<div class="text-center"><div class="spinner-border text-success"></div><p>Running final verification...</p></div>';
            statsEl.textContent = 'Verifying...';
            statsEl.className = 'badge bg-warning fs-6';
            
            // BUILD FORM DATA - check all possible CSV sources
            const formData = new FormData();
            formData.append('tab', tabName);
            if (misData.csvFile) {
                formData.append('csv', misData.csvFile);
            } else if (misData.localPath) {
                formData.append('local_csv_path', misData.localPath);
            } else if (misData.pulledCSVPath) {
                formData.append('local_csv_path', misData.pulledCSVPath);
            }
            // If none of the above, backend will use GLOBAL_DATA fallback
            
            try {
                const response = await fetch('/api/mis/split-audit/final-check', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (!data.success) {
                    resultsDiv.innerHTML = '<div class="alert alert-danger">' + data.error + '</div>';
                    statsEl.textContent = 'Error';
                    statsEl.className = 'badge bg-danger fs-6';
                    return;
                }
                
                renderPhase2Results(data, resultsDiv);
                
                // Update stats
                const summary = data.summary || {};
                const correct = summary.fully_correct || 0;
                const errors = summary.partial_errors || 0;
                const missing = summary.missing_ids || 0;
                
                if (errors === 0 && missing === 0) {
                    statsEl.textContent = correct + ' Verified';
                    statsEl.className = 'badge bg-success fs-6';
                } else {
                    statsEl.textContent = correct + ' OK | ' + errors + ' Errors | ' + missing + ' Missing';
                    statsEl.className = 'badge bg-danger fs-6';
                }
                
            } catch (err) {
                resultsDiv.innerHTML = '<div class="alert alert-danger">Error: ' + err.message + '</div>';
                statsEl.textContent = 'Error';
                statsEl.className = 'badge bg-danger fs-6';
            }
        }
        
        function renderPhase2Results(data, container) {
            const results = data.verification_results || [];
            const noConflict = data.no_conflict || [];
            const summary = data.summary || {};
            
            let html = '';
            
            // Summary Stats
            html += '<div class="row mb-3">';
            html += '<div class="col-12">';
            html += '<div class="d-flex gap-2 flex-wrap">';
            html += '<span class="badge bg-success fs-6"><i class="bi bi-check-circle"></i> ' + (summary.fully_correct || 0) + ' Verified</span>';
            html += '<span class="badge bg-danger fs-6"><i class="bi bi-x-circle"></i> ' + (summary.partial_errors || 0) + ' Errors</span>';
            html += '<span class="badge bg-warning text-dark fs-6"><i class="bi bi-question-circle"></i> ' + (summary.missing_ids || 0) + ' Missing IDs</span>';
            html += '<span class="badge bg-secondary fs-6"><i class="bi bi-dash-circle"></i> ' + (summary.no_conflict_count || 0) + ' No Conflict</span>';
            html += '</div>';
            html += '</div>';
            html += '</div>';
            
            // Verification Results Table
            if (results.length > 0) {
                html += '<h5 class="mb-3"><i class="bi bi-list-check"></i> Verification Results</h5>';
                
                results.forEach((split, splitIdx) => {
                    const statusClass = split.overall_status === 'CORRECT' ? 'border-success' : 
                                       split.overall_status === 'MISSING_ID' ? 'border-warning' : 'border-danger';
                    const headerClass = split.overall_status === 'CORRECT' ? 'bg-success text-white' : 
                                       split.overall_status === 'MISSING_ID' ? 'bg-warning text-dark' : 'bg-danger text-white';
                    
                    html += '<div class="card mb-3 ' + statusClass + '" style="border-width: 2px;">';
                    html += '<div class="card-header ' + headerClass + '">';
                    html += '<div class="d-flex justify-content-between align-items-center">';
                    html += '<strong>' + (split.brand || 'Unknown') + '</strong>';
                    html += '<span class="badge bg-white text-dark">' + (split.weekday || '-') + ' | Row ' + (split.google_row || '-') + '</span>';
                    html += '</div>';
                    html += '<small>Conflict Type: ' + (split.conflict_type || 'FULL') + ' | Dates: ' + (split.conflict_dates || []).join(', ') + '</small>';
                    html += '</div>';
                    html += '<div class="card-body p-0">';
                    
                    // Details table
                    html += '<div class="table-responsive">';
                    html += '<table class="table table-sm table-bordered mb-0" style="font-size: 0.85rem;">';
                    html += '<thead class="table-light">';
                    html += '<tr>';
                    html += '<th style="width: 100px;">Action</th>';
                    html += '<th style="width: 80px;">MIS ID</th>';
                    html += '<th>Expected</th>';
                    html += '<th>Actual (CSV)</th>';
                    html += '<th style="width: 80px;">Status</th>';
                    html += '<th>Issues / Suggestions</th>';
                    html += '</tr>';
                    html += '</thead>';
                    html += '<tbody>';
                    
                    const details = split.details || [];
                    details.forEach((entry, actionIdx) => {
                        const rowClass = entry.status === 'CORRECT' ? 'table-success' : 
                                        entry.status === 'MISSING_ID' ? 'table-warning' : 'table-danger';
                        const statusIcon = entry.status === 'CORRECT' ? '<i class="bi bi-check-circle text-success"></i>' : 
                                          entry.status === 'MISSING_ID' ? '<i class="bi bi-question-circle text-warning"></i>' : 
                                          '<i class="bi bi-x-circle text-danger"></i>';
                        
                        html += '<tr class="' + rowClass + '">';
                        // v10.8: Pass section info for dynamic labels
                        const dealSection = split.section || 'weekly';
                        const intSection = split.interrupting_deal_type || '';
                        html += '<td><strong>' + formatActionLabel(entry.action, dealSection, intSection) + '</strong><br><small class="text-muted">' + (entry.expected_dates || '') + '</small></td>';
                        
                        // MIS ID - make clickable for browser automation
                        html += '<td>';
                        if (entry.mis_id) {
                            html += renderClickableMisId(entry.mis_id, entry);
                        } else {
                            html += '<em class="text-muted">-</em>';
                        }
                        html += '</td>';
                        
                        html += '<td>' + formatExpectedAttrs(entry.expected) + '</td>';
                        
                        // Actual (CSV) - add tooltip with suggestions when available
                        html += '<td>';
                        if (entry.actual) {
                            html += formatActualAttrs(entry.actual);
                        } else if (entry.status === 'MISSING_ID' && entry.suggestions && entry.suggestions.length > 0) {
                            // Show suggestions in tooltip like ID MATCHER
                            const tooltipContent = entry.suggestions.map(s => 
                                s.score + '%: ID ' + s.mis_id + ' - ' + (s.brand || '') + ' ' + (s.discount || '')
                            ).join('&#10;');
                            html += '<span class="badge bg-info" data-bs-toggle="tooltip" data-bs-html="true" title="' + tooltipContent + '" style="cursor:help;">?? Suggestions</span>';
                        } else {
                            html += '<em class="text-muted">Not found</em>';
                        }
                        html += '</td>';
                        
                        html += '<td class="text-center">' + statusIcon + '</td>';
                        html += '<td>';
                        
                        if (entry.issues && entry.issues.length > 0) {
                            html += '<ul class="mb-0 ps-3 small text-danger">';
                            entry.issues.forEach(issue => {
                                html += '<li>' + escapeHtml(issue) + '</li>';
                            });
                            html += '</ul>';
                        }
                        
                        if (entry.status === 'MISSING_ID' && entry.suggestions && entry.suggestions.length > 0) {
                            html += '<div class="mt-2">';
                            html += '<strong class="small">Suggestions:</strong>';
                            html += '<div class="d-flex flex-column gap-1 mt-1">';
                            entry.suggestions.forEach((sug, sugIdx) => {
                                const sugKey = splitIdx + '_' + actionIdx + '_' + sugIdx;
                                const confClass = sug.score >= 80 ? 'bg-success' : sug.score >= 60 ? 'bg-warning text-dark' : 'bg-secondary';
                                html += '<div class="d-flex align-items-center gap-2">';
                                html += '<span class="badge ' + confClass + '">' + sug.score + '%</span>';
                                html += '<span class="small">' + renderClickableMisId(sug.mis_id, sug) + ' - ' + (sug.brand || '') + ' ' + (sug.discount || '') + '</span>';
                                html += '<button class="btn btn-outline-primary btn-sm py-0 px-1" onclick="selectPhase2Suggestion(' + splitIdx + ', ' + actionIdx + ', \'' + sug.mis_id + '\')">Select</button>';
                                html += '</div>';
                            });
                            html += '</div>';
                            html += '<div class="mt-2" id="phase2-approve-' + splitIdx + '-' + actionIdx + '" style="display:none;">';
                            html += '<input type="text" class="form-control form-control-sm mb-1" id="phase2-selected-id-' + splitIdx + '-' + actionIdx + '" placeholder="Selected MIS ID">';
                            html += '<button class="btn btn-success btn-sm" onclick="approvePhase2Suggestion(' + splitIdx + ', ' + actionIdx + ', ' + split.google_row + ')"><i class="bi bi-check"></i> Approve & Apply</button>';
                            html += '</div>';
                            html += '</div>';
                        }
                        
                        html += '</td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody>';
                    html += '</table>';
                    html += '</div>';
                    html += '</div>';
                    html += '</div>';
                });
            }
            
            // No Conflict deals (collapsible)
            if (noConflict.length > 0) {
                html += '<details class="mt-4">';
                html += '<summary class="h5" style="cursor: pointer;"><i class="bi bi-check-all text-success"></i> No Conflict Deals (' + noConflict.length + ')</summary>';
                html += '<div class="table-responsive mt-2">';
                html += '<table class="table table-sm table-striped">';
                html += '<thead><tr><th>Row</th><th>Brand</th><th>Weekday</th><th>Discount</th><th>Locations</th><th>MIS ID</th></tr></thead>';
                html += '<tbody>';
                noConflict.forEach(deal => {
                    html += '<tr>';
                    html += '<td>' + (deal.google_row || '-') + '</td>';
                    html += '<td>' + (deal.brand || '-') + '</td>';
                    html += '<td>' + (deal.weekday || '-') + '</td>';
                    html += '<td>' + (deal.discount || '-') + '</td>';
                    html += '<td>' + (deal.locations || '-') + '</td>';
                    html += '<td>' + (deal.mis_id || '-') + '</td>';
                    html += '</tr>';
                });
                html += '</tbody></table>';
                html += '</div>';
                html += '</details>';
            }
            
            if (results.length === 0 && noConflict.length === 0) {
                html += '<div class="alert alert-info"><i class="bi bi-info-circle"></i> No deals to verify. Run Phase 1 first to identify splits.</div>';
            }
            
            container.innerHTML = html;
            
            // Initialize Bootstrap tooltips for suggestion hovers
            if (typeof bootstrap !== 'undefined') {
                const tooltipTriggerList = container.querySelectorAll('[data-bs-toggle="tooltip"]');
                tooltipTriggerList.forEach(el => new bootstrap.Tooltip(el));
            }
        }
        
        // v10.8: Format action labels based on section and action type
        function formatActionLabel(action, section, interruptingSection) {
            // section: 'weekly', 'monthly', 'sale' - the deal being split
            // interruptingSection: 'monthly', 'sale' - what's causing the interruption (for GAP)
            section = section || 'weekly';
            
            const sectionNames = {
                'weekly': 'Weekly',
                'monthly': 'Monthly',
                'sale': 'Sale'
            };
            
            const sectionName = sectionNames[section.toLowerCase()] || 'Weekly';
            const intName = interruptingSection ? (sectionNames[interruptingSection.toLowerCase()] || interruptingSection) : '';
            
            if (action === 'CREATE_PART1' || action === 'ORIGINAL') {
                return sectionName + ' (Original)';
            } else if (action === 'CREATE_PART2' || action === 'CONTINUATION') {
                return sectionName + ' (Cont.)';
            } else if (action === 'GAP' || action === 'INTERRUPTING') {
                return intName || 'Interrupting Deal';
            } else if (action === 'PATCH') {
                return sectionName + ' (Patch)';
            }
            
            return action;
        }
        
        function formatExpectedAttrs(expected) {
            if (!expected) return '<em class="text-muted">-</em>';
            let parts = [];
            if (expected.discount) parts.push('Disc: ' + expected.discount);
            if (expected.vendor_pct) parts.push('Vendor: ' + expected.vendor_pct);
            if (expected.locations) parts.push('Loc: ' + expected.locations.substring(0, 30) + (expected.locations.length > 30 ? '...' : ''));
            return parts.length > 0 ? '<small>' + parts.join('<br>') + '</small>' : '<em class="text-muted">-</em>';
        }
        
        function formatActualAttrs(actual) {
            if (!actual) return '<em class="text-muted">Not Found</em>';
            let parts = [];
            if (actual.discount) parts.push('Disc: ' + actual.discount);
            if (actual.vendor_pct) parts.push('Vendor: ' + actual.vendor_pct);
            if (actual.locations) parts.push('Loc: ' + actual.locations.substring(0, 30) + (actual.locations.length > 30 ? '...' : ''));
            if (actual.start_date && actual.end_date) parts.push('Dates: ' + actual.start_date + ' - ' + actual.end_date);
            return parts.length > 0 ? '<small>' + parts.join('<br>') + '</small>' : '<em class="text-muted">-</em>';
        }
        
        function selectPhase2Suggestion(splitIdx, actionIdx, misId) {
            // Show the approve section and fill in the selected ID
            const approveDiv = document.getElementById('phase2-approve-' + splitIdx + '-' + actionIdx);
            const inputEl = document.getElementById('phase2-selected-id-' + splitIdx + '-' + actionIdx);
            
            if (approveDiv) approveDiv.style.display = 'block';
            if (inputEl) {
                inputEl.value = misId;
                inputEl.style.backgroundColor = '#d4edda';
            }
        }
        
        async function approvePhase2Suggestion(splitIdx, actionIdx, googleRow) {
            const inputEl = document.getElementById('phase2-selected-id-' + splitIdx + '-' + actionIdx);
            if (!inputEl || !inputEl.value.trim()) {
                alert('Please select or enter a MIS ID first.');
                return;
            }
            
            const misId = inputEl.value.trim();
            
            // Determine the prefix based on action type - ask user
            const actionType = prompt('What type of entry is this?\nEnter: gap, patch, part1, or part2', 'part2');
            if (!actionType) return;
            
            let prefix = '';
            if (actionType.toLowerCase() === 'gap') {
                prefix = 'Gap: ';
            } else if (actionType.toLowerCase() === 'patch') {
                prefix = 'Patch: ';
            }
            
            const finalValue = prefix + misId;
            
            try {
                const response = await fetch('/api/mis/apply-split-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        google_row: googleRow,
                        new_mis_id: finalValue,
                        append: true
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert('Applied MIS ID to row ' + googleRow + ': ' + data.new_value);
                    inputEl.style.backgroundColor = '#c3e6cb';
                    inputEl.disabled = true;
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (err) {
                alert('Error: ' + err.message);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // END PHASE 2 FINAL VERIFICATION FUNCTIONS
        // ============================================
        
        async function searchMisBrand(brandName) {
            closeBrandPopup();
            const originalTitle = document.title;
            document.title = "Searching: " + brandName;
            try {
                await fetch('/api/mis/search-brand', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ brand: brandName })
                });
            } catch (e) { 
                alert('Search Error: ' + e.message); 
            } finally { 
                setTimeout(() => document.title = originalTitle, 2000); 
            }
        }

        function toggleBrandPopup(event, brandsStr) {
            event.stopPropagation();
            const popup = document.getElementById('brand-sticky-popup');
            const listContainer = document.getElementById('brand-popup-list');
            
            if (popup.style.display === 'block' && popup.dataset.trigger === event.target.id) {
                closeBrandPopup(); 
                return;
            }

            const brands = brandsStr.split(',').map(b => b.trim()).filter(b => b);
            listContainer.innerHTML = '';
            brands.forEach(b => {
                const btn = document.createElement('button');
                btn.className = 'brand-select-btn';
                btn.innerText = b;
                btn.onclick = () => searchMisBrand(b);
                listContainer.appendChild(btn);
            });

            const rect = event.target.getBoundingClientRect();
            popup.style.top = (window.scrollY + rect.bottom + 5) + 'px';
            popup.style.left = (window.scrollX + rect.left) + 'px';
            popup.style.display = 'block';
            popup.dataset.trigger = event.target.id;
        }

        function closeBrandPopup() {
            document.getElementById('brand-sticky-popup').style.display = 'none';
        }

        function renderBrandCell(brandStr, rowIdx, prefix = '') {
            if (!brandStr) return '<span style="color:#999;">-</span>';
            
            const brandList = brandStr.split(',').map(s => s.trim()).filter(s => s);
            const uniqueId = `${prefix}-brand-${rowIdx}`;
            
            if (brandList.length > 1) {
                return `<div id="${uniqueId}" class="brand-multi" onclick="toggleBrandPopup(event, '${brandStr.replace(/'/g, "&apos;")}')">${brandList[0]}...</div>`;
            } else {
                return `<span class="brand-single" onclick="searchMisBrand('${brandStr.replace(/'/g, "&apos;")}')">${brandStr}</span>`;
            }
        }
        
        // v12.1: Navigate to specific row in Google Sheet
        function goToSheetRow(rowNum) {
            // Use the globally stored spreadsheet ID
            // This is set when /api/mis/load-sheet returns the spreadsheet_id
            const spreadsheetId = window.globalSpreadsheetId || '';
            if (!spreadsheetId) {
                alert('Spreadsheet ID not available. Please load the sheet first.');
                return;
            }
            const url = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/edit#gid=0&range=A${rowNum}`;
            window.open(url, '_blank');
        }
        
        // v12.2: Global helper - Parse month/year from tab name (e.g., "January 2026")
        function parseTabMonthYear(tabName) {
            const months = ['january','february','march','april','may','june','july','august','september','october','november','december'];
            const parts = (tabName || '').toLowerCase().trim().split(/\s+/);
            let month = -1, year = -1;
            for (const p of parts) {
                const mIdx = months.indexOf(p);
                if (mIdx >= 0) month = mIdx;
                if (/^\d{4}$/.test(p)) year = parseInt(p);
            }
            return { month, year };
        }
        
        // v12.2: Global helper - Get last day of month (handles leap years)
        function getLastDayOfMonth(year, month) {
            // month is 0-indexed (0=Jan, 11=Dec)
            return new Date(year, month + 1, 0).getDate();
        }
        
        async function lookupMisId(misId) {
            if (!misId || misId === '-') return;
            
            const originalTitle = document.title;
            document.title = "Looking up: " + misId;
            try {
                await fetch('/api/mis/lookup-mis-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ mis_id: misId })
                });
            } catch (e) { 
                console.error('Lookup Error:', e); 
            } finally { 
                setTimeout(() => document.title = originalTitle, 2000); 
            }
        }
        
        async function lookupMisIdWithValidation(buttonElement, misId) {
            /**
             * Enhanced MIS ID lookup that includes row data for validation.
             * Extracts row data from button's data-row attribute and sends to backend.
             */
            if (!misId || misId === '-') return;
            
            const originalTitle = document.title;
            document.title = "Looking up: " + misId;
            
            try {
                // Try to get row data from button element
                let rowData = null;
                if (buttonElement && buttonElement.getAttribute) {
                    try {
                        const rowDataJson = buttonElement.getAttribute('data-row');
                        if (rowDataJson) {
                            rowData = JSON.parse(rowDataJson);
                            console.log('[MIS ID LOOKUP] Row data found:', rowData);
                        }
                    } catch (e) {
                        console.warn('[MIS ID LOOKUP] Could not parse row data:', e);
                    }
                }
                
                // Send request with optional row data
                await fetch('/api/mis/lookup-mis-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        mis_id: misId,
                        row_data: rowData  // Will be null if not available
                    })
                });
                
                if (rowData) {
                    console.log('[MIS ID LOOKUP] Validation will be applied');
                } else {
                    console.log('[MIS ID LOOKUP] No validation (no row data)');
                }
                
            } catch (e) { 
                console.error('[MIS ID LOOKUP] Error:', e); 
            } finally { 
                setTimeout(() => document.title = originalTitle, 2000); 
            }
        }

        function renderMisIdCell(misIdStr, rowData) {
            if (!misIdStr || misIdStr === '-') {
                return '<span style="color:#999; font-style:italic;">No ID</span>';
            }
            
            // Helper to strip tag prefix (Part 1:, GAP:, Patch:, etc.)
            function stripTag(str) {
                if (!str) return '';
                str = String(str).trim();
                if (str.indexOf(':') !== -1) {
                    return str.split(':').pop().trim();
                }
                return str;
            }
            
            // Handle both newline-separated (new format) and comma-separated (legacy)
            const rawStr = String(misIdStr);
            let ids = [];
            
            if (rawStr.indexOf('\n') !== -1) {
                // New tagged format with newlines
                ids = rawStr.split('\n').map(line => line.trim()).filter(line => line);
            } else {
                // Legacy comma-separated format
                ids = rawStr.split(',').map(id => id.trim()).filter(id => id);
            }
            
            if (ids.length === 0) {
                return '<span style="color:#999; font-style:italic;">No ID</span>';
            }
            
            // Prepare row data for validation (if provided)
            let rowDataJson = null;
            if (rowData) {
                const validationData = {
                    brand: rowData.brand || '',
                    linked_brand: rowData.linked_brand || '',
                    weekday: rowData.weekday || '',
                    categories: rowData.categories || '',
                    discount: rowData.discount || '',
                    vendor_contrib: rowData.vendor_contrib || rowData.vendor_percentage || '',
                    locations: rowData.locations || 'All Locations',
                    rebate_type: rowData.rebate_type || '',
                    after_wholesale: rowData.after_wholesale || false
                };
                rowDataJson = JSON.stringify(validationData).replace(/"/g, '&quot;');
            }
            
            // Make each ID clickable
            const clickableIds = ids.map(id => {
                let cleanId = stripTag(id.replace(' (Estimated)', '').trim());
                const displayId = id; // Keep original format with tag and (Estimated) if present
                
                // Use enhanced validation if row data is available
                if (rowDataJson) {
                    return `<span data-row='${rowDataJson}' 
                                  onclick="lookupMisIdWithValidation(this, '${cleanId}')" 
                                  style="cursor:pointer; font-weight:bold; text-decoration:underline; color:#667eea;" 
                                  title="Click to lookup and validate in MIS">${displayId}</span>`;
                } else {
                    // Fallback to old method without validation
                    return `<span onclick="lookupMisIdWithValidation(this, '${cleanId}')" 
                                  style="cursor:pointer; font-weight:bold; text-decoration:underline; color:#667eea;" 
                                  title="Click to lookup in MIS (backend will search Google Sheet)">${displayId}</span>`;
                }
            });
            
            return clickableIds.join(', ');
        }
        
        async function openSheetRow(rowNum) {
            try {
                await fetch('/api/mis/open-sheet-row', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ row: rowNum })
                });
            } catch (e) { 
                console.error('Row Navigation Error:', e); 
            }
        }

        function renderRowButton(rowNum) {
            return `<button class="btn" style="padding:4px 8px; font-size:0.85em;" onclick="openSheetRow(${rowNum})">Row ${rowNum}</button>`;
        }
        
        function displayMatchResults(matchesObj) {
            const containerId = 'match-results';
            const titles = {'weekly': ' WEEKLY DEALS', 'monthly': ' MONTHLY DEALS', 'sale': ' SALE DEALS'};
            
            // DEBUG: Log what we received
            console.log('[DISPLAY] Received matchesObj:', Object.keys(matchesObj));
            console.log('[DISPLAY] Weekly count:', (matchesObj.weekly || []).length);
            console.log('[DISPLAY] Monthly count:', (matchesObj.monthly || []).length);
            console.log('[DISPLAY] Sale count:', (matchesObj.sale || []).length);
            
            // 1. Flatten Matches for Global Indexing (Source of Truth)
            matchesData = [];
            ['weekly', 'monthly', 'sale'].forEach(key => {
                if (matchesObj[key]) {
                    console.log(`[DISPLAY] Adding ${matchesObj[key].length} ${key} matches to matchesData`);
                    matchesData = matchesData.concat(matchesObj[key]);
                }
            });
            console.log('[DISPLAY] Total matchesData:', matchesData.length);

            // Count items per section
            const counts = {
                weekly: (matchesObj.weekly || []).length,
                monthly: (matchesObj.monthly || []).length,
                sale: (matchesObj.sale || []).length
            };

            // Header and actions
            let headerHtml = '<h3>Match Results</h3>';
            headerHtml += '<p>&#x3030; Multi-day deals are grouped. Use <b>Approve All Days</b> for bulk approval.</p>';
            headerHtml += `
                <div style="margin-bottom:15px;">
                    <button class="btn btn-success btn-sm" onclick="approveAll()" style="margin-right: 5px;" title="Approve all visible matches">[OK] Approve All Sections</button>
                    <button class="btn btn-danger btn-sm" onclick="denyAll()" title="Deny all visible matches">[X] Deny All Sections</button>
                </div>
            `;
            
            // Generate deal type tabs
            headerHtml += generateDealTypeTabsHTML(containerId, counts);

            // Build a single unified table with data-section attributes for filtering
            let unifiedHtml = '<div class="scrollable-table-container" style="max-height:600px; margin-bottom:20px;">';
            unifiedHtml += '<table class="table table-sm" id="match-results-unified-table" style="font-size:0.85em;">';
            unifiedHtml += '<thead><tr>';
            unifiedHtml += '<th>Row</th><th>Brand</th><th style="color:#6c757d;">Linked</th><th>Weekday</th><th>Notes</th><th>Deal Info</th><th>Discount</th>';
            unifiedHtml += '<th>Vendor %</th><th>Locations</th><th>Categories</th><th>Confidence</th><th>Current ID</th>';
            unifiedHtml += '<th>Suggested MIS ID</th>';
            unifiedHtml += '<th style="white-space: nowrap;">Actions</th>';
            unifiedHtml += '</tr></thead><tbody>';

            // Re-render all matches into unified table with section markers
            let globalIdx = 0;
            ['weekly', 'monthly', 'sale'].forEach(sectionKey => {
                const sectionMatches = matchesObj[sectionKey] || [];
                console.log(`[DISPLAY] Processing section ${sectionKey}: ${sectionMatches.length} matches`);
                if (sectionMatches.length === 0) {
                    console.log(`[DISPLAY] Skipping empty section: ${sectionKey}`);
                    return;
                }

                // Add section header row
                unifiedHtml += `<tr class="section-header-row" data-section="${sectionKey}"><td colspan="14" style="background:#e9ecef; font-weight:bold; padding:10px;">${titles[sectionKey]} <small class="text-muted">(${sectionMatches.length} Items)</small></td></tr>`;
                console.log(`[DISPLAY] Added section header for ${sectionKey}`);

                const renderedGroups = new Set();

                sectionMatches.forEach((m) => {
                    const idx = globalIdx++;
                    const isGrouped = m.multi_day_group !== null && m.multi_day_group !== undefined;
                    const isFirstInGroup = isGrouped && m.multi_day_group.is_first;
                    const groupId = isGrouped ? m.multi_day_group.group_id : null;

                    if (isGrouped && !isFirstInGroup) {
                        return; // Skip non-first members
                    }

                    if (isGrouped && isFirstInGroup) {
                        renderedGroups.add(groupId);
                        const groupData = m.multi_day_group;
                        const hasMissingWeekday = groupData.has_missing_weekday;
                        const warningIcon = hasMissingWeekday ? '<span class="weekday-missing-icon" title="Missing weekday data!">[!] </span>' : '';
                        
                        // v12.1: Get weekdays list for display
                        const weekdaysList = (groupData.weekdays || []).filter(w => w && !w.toLowerCase().includes('missing')).join(', ');
                        
                        // v12.1: For multi-brand groups, show full brand string and total entries
                        const headerBrand = groupData.brand_raw || m.brand;
                        const isMultiBrandGroup = groupData.is_multi_brand || false;
                        const totalEntries = groupData.total_entries || groupData.total_days;
                        const totalBrands = groupData.total_brands || 1;
                        
                        // Badge text: show days and brands info for multi-brand
                        let badgeText = '';
                        if (isMultiBrandGroup) {
                            badgeText = `[EMOJI] ${groupData.total_days}-Day [EMOJI] ${totalBrands}-Brand Deal`;
                        } else {
                            badgeText = `[EMOJI] ${groupData.total_days}-Day Deal`;
                        }
                        
                        // Button text: use total entries for multi-brand
                        const buttonText = isMultiBrandGroup ? 
                            `[OK] Approve All ${totalEntries} Entries` : 
                            `[OK] Approve All ${groupData.total_days} Days`;
                        
                        unifiedHtml += `<tr class="group-header-row" data-section="${sectionKey}" onclick="toggleGroup('${groupId}')" title="Click to collapse/expand">`;
                        unifiedHtml += `<td colspan="14">`;
                        unifiedHtml += `<span class="group-toggle-icon" id="toggle-${groupId}">&#x25BC;</span>`;
                        unifiedHtml += `${warningIcon}<strong>${headerBrand}</strong>`;
                        unifiedHtml += `<span class="multi-day-badge">${badgeText}</span>`;
                        unifiedHtml += ` (Rows: ${[...new Set(groupData.row_numbers)].join(', ')}) `;
                        unifiedHtml += `<span style="color:#6c757d; font-size:0.85em;">[${weekdaysList}]</span>`;
                        
                        if (!hasMissingWeekday) {
                            unifiedHtml += `<button class="bulk-approve-btn" onclick="event.stopPropagation(); approveAllDaysInGroup('${groupId}')">${buttonText}</button>`;
                        }
                        unifiedHtml += `</td></tr>`;

                        // Render group members
                        const groupMembers = sectionMatches.filter(gm => gm.multi_day_group && gm.multi_day_group.group_id === groupId);
                        groupMembers.forEach((gm) => {
                            const memberGlobalIdx = matchesData.indexOf(gm);
                            unifiedHtml += renderMatchRowWithSection(gm, memberGlobalIdx, groupId, hasMissingWeekday, sectionKey);
                        });
                    } else {
                        // Single (non-grouped) row
                        unifiedHtml += renderMatchRowWithSection(m, idx, null, false, sectionKey);
                    }
                });
            });

            unifiedHtml += '</tbody></table></div>';

            // Build final HTML
            let finalHtml = headerHtml;
            finalHtml += `<div id="${containerId}-unified" class="deal-type-content active" style="display:block;">${unifiedHtml}</div>`;
            
            document.getElementById('match-results').innerHTML = finalHtml;
            
            // v12.2: Set default weekly view button state
            setTimeout(() => {
                const breakdownBtn = document.getElementById('weekly-view-breakdown');
                const fullBtn = document.getElementById('weekly-view-full');
                if (breakdownBtn && fullBtn) {
                    breakdownBtn.classList.add('active');
                    fullBtn.classList.remove('active');
                }
            }, 10);
            
            // Apply initial filter - this will trigger breakdown view if enabled
            filterMatchResultsBySection('all');
        }

// v10.9.3: FIX 0% DISPLAY vs EMPTY
        function renderMatchRowWithSection(m, idx, groupId, hasMissingWeekday, sectionKey) {
            const statusClass = m.status === 'HIGH' ? 'status-high' : m.status === 'MEDIUM' ? 'status-medium' : 'status-low';
            const rowBtn = renderRowButton(m.google_row);
            
            // v12.1: Add multi-brand badge if applicable, BOLD the brand name
            let brandCell = `<strong>${renderBrandCell(m.brand, idx, 'match')}</strong>`;
            if (m.is_multi_brand) {
                const brandIdx = (m.multi_brand_index || 0) + 1;
                const total = m.multi_brand_total || 1;
                brandCell = `<span class="badge bg-info text-dark me-1" title="Multi-brand deal: ${m.brand_raw}">${brandIdx}/${total}</span> <strong>${renderBrandCell(m.brand, idx, 'match')}</strong>`;
            }
            
            // v12.1: Get linked brand from Settings tab (same as Creation Checklist)
            let linkedBrandDisplay = '-';
            if (m.linked_brand && m.linked_brand !== '') {
                linkedBrandDisplay = `<span style="color:#6c757d;">${m.linked_brand}</span>`;
            }
            
            let weekdayDisplay = m.weekday || '-';
            if (!m.weekday || m.weekday.trim() === '') {
                weekdayDisplay = '<span class="weekday-missing-icon">[!] </span><span style="color:#dc3545; font-style:italic;">MISSING</span>';
            }

            // --- DISCOUNT DISPLAY LOGIC ---
            // If null/undefined/empty string -> Show RED "EMPTY"
            // If 0 or any number -> Show "0%" or "20%"
            let discountDisplay = '';
            if (m.discount === null || m.discount === undefined || m.discount === '') {
                discountDisplay = '<span style="color:#dc3545; font-weight:bold; font-size:0.85em;">EMPTY</span>';
            } else {
                discountDisplay = `${m.discount}%`;
            }

            // --- VENDOR DISPLAY LOGIC ---
            // Applying similar logic for consistency: Ensure 0% shows as 0%, not -%
            let vendorDisplay = '';
            if (m.vendor_contrib === null || m.vendor_contrib === undefined || m.vendor_contrib === '') {
                vendorDisplay = '-';
            } else {
                vendorDisplay = `${m.vendor_contrib}%`;
            }

            // v12.1: Handle tagged MIS IDs (W1: 12345, W2: 67890, etc.) - Individual clickable buttons
            let currentIdDisplay = '<span style="color:#999; font-style:italic;">No ID</span>';
            const currentIdStr = m.current_sheet_id ? String(m.current_sheet_id).trim() : '';
            const suggestedId = m.matched_mis_id ? String(m.matched_mis_id).trim() : '';

            if (currentIdStr) {
                // Parse tagged IDs: W1: 12345, W1: 67890, W2: 11111, WP: 99999, etc.
                const tagPattern = /([WwMmSs][1-9Pp]|[Pp]art\s*\d+|[Gg][Aa][Pp]|[Pp]atch)\s*:\s*(\d+)/g;
                let taggedIds = [];
                let match;
                while ((match = tagPattern.exec(currentIdStr)) !== null) {
                    let tag = match[1].toUpperCase().replace(/\s+/g, '');
                    // Normalize legacy tags
                    if (tag.startsWith('PART')) {
                        const partNum = tag.match(/\\d+/)[0];
                        tag = 'W' + partNum;
                    } else if (tag === 'GAP') {
                        tag = 'GAP';
                    } else if (tag === 'PATCH') {
                        tag = 'WP';
                    }
                    taggedIds.push({ tag: tag, id: match[2] });
                }
                
                // If no tags found, try comma-separated plain IDs
                if (taggedIds.length === 0) {
                    const plainIds = currentIdStr.split(',').map(s => s.trim()).filter(s => /^\\d{5,7}$/.test(s));
                    taggedIds = plainIds.map(id => ({ tag: '', id: id }));
                }
                
                if (taggedIds.length > 0) {
                    currentIdDisplay = taggedIds.map(item => {
                        const isMatch = (item.id === suggestedId);
                        const bg = isMatch ? '#d4edda' : '#e9ecef';
                        const color = isMatch ? '#155724' : '#495057';
                        const border = isMatch ? '1px solid #28a745' : '1px solid #ced4da';
                        const tagDisplay = item.tag ? `<span style="font-size:0.75em; color:#6c757d;">${item.tag}:</span> ` : '';
                        return `<span onclick="lookupMisId('${item.id}')" 
                                      style="cursor:pointer; font-weight:bold; padding:2px 6px; border-radius:4px; 
                                             background:${bg}; color:${color}; border:${border};
                                             text-decoration:underline; display:inline-block; margin:2px;">
                                    ${tagDisplay}${item.id}
                                </span>`;
                    }).join('');
                }
            }

            let inputHtml = '';
            if (hasMissingWeekday && (!m.weekday || m.weekday.trim() === '')) {
                inputHtml = '<span style="color:#dc3545; font-style:italic;">[!] Manual entry required</span>';
            } else {
                // SUGGESTION LOGIC: ALWAYS USE MAGNIFYING GLASS (No Dropdowns)
                const hasSuggestions = m.suggestions && m.suggestions.length > 0;
                
                const iconColor = hasSuggestions ? '#ffc107' : '#e2e6ea'; 
                const iconCursor = hasSuggestions ? 'pointer' : 'default';
                const iconTitle = hasSuggestions ? `View ${m.suggestions.length} Suggestions` : 'No Suggestions found';
                const iconShadow = hasSuggestions ? 'text-shadow: 0 0 2px rgba(255, 193, 7, 0.5);' : '';
                
                const clickAction = hasSuggestions ? `onclick="showSuggestionTooltip(${idx})"` : '';

                inputHtml = `
                    <div style="min-width:150px;" id="input-container-${idx}">
                        <div style="display:flex; gap:5px; align-items:center;">
                            <input type="text" id="input-mis-${idx}" class="mis-id-input" value="${m.matched_mis_id || ''}" 
                                   style="width:90px; font-weight:bold; padding:4px;" data-row="${idx}" placeholder="MIS ID">
                            
                            <span class="suggestion-indicator" ${clickAction} 
                                  title="${iconTitle}" 
                                  style="cursor:${iconCursor}; color:${iconColor}; font-size:1.3em; vertical-align:middle; ${iconShadow}">
                                &#128269;
                            </span>

                            <button class="btn btn-sm btn-outline-secondary" style="padding:0px 5px;" onclick="addIdField(${idx})">+</button>
                        </div>
                    </div>`;
            }

            const truncate = (text, len) => {
                if (!text) return '-';
                text = String(text);
                return text.length > len ? text.substring(0, len) + '...' : text;
            };
            
            // v12.1: Format locations with numbered list for tooltip
            const formatLocationsNumbered = (locStr) => {
                if (!locStr || locStr === '-') return '-';
                const locs = locStr.split(',').map(l => l.trim()).filter(l => l);
                return locs.map((loc, i) => (i + 1) + '. ' + loc).join('&#10;');
            };
            const locationsTooltip = formatLocationsNumbered(m.locations);

            let actionHtml = '';
            if (hasMissingWeekday && (!m.weekday || m.weekday.trim() === '')) {
                actionHtml = '<span style="color:#999; font-style:italic;">N/A</span>';
            } else {
                // v12.5: Smaller Approve/Deny buttons + Blue Blaze button
                const existingBlazeTitles = approvedMatches[m.google_row]?.blaze_titles || [];
                const blazeBtnClass = existingBlazeTitles.length > 0 ? 'btn-primary' : 'btn-outline-primary';
                const blazeBtnText = existingBlazeTitles.length > 0 ? '<i class="bi bi-lightning-charge-fill"></i> ' + existingBlazeTitles.length : '<i class="bi bi-lightning-charge"></i>';
                
                actionHtml = `
                    <div style="display:flex; gap:2px; align-items:center; flex-wrap:nowrap;">
                        <button class="btn btn-success btn-sm btn-approve" style="padding:1px 4px; font-size:0.7rem;" onclick="approveSingleMatch(${idx})" title="Approve">[OK]</button>
                        <button class="btn btn-danger btn-sm btn-reject" style="padding:1px 4px; font-size:0.7rem;" onclick="rejectMatch(${idx})" title="Deny">[X]</button>
                        <button class="btn ${blazeBtnClass} btn-sm btn-blaze" style="padding:1px 5px; font-size:0.7rem;" onclick="openBlazeModal(${idx})" title="Select Blaze Discount">${blazeBtnText}</button>
                    </div>`;
            }

            const rowClass = groupId ? `group-member-row group-${groupId}` : '';
            const warningClass = (hasMissingWeekday && (!m.weekday || m.weekday.trim() === '')) ? 'missing-weekday-warning' : '';
            const bgStyle = groupId ? 'style="background-color: #fff3cd !important;"' : '';
            
            // v12.1: Add dashed border for multi-brand rows after first brand
            const multiBrandStyle = m.is_multi_brand && m.multi_brand_index > 0 ? 'style="border-top: 1px dashed #dee2e6 !important;"' : bgStyle;

            return `<tr id="match-row-${idx}" class="${rowClass} ${warningClass}" data-section="${sectionKey}" data-group="${groupId || ''}" ${multiBrandStyle}>
                <td>${rowBtn}</td>
                <td>${brandCell}</td>
                <td>${linkedBrandDisplay}</td>
                <td>${weekdayDisplay}</td>
                <td title="${m.special_notes || ''}">${truncate(m.special_notes, 15)}</td>
                <td title="${m.deal_info || ''}">${truncate(m.deal_info, 15)}</td>
                <td>${discountDisplay}</td>
                <td>${vendorDisplay}</td>
                <td title="${locationsTooltip}">${truncate(m.locations, 25)}</td>
                <td title="${m.categories || ''}">${truncate(m.categories, 15)}</td>
                <td><span class="status-badge ${statusClass}">${m.confidence || 0}%</span></td>
                <td>${currentIdDisplay}</td>
                <td>${inputHtml}</td>
                <td>${actionHtml}</td>
            </tr>`;
        }
        
        // v88: Filter function for section tabs
        function filterMatchResultsBySection(section) {
            console.log('[FILTER] Filtering to section:', section);
            
            const rows = document.querySelectorAll('#match-results-unified-table tbody tr');
            rows.forEach(row => {
                const rowSection = row.getAttribute('data-section');
                if (section === 'all' || rowSection === section) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
            
            console.log('[FILTER] Rows visible, weeklyViewMode:', weeklyViewMode);
            
            // v12.2: If weekly section is visible AND breakdown mode is on, reorganize into weekday sections
            if ((section === 'weekly' || section === 'all') && weeklyViewMode === 'breakdown') {
                console.log('[FILTER] Triggering breakdown view');
                
                // SAVE ORIGINAL TABLE STATE before breakdown modifies it
                const table = document.getElementById('match-results-unified-table');
                if (table) {
                    const tbody = table.querySelector('tbody');
                    if (tbody && !originalTableState) {
                        originalTableState = tbody.innerHTML;
                        console.log('[FILTER] Saved original table state');
                    }
                }
                
                setTimeout(() => insertWeekdayHeaders(), 50); // Small delay to ensure rows are visible
            }
        }


        function toggleGroup(groupId) {
            const members = document.querySelectorAll(`.group-${groupId}`);
            const toggleIcon = document.getElementById(`toggle-${groupId}`);
            
            members.forEach(member => {
                member.classList.toggle('collapsed');
            });
            
            if (toggleIcon) {
                toggleIcon.classList.toggle('collapsed');
                toggleIcon.textContent = toggleIcon.classList.contains('collapsed') ? '->[EMOJI]' : '->[EMOJI]';
            }
        }

        function approveAllDaysInGroup(groupId) {
            const members = document.querySelectorAll(`.group-${groupId}`);
            const rowIndices = [];
            
            members.forEach(member => {
                const rowId = member.id;
                if (rowId && rowId.startsWith('match-row-')) {
                    const idx = parseInt(rowId.replace('match-row-', ''));
                    rowIndices.push(idx);
                }
            });
            
            if (rowIndices.length === 0) {
                alert('No rows found in this group');
                return;
            }
            
            rowIndices.forEach(idx => {
                approveSingleMatch(idx);
            });
            
            alert(`[OK] Approved all ${rowIndices.length} days in this group`);
        }

        function addIdField(idx) {
            const container = document.getElementById(`input-container-${idx}`);
            if (!container) return;
            
            const newDiv = document.createElement('div');
            newDiv.style.cssText = "display:flex; gap:5px; align-items:center; margin-top:4px;";
            
            newDiv.innerHTML = `
                <input type="text" class="mis-id-input" value="" 
                       style="width:80px; font-weight:bold; padding:4px;" data-row="${idx}">
                <span class="suggestion-indicator" onclick="showSuggestionTooltip(${idx}, this)" 
                      title="View Suggestions" style="cursor:pointer;"></span>
                <button class="btn" style="padding:2px 6px; font-size:1.1em; color:#dc3545;" 
                        onclick="this.parentElement.remove()">-</button>
            `;
            
            container.appendChild(newDiv);
        }

        function approveAll() {
            // v12.1: Show popup with section selection
            showBulkActionModal('approve');
        }
        
        function denyAll() {
            // v12.1: Show popup with section selection
            showBulkActionModal('deny');
        }
        
        // v12.1: Smart bulk action modal with section selection
        function showBulkActionModal(actionType) {
            // Remove any existing modal
            const existing = document.getElementById('bulk-action-modal-overlay');
            if (existing) existing.remove();
            
            const actionLabel = actionType === 'approve' ? 'Approve' : 'Deny';
            const actionColor = actionType === 'approve' ? '#28a745' : '#dc3545';
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'bulk-action-modal-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.5); z-index: 9998;
                display: flex; justify-content: center; align-items: center;
            `;
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #fff; padding: 25px; border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3); text-align: center;
                min-width: 350px;
            `;
            
            modal.innerHTML = `
                <h4 style="margin-bottom: 20px; color: ${actionColor};">${actionLabel} MIS IDs</h4>
                <p style="color: #666; margin-bottom: 20px;">Select which section to ${actionType.toLowerCase()}:<br>
                <small>(Only rows with MIS IDs entered will be processed)</small></p>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="btn btn-lg" style="background: ${actionColor}; color: white; font-weight: bold;"
                            onclick="executeBulkAction('${actionType}', 'all')">
                        All Sections!
                    </button>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="btn btn-primary" style="flex: 1;"
                                onclick="executeBulkAction('${actionType}', 'weekly')">
                            Weekly
                        </button>
                        <button class="btn btn-success" style="flex: 1;"
                                onclick="executeBulkAction('${actionType}', 'monthly')">
                            Monthly
                        </button>
                        <button class="btn btn-warning" style="flex: 1;"
                                onclick="executeBulkAction('${actionType}', 'sale')">
                            Sale
                        </button>
                    </div>
                    <button class="btn btn-outline-secondary" onclick="closeBulkActionModal()">
                        Cancel
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Click outside to close
            overlay.onclick = function(e) {
                if (e.target === overlay) closeBulkActionModal();
            };
        }
        
        function closeBulkActionModal() {
            const modal = document.getElementById('bulk-action-modal-overlay');
            if (modal) modal.remove();
        }
        
        function executeBulkAction(actionType, section) {
            let count = 0;
            let skipped = 0;
            
            matchesData.forEach((match, idx) => {
                // Check if this row matches the selected section
                if (section !== 'all' && match.section !== section) {
                    return;
                }
                
                // Check if row is visible (not filtered out)
                const row = document.getElementById('match-row-' + idx);
                if (!row || row.style.display === 'none') {
                    return;
                }
                
                if (actionType === 'approve') {
                    // Only approve rows that have MIS IDs entered
                    const container = document.getElementById(`input-container-${idx}`);
                    if (container) {
                        const inputs = container.querySelectorAll('input.mis-id-input');
                        const values = Array.from(inputs)
                            .map(i => i.value.trim())
                            .filter(v => v.length > 0);
                        
                        if (values.length > 0) {
                            if (approveSingleMatch(idx)) {
                                count++;
                            }
                        } else {
                            skipped++;
                        }
                    }
                } else {
                    // Deny - remove from approved and mark as rejected
                    rejectMatch(idx);
                    count++;
                }
            });
            
            closeBulkActionModal();
            
            const sectionLabel = section === 'all' ? 'all sections' : section;
            if (actionType === 'approve') {
                let msg = `Approved ${count} rows in ${sectionLabel}.`;
                if (skipped > 0) {
                    msg += `\\nSkipped ${skipped} rows without MIS IDs.`;
                }
                alert(msg);
            } else {
                alert(`Denied ${count} rows in ${sectionLabel}.`);
            }
            
            console.log(`[BULK] ${actionType} completed: ${count} rows in ${sectionLabel}`);
        }
        
        function approveSingleMatch(idx) {
            const container = document.getElementById(`input-container-${idx}`);
            if (!container) {
                console.error(`Container not found for idx ${idx}`);
                return;
            }
            
            const inputs = container.querySelectorAll('input.mis-id-input');
            const values = Array.from(inputs)
                .map(i => i.value.trim())
                .filter(v => v.length > 0);
            
            if (values.length === 0) {
                // For bulk operations, silently skip rows without IDs
                return false;
            }
            
            const newMisId = values.join(', ');
            const match = matchesData[idx];
            
            if (!match) {
                console.error(`Match data not found for idx ${idx}`);
                return false;
            }
            
            // v12.1: Handle multi-brand deals - append MIS IDs instead of overwriting
            const existingApproval = approvedMatches[match.google_row];
            
            if (existingApproval && match.is_multi_brand) {
                // Same row already has an approval - this is a multi-brand situation
                // Append the new MIS ID to existing ones
                const existingIds = existingApproval.mis_ids || [existingApproval.mis_id];
                const existingBrands = existingApproval.brands || [];
                
                // Check if this brand was already approved (avoid duplicates)
                if (!existingBrands.includes(match.brand)) {
                    existingIds.push(newMisId);
                    existingBrands.push(match.brand);
                    
                    // v12.6 FIX: Preserve existing blaze_titles when updating MIS IDs
                    const existingBlazeTitles = existingApproval.blaze_titles || [];
                    
                    approvedMatches[match.google_row] = {
                        mis_ids: existingIds,
                        brands: existingBrands,
                        section: match.section || 'weekly',
                        is_multi_brand: true,
                        blaze_titles: existingBlazeTitles  // [EMOJI] PRESERVE blaze_titles
                    };
                    console.log(`[MULTI-BRAND] Row ${match.google_row}: Added ${match.brand} (${newMisId}). Total: ${existingIds.length} brands`);
                } else {
                    // Brand already approved - update its MIS ID
                    const brandIdx = existingBrands.indexOf(match.brand);
                    existingIds[brandIdx] = newMisId;
                    approvedMatches[match.google_row].mis_ids = existingIds;
                    console.log(`[MULTI-BRAND] Row ${match.google_row}: Updated ${match.brand} to ${newMisId}`);
                }
            } else {
                // First approval for this row or single-brand deal
                // v12.6 FIX: Check if there are existing blaze_titles to preserve
                const existingBlazeTitles = existingApproval?.blaze_titles || [];
                
                approvedMatches[match.google_row] = {
                    mis_ids: [newMisId],
                    brands: [match.brand],
                    section: match.section || 'weekly',
                    is_multi_brand: match.is_multi_brand || false,
                    blaze_titles: existingBlazeTitles  // [EMOJI] PRESERVE blaze_titles
                };
            }
            
            const row = document.getElementById('match-row-' + idx);
            if (row) {
                row.classList.add('row-approved');
                row.classList.remove('row-rejected');
            }
            
            // v12.1: Turn input text box green to show approval
            inputs.forEach(input => {
                input.style.backgroundColor = '#d4edda';
                input.style.borderColor = '#28a745';
                input.style.color = '#155724';
            });
            
            updateApplyButtonsVisibility();
            return true; // Return true to indicate success
        }

        function rejectMatch(idx) {
            const match = matchesData[idx];
            if (!match) return;
            
            const row = document.getElementById('match-row-' + idx);
            
            // v12.1: Handle multi-brand rejection properly
            const existingApproval = approvedMatches[match.google_row];
            if (existingApproval) {
                if (existingApproval.is_multi_brand && existingApproval.brands && existingApproval.brands.length > 1) {
                    // Multi-brand: Only remove this specific brand
                    const brandIdx = existingApproval.brands.indexOf(match.brand);
                    if (brandIdx !== -1) {
                        existingApproval.mis_ids.splice(brandIdx, 1);
                        existingApproval.brands.splice(brandIdx, 1);
                        console.log(`[MULTI-BRAND] Row ${match.google_row}: Rejected ${match.brand}. Remaining: ${existingApproval.brands.join(', ')}`);
                        
                        // If only one brand left, convert back to simple format
                        if (existingApproval.brands.length === 1) {
                            existingApproval.is_multi_brand = false;
                        }
                    }
                } else {
                    // Single brand or last brand: delete entire entry
                    delete approvedMatches[match.google_row];
                }
            }
            
            if (row) {
                row.classList.add('row-rejected');
                row.classList.remove('row-approved');
            }
            
            // v12.1: Clear green styling from input if it was approved
            const container = document.getElementById(`input-container-${idx}`);
            if (container) {
                const inputs = container.querySelectorAll('input.mis-id-input');
                inputs.forEach(input => {
                    input.style.backgroundColor = '';
                    input.style.borderColor = '';
                    input.style.color = '';
                });
            }
        }

// HELPER: Normalize date to YYYY-MM-DD format for comparison
        function normalizeDate(dateStr) {
            if (!dateStr || dateStr === 'N/A') return null;
            
            // Already in YYYY-MM-DD format
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateStr;
            }
            
            // Handle MM/DD/YYYY or M/D/YYYY format
            if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
                const parts = dateStr.split('/');
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }
            
            // Handle MM/DD/YY or M/D/YY format (2-digit year)
            if (/^\d{1,2}\/\d{1,2}\/\d{2}$/.test(dateStr)) {
                const parts = dateStr.split('/');
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = '20' + parts[2]; // Assume 2000s
                return `${year}-${month}-${day}`;
            }
            
            return null; // Invalid format
        }

  // v12.1: ENHANCED MODAL for Suggestions with full comparison
        function showSuggestionTooltip(rowIdx) {
            // Remove any existing modals first
            const existing = document.getElementById('suggestion-modal-overlay');
            if (existing) existing.remove();

            const match = matchesData[rowIdx];
            if (!match || !match.suggestions || match.suggestions.length === 0) return;

            // Create Overlay (Dark Background)
            const overlay = document.createElement('div');
            overlay.id = 'suggestion-modal-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.5); z-index: 9998;
                display: flex; justify-content: center; align-items: center;
            `;
            overlay.onclick = function(e) {
                if(e.target === overlay) overlay.remove();
            };

            // v12.1: Adaptive width - 1500px or screen width minus padding, whichever is smaller
            const screenWidth = window.innerWidth;
            const modalWidth = Math.min(1500, screenWidth - 40); // 40px padding total
            
            // Create Modal Box - adaptive width with horizontal scroll
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #fff; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                width: ${modalWidth}px; max-width: 98%; max-height: 85vh;
                overflow-y: auto; overflow-x: auto; z-index: 9999; position: relative;
            `;
            
            // v12.1: Helper to format locations vertically for tooltip
            const formatLocationsVertical = (locations) => {
                if (!locations || locations === '-') return '-';
                // Split by comma, trim each, join with newlines
                return locations.split(',').map(loc => loc.trim()).filter(loc => loc).join('&#10;');
            };

            // Helper: Get cell style based on match
            const getMatchStyle = (sourceVal, targetVal, isNumeric = false) => {
                if (!sourceVal && !targetVal) return '';
                if (!sourceVal || !targetVal) return 'background:#fff3cd; color:#856404;'; // Yellow - missing
                
                let matches = false;
                if (isNumeric) {
                    const s = parseFloat(String(sourceVal).replace(/[%$,]/g, '')) || 0;
                    const t = parseFloat(String(targetVal).replace(/[%$,]/g, '')) || 0;
                    matches = Math.abs(s - t) < 0.01;
                } else {
                    matches = String(sourceVal).toLowerCase().trim() === String(targetVal).toLowerCase().trim();
                }
                
                return matches ? 'background:#d4edda; color:#155724;' : 'background:#f8d7da; color:#721c24;';
            };
            
            // Helper: Fuzzy match for brand
            const getBrandMatchStyle = (sourceBrand, targetBrand) => {
                if (!sourceBrand || !targetBrand) return 'background:#fff3cd; color:#856404;';
                const s = String(sourceBrand).toLowerCase().trim();
                const t = String(targetBrand).toLowerCase().trim();
                if (s === t) return 'background:#d4edda; color:#155724;'; // Exact match - green
                if (s.includes(t) || t.includes(s)) return 'background:#d4edda; color:#155724;'; // Contains - green
                return 'background:#f8d7da; color:#721c24;'; // No match - red
            };
            
            // v12.1: Get tab name for month/year parsing
            // v12.24.8: Fixed element ID from 'sheet-select' to 'mis-tab'
            const currentTabName = document.getElementById('mis-tab')?.value || '';
            
            // v12.1: Parse month/year from tab name (e.g., "January 2026")
            const parseTabMonthYear = (tabName) => {
                const months = ['january','february','march','april','may','june','july','august','september','october','november','december'];
                const parts = tabName.toLowerCase().trim().split(/\s+/);
                let month = -1, year = -1;
                for (const p of parts) {
                    const mIdx = months.indexOf(p);
                    if (mIdx >= 0) month = mIdx;
                    if (/^\d{4}$/.test(p)) year = parseInt(p);
                }
                return { month, year };
            };
            
            // v12.1: Get last day of month (handles leap years)
            const getLastDayOfMonth = (year, month) => {
                // month is 0-indexed (0=Jan, 11=Dec)
                return new Date(year, month + 1, 0).getDate();
            };
            
            // v12.1: Format date as YYYY-MM-DD
            const formatDate = (year, month, day) => {
                const m = String(month + 1).padStart(2, '0');
                const d = String(day).padStart(2, '0');
                return year + '-' + m + '-' + d;
            };
            
            // v12.1: Parse date string to {year, month, day}
            const parseDate = (dateStr) => {
                if (!dateStr || dateStr === '-' || dateStr === 'N/A') return null;
                // Try YYYY-MM-DD
                let m = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
                if (m) return { year: parseInt(m[1]), month: parseInt(m[2]) - 1, day: parseInt(m[3]) };
                // Try MM/DD/YYYY
                m = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                if (m) return { year: parseInt(m[3]), month: parseInt(m[1]) - 1, day: parseInt(m[2]) };
                // Try MM/DD/YY
                m = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
                if (m) return { year: 2000 + parseInt(m[3]), month: parseInt(m[1]) - 1, day: parseInt(m[2]) };
                return null;
            };
            
            // v12.1: Normalize weekdays for comparison
            const normalizeWeekdays = (weekdayStr) => {
                if (!weekdayStr || weekdayStr === '-' || weekdayStr === 'N/A') return [];
                const days = ['mon','tue','wed','thu','fri','sat','sun'];
                const result = [];
                const lower = weekdayStr.toLowerCase();
                days.forEach(d => {
                    if (lower.includes(d)) result.push(d);
                });
                return result.sort();
            };
            
            // v12.1: Normalize locations for comparison
            const normalizeLocations = (locStr) => {
                if (!locStr || locStr === '-') return [];
                return locStr.split(',').map(l => l.trim().toLowerCase()).filter(l => l).sort();
            };
            
            // v12.1: Check if suggestion is a perfect match for Continue/Recycle
            const checkContinueEligibility = (searchingFor, suggestion, sectionType) => {
                const result = {
                    isContinue: false,
                    isPartialContinue: false,
                    mismatches: [],
                    newEndDate: null,
                    currentEndDate: null,
                    needsManualReview: false,
                    needsLinkedBrand: false,  // v12.1: Flag if MIS needs linked brand added
                    cannotDetermineDate: false  // Flag when tab name can't be parsed
                };
                
                // Parse tab for target month/year
                const tabInfo = parseTabMonthYear(currentTabName);
                if (tabInfo.month < 0 || tabInfo.year < 0) {
                    // Can't determine Continue eligibility without valid date - mark as indeterminate
                    result.cannotDetermineDate = true;
                    // Still check field matches for partial info
                }
                
                // Calculate new end date (last day of target month) - only if we have valid date
                if (!result.cannotDetermineDate) {
                    const lastDay = getLastDayOfMonth(tabInfo.year, tabInfo.month);
                    result.newEndDate = formatDate(tabInfo.year, tabInfo.month, lastDay);
                }
                
                // Get current MIS end date
                const misEndDate = suggestion.mis_data.end_date;
                result.currentEndDate = misEndDate;
                
                // Check each key field
                // 1. Brand - v12.1: STRICT match, no partial "includes" allowed
                const srcBrand = String(searchingFor.brand || '').toLowerCase().trim();
                const tgtBrand = String(suggestion.mis_data.brand || '').toLowerCase().trim();
                if (srcBrand !== tgtBrand) {
                    // Strict match only - "Stiiizy" should NOT match "Stiiizy Accessories"
                    result.mismatches.push('Brand');
                }
                
                // 2. Linked Brand - v12.1: Enhanced check with needsLinkedBrand flag
                const srcLinked = String(searchingFor.linked_brand || '').toLowerCase().trim();
                const tgtLinked = String(suggestion.mis_data.linked_brand || '').toLowerCase().trim();
                const srcHasLinked = srcLinked && srcLinked !== 'n/a' && srcLinked !== '';
                const tgtHasLinked = tgtLinked && tgtLinked !== 'n/a' && tgtLinked !== '';
                
                if (srcHasLinked) {
                    if (!tgtHasLinked) {
                        // Google Sheet has linked brand but MIS doesn't
                        result.needsLinkedBrand = true;
                    } else if (srcLinked !== tgtLinked) {
                        // Both have linked brand but they don't match
                        result.mismatches.push('Linked Brand');
                    }
                }
                
                // 3. Discount
                const srcDiscount = parseFloat(String(searchingFor.discount || 0).replace(/[%]/g, '')) || 0;
                const tgtDiscount = parseFloat(String(suggestion.mis_data.discount || 0).replace(/[%]/g, '')) || 0;
                if (Math.abs(srcDiscount - tgtDiscount) > 0.01) {
                    result.mismatches.push('Discount');
                }
                
                // 4. Vendor %
                const srcVendor = parseFloat(String(searchingFor.vendor_contrib || 0).replace(/[%]/g, '')) || 0;
                const tgtVendor = parseFloat(String(suggestion.mis_data.vendor_contribution || 0).replace(/[%]/g, '')) || 0;
                if (Math.abs(srcVendor - tgtVendor) > 0.01) {
                    result.mismatches.push('Vendor %');
                }
                
                // 5. Locations
                const srcLocs = normalizeLocations(searchingFor.locations);
                const tgtLocs = normalizeLocations(suggestion.mis_data.locations);
                if (JSON.stringify(srcLocs) !== JSON.stringify(tgtLocs)) {
                    result.mismatches.push('Locations');
                }
                
                // 6. Weekdays (for Weekly deals)
                if (sectionType === 'weekly') {
                    // Get all weekdays from multi-day group if applicable
                    let srcWeekdays = [];
                    if (searchingFor.multi_day_group && searchingFor.multi_day_group.weekdays) {
                        srcWeekdays = searchingFor.multi_day_group.weekdays.map(w => w.toLowerCase().substring(0,3)).filter(w => w && !w.includes('missing')).sort();
                    } else {
                        srcWeekdays = normalizeWeekdays(searchingFor.weekday);
                    }
                    const tgtWeekdays = normalizeWeekdays(suggestion.mis_data.weekdays);
                    if (JSON.stringify(srcWeekdays) !== JSON.stringify(tgtWeekdays)) {
                        result.mismatches.push('Weekdays');
                    }
                }
                
                // 7. Categories
                const srcCat = String(searchingFor.categories || '').toLowerCase().trim();
                const tgtCat = String(suggestion.mis_data.category || '').toLowerCase().trim();
                // "all" or empty both mean all categories
                const srcIsAll = !srcCat || srcCat === 'all' || srcCat === '-' || srcCat.includes('all categories');
                const tgtIsAll = !tgtCat || tgtCat === 'all' || tgtCat === '-' || tgtCat === 'n/a' || tgtCat === 'nan';
                if (srcIsAll !== tgtIsAll) {
                    result.mismatches.push('Categories');
                } else if (!srcIsAll && !tgtIsAll && srcCat !== tgtCat) {
                    result.mismatches.push('Categories');
                }
                
                // Determine eligibility
                // Can only determine Continue eligibility if we could parse the tab date
                if (result.mismatches.length === 0 && !result.cannotDetermineDate) {
                    result.isContinue = true;
                    
                    // Check if end date needs manual review
                    const parsedEnd = parseDate(misEndDate);
                    if (parsedEnd) {
                        const endDateObj = new Date(parsedEnd.year, parsedEnd.month, parsedEnd.day);
                        const targetMonthStart = new Date(tabInfo.year, tabInfo.month, 1);
                        if (endDateObj >= targetMonthStart) {
                            result.needsManualReview = true;
                            result.isPartialContinue = true;
                        }
                    }
                }
                
                return result;
            };

            // Helper: Build More Info popup content
            const buildMoreInfoHtml = (data, title) => {
                if (!data || Object.keys(data).length === 0) return '<em>No additional data</em>';
                let html = '<table class="table table-sm table-bordered" style="font-size:0.8em; margin:0;">';
                html += '<thead><tr><th style="width:40%;">Field</th><th>Value</th></tr></thead><tbody>';
                Object.entries(data).forEach(([key, val]) => {
                    html += '<tr><td><strong>' + key + '</strong></td><td>' + val + '</td></tr>';
                });
                html += '</tbody></table>';
                return html;
            };

            // Escape for JSON embedding
            const escapeForAttr = (str) => {
                if (!str) return '';
                return String(str).replace(/'/g, "\\'").replace(/"/g, "&quot;");
            };

            // --- HEADER ---
            let html = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:2px solid #007bff; padding-bottom:10px;">
                    <h5 style="margin:0; color:#007bff;">Suggestion Details for Row ${match.google_row}</h5>
                    <button class="btn btn-sm btn-outline-danger" onclick="document.getElementById('suggestion-modal-overlay').remove()">Close</button>
                </div>
            `;

            // --- SEARCHING FOR SECTION ---
            const linkedBrandDisplay = match.linked_brand ? `<br><small style="color:#6c757d;">${match.linked_brand}</small>` : '';
            const rawRowDataJson = match.raw_row_data ? escapeForAttr(JSON.stringify(match.raw_row_data)) : '{}';
            
            // v12.1: Format weekdays vertically for display and tooltip
            let searchingWeekdays = match.weekday || '-';
            let searchingWeekdaysTooltip = match.weekday || '-';
            if (match.multi_day_group && match.multi_day_group.weekdays) {
                const weekdaysList = match.multi_day_group.weekdays.filter(w => w && !w.toLowerCase().includes('missing'));
                searchingWeekdays = weekdaysList.join('<br>');
                searchingWeekdaysTooltip = weekdaysList.join('&#10;');
            }
            
            // v12.1: Format categories vertically
            const formatCategoriesVertical = (catStr) => {
                if (!catStr || catStr === '-') return { display: '-', tooltip: '-' };
                const cats = catStr.split(',').map(c => c.trim()).filter(c => c);
                return { 
                    display: cats.slice(0, 3).join('<br>') + (cats.length > 3 ? '<br>...' : ''),
                    tooltip: cats.join('&#10;')
                };
            };
            const searchingCategories = formatCategoriesVertical(match.categories);
            
            html += `
                <div style="margin-bottom:20px;">
                    <h6 style="color:#495057; margin-bottom:10px; border-bottom:1px solid #dee2e6; padding-bottom:5px;">
                        Searching For (Google Sheet Data)
                    </h6>
                    <div style="overflow-x:auto;">
                        <table class="table table-sm table-bordered" style="font-size:0.85em; white-space:nowrap;">
                            <thead class="table-primary">
                                <tr>
                                    <th>Row</th>
                                    <th>Weekday</th>
                                    <th>Brand / Linked</th>
                                    <th>Category</th>
                                    <th>Discount</th>
                                    <th>Vendor %</th>
                                    <th>Deal Info</th>
                                    <th>Notes</th>
                                    <th>Locations</th>
                                    <th>More Info</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background:#e7f1ff;">
                                    <td>
                                        <button class="btn btn-sm btn-outline-primary py-0 px-2" 
                                                onclick="openSheetRow(${match.google_row})" 
                                                title="Go to row in Google Sheet">
                                            ${match.google_row}
                                        </button>
                                    </td>
                                    <td title="${searchingWeekdaysTooltip}" style="white-space:normal;"><strong>${searchingWeekdays}</strong></td>
                                    <td><strong>${match.brand}</strong>${linkedBrandDisplay}</td>
                                    <td title="${searchingCategories.tooltip}" style="white-space:normal;">${searchingCategories.display}</td>
                                    <td><strong>${match.discount !== null && match.discount !== '' ? match.discount + '%' : '-'}</strong></td>
                                    <td>${match.vendor_contrib !== null && match.vendor_contrib !== '' ? match.vendor_contrib + '%' : '-'}</td>
                                    <td title="${match.deal_info || ''}">${(match.deal_info || '-').substring(0, 20)}${(match.deal_info || '').length > 20 ? '...' : ''}</td>
                                    <td title="${match.special_notes || ''}">${(match.special_notes || '-').substring(0, 20)}${(match.special_notes || '').length > 20 ? '...' : ''}</td>
                                    <td title="${formatLocationsVertical(match.locations)}">${(match.locations || '-').substring(0, 25)}${(match.locations || '').length > 25 ? '...' : ''}</td>
                                    <td>
                                        <div class="more-info-container" style="position:relative; display:inline-block;">
                                            <button class="btn btn-sm btn-outline-info py-0 px-2" 
                                                    onclick="showMoreInfoPopup(this, 'sheet', ${rowIdx})"
                                                    onmouseenter="showMoreInfoPopup(this, 'sheet', ${rowIdx})"
                                                    title="View all Google Sheet fields">
                                                Info
                                            </button>
                                        </div>
                                        <button class="btn btn-sm btn-success py-0 px-2 ms-1" 
                                            onclick="useUnifiedPreFlightForIDMatcher(${rowIdx})"
                                            title="Create new deal in MIS based on this Google Sheet data">
                                            Create
                                        </button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            // v12.24.6: Helper function to determine End Date button color based on month comparison
            // RED = past month (expired), GREEN = current month, ORANGE = future month
            const getEndDateButtonColor = (endDateStr) => {
                const tabInfo = parseTabMonthYear(currentTabName);
                if (tabInfo.month < 0 || tabInfo.year < 0) {
                    // Cannot parse tab name - use PURPLE as "unknown" indicator
                    return { 
                        btnClass: 'btn-secondary', 
                        style: 'background:#6c757d; border-color:#6c757d; color:white;',
                        tooltip: 'Cannot determine month from tab name: ' + currentTabName
                    };
                }
                
                const parsedEnd = parseDate(endDateStr);
                if (!parsedEnd) {
                    // Cannot parse date - use GRAY as "invalid" indicator
                    return { 
                        btnClass: 'btn-secondary', 
                        style: 'background:#6c757d; border-color:#6c757d; color:white;',
                        tooltip: 'Invalid date format: ' + endDateStr
                    };
                }
                
                // Compare year and month
                const tabYearMonth = tabInfo.year * 12 + tabInfo.month;
                const endYearMonth = parsedEnd.year * 12 + parsedEnd.month;
                
                if (endYearMonth < tabYearMonth) {
                    // End date is in a PAST month - RED (expired/needs update)
                    return { 
                        btnClass: 'btn-danger', 
                        style: 'background:#dc3545; border-color:#dc3545; color:white;',
                        tooltip: 'EXPIRED: End date is before ' + currentTabName + ' - needs update!'
                    };
                } else if (endYearMonth === tabYearMonth) {
                    // End date is in CURRENT month - GREEN (correct)
                    return { 
                        btnClass: 'btn-success', 
                        style: 'background:#28a745; border-color:#28a745; color:white;',
                        tooltip: 'CURRENT: End date is within ' + currentTabName
                    };
                } else {
                    // End date is in a FUTURE month - ORANGE (already extended)
                    return { 
                        btnClass: 'btn-warning', 
                        style: 'background:#fd7e14; border-color:#fd7e14; color:white;',
                        tooltip: 'FUTURE: End date extends beyond ' + currentTabName
                    };
                }
            };

            // --- v12.24.8: ASSIGNED MIS ID SECTION (supports multiple IDs, proper comparison) ---
            const assignedMisIdRaw = match.current_sheet_id ? String(match.current_sheet_id).trim() : '';
            
            // v12.24.7: Helper to clean MIS ID by stripping tag prefixes (e.g., "W1 12345" ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ "12345")
            const cleanMisId = (rawId) => {
                if (!rawId) return '';
                const str = String(rawId).trim();
                // Pattern: optional tag prefix (letters + optional digits) followed by space, then the actual ID
                // Examples: "W1 12345", "M2 67890", "S1 11111", "12345" (no tag)
                const tagMatch = str.match(/^([A-Za-z]+\d*)\s+(\d+)$/);
                if (tagMatch) return tagMatch[2];
                // Also try: just extract the last numeric sequence
                const numMatch = str.match(/(\d+)\s*$/);
                if (numMatch) return numMatch[1];
                return str;
            };
            
            // v12.24.8: Extract tag from raw MIS ID (e.g., "W1 12345" ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ "W1")
            const extractTag = (rawId) => {
                if (!rawId) return '';
                const str = String(rawId).trim();
                const tagMatch = str.match(/^([A-Za-z]+\d*)\s+\d+$/);
                return tagMatch ? tagMatch[1] : '';
            };
            
            // v12.24.8: Parse multiple MIS IDs from cell (line-separated or tag-detected)
            // v12.25.2: Added STIIIZY ignore logic
            const parseMultipleMisIds = (rawValue) => {
                if (!rawValue) return [];
                const str = String(rawValue).trim();
                
                // v12.25.2: Ignore known notes/non-ID text
                const ignorePhrases = [
                    'stiiizy monthly + weekly deal planner',
                    'stiiizy monthly+ weekly deal planner',
                    'stiiizy monthly and weekly deal planner',
                    'deal planner'
                ];
                const lowerStr = str.toLowerCase();
                // Check if entire string is just a note to ignore
                if (ignorePhrases.some(phrase => lowerStr === phrase || lowerStr.includes(phrase) && !/\d/.test(str))) {
                    return [];
                }
                
                // Split by newlines first
                let parts = str.split(/\n|\r\n|\r/).map(p => p.trim()).filter(p => p);
                // If only one part, check if it contains multiple tagged IDs (space-separated tags)
                if (parts.length === 1) {
                    // Try to find multiple tagged IDs like "W1 12345 W2 67890"
                    const multiTagMatch = str.match(/([A-Za-z]+\d*\s+\d+)/g);
                    if (multiTagMatch && multiTagMatch.length > 1) {
                        parts = multiTagMatch;
                    }
                }
                
                // v12.25.2: Filter out parts that are just notes (no digits)
                return parts.filter(p => {
                    const lower = p.toLowerCase();
                    if (ignorePhrases.some(phrase => lower.includes(phrase))) return false;
                    if (!/\d/.test(p)) return false;
                    return true;
                });
            };
            
            // v12.24.8: Enhanced comparison helpers
            // Weekday comparison - GREEN if MIS weekdays contain the Google Sheet weekday(s)
            const getWeekdayMatchStyle = (sheetWeekday, misWeekdays) => {
                if (!sheetWeekday || sheetWeekday === '-') return '';
                if (!misWeekdays || misWeekdays === '-' || misWeekdays === 'N/A') return 'background:#fff3cd; color:#856404;';
                
                // Normalize both to lowercase arrays of 3-letter codes
                const normalize = (str) => {
                    const days = ['mon','tue','wed','thu','fri','sat','sun'];
                    const lower = String(str).toLowerCase();
                    return days.filter(d => lower.includes(d));
                };
                
                // Get sheet weekdays (may be from multi-day group)
                let sheetDays = [];
                if (match.multi_day_group && match.multi_day_group.weekdays) {
                    sheetDays = match.multi_day_group.weekdays
                        .map(w => String(w).toLowerCase().substring(0,3))
                        .filter(w => w && !w.includes('missing'));
                } else {
                    sheetDays = normalize(sheetWeekday);
                }
                
                const misDays = normalize(misWeekdays);
                
                if (sheetDays.length === 0 || misDays.length === 0) return 'background:#fff3cd; color:#856404;';
                
                // Check if all sheet days are in MIS days (MIS can have more, that's OK)
                const allMatch = sheetDays.every(d => misDays.includes(d));
                return allMatch ? 'background:#d4edda; color:#155724;' : 'background:#fff3cd; color:#856404;';
            };
            
            // v12.24.8: Category comparison - handles "All", blank=All, specific lists, "All Except"
            // v12.25.0: Category comparison - SET-BASED (order independent) with NaN/blank = All
            const getCategoryMatchStyle = (sheetCategory, misCategory) => {
                const sheetCat = String(sheetCategory || '').toLowerCase().trim();
                const misCat = String(misCategory || '').toLowerCase().trim();
                
                // v12.25.0: Treat blank/empty/NaN as "All" (universal match)
                const isSheetAll = !sheetCat || sheetCat === 'all' || sheetCat === '-' || 
                                   sheetCat === 'all categories' || sheetCat.includes('all categories') ||
                                   sheetCat === 'nan' || sheetCat === 'null' || sheetCat === 'undefined';
                const isMisAll = !misCat || misCat === 'all' || misCat === '-' || 
                                 misCat === 'n/a' || misCat === 'nan' || misCat === 'all categories' ||
                                 misCat === 'null' || misCat === 'undefined';
                
                // Check for "All Except" pattern
                const sheetExceptMatch = sheetCat.match(/all\s*(?:categories\s*)?except[:\s]*(.+)/i);
                const misExceptMatch = misCat.match(/all\s*(?:categories\s*)?except[:\s]*(.+)/i);
                
                // Both are "All" - GREEN
                if (isSheetAll && isMisAll) return 'background:#d4edda; color:#155724;';
                
                // Sheet is "All Except X" - compare exclusions as sets
                if (sheetExceptMatch) {
                    if (misExceptMatch) {
                        const sheetExcepts = new Set(sheetExceptMatch[1].split(',').map(s => s.trim().toLowerCase()).filter(s => s));
                        const misExcepts = new Set(misExceptMatch[1].split(',').map(s => s.trim().toLowerCase()).filter(s => s));
                        // Set equality check
                        const setsEqual = sheetExcepts.size === misExcepts.size && 
                                         [...sheetExcepts].every(x => misExcepts.has(x));
                        return setsEqual ? 'background:#d4edda; color:#155724;' : 'background:#fff3cd; color:#856404;';
                    }
                    return 'background:#fff3cd; color:#856404;';
                }
                
                // One is All, other is specific - YELLOW (mismatch)
                if (isSheetAll !== isMisAll) return 'background:#fff3cd; color:#856404;';
                
                // v12.25.0: Both are specific lists - SET-BASED comparison (order independent)
                const sheetSet = new Set(sheetCat.split(',').map(s => s.trim().toLowerCase()).filter(s => s));
                const misSet = new Set(misCat.split(',').map(s => s.trim().toLowerCase()).filter(s => s));
                
                // Set equality: same size and all elements match
                const setsEqual = sheetSet.size === misSet.size && [...sheetSet].every(x => misSet.has(x));
                return setsEqual ? 'background:#d4edda; color:#155724;' : 'background:#fff3cd; color:#856404;';
            };
            
            // v12.25.0: Location comparison - SET-BASED (order independent) with NaN/blank = All
            const getLocationMatchStyle = (sheetLocations, misLocations) => {
                const sheetLoc = String(sheetLocations || '').toLowerCase().trim();
                const misLoc = String(misLocations || '').toLowerCase().trim();
                
                // v12.25.0: Treat blank/empty/NaN as "All" (universal match)
                const isSheetAll = !sheetLoc || sheetLoc === 'all' || sheetLoc === '-' || 
                                   sheetLoc === 'all locations' || sheetLoc.includes('all locations') ||
                                   sheetLoc === 'nan' || sheetLoc === 'null' || sheetLoc === 'undefined';
                const isMisAll = !misLoc || misLoc === 'all' || misLoc === '-' || 
                                 misLoc === 'n/a' || misLoc === 'nan' || misLoc === 'all locations' ||
                                 misLoc === 'null' || misLoc === 'undefined';
                
                // Check for "All Except" pattern
                const sheetExceptMatch = sheetLoc.match(/all\s*(?:locations\s*)?except[:\s]*(.+)/i);
                const misExceptMatch = misLoc.match(/all\s*(?:locations\s*)?except[:\s]*(.+)/i);
                
                // Both are "All" - GREEN
                if (isSheetAll && isMisAll) return 'background:#d4edda; color:#155724;';
                
                // Sheet is "All Except X" - compare exclusions as sets
                if (sheetExceptMatch) {
                    if (misExceptMatch) {
                        const sheetExcepts = new Set(sheetExceptMatch[1].split(',').map(s => s.trim().toLowerCase()).filter(s => s));
                        const misExcepts = new Set(misExceptMatch[1].split(',').map(s => s.trim().toLowerCase()).filter(s => s));
                        const setsEqual = sheetExcepts.size === misExcepts.size && 
                                         [...sheetExcepts].every(x => misExcepts.has(x));
                        return setsEqual ? 'background:#d4edda; color:#155724;' : 'background:#fff3cd; color:#856404;';
                    }
                    return 'background:#fff3cd; color:#856404;';
                }
                
                // One is All, other is specific - YELLOW (mismatch)
                if (isSheetAll !== isMisAll) return 'background:#fff3cd; color:#856404;';
                
                // v12.25.0: Both are specific lists - SET-BASED comparison (order independent)
                const sheetSet = new Set(sheetLoc.split(',').map(s => s.trim().toLowerCase()).filter(s => s));
                const misSet = new Set(misLoc.split(',').map(s => s.trim().toLowerCase()).filter(s => s));
                
                // Set equality: same size and all elements match
                const setsEqual = sheetSet.size === misSet.size && [...sheetSet].every(x => misSet.has(x));
                return setsEqual ? 'background:#d4edda; color:#155724;' : 'background:#fff3cd; color:#856404;';
            };
            
            // v12.24.8: Parse multiple assigned MIS IDs
            const assignedMisIds = parseMultipleMisIds(assignedMisIdRaw);
            
            if (assignedMisIds.length > 0) {
                html += `
                    <div style="margin-bottom:20px;">
                        <h6 style="color:#198754; margin-bottom:10px; border-bottom:2px solid #198754; padding-bottom:5px;">
                            ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Currently Assigned in Google Sheet
                            ${assignedMisIds.length > 1 ? '<small style="color:#6c757d; font-weight:normal;"> (' + assignedMisIds.length + ' IDs)</small>' : ''}
                        </h6>
                        <div style="overflow-x:auto;">
                            <table class="table table-sm table-bordered" style="font-size:0.85em; white-space:nowrap; border:2px solid #198754;">
                                <thead style="background:#d4edda;">
                                    <tr>
                                        <th>Status</th>
                                        <th>MIS ID</th>
                                        <th>Weekday</th>
                                        <th>Brand / Linked</th>
                                        <th>Category</th>
                                        <th>Discount</th>
                                        <th>Vendor %</th>
                                        <th>Locations</th>
                                        <th>Start Date</th>
                                        <th>End Date</th>
                                        <th>More Info</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody>
                `;
                
                // v12.24.8: Render each assigned MIS ID as its own row
                assignedMisIds.forEach((rawId, aIdx) => {
                    const cleanId = cleanMisId(rawId);
                    const tag = extractTag(rawId);
                    const assignedSuggestion = match.suggestions.find(s => String(s.mis_id) === cleanId);
                    
                    if (assignedSuggestion) {
                        // We have full data for the assigned ID
                        const aData = assignedSuggestion.mis_data;
                        const aLinkedBrand = aData.linked_brand && aData.linked_brand !== 'N/A' ? aData.linked_brand : '';
                        const aWeekday = aData.weekdays && aData.weekdays !== 'N/A' ? aData.weekdays : '-';
                        const aCategory = aData.category && aData.category !== 'N/A' && aData.category !== '-' && aData.category !== 'nan' ? aData.category : '';
                        const aDiscount = aData.discount !== null && aData.discount !== undefined ? aData.discount : '-';
                        const aVendor = aData.vendor_contribution !== null && aData.vendor_contribution !== undefined ? aData.vendor_contribution : '-';
                        const aLocations = aData.locations || '';
                        const aStartDate = aData.start_date && aData.start_date !== 'N/A' ? aData.start_date : '-';
                        const aEndDate = aData.end_date && aData.end_date !== 'N/A' ? aData.end_date : '-';
                        
                        // v12.24.8: Get end date button color with proper styling
                        const endDateColor = getEndDateButtonColor(aEndDate);
                        const endBtnStyle = endDateColor.style || 'background:#6c757d; border-color:#6c757d; color:white;';
                        
                        // Format weekday/category for display
                        const aWeekdayParts = aWeekday.split(',').map(w => w.trim()).filter(w => w && w !== '-');
                        const aWeekdayDisplay = aWeekdayParts.length > 0 ? aWeekdayParts.join('<br>') : '-';
                        const aWeekdayTooltip = aWeekdayParts.length > 0 ? aWeekdayParts.join('&#10;') : '-';
                        const aCategoryDisplay = aCategory || 'All Categories';
                        const aCategoryParts = aCategoryDisplay.split(',').map(c => c.trim()).filter(c => c);
                        const aCategoryDisplayShort = aCategoryParts.slice(0, 3).join('<br>') + (aCategoryParts.length > 3 ? '<br>...' : '');
                        const aCategoryTooltip = aCategoryParts.join('&#10;');
                        const aLocationsDisplay = aLocations || 'All Locations';
                        
                        // v12.24.8: Enhanced color coding for all comparable fields
                        const weekdayStyle = getWeekdayMatchStyle(match.weekday, aWeekday);
                        const brandStyle = getBrandMatchStyle(match.brand, aData.brand);
                        const categoryStyle = getCategoryMatchStyle(match.categories, aCategory);
                        const discountStyle = getMatchStyle(match.discount, aDiscount, true);
                        const vendorStyle = getMatchStyle(match.vendor_contrib, aVendor, true);
                        const locationStyle = getLocationMatchStyle(match.locations, aLocations);
                        
                        html += `
                            <tr style="background:#e8f5e9;">
                                <td style="text-align:center; background:#d4edda;">
                                    <span style="color:#198754; font-weight:bold;">ASSIGNED</span>
                                    ${tag ? '<br><small style="color:#6c757d;">(' + tag + ')</small>' : ''}
                                </td>
                                <td>
                                    <button class="btn btn-sm btn-success py-0 px-2" 
                                            onclick="lookupMisIdWithValidation(this, '${cleanId}')" 
                                            style="font-weight:bold;" 
                                            title="Click to lookup in MIS">
                                        ${cleanId}
                                    </button>
                                </td>
                                <td title="${aWeekdayTooltip}" style="${weekdayStyle} white-space:normal;">${aWeekdayDisplay}</td>
                                <td style="${brandStyle}">
                                    <strong>${aData.brand || '-'}</strong>
                                    ${aLinkedBrand ? '<br><small style="color:#6c757d;">' + aLinkedBrand + '</small>' : ''}
                                </td>
                                <td title="${aCategoryTooltip}" style="${categoryStyle} white-space:normal;">${aCategoryDisplayShort}</td>
                                <td style="${discountStyle}"><strong>${aDiscount}%</strong></td>
                                <td style="${vendorStyle}">${aVendor}%</td>
                                <td title="${formatLocationsVertical(aLocationsDisplay)}" style="${locationStyle}">${aLocationsDisplay.substring(0, 20)}${aLocationsDisplay.length > 20 ? '...' : ''}</td>
                                <td>${aStartDate}</td>
                                <td title="${endDateColor.tooltip}">
                                    <div id="end-date-display-assigned-${aIdx}">
                                        <button class="btn btn-sm py-0 px-1" 
                                                style="${endBtnStyle}"
                                                onclick="showEndDateEditor('assigned', ${aIdx}, '${cleanId}', '${aEndDate}')"
                                                title="${endDateColor.tooltip}">
                                            ${aEndDate}
                                        </button>
                                    </div>
                                    <div id="end-date-editor-assigned-${aIdx}" style="display:none;">
                                        <div style="display:flex; gap:2px; align-items:center; flex-wrap:wrap;">
                                            <select id="end-month-assigned-${aIdx}" class="form-select form-select-sm" style="width:60px; padding:2px;">
                                                <option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>
                                                <option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>
                                                <option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>
                                                <option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>
                                            </select>
                                            <select id="end-day-assigned-${aIdx}" class="form-select form-select-sm" style="width:55px; padding:2px;"></select>
                                            <select id="end-year-assigned-${aIdx}" class="form-select form-select-sm" style="width:70px; padding:2px;"></select>
                                            <button class="btn btn-sm btn-success py-0 px-2" onclick="updateMisEndDate('assigned', ${aIdx}, '${cleanId}')">Update</button>
                                            <button class="btn btn-sm btn-secondary py-0 px-1" onclick="cancelEndDateEditor('assigned', ${aIdx})">ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¢</button>
                                        </div>
                                    </div>
                                </td>
                                <td>
                                    <button class="btn btn-sm btn-outline-info py-0 px-2" 
                                            onclick="lookupMisIdWithValidation(this, '${cleanId}')"
                                            title="View full details in MIS">
                                        View
                                    </button>
                                </td>
                                <td>
                                    <span class="badge bg-success">Current</span>
                                </td>
                            </tr>
                        `;
                    } else {
                        // Assigned ID not found in suggestions - show minimal info
                        html += `
                            <tr style="background:#e8f5e9;">
                                <td style="text-align:center; background:#d4edda;">
                                    <span style="color:#198754; font-weight:bold;">ASSIGNED</span>
                                    ${tag ? '<br><small style="color:#6c757d;">(' + tag + ')</small>' : ''}
                                </td>
                                <td>
                                    <button class="btn btn-sm btn-success py-0 px-2" 
                                            onclick="lookupMisIdWithValidation(this, '${cleanId}')" 
                                            style="font-weight:bold;" 
                                            title="Click to lookup in MIS">
                                        ${cleanId}
                                    </button>
                                </td>
                                <td colspan="8" style="text-align:center; color:#6c757d; font-style:italic;">
                                    MIS ID not found in current CSV data - click ID to view in MIS
                                </td>
                                <td>
                                    <button class="btn btn-sm btn-outline-info py-0 px-2" 
                                            onclick="lookupMisIdWithValidation(this, '${cleanId}')"
                                            title="View full details in MIS">
                                        View
                                    </button>
                                </td>
                                <td>
                                    <span class="badge bg-success">Current</span>
                                </td>
                            </tr>
                        `;
                    }
                });
                
                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            }

            // --- SUGGESTIONS SECTION ---
            html += `
                <div>
                    <h6 style="color:#495057; margin-bottom:10px; border-bottom:1px solid #dee2e6; padding-bottom:5px;">
                        Suggested Matches from MIS CSV <small class="text-muted">(${match.suggestions.length} found)</small>
                    </h6>
                    <div style="overflow-x:auto;">
                        <table class="table table-sm table-bordered table-hover" style="font-size:0.85em; white-space:nowrap;">
                            <thead class="table-light">
                                <tr>
                                    <th>Conf.</th>
                                    <th>MIS ID</th>
                                    <th>Weekday</th>
                                    <th>Brand / Linked</th>
                                    <th>Category</th>
                                    <th>Discount</th>
                                    <th>Vendor %</th>
                                    <th>Locations</th>
                                    <th>Start Date</th>
                                    <th>End Date</th>
                                    <th>More Info</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
            `;

            match.suggestions.forEach((s, sIdx) => {
                // Confidence color
                const confColor = s.confidence >= 90 ? '#28a745' : (s.confidence >= 70 ? '#ffc107' : '#dc3545');
                const confBg = s.confidence >= 90 ? '#d4edda' : (s.confidence >= 70 ? '#fff3cd' : '#f8d7da');
                
                // Get values from suggestion
                const sLinkedBrand = s.mis_data.linked_brand && s.mis_data.linked_brand !== 'N/A' ? s.mis_data.linked_brand : '';
                const sWeekday = s.mis_data.weekdays && s.mis_data.weekdays !== 'N/A' ? s.mis_data.weekdays : '-';
                const sCategory = s.mis_data.category && s.mis_data.category !== 'N/A' && s.mis_data.category !== '-' && s.mis_data.category !== 'nan' ? s.mis_data.category : 'All Categories';
                const sDiscount = s.mis_data.discount !== null && s.mis_data.discount !== undefined ? s.mis_data.discount : '-';
                const sVendor = s.mis_data.vendor_contribution !== null && s.mis_data.vendor_contribution !== undefined ? s.mis_data.vendor_contribution : '-';
                const sLocations = s.mis_data.locations || '-';
                const sLocationsVertical = formatLocationsVertical(sLocations);
                const sStartDate = s.mis_data.start_date && s.mis_data.start_date !== 'N/A' ? s.mis_data.start_date : '-';
                const sEndDate = s.mis_data.end_date && s.mis_data.end_date !== 'N/A' ? s.mis_data.end_date : '-';
                
                // v12.1: Format weekday vertically with tooltip
                const sWeekdayParts = sWeekday.split(',').map(w => w.trim()).filter(w => w && w !== '-');
                const sWeekdayDisplay = sWeekdayParts.length > 0 ? sWeekdayParts.join('<br>') : '-';
                const sWeekdayTooltip = sWeekdayParts.length > 0 ? sWeekdayParts.join('&#10;') : '-';
                
                // v12.1: Format category vertically with tooltip
                const sCategoryParts = sCategory === 'All Categories' ? ['All Categories'] : sCategory.split(',').map(c => c.trim()).filter(c => c);
                const sCategoryDisplay = sCategoryParts.slice(0, 3).join('<br>') + (sCategoryParts.length > 3 ? '<br>...' : '');
                const sCategoryTooltip = sCategoryParts.join('&#10;');
                
                // v12.24.8: Enhanced color coding for all comparable fields
                const weekdayStyle = getWeekdayMatchStyle(match.weekday, sWeekday);
                const brandStyle = getBrandMatchStyle(match.brand, s.mis_data.brand);
                const categoryStyle = getCategoryMatchStyle(match.categories, s.mis_data.category);
                const discountStyle = getMatchStyle(match.discount, sDiscount, true);
                const vendorStyle = getMatchStyle(match.vendor_contrib, sVendor, true);
                const locationStyle = getLocationMatchStyle(match.locations, sLocations);
                
                // v12.1: Check Continue/Recycle eligibility
                const continueCheck = checkContinueEligibility(match, s, match.section || 'weekly');
                
                // v12.1: Build Continue/New Entry indicator
                let continueIndicator = '';
                let endDateStyle = '';
                let endDateTooltip = sEndDate;
                
                if (continueCheck.isContinue) {
                    if (continueCheck.needsManualReview) {
                        continueIndicator = '<br><span style="color:#856404; font-size:0.75em; font-weight:bold;">CONTINUE*</span>';
                        endDateStyle = 'background:#fff3cd; font-weight:bold;';
                        endDateTooltip = 'MANUAL REVIEW NEEDED: End date (' + sEndDate + ') is already within target month. Verify if extension to ' + continueCheck.newEndDate + ' is needed.';
                    } else {
                        continueIndicator = '<br><span style="color:#155724; font-size:0.75em; font-weight:bold;">CONTINUE</span>';
                        endDateStyle = 'background:#fff3cd; font-weight:bold;';
                        endDateTooltip = 'UPDATE END DATE: Change from ' + sEndDate + ' to ' + continueCheck.newEndDate + ' (last day of ' + currentTabName + ')';
                    }
                    // v12.1: Add warning if MIS needs linked brand
                    if (continueCheck.needsLinkedBrand) {
                        continueIndicator += '<br><span style="color:#856404; font-size:0.65em; background:#fff3cd; padding:1px 3px; border-radius:2px;" title="Google Sheet has Linked Brand but MIS entry does not">ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â Needs Linked Brand</span>';
                    }
                } else {
                    // Not a Continue - show as NEW ENTRY
                    if (continueCheck.cannotDetermineDate) {
                        // Can't determine Continue status due to unparseable tab name
                        continueIndicator = '<br><span style="color:#856404; font-size:0.75em; font-weight:bold; background:#fff3cd; padding:1px 3px; border-radius:2px;" title="Cannot determine Continue eligibility - tab name could not be parsed for date">? UNDETERMINED</span>';
                        if (continueCheck.mismatches.length > 0) {
                            continueIndicator += '<br><span style="color:#dc3545; font-size:0.65em;">Diff: ' + continueCheck.mismatches.join(', ') + '</span>';
                        }
                    } else {
                        continueIndicator = '<br><span style="color:#721c24; font-size:0.75em; font-weight:bold;">NEW ENTRY</span>';
                        if (continueCheck.mismatches.length > 0) {
                            continueIndicator += '<br><span style="color:#dc3545; font-size:0.65em;">Diff: ' + continueCheck.mismatches.join(', ') + '</span>';
                        }
                    }
                    // v12.1: Also show needs linked brand warning for NEW ENTRY
                    if (continueCheck.needsLinkedBrand) {
                        continueIndicator += '<br><span style="color:#856404; font-size:0.65em; background:#fff3cd; padding:1px 3px; border-radius:2px;" title="Google Sheet has Linked Brand but MIS entry does not">ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â Needs Linked Brand</span>';
                    }
                }
                
                const rawCsvDataJson = s.mis_data.raw_csv_data ? escapeForAttr(JSON.stringify(s.mis_data.raw_csv_data)) : '{}';
                
                // v12.24.8: Get end date button color with fallback styling
                const suggEndDateColor = getEndDateButtonColor(sEndDate);
                const suggEndBtnStyle = suggEndDateColor.style || 'background:#6c757d; border-color:#6c757d; color:white;';
                
                html += `
                    <tr>
                        <td style="background:${confBg}; text-align:center;">
                            <span style="color:${confColor}; font-weight:bold;">${s.confidence}%</span>
                            ${continueIndicator}
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-secondary py-0 px-2" 
                                    onclick="lookupMisIdWithValidation(this, '${s.mis_id}')" 
                                    style="font-weight:bold;" 
                                    title="Click to lookup in MIS">
                                ${s.mis_id}
                            </button>
                        </td>
                        <td title="${sWeekdayTooltip}" style="${weekdayStyle} white-space:normal;">${sWeekdayDisplay}</td>
                        <td style="${brandStyle}">
                            <strong>${s.mis_data.brand}</strong>
                            ${sLinkedBrand ? '<br><small style="color:#6c757d;">' + sLinkedBrand + '</small>' : ''}
                        </td>
                        <td title="${sCategoryTooltip}" style="${categoryStyle} white-space:normal;">${sCategoryDisplay}</td>
                        <td style="${discountStyle}"><strong>${sDiscount}%</strong></td>
                        <td style="${vendorStyle}">${sVendor}%</td>
                        <td title="${sLocationsVertical}" style="${locationStyle}">${sLocations.substring(0, 20)}${sLocations.length > 20 ? '...' : ''}</td>
                        <td>${sStartDate}</td>
                        <td style="${endDateStyle}" title="${endDateTooltip}">
                            <div id="end-date-display-${rowIdx}-${sIdx}">
                                <button class="btn btn-sm py-0 px-1" 
                                        style="${suggEndBtnStyle}"
                                        onclick="showEndDateEditor(${rowIdx}, ${sIdx}, '${s.mis_id}', '${sEndDate}')"
                                        title="${suggEndDateColor.tooltip}">
                                    ${sEndDate}
                                </button>
                            </div>
                            <div id="end-date-editor-${rowIdx}-${sIdx}" style="display:none;">
                                <div style="display:flex; gap:2px; align-items:center; flex-wrap:wrap;">
                                    <select id="end-month-${rowIdx}-${sIdx}" class="form-select form-select-sm" style="width:60px; padding:2px;">
                                        <option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>
                                        <option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>
                                        <option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>
                                        <option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>
                                    </select>
                                    <select id="end-day-${rowIdx}-${sIdx}" class="form-select form-select-sm" style="width:55px; padding:2px;"></select>
                                    <select id="end-year-${rowIdx}-${sIdx}" class="form-select form-select-sm" style="width:70px; padding:2px;"></select>
                                    <button class="btn btn-sm btn-success py-0 px-2" onclick="updateMisEndDate(${rowIdx}, ${sIdx}, '${s.mis_id}')">Update</button>
                                    <button class="btn btn-sm btn-secondary py-0 px-1" onclick="cancelEndDateEditor(${rowIdx}, ${sIdx})">ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¢</button>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="more-info-container" style="position:relative; display:inline-block;">
                                <button class="btn btn-sm btn-outline-info py-0 px-2" 
                                        onclick="showMoreInfoPopup(this, 'csv', ${rowIdx}, ${sIdx})"
                                        onmouseenter="showMoreInfoPopup(this, 'csv', ${rowIdx}, ${sIdx})"
                                        title="View all MIS CSV fields">
                                    Info
                                </button>
                            </div>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-primary" 
                                onclick="applySuggestionFromModal(${rowIdx}, '${s.mis_id}')">
                                Select
                            </button>
                        </td>
                    </tr>
                `;
            });

            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div style="margin-top:15px; padding-top:10px; border-top:1px solid #dee2e6; text-align:right;">
                    <small class="text-muted">Field Match: </small>
                    <span class="badge" style="background:#d4edda; color:#155724;">Match</span>
                    <span class="badge" style="background:#fff3cd; color:#856404;">Partial/Missing</span>
                    <span class="badge" style="background:#f8d7da; color:#721c24;">Mismatch</span>
                    <span style="margin-left:15px;"></span>
                    <small class="text-muted">End Date: </small>
                    <span class="badge" style="background:#dc3545; color:white;">Past Month</span>
                    <span class="badge" style="background:#28a745; color:white;">Current Month</span>
                    <span class="badge" style="background:#fd7e14; color:white;">Future Month</span>
                </div>
            `;
            
            modal.innerHTML = html;
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }
        
        // v12.2: End Date Editor functions for updating MIS end dates
        function showEndDateEditor(rowIdx, sIdx, misId, currentEndDate) {
            // Hide display, show editor
            const displayEl = document.getElementById(`end-date-display-${rowIdx}-${sIdx}`);
            const editorEl = document.getElementById(`end-date-editor-${rowIdx}-${sIdx}`);
            if (displayEl) displayEl.style.display = 'none';
            if (editorEl) editorEl.style.display = 'block';
            
            // Calculate default end date (last day of month from tab name)
            const defaultDate = calculateDefaultEndDate();
            
            // Populate dropdowns
            const monthSelect = document.getElementById(`end-month-${rowIdx}-${sIdx}`);
            const daySelect = document.getElementById(`end-day-${rowIdx}-${sIdx}`);
            const yearSelect = document.getElementById(`end-year-${rowIdx}-${sIdx}`);
            
            // Populate year dropdown (current year and next 2 years)
            const currentYear = new Date().getFullYear();
            yearSelect.innerHTML = '';
            for (let y = currentYear; y <= currentYear + 2; y++) {
                const opt = document.createElement('option');
                opt.value = y;
                opt.textContent = y;
                yearSelect.appendChild(opt);
            }
            
            // Set default values
            if (defaultDate) {
                monthSelect.value = defaultDate.month;
                yearSelect.value = defaultDate.year;
                updateDayDropdown(rowIdx, sIdx);
                daySelect.value = defaultDate.day;
            } else {
                // Fallback: try to parse current end date
                const parsed = parseEndDateString(currentEndDate);
                if (parsed) {
                    monthSelect.value = parsed.month;
                    yearSelect.value = parsed.year;
                    updateDayDropdown(rowIdx, sIdx);
                    daySelect.value = parsed.day;
                } else {
                    updateDayDropdown(rowIdx, sIdx);
                }
            }
            
            // Add change listeners to update day dropdown when month/year changes
            monthSelect.onchange = () => updateDayDropdown(rowIdx, sIdx);
            yearSelect.onchange = () => updateDayDropdown(rowIdx, sIdx);
        }
        
        function cancelEndDateEditor(rowIdx, sIdx) {
            const displayEl = document.getElementById(`end-date-display-${rowIdx}-${sIdx}`);
            const editorEl = document.getElementById(`end-date-editor-${rowIdx}-${sIdx}`);
            if (displayEl) displayEl.style.display = 'block';
            if (editorEl) editorEl.style.display = 'none';
        }
        
        function updateDayDropdown(rowIdx, sIdx) {
            const monthSelect = document.getElementById(`end-month-${rowIdx}-${sIdx}`);
            const daySelect = document.getElementById(`end-day-${rowIdx}-${sIdx}`);
            const yearSelect = document.getElementById(`end-year-${rowIdx}-${sIdx}`);
            
            if (!monthSelect || !daySelect || !yearSelect) return;
            
            const month = parseInt(monthSelect.value);
            const year = parseInt(yearSelect.value);
            const daysInMonth = new Date(year, month, 0).getDate();
            
            const currentDay = daySelect.value;
            daySelect.innerHTML = '';
            
            for (let d = 1; d <= daysInMonth; d++) {
                const opt = document.createElement('option');
                opt.value = String(d).padStart(2, '0');
                opt.textContent = d;
                daySelect.appendChild(opt);
            }
            
            // Try to restore previous selection or default to last day
            if (currentDay && parseInt(currentDay) <= daysInMonth) {
                daySelect.value = currentDay;
            } else {
                daySelect.value = String(daysInMonth).padStart(2, '0');
            }
        }
        
        function calculateDefaultEndDate() {
            // Get tab name and calculate last day of that month
            const currentTabName = document.getElementById('mis-tab')?.value || '';
            if (!currentTabName) return null;
            
            // Parse tab name for month/year (reuse logic from checkContinueEligibility)
            const tabInfo = parseTabMonthYear(currentTabName);
            if (tabInfo.month < 0 || tabInfo.year < 0) return null;
            
            // Calculate last day of month
            const lastDay = getLastDayOfMonth(tabInfo.year, tabInfo.month);
            
            return {
                month: String(tabInfo.month + 1).padStart(2, '0'), // Convert 0-indexed to 1-indexed
                day: String(lastDay).padStart(2, '0'),
                year: String(tabInfo.year)
            };
        }
        
        function parseEndDateString(dateStr) {
            if (!dateStr || dateStr === '-' || dateStr === 'N/A') return null;
            
            // Try MM/DD/YYYY or MM/DD/YY format
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                let year = parts[2];
                if (year.length === 2) {
                    year = '20' + year;
                }
                return {
                    month: parts[0].padStart(2, '0'),
                    day: parts[1].padStart(2, '0'),
                    year: year
                };
            }
            return null;
        }
        
        // v12.22.3: Fixed updateMisEndDate to use working automateEndDate endpoint
        async function updateMisEndDate(rowIdx, sIdx, misId) {
            const monthSelect = document.getElementById(`end-month-${rowIdx}-${sIdx}`);
            const daySelect = document.getElementById(`end-day-${rowIdx}-${sIdx}`);
            const yearSelect = document.getElementById(`end-year-${rowIdx}-${sIdx}`);
            
            if (!monthSelect || !daySelect || !yearSelect) {
                alert('Date selectors not found');
                return;
            }
            
            const month = monthSelect.value;
            const day = daySelect.value;
            const year = yearSelect.value; // Full year for working endpoint
            
            // Format as MM/DD/YYYY for the working endpoint
            const newEndDate = `${month}/${day}/${year}`;
            
            console.log('[UPDATE-END-DATE] Starting with date:', newEndDate, 'MIS ID:', misId);
            
            // Get googleRow from matchesData if available
            const match = matchesData[rowIdx];
            const googleRow = match ? match.google_row : null;
            
            // Show loading overlay (same style as working automateEndDate)
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'automate-loading';
            loadingOverlay.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:10003; display:flex; justify-content:center; align-items:center; flex-direction:column;';
            loadingOverlay.innerHTML = '<div class="spinner-border text-light" style="width:3rem; height:3rem;"></div><div style="color:white; margin-top:15px; font-size:1.2em;">Updating End Date in MIS...</div><div id="automate-status" style="color:#aaa; margin-top:10px; font-size:0.9em;">Opening MIS entry ' + misId + '...</div>';
            document.body.appendChild(loadingOverlay);
            
            try {
                // Use the WORKING endpoint from automateEndDate
                const response = await fetch('/api/mis/automate-end-date', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mis_id: misId,
                        new_end_date: newEndDate,
                        google_row: googleRow,
                        split_idx: null,  // Not from splits, from suggestions
                        step_idx: null
                    })
                });
                
                const data = await response.json();
                document.getElementById('automate-loading')?.remove();
                
                if (data.success) {
                    // Update the display in the Suggestions popup
                    const displayEl = document.getElementById(`end-date-display-${rowIdx}-${sIdx}`);
                    if (displayEl) {
                        displayEl.innerHTML = `<span style="color:#155724; font-weight:bold;">ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ ${newEndDate}</span>`;
                    }
                    
                    // Hide the editor
                    const editorEl = document.getElementById(`end-date-editor-${rowIdx}-${sIdx}`);
                    if (editorEl) {
                        editorEl.style.display = 'none';
                    }
                    
                    alert('ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ End Date updated to ' + newEndDate + '\\n\\nPlease review and click Save in MIS if everything looks correct.\\n\\nValidation is active - check the banner for any warnings.');
                } else {
                    alert('Error updating end date: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                document.getElementById('automate-loading')?.remove();
                alert('Error: ' + error.message);
            }
        }
        
        // ============================================
        // v12.3: CREATE DEAL IN MIS - Functions
        // ============================================
        
        // v12.21: Adapter function for ID Matcher ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ Unified Pre-Flight
        async function useUnifiedPreFlightForIDMatcher(rowIdx) {
            const match = matchesData[rowIdx];
            if (!match) {
                alert('Error: Could not find row data');
                return;
            }
            
            // Load settings dropdown data
            await loadSettingsDropdownData();
            
            // Extract values from match
            const brand = match.brand || '';
            const linkedBrand = match.linked_brand || settingsCache.brandLinkedMap[brand.toLowerCase()] || '';
            
            // v12.21.4.1: DEBUG - Log linked brand resolution
            console.log('[LINKED-BRAND-DEBUG] Brand:', brand);
            console.log('[LINKED-BRAND-DEBUG] match.linked_brand:', match.linked_brand);
            console.log('[LINKED-BRAND-DEBUG] settingsCache.brandLinkedMap:', settingsCache.brandLinkedMap);
            console.log('[LINKED-BRAND-DEBUG] Lookup result for brand.toLowerCase():', settingsCache.brandLinkedMap[brand.toLowerCase()]);
            console.log('[LINKED-BRAND-DEBUG] Final linkedBrand:', linkedBrand);
            
            // v12.22: Handle multi-day groups - collect ALL weekdays from group
            // If this row is part of a multi-day group, the Pre-Flight popup should show
            // all weekdays (e.g., "Monday, Wednesday, Friday") instead of just this row's weekday
            let weekday = match.weekday || '';
            if (match.multi_day_group && match.multi_day_group.weekdays) {
                const weekdaysList = match.multi_day_group.weekdays.filter(w => w && !w.toLowerCase().includes('missing'));
                if (weekdaysList.length > 0) {
                    weekday = weekdaysList.join(', ');
                    console.log('[MULTI-DAY-FIX] Group detected! group_id:', match.multi_day_group.group_id);
                    console.log('[MULTI-DAY-FIX] All weekdays in group:', weekdaysList);
                    console.log('[MULTI-DAY-FIX] Combined weekday string:', weekday);
                }
            } else {
                console.log('[MULTI-DAY-FIX] Single-day deal, weekday:', weekday);
            }
            
            const categories = match.categories || '';
            const locations = match.locations || '';
            // v12.21.1: Handle numeric values - convert to string before .replace()
            const discount = String(match.discount || '').replace('%', '');
            const vendorContrib = String(match.vendor_contrib || '').replace('%', '');
            
            // Determine Rebate Type from checkboxes
            // v12.21.3: Check both 'Wholesale?' and 'Wholesale' (with and without ?)
            let rebateType = '';
            const retailVal = String(
                match.retail || 
                match.raw_row_data?.['Retail?'] ||  // Google Sheet column name with ?
                match.raw_row_data?.['Retail'] ||   // Fallback without ?
                ''
            ).toUpperCase();
            const wholesaleVal = String(
                match.wholesale || 
                match.raw_row_data?.['Wholesale?'] ||  // Google Sheet column name with ?
                match.raw_row_data?.['Wholesale'] ||   // Fallback without ?
                ''
            ).toUpperCase();
            if (wholesaleVal === 'TRUE') rebateType = 'Wholesale';
            else if (retailVal === 'TRUE') rebateType = 'Retail';
            
            console.log('[REBATE-TYPE-DEBUG] retailVal:', retailVal, ', wholesaleVal:', wholesaleVal, ', result:', rebateType);
            
            // Determine After Wholesale
            const afterWholesaleVal = String(match.after_wholesale || match.raw_row_data?.['After Wholesale Discount'] || '').toUpperCase();
            const afterWholesale = afterWholesaleVal === 'TRUE';
            
            // v12.22.1: Smart Date Auto-Fill for Weekly Deals
            // For Weekly deals: Start = 1st of month, End = last day of month
            // Month/Year derived from tab name (e.g., "January 2026") or fallback to current month
            let startDate = '';
            let endDate = '';
            const sectionType = match.section_type || 'weekly';
            
            if (sectionType === 'weekly') {
                // Try to parse month/year from tab name
                const tabName = document.getElementById('mis-tab')?.value || '';
                const monthNames = ['january', 'february', 'march', 'april', 'may', 'june', 
                                   'july', 'august', 'september', 'october', 'november', 'december'];
                
                let targetMonth = -1;
                let targetYear = -1;
                
                // Parse tab name like "January 2026" or "Feb 2026"
                const tabMatch = tabName.match(/([a-zA-Z]+)\s*(\d{4})/);
                if (tabMatch) {
                    const monthStr = tabMatch[1].toLowerCase();
                    const yearStr = tabMatch[2];
                    
                    // Find month index (supports full names and 3-letter abbreviations)
                    targetMonth = monthNames.findIndex(m => m.startsWith(monthStr.substring(0, 3)));
                    targetYear = parseInt(yearStr);
                    
                    console.log('[WEEKLY-DATE-FIX] Parsed tab name:', tabName, '-> Month:', targetMonth, ', Year:', targetYear);
                }
                
                // Fallback to current date if parsing failed
                if (targetMonth < 0 || targetYear < 0 || isNaN(targetYear)) {
                    const now = new Date();
                    targetMonth = now.getMonth();
                    targetYear = now.getFullYear();
                    console.log('[WEEKLY-DATE-FIX] Fallback to current month:', targetMonth, ', Year:', targetYear);
                }
                
                // Calculate first and last day of month
                const firstDay = 1;
                const lastDay = new Date(targetYear, targetMonth + 1, 0).getDate(); // Day 0 of next month = last day of current month
                
                // Format as MM/DD/YYYY
                const monthNum = String(targetMonth + 1).padStart(2, '0');
                startDate = `${monthNum}/01/${targetYear}`;
                endDate = `${monthNum}/${String(lastDay).padStart(2, '0')}/${targetYear}`;
                
                console.log('[WEEKLY-DATE-FIX] Auto-filled dates for Weekly deal:');
                console.log('  Start Date:', startDate, '(1st of month)');
                console.log('  End Date:', endDate, '(last day of month)');
            } else {
                // Non-weekly deals: Parse dates from date_raw as before
                const dateRaw = match.date_raw || '';
                if (dateRaw) {
                    const rangeMatch = dateRaw.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})\s*[-\u2013\u2014]\s*(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
                    if (rangeMatch) {
                        startDate = rangeMatch[1] + '/' + rangeMatch[2] + '/' + (rangeMatch[3].length === 2 ? '20' + rangeMatch[3] : rangeMatch[3]);
                        endDate = rangeMatch[4] + '/' + rangeMatch[5] + '/' + (rangeMatch[6].length === 2 ? '20' + rangeMatch[6] : rangeMatch[6]);
                    } else {
                        const singleMatch = dateRaw.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
                        if (singleMatch) {
                            startDate = singleMatch[1] + '/' + singleMatch[2] + '/' + (singleMatch[3].length === 2 ? '20' + singleMatch[3] : singleMatch[3]);
                            endDate = startDate;
                        }
                    }
                }
                console.log('[DATE-PARSE] Non-weekly deal, parsed from date_raw:', startDate, '-', endDate);
            }
            
            // Build preFlightData object
            const preFlightData = {
                brand: brand,
                linked_brand: linkedBrand,
                weekday: weekday,
                categories: categories,
                locations: locations,
                discount: discount,
                vendor_contrib: vendorContrib,
                rebate_type: rebateType,
                after_wholesale: afterWholesale,
                start_date: startDate,
                end_date: endDate
            };
            
            console.log('[ID-MATCHER ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ PRE-FLIGHT] Converted data:', preFlightData);
            
            // Call unified Pre-Flight popup
            openUnifiedPreFlight(preFlightData, match.google_row, match.section_type || 'weekly', null, null);
        }
        
        async function showCreateDealPopup(rowIdx, context = 'id-matcher') {
            // v12.17: Enhanced Create Deal Popup with all fields
            const match = matchesData[rowIdx];
            if (!match) {
                alert('Error: Could not find row data');
                return;
            }
            
            // Load settings dropdown data
            await loadSettingsDropdownData();
            
            // Remove any existing popup
            const existingPopup = document.getElementById('create-deal-popup-overlay');
            if (existingPopup) existingPopup.remove();
            
            // Calculate default dates
            const defaultDate = calculateDefaultEndDate();
            const today = new Date();
            const todayStr = {
                month: String(today.getMonth() + 1).padStart(2, '0'),
                day: String(today.getDate()).padStart(2, '0'),
                year: String(today.getFullYear())
            };
            
            // v12.17: Parse date_raw for Sale section auto-fill
            let parsedStartDate = null;
            let parsedEndDate = null;
            const dateRaw = match.date_raw || '';
            if (dateRaw) {
                const rangeMatch = dateRaw.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})\s*[-[EMOJI]]\s*(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
                if (rangeMatch) {
                    parsedStartDate = {
                        month: rangeMatch[1].padStart(2, '0'),
                        day: rangeMatch[2].padStart(2, '0'),
                        year: rangeMatch[3].length === 2 ? '20' + rangeMatch[3] : rangeMatch[3]
                    };
                    parsedEndDate = {
                        month: rangeMatch[4].padStart(2, '0'),
                        day: rangeMatch[5].padStart(2, '0'),
                        year: rangeMatch[6].length === 2 ? '20' + rangeMatch[6] : rangeMatch[6]
                    };
                    console.log('[DATE-PARSE] Range:', dateRaw, '->', parsedStartDate, parsedEndDate);
                } else {
                    const singleMatch = dateRaw.match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
                    if (singleMatch) {
                        parsedStartDate = {
                            month: singleMatch[1].padStart(2, '0'),
                            day: singleMatch[2].padStart(2, '0'),
                            year: singleMatch[3].length === 2 ? '20' + singleMatch[3] : singleMatch[3]
                        };
                    }
                }
            }
            
            // Popup title based on context
            let popupTitle = 'Create New Deal in MIS';
            let titleColor = '#28a745';
            if (context === 'phase1-gap') {
                popupTitle = 'GAP/Interrupt Deal';
                titleColor = '#ffc107';
            } else if (context === 'phase1-continue') {
                popupTitle = 'Continue Deal';
                titleColor = '#007bff';
            }
            
            // Extract values
            const brand = match.brand || '';
            const linkedBrand = match.linked_brand || settingsCache.brandLinkedMap[brand.toLowerCase()] || '';
            const weekday = match.weekday || '';
            const categories = match.categories || '';
            const locations = match.locations || '';
            const discount = match.discount || '';
            const vendorContrib = match.vendor_contrib || '';
            const dealInfo = match.deal_info || '';
            const specialNotes = match.special_notes || '';
            const minWeight = match.min_weight || match.raw_row_data?.['Min Weight'] || '';
            const maxWeight = match.max_weight || match.raw_row_data?.['Max Weight'] || '';
            
            // Determine Rebate Type from checkboxes
            let rebateType = '';
            const retailVal = String(match.retail || match.raw_row_data?.['Retail'] || '').toUpperCase();
            const wholesaleVal = String(match.wholesale || match.raw_row_data?.['Wholesale'] || '').toUpperCase();
            if (wholesaleVal === 'TRUE') rebateType = 'Wholesale';
            else if (retailVal === 'TRUE') rebateType = 'Retail';
            
            // Determine After Wholesale
            const afterWholesaleVal = String(match.after_wholesale || match.raw_row_data?.['After Wholesale Discount'] || '').toUpperCase();
            const afterWholesale = afterWholesaleVal === 'TRUE' ? 'Yes' : 'No';
            
            // Build stores dropdown options
            let storesOptions = '';
            settingsCache.stores.forEach(store => {
                storesOptions += `<option value="${store}">${store}</option>`;
            });
            
            // Build categories dropdown options
            let categoriesOptions = '';
            settingsCache.categories.forEach(cat => {
                categoriesOptions += `<option value="${cat}">${cat}</option>`;
            });
            
            // Build linked brand dropdown options
            let linkedBrandOptions = '<option value="">-- Select --</option>';
            const uniqueLinkedBrands = [...new Set(Object.values(settingsCache.brandLinkedMap).filter(v => v))];
            uniqueLinkedBrands.sort().forEach(lb => {
                const selected = lb.toLowerCase() === linkedBrand.toLowerCase() ? 'selected' : '';
                linkedBrandOptions += `<option value="${lb}" ${selected}>${lb}</option>`;
            });
            
            // Build popup HTML
            const overlay = document.createElement('div');
            overlay.id = 'create-deal-popup-overlay';
            overlay.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:10002; display:flex; justify-content:center; align-items:center;';
            
            const popup = document.createElement('div');
            popup.style.cssText = 'background:white; border-radius:10px; padding:25px; max-width:700px; width:95%; max-height:90vh; overflow-y:auto; box-shadow:0 10px 40px rgba(0,0,0,0.3);';
            
            popup.innerHTML = `
                <h5 style="margin-bottom:15px; color:${titleColor}; border-bottom:2px solid ${titleColor}; padding-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
                    <span><i class="bi bi-plus-circle"></i> ${popupTitle}</span>
                    <button class="btn btn-sm btn-outline-secondary" onclick="loadSettingsDropdownData(true).then(() => alert('Settings refreshed!'))" title="Refresh Settings">[EMOJI]</button>
                </h5>
                
                <div class="alert alert-secondary" style="font-size:0.85em; padding:10px;">
                    <strong>Brand:</strong> ${brand} | <strong>Row:</strong> ${match.google_row} | <strong>Deal:</strong> ${dealInfo || '-'}
                    ${specialNotes ? '<br><strong>Notes:</strong> ' + specialNotes : ''}
                </div>
                
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px;">
                    <!-- Left Column -->
                    <div>
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Linked Brand:</label>
                            <select id="create-linked-brand" class="form-select form-select-sm">${linkedBrandOptions}</select>
                        </div>
                        
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Rebate Type: <span style="color:red;">*</span></label>
                            <select id="create-rebate-type" class="form-select form-select-sm" required>
                                <option value="">-- Select --</option>
                                <option value="Retail" ${rebateType === 'Retail' ? 'selected' : ''}>Retail</option>
                                <option value="Wholesale" ${rebateType === 'Wholesale' ? 'selected' : ''}>Wholesale</option>
                            </select>
                        </div>
                        
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Weekday:</label>
                            <select id="create-weekday" class="form-select form-select-sm" multiple size="3">
                                <option value="Monday">Monday</option>
                                <option value="Tuesday">Tuesday</option>
                                <option value="Wednesday">Wednesday</option>
                                <option value="Thursday">Thursday</option>
                                <option value="Friday">Friday</option>
                                <option value="Saturday">Saturday</option>
                                <option value="Sunday">Sunday</option>
                            </select>
                        </div>
                        
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Rebate After Wholesale:</label>
                            <select id="create-after-wholesale" class="form-select form-select-sm">
                                <option value="No" ${afterWholesale === 'No' ? 'selected' : ''}>No</option>
                                <option value="Yes" ${afterWholesale === 'Yes' ? 'selected' : ''}>Yes</option>
                            </select>
                        </div>
                        
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Discount %:</label>
                            <input type="text" id="create-discount" class="form-control form-control-sm" value="${discount}">
                        </div>
                        
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Vendor %:</label>
                            <input type="text" id="create-vendor" class="form-control form-control-sm" value="${vendorContrib}">
                        </div>
                    </div>
                    
                    <!-- Right Column -->
                    <div>
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Min Weight:</label>
                            <input type="text" id="create-min-weight" class="form-control form-control-sm" value="${minWeight}">
                        </div>
                        
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Max Weight:</label>
                            <input type="text" id="create-max-weight" class="form-control form-control-sm" value="${maxWeight}">
                        </div>
                        
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Category:</label>
                            <select id="create-category" class="form-select form-select-sm" multiple size="3">${categoriesOptions}</select>
                        </div>
                        
                        <div class="mb-2">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Locations Mode:</label>
                            <select id="create-location-mode" class="form-select form-select-sm" onchange="toggleLocationExceptions()">
                                <option value="ALL_LOCATIONS">All Locations</option>
                                <option value="ALL_EXCEPT">All Locations Except...</option>
                                <option value="SPECIFIC">Specific Locations...</option>
                            </select>
                        </div>
                        
                        <div class="mb-2" id="location-select-container" style="display:none;">
                            <label class="form-label fw-bold" style="font-size:0.85em;">Select Stores:</label>
                            <select id="create-locations" class="form-select form-select-sm" multiple size="4">${storesOptions}</select>
                            <small id="location-help" class="text-muted"></small>
                        </div>
                    </div>
                </div>
                
                <!-- Date Row -->
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin-top:15px; padding-top:15px; border-top:1px solid #dee2e6;">
                    <div>
                        <label class="form-label fw-bold" style="font-size:0.85em;">Start Date:</label>
                        <div style="display:flex; gap:5px;">
                            <select id="create-start-month" class="form-select form-select-sm" style="width:70px;">
                                <option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>
                                <option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>
                                <option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>
                                <option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>
                            </select>
                            <select id="create-start-day" class="form-select form-select-sm" style="width:60px;"></select>
                            <select id="create-start-year" class="form-select form-select-sm" style="width:80px;"></select>
                        </div>
                    </div>
                    <div>
                        <label class="form-label fw-bold" style="font-size:0.85em;">End Date:</label>
                        <div style="display:flex; gap:5px;">
                            <select id="create-end-month" class="form-select form-select-sm" style="width:70px;">
                                <option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>
                                <option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>
                                <option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>
                                <option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>
                            </select>
                            <select id="create-end-day" class="form-select form-select-sm" style="width:60px;"></select>
                            <select id="create-end-year" class="form-select form-select-sm" style="width:80px;"></select>
                        </div>
                    </div>
                </div>
                
                <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:20px; padding-top:15px; border-top:1px solid #dee2e6;">
                    <button class="btn btn-secondary" onclick="closeCreateDealPopup()">Cancel</button>
                    <button class="btn btn-success" onclick="executeCreateDeal(${rowIdx})">
                        <i class="bi bi-check-lg"></i> Confirm & Create
                    </button>
                </div>
            `;
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            // Helper: Toggle location exceptions visibility
            window.toggleLocationExceptions = function() {
                const mode = document.getElementById('create-location-mode').value;
                const container = document.getElementById('location-select-container');
                const help = document.getElementById('location-help');
                
                if (mode === 'ALL_LOCATIONS') {
                    container.style.display = 'none';
                } else {
                    container.style.display = 'block';
                    help.textContent = mode === 'ALL_EXCEPT' ? 'Select stores to EXCLUDE' : 'Select specific stores';
                }
            };
            
            // Initialize location dropdown based on current value
            function initializeLocationDropdown(locValue) {
                const modeSelect = document.getElementById('create-location-mode');
                const locSelect = document.getElementById('create-locations');
                const locLower = (locValue || '').toLowerCase().trim();
                
                if (locLower === 'all locations' || locLower === '') {
                    modeSelect.value = 'ALL_LOCATIONS';
                } else if (locLower.startsWith('all locations except')) {
                    modeSelect.value = 'ALL_EXCEPT';
                    const exceptions = locValue.replace(/all locations except:?/i, '').trim();
                    const excList = exceptions.split(',').map(s => s.trim());
                    Array.from(locSelect.options).forEach(opt => {
                        if (excList.some(e => e.toLowerCase() === opt.value.toLowerCase())) {
                            opt.selected = true;
                        }
                    });
                } else {
                    modeSelect.value = 'SPECIFIC';
                    const storeList = locValue.split(',').map(s => s.trim());
                    Array.from(locSelect.options).forEach(opt => {
                        if (storeList.some(s => s.toLowerCase() === opt.value.toLowerCase())) {
                            opt.selected = true;
                        }
                    });
                }
                toggleLocationExceptions();
            }
            
            // Populate year dropdowns
            const currentYear = new Date().getFullYear();
            ['create-start-year', 'create-end-year'].forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = '';
                for (let y = currentYear; y <= currentYear + 2; y++) {
                    const opt = document.createElement('option');
                    opt.value = y;
                    opt.textContent = y;
                    select.appendChild(opt);
                }
            });
            
            // Set date values - use parsed dates if available
            if (parsedStartDate) {
                document.getElementById('create-start-month').value = parsedStartDate.month;
                document.getElementById('create-start-year').value = parsedStartDate.year;
                updateCreateDayDropdown('start');
                document.getElementById('create-start-day').value = parsedStartDate.day;
            } else {
                document.getElementById('create-start-month').value = todayStr.month;
                document.getElementById('create-start-year').value = todayStr.year;
                updateCreateDayDropdown('start');
                document.getElementById('create-start-day').value = todayStr.day;
            }
            
            if (parsedEndDate) {
                document.getElementById('create-end-month').value = parsedEndDate.month;
                document.getElementById('create-end-year').value = parsedEndDate.year;
                updateCreateDayDropdown('end');
                document.getElementById('create-end-day').value = parsedEndDate.day;
            } else if (defaultDate) {
                document.getElementById('create-end-month').value = defaultDate.month;
                document.getElementById('create-end-year').value = defaultDate.year;
                updateCreateDayDropdown('end');
                document.getElementById('create-end-day').value = defaultDate.day;
            } else {
                updateCreateDayDropdown('end');
            }
            
            // Pre-select weekdays
            if (weekday) {
                const weekdaySelect = document.getElementById('create-weekday');
                const weekdayParts = weekday.split(',').map(w => w.trim());
                Array.from(weekdaySelect.options).forEach(opt => {
                    if (weekdayParts.some(w => opt.value.toLowerCase().includes(w.toLowerCase()))) {
                        opt.selected = true;
                    }
                });
            }
            
            // Pre-select categories
            if (categories) {
                const categorySelect = document.getElementById('create-category');
                const categoryParts = categories.split(',').map(c => c.trim());
                Array.from(categorySelect.options).forEach(opt => {
                    if (categoryParts.some(c => opt.value.toLowerCase() === c.toLowerCase())) {
                        opt.selected = true;
                    }
                });
            }
            
            // Initialize locations
            initializeLocationDropdown(locations);
            
            // Add change listeners
            document.getElementById('create-start-month').onchange = () => updateCreateDayDropdown('start');
            document.getElementById('create-start-year').onchange = () => updateCreateDayDropdown('start');
            document.getElementById('create-end-month').onchange = () => updateCreateDayDropdown('end');
            document.getElementById('create-end-year').onchange = () => updateCreateDayDropdown('end');
            
            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) closeCreateDealPopup();
            };
        }
        
        function closeCreateDealPopup() {
            const popup = document.getElementById('create-deal-popup-overlay');
            if (popup) popup.remove();
        }
        
        function updateCreateDayDropdown(type) {
            const monthSelect = document.getElementById(`create-${type}-month`);
            const daySelect = document.getElementById(`create-${type}-day`);
            const yearSelect = document.getElementById(`create-${type}-year`);
            
            if (!monthSelect || !daySelect || !yearSelect) return;
            
            const month = parseInt(monthSelect.value);
            const year = parseInt(yearSelect.value);
            const daysInMonth = new Date(year, month, 0).getDate();
            
            const currentDay = daySelect.value;
            daySelect.innerHTML = '';
            
            for (let d = 1; d <= daysInMonth; d++) {
                const opt = document.createElement('option');
                opt.value = String(d).padStart(2, '0');
                opt.textContent = d;
                daySelect.appendChild(opt);
            }
            
            // Restore or default to last day
            if (currentDay && parseInt(currentDay) <= daysInMonth) {
                daySelect.value = currentDay;
            } else if (type === 'end') {
                daySelect.value = String(daysInMonth).padStart(2, '0');
            }
        }
        
        async function executeCreateDeal(rowIdx) {
            const match = matchesData[rowIdx];
            if (!match) {
                alert('Error: Could not find row data');
                return;
            }
            
            // Get dates from popup
            const startMonth = document.getElementById('create-start-month').value;
            const startDay = document.getElementById('create-start-day').value;
            const startYear = document.getElementById('create-start-year').value.slice(-2);
            const endMonth = document.getElementById('create-end-month').value;
            const endDay = document.getElementById('create-end-day').value;
            const endYear = document.getElementById('create-end-year').value.slice(-2);
            
            const startDate = `${startMonth}/${startDay}/${startYear}`;
            const endDate = `${endMonth}/${endDay}/${endYear}`;
            
            // Get all form values
            const selectedWeekdays = Array.from(document.getElementById('create-weekday').selectedOptions).map(o => o.value).join(', ');
            const selectedCategories = Array.from(document.getElementById('create-category').selectedOptions).map(o => o.value).join(', ');
            const linkedBrand = document.getElementById('create-linked-brand').value;
            const rebateType = document.getElementById('create-rebate-type').value;
            const afterWholesale = document.getElementById('create-after-wholesale').value === 'Yes';
            const discount = document.getElementById('create-discount').value.trim();
            const vendorContrib = document.getElementById('create-vendor').value.trim();
            const minWeight = document.getElementById('create-min-weight').value.trim();
            const maxWeight = document.getElementById('create-max-weight').value.trim();
            
            // Locations handling
            const locationMode = document.getElementById('create-location-mode').value;
            let locations = '';
            if (locationMode === 'ALL_LOCATIONS') {
                locations = 'All Locations';
            } else {
                const selectedStores = Array.from(document.getElementById('create-locations').selectedOptions).map(o => o.value);
                if (locationMode === 'ALL_EXCEPT') {
                    locations = 'All Locations Except: ' + selectedStores.join(', ');
                } else {
                    locations = selectedStores.join(', ');
                }
            }
            
            // Validation
            if (!selectedWeekdays) { alert('Weekday is required!'); return; }
            if (!rebateType) { alert('Rebate Type is required!'); return; }
            
            // Close popup and show loading
            closeCreateDealPopup();
            
            // Show loading indicator
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'create-deal-loading';
            loadingOverlay.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:10003; display:flex; justify-content:center; align-items:center; flex-direction:column;';
            loadingOverlay.innerHTML = `
                <div class="spinner-border text-light" style="width:3rem; height:3rem;"></div>
                <div style="color:white; margin-top:15px; font-size:1.2em;">Creating deal in MIS...</div>
                <div id="create-deal-status" style="color:#aaa; margin-top:10px; font-size:0.9em;">Initializing...</div>
            `;
            document.body.appendChild(loadingOverlay);
            
            try {
                // v12.20: Use unified automate-create-deal endpoint (includes checklist injection)
                const sheetPayload = {
                    brand: match.brand,
                    linked_brand: linkedBrand,
                    weekday: selectedWeekdays,
                    categories: selectedCategories,
                    locations: locations,
                    discount: discount,
                    vendor_contrib: vendorContrib,
                    retail: rebateType === 'Retail' ? 'TRUE' : 'FALSE',
                    wholesale: rebateType === 'Wholesale' ? 'TRUE' : 'FALSE',
                    after_wholesale: afterWholesale ? 'TRUE' : 'FALSE',
                    min_weight: minWeight,
                    max_weight: maxWeight
                };
                
                const response = await fetch('/api/mis/automate-create-deal', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        google_row: match.google_row,
                        start_date: `${startMonth}/${startDay}/${startYear}`,
                        end_date: `${endMonth}/${endDay}/${endYear}`,
                        section_type: match.section_type || 'weekly',
                        sheet_data: sheetPayload
                    })
                });
                
                const data = await response.json();
                
                // Remove loading
                document.getElementById('create-deal-loading')?.remove();
                
                if (data.success) {
                    let message = '[EMOJI] Deal created in MIS!\\n\\n';
                    if (data.warnings && data.warnings.length > 0) {
                        message += '[EMOJI] Warnings:\\n' + data.warnings.join('\\n') + '\\n\\n';
                    }
                    message += 'Please review and click Save in MIS if everything looks correct.';
                    alert(message);
                } else {
                    alert('Error creating deal: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                document.getElementById('create-deal-loading')?.remove();
                alert('Error: ' + error.message);
            }
        }
        
        // v12.1: More Info popup for detailed field view - CENTERED on screen
        function showMoreInfoPopup(btn, type, rowIdx, suggestionIdx = null) {
            // Remove any existing more-info popups
            const existingPopup = document.getElementById('more-info-popup');
            if (existingPopup) existingPopup.remove();
            
            const match = matchesData[rowIdx];
            if (!match) return;
            
            let data = {};
            let title = '';
            
            if (type === 'sheet') {
                data = match.raw_row_data || {};
                title = 'Google Sheet - All Fields';
            } else if (type === 'csv' && suggestionIdx !== null && match.suggestions[suggestionIdx]) {
                data = match.suggestions[suggestionIdx].mis_data.raw_csv_data || {};
                title = 'MIS CSV - All Fields';
            }
            
            if (Object.keys(data).length === 0) {
                return;
            }
            
            // Create popup - CENTERED on screen
            const popup = document.createElement('div');
            popup.id = 'more-info-popup';
            popup.style.cssText = `
                position: fixed; z-index: 10001;
                background: #fff; border: 1px solid #ccc; border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                padding: 15px; max-width: 500px; max-height: 500px;
                overflow-y: auto;
                left: 50%; top: 50%;
                transform: translate(-50%, -50%);
            `;
            
            // Build content
            let html = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; border-bottom:1px solid #eee; padding-bottom:5px;">
                    <strong style="color:#007bff;">${title}</strong>
                    <button class="btn btn-sm btn-outline-danger py-0 px-1" onclick="document.getElementById('more-info-popup').remove()">X</button>
                </div>
                <table class="table table-sm table-bordered" style="font-size:0.8em; margin:0;">
                    <thead><tr><th style="width:40%;">Field</th><th>Value</th></tr></thead>
                    <tbody>
            `;
            
            Object.entries(data).forEach(([key, val]) => {
                const displayVal = String(val).length > 100 ? String(val).substring(0, 100) + '...' : val;
                html += `<tr><td><strong>${key}</strong></td><td title="${String(val).replace(/"/g, '&quot;')}">${displayVal}</td></tr>`;
            });
            
            html += '</tbody></table>';
            popup.innerHTML = html;
            
            document.body.appendChild(popup);
            
            // Close on mouse leave after delay
            let closeTimeout = null;
            popup.onmouseenter = () => { if (closeTimeout) clearTimeout(closeTimeout); };
            popup.onmouseleave = () => { closeTimeout = setTimeout(() => popup.remove(), 300); };
            btn.onmouseleave = () => { closeTimeout = setTimeout(() => popup.remove(), 300); };
        }

        // Helper function to apply ID from the modal and close it
        function applySuggestionFromModal(rowIdx, misId) {
            const input = document.getElementById(`input-mis-${rowIdx}`);
            if (input) {
                input.value = misId;
                // Highlight the input to show it changed
                input.style.backgroundColor = '#d4edda';
                setTimeout(() => { input.style.backgroundColor = ''; }, 1000);
            }
            // Close modal
            const overlay = document.getElementById('suggestion-modal-overlay');
            if (overlay) overlay.remove();
        }

        // v12.5: Enhanced applyMatches with mode parameter (mis, blaze, all)
        async function applyMatches(mode = 'all') {
            // Check if there's anything to apply based on mode
            const hasMisIds = Object.keys(approvedMatches).some(row => {
                const data = approvedMatches[row];
                return data.mis_ids && data.mis_ids.length > 0;
            });
            const hasBlazeTitles = Object.keys(approvedMatches).some(row => {
                const data = approvedMatches[row];
                return data.blaze_titles && data.blaze_titles.length > 0;
            });
            
            if (mode === 'mis' && !hasMisIds) {
                alert('No MIS IDs approved yet');
                return;
            }
            if (mode === 'blaze' && !hasBlazeTitles) {
                alert('No Blaze Titles selected yet');
                return;
            }
            if (mode === 'all' && !hasMisIds && !hasBlazeTitles) {
                alert('No matches approved yet');
                return;
            }
            
            const btn = event.target;
            btn.disabled = true;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Applying...';
            
            try {
                let misUpdated = 0, blazeUpdated = 0;
                
                // Apply MIS IDs if mode is 'mis' or 'all'
                if ((mode === 'mis' || mode === 'all') && hasMisIds) {
                    const response = await fetch('/api/mis/apply-matches', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({matches: approvedMatches})
                    });
                    const data = await response.json();
                    if (data.success) {
                        misUpdated = data.updated || 0;
                    } else {
                        throw new Error('MIS ID Apply Error: ' + data.error);
                    }
                }
                
                // Apply Blaze Titles if mode is 'blaze' or 'all'
                if ((mode === 'blaze' || mode === 'all') && hasBlazeTitles) {
                    const blazeResponse = await fetch('/api/mis/apply-blaze-titles', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({matches: approvedMatches})
                    });
                    const blazeData = await blazeResponse.json();
                    if (blazeData.success) {
                        blazeUpdated = blazeData.updated || 0;
                    } else {
                        throw new Error('Blaze Title Apply Error: ' + blazeData.error);
                    }
                }
                
                // Update table visually
                const rowToIndices = {};
                matchesData.forEach((m, idx) => {
                    if (!rowToIndices[m.google_row]) {
                        rowToIndices[m.google_row] = [];
                    }
                    rowToIndices[m.google_row].push(idx);
                });
                
                Object.keys(approvedMatches).forEach(googleRow => {
                    const approvedData = approvedMatches[googleRow];
                    const indices = rowToIndices[googleRow] || [];
                    
                    // Get applied IDs
                    let appliedIds = [];
                    if (approvedData.mis_ids && Array.isArray(approvedData.mis_ids)) {
                        appliedIds = approvedData.mis_ids;
                    } else if (approvedData.mis_id) {
                        appliedIds = [approvedData.mis_id];
                    }
                    
                    const appliedIdDisplay = appliedIds.join(', ');
                    
                    indices.forEach((idx, i) => {
                        const specificId = appliedIds[i] || appliedIdDisplay;
                        
                        if (matchesData[idx]) {
                            if (mode === 'mis' || mode === 'all') {
                                matchesData[idx].current_sheet_id = specificId;
                                matchesData[idx].matched_mis_id = specificId;
                            }
                            if (mode === 'blaze' || mode === 'all') {
                                matchesData[idx].blaze_titles = approvedData.blaze_titles || [];
                            }
                        }
                        
                        const row = document.getElementById('match-row-' + idx);
                        if (row) {
                            row.style.backgroundColor = '#d4edda';
                            row.style.borderLeft = '4px solid #28a745';
                            row.classList.add('row-applied');
                            
                            // Update Current ID column if MIS was applied
                            if ((mode === 'mis' || mode === 'all') && specificId) {
                                const cells = row.getElementsByTagName('td');
                                if (cells.length >= 12) {
                                    const currentIdCell = cells[11];
                                    currentIdCell.innerHTML = `<span style="cursor:pointer; font-weight:bold; padding:2px 6px; border-radius:4px; 
                                        background:#d4edda; color:#155724; border:1px solid #28a745;
                                        text-decoration:underline; display:inline-block; margin:2px;"
                                        onclick="lookupMisIdWithValidation(this, '${specificId}')">${specificId}</span>
                                        <span class="badge bg-success ms-1">Applied</span>`;
                                }
                            }
                            
                            // Update Blaze button indicator if Blaze was applied
                            if ((mode === 'blaze' || mode === 'all') && approvedData.blaze_titles && approvedData.blaze_titles.length > 0) {
                                const blazeBtn = row.querySelector('.btn-blaze');
                                if (blazeBtn) {
                                    blazeBtn.classList.remove('btn-outline-primary');
                                    blazeBtn.classList.add('btn-success');
                                    blazeBtn.innerHTML = '<i class="bi bi-lightning-charge-fill"></i> ' + approvedData.blaze_titles.length;
                                }
                            }
                            
                            // Disable action buttons
                            const approveBtn = row.querySelector('.btn-approve');
                            const rejectBtn = row.querySelector('.btn-reject');
                            if (approveBtn) {
                                approveBtn.disabled = true;
                                approveBtn.style.opacity = '0.5';
                            }
                            if (rejectBtn) {
                                rejectBtn.disabled = true;
                                rejectBtn.style.opacity = '0.5';
                            }
                        }
                    });
                });
                
                // Build result message
                let resultMsg = '[OK] Applied successfully!\n';
                if (mode === 'mis') resultMsg += 'MIS IDs updated: ' + misUpdated + ' rows';
                else if (mode === 'blaze') resultMsg += 'Blaze Titles updated: ' + blazeUpdated + ' rows';
                else resultMsg += 'MIS IDs: ' + misUpdated + ' rows\nBlaze Titles: ' + blazeUpdated + ' rows';
                
                alert(resultMsg);
                
                // Clear applied entries from approvedMatches based on mode
                if (mode === 'all') {
                    approvedMatches = {};
                } else {
                    // Only clear the part that was applied
                    Object.keys(approvedMatches).forEach(row => {
                        if (mode === 'mis') {
                            approvedMatches[row].mis_ids = [];
                            approvedMatches[row].brands = [];
                        } else if (mode === 'blaze') {
                            approvedMatches[row].blaze_titles = [];
                        }
                        // If both are empty, remove the entry
                        const d = approvedMatches[row];
                        if ((!d.mis_ids || d.mis_ids.length === 0) && (!d.blaze_titles || d.blaze_titles.length === 0)) {
                            delete approvedMatches[row];
                        }
                    });
                }
                
                updateApplyButtonsVisibility();
                
            } catch (error) {
                alert('Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }
        
        // v12.5: Update visibility of apply buttons based on approved data
        function updateApplyButtonsVisibility() {
            const container = document.getElementById('apply-btns-container');
            if (!container) return;
            
            const hasMisIds = Object.keys(approvedMatches).some(row => {
                const data = approvedMatches[row];
                return data.mis_ids && data.mis_ids.length > 0;
            });
            const hasBlazeTitles = Object.keys(approvedMatches).some(row => {
                const data = approvedMatches[row];
                return data.blaze_titles && data.blaze_titles.length > 0;
            });
            
            container.style.display = (hasMisIds || hasBlazeTitles) ? 'flex' : 'none';
            container.style.gap = '5px';
            
            // Enable/disable individual buttons
            const misBtn = document.getElementById('apply-mis-btn');
            const blazeBtn = document.getElementById('apply-blaze-btn');
            const allBtn = document.getElementById('apply-all-btn');
            
            if (misBtn) {
                misBtn.disabled = !hasMisIds;
                misBtn.style.opacity = hasMisIds ? '1' : '0.5';
            }
            if (blazeBtn) {
                blazeBtn.disabled = !hasBlazeTitles;
                blazeBtn.style.opacity = hasBlazeTitles ? '1' : '0.5';
            }
            if (allBtn) {
                allBtn.disabled = !(hasMisIds || hasBlazeTitles);
            }
        }

        // ============================================================================
        // v12.5: BLAZE DISCOUNT SELECTION MODAL
        // ============================================================================
        
        // Global state for Blaze modal
        let blazeModalData = {
            rowIdx: null,
            selectedTitles: [],
            allPromotions: [],
            filterType: 'NONE',        // v12.5: NONE, BOGO, B2G1, BULK
            alternateBrands: [],       // v12.5: List of alternate brand names
            libraryStatusFilter: 'All' // v12.5: All, Active, Inactive
        };
        
        async function openBlazeModal(rowIdx) {
            const match = matchesData[rowIdx];
            if (!match) return;
            
            // Initialize modal data
            blazeModalData.rowIdx = rowIdx;
            blazeModalData.filterType = 'NONE';        // v12.5: Reset filter
            blazeModalData.alternateBrands = [];       // v12.5: Reset alternate brands
            blazeModalData.libraryStatusFilter = 'All'; // v12.5: Reset status filter
            
            // Get existing selections from approvedMatches
            const existingData = approvedMatches[match.google_row];
            blazeModalData.selectedTitles = existingData?.blaze_titles ? [...existingData.blaze_titles] : [];
            
            // v12.7: Auto-load existing titles from Google Sheet column
            // Track which titles exist in Blaze and which don't
            blazeModalData.notFoundTitles = [];  // Titles that don't exist in Blaze yet
            
            // Get all Blaze promotions - check if already loaded
            blazeModalData.allPromotions = blazeData.currentRows || [];
            
            // If no Blaze data loaded, try to fetch it
            if (blazeModalData.allPromotions.length === 0) {
                // Show loading indicator
                const loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'blaze-loading-overlay';
                loadingOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background-color: rgba(0, 0, 0, 0.6); z-index: 9998;
                    display: flex; justify-content: center; align-items: center;
                `;
                loadingOverlay.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 8px; text-align: center;">
                        <div class="spinner-border text-primary" role="status"></div>
                        <p style="margin-top: 15px; margin-bottom: 0;">Loading Blaze Promotions...</p>
                    </div>
                `;
                document.body.appendChild(loadingOverlay);
                
                try {
                    const response = await fetch('/api/blaze/refresh');
                    const data = await response.json();
                    if (data.success && data.promotions) {
                        // Store globally so Blaze tab also has it
                        blazeData.currentRows = data.promotions;
                        blazeModalData.allPromotions = data.promotions;
                        console.log('[BLAZE-MODAL] Fetched ' + data.promotions.length + ' promotions');
                    } else {
                        throw new Error(data.error || 'Failed to fetch Blaze data');
                    }
                } catch (e) {
                    console.error('[BLAZE-MODAL] Error fetching Blaze data:', e);
                    loadingOverlay.remove();
                    alert('Could not load Blaze promotions.\n\nPlease go to the Blaze tab and click "Refresh / Sync Data" first, then try again.\n\nError: ' + e.message);
                    return;
                }
                
                loadingOverlay.remove();
            }
            
            // v12.7: Auto-load existing Blaze titles from Google Sheet column "Blaze Discount Title"
            // Parse the current sheet value (may have newline-separated titles)
            const sheetBlazeTitle = match.blaze_discount_title || '';  // Assuming this field exists
            if (sheetBlazeTitle && sheetBlazeTitle.trim() !== '') {
                const titleLines = sheetBlazeTitle.split('\n').map(t => t.trim()).filter(t => t.length > 0);
                
                titleLines.forEach(title => {
                    // Check if this title exists in Blaze promotions
                    const foundPromo = blazeModalData.allPromotions.find(p => 
                        (p.Name || '').toLowerCase() === title.toLowerCase()
                    );
                    
                    if (foundPromo) {
                        // Title exists in Blaze - add to selected titles if not already there
                        if (!blazeModalData.selectedTitles.includes(title)) {
                            blazeModalData.selectedTitles.push(title);
                        }
                    } else {
                        // Title NOT found in Blaze - track it separately
                        if (!blazeModalData.notFoundTitles.includes(title)) {
                            blazeModalData.notFoundTitles.push(title);
                        }
                        // Also add to selectedTitles so it appears in queue with warning
                        if (!blazeModalData.selectedTitles.includes(title)) {
                            blazeModalData.selectedTitles.push(title);
                        }
                    }
                });
                
                console.log('[BLAZE-MODAL] Auto-loaded from sheet:', titleLines.length, 'titles');
                console.log('[BLAZE-MODAL] Not found in Blaze:', blazeModalData.notFoundTitles.length);
            }
            
            // Generate suggestions based on brand name
            const suggestions = generateBlazeSuggestions(match, blazeModalData.allPromotions);
            
            // Create modal overlay
            const existing = document.getElementById('blaze-modal-overlay');
            if (existing) existing.remove();
            
            const overlay = document.createElement('div');
            overlay.id = 'blaze-modal-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.6); z-index: 9998;
                display: flex; justify-content: center; align-items: center;
            `;
            overlay.onclick = function(e) {
                if(e.target === overlay) overlay.remove();
            };
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #fff; padding: 20px; border-radius: 12px;
                box-shadow: 0 8px 30px rgba(0,0,0,0.3);
                width: 900px; max-width: 95%; max-height: 90vh;
                overflow-y: auto; z-index: 9999; position: relative;
            `;
            
            // Build modal HTML
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 2px solid #0d6efd; padding-bottom: 10px;">
                    <h4 style="margin: 0; color: #0d6efd;"><i class="bi bi-lightning-charge-fill"></i> Select Blaze Discounts</h4>
                    <button class="btn btn-outline-secondary btn-sm" onclick="document.getElementById('blaze-modal-overlay').remove()">
                        <i class="bi bi-x-lg"></i> Close
                    </button>
                </div>
                
                <!-- Current Row Details -->
                <div style="background: #e7f1ff; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <h6 style="margin: 0 0 8px 0; color: #0d6efd;"><i class="bi bi-info-circle"></i> Google Sheet Row ${match.google_row}</h6>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; font-size: 0.9em;">
                        <div><strong>Brand:</strong> ${match.brand || '-'}</div>
                        <div><strong>Discount:</strong> ${match.discount !== null ? match.discount + '%' : '-'}</div>
                        <div><strong>Weekday:</strong> ${match.weekday || '-'}</div>
                        <div style="grid-column: span 2;">
                            <strong>Locations:</strong> ${(match.locations || '-').substring(0, 50)}${(match.locations || '').length > 50 ? '...' : ''}
                            <button class="btn btn-success btn-sm" style="margin-left: 10px; padding: 2px 8px; font-size: 0.85em;" 
                                    onclick="openCreateBlazeModal(${rowIdx})" title="Create new Blaze discount">
                                <i class="bi bi-plus-circle"></i> Create
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Selection Queue (v12.6: Scrollable with counter) -->
                <div style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <h6 style="margin: 0 0 8px 0; color: #856404;">
                        <i class="bi bi-list-ol"></i> Selected Queue (<span id="queue-counter">0</span> items) - drag to reorder
                    </h6>
                    <div id="blaze-queue-container" style="display: flex; flex-wrap: wrap; gap: 5px; min-height: 60px; max-height: 120px; overflow-y: auto;">
                        ${blazeModalData.selectedTitles.length === 0 ? '<span style="color: #999; font-style: italic;">No discounts selected</span>' : ''}
                    </div>
                </div>
                
                <!-- Suggested Matches -->
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #198754; padding-bottom: 5px; margin-bottom: 10px;">
                        <h6 style="color: #198754; margin: 0;">
                            <i class="bi bi-stars"></i> Suggested Matches (<span id="suggestion-count">${suggestions.length}</span>)
                        </h6>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <label style="font-size: 0.85em; margin: 0;">Filter:</label>
                            <select id="blaze-suggestion-filter" class="form-select form-select-sm" style="width: auto;" onchange="updateBlazeSuggestions()">
                                <option value="NONE" selected>NONE</option>
                                <option value="BOGO">BOGO</option>
                                <option value="B2G1">B2G1</option>
                                <option value="BULK">BULK</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Alternate Brand Names -->
                    <div style="margin-bottom: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                            <label style="font-size: 0.85em; margin: 0; white-space: nowrap;">Alt Brand Names:</label>
                            <input type="text" id="blaze-alt-brand-input" class="form-control form-control-sm" 
                                   placeholder="e.g., Stizzy, Stizy" style="flex: 1;"
                                   onkeypress="if(event.key==='Enter'){addAlternateBrand(); event.preventDefault();}">
                            <button class="btn btn-outline-success btn-sm" onclick="addAlternateBrand()" title="Add alternate brand">
                                <i class="bi bi-plus"></i> Add
                            </button>
                        </div>
                        <div id="blaze-alt-brands-container" style="display: flex; flex-wrap: wrap; gap: 5px; min-height: 20px;">
                            <span style="color: #999; font-size: 0.85em; font-style: italic;">No alternate brands added</span>
                        </div>
                    </div>
                    
                    <div id="blaze-suggestions-container" style="max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px;">
                        ${renderBlazePromoList(suggestions, 'suggestion')}
                    </div>
                </div>
                
                <!-- Full Library (v12.6: Collapsible) -->
                <div style="margin-bottom: 15px;">
                    <h6 style="color: #6c757d; border-bottom: 1px solid #6c757d; padding-bottom: 5px; cursor: pointer; display: flex; align-items: center; gap: 8px;" 
                        onclick="toggleFullLibrary()">
                        <span id="library-toggle-icon">[EMOJI]</span>
                        <i class="bi bi-collection"></i> Full Library (${blazeModalData.allPromotions.length})
                    </h6>
                    <div id="full-library-content" style="display: none;">
                        <div style="display: flex; gap: 8px; margin-bottom: 8px; margin-top: 8px; align-items: center;">
                            <input type="text" id="blaze-library-search" class="form-control form-control-sm" 
                                   placeholder="Search by name..." style="flex: 1;" oninput="filterBlazeLibrary()">
                            <label style="font-size: 0.85em; margin: 0; white-space: nowrap;">Status:</label>
                            <select id="blaze-library-status" class="form-select form-select-sm" style="width: auto;" onchange="filterBlazeLibrary()">
                                <option value="All" selected>All</option>
                                <option value="Active">Active</option>
                                <option value="Inactive">Inactive</option>
                            </select>
                        </div>
                        <div id="blaze-library-container" style="max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px;">
                            ${renderBlazePromoList(blazeModalData.allPromotions.slice(0, 50), 'library')}
                        </div>
                        ${blazeModalData.allPromotions.length > 50 ? '<small class="text-muted">Showing first 50. Use search to narrow results.</small>' : ''}
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: flex; justify-content: flex-end; gap: 10px; border-top: 1px solid #dee2e6; padding-top: 15px;">
                    <button class="btn btn-outline-secondary" onclick="document.getElementById('blaze-modal-overlay').remove()">Cancel</button>
                    <button class="btn btn-primary" onclick="confirmBlazeSelection()">
                        <i class="bi bi-check-lg"></i> Confirm Selection
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Render initial queue
            renderBlazeQueue();
        }
        
        function generateBlazeSuggestions(match, allPromos, filterType = 'NONE', alternateBrands = []) {
            if (!allPromos || allPromos.length === 0) return [];
            
            const brand = (match.brand || '').toLowerCase();
            // Combine primary brand words with alternate brands
            let brandWords = brand.split(/[\s,]+/).filter(w => w.length > 2);
            alternateBrands.forEach(alt => {
                const altWords = alt.toLowerCase().split(/[\s,]+/).filter(w => w.length > 2);
                brandWords = brandWords.concat(altWords);
            });
            brandWords = [...new Set(brandWords)]; // Remove duplicates
            
            // Filter type patterns
            const bulkPatterns = [
                /bulk/i,
                /mix\s*&\s*match/i,
                /mix\s+and\s+match/i,
                /\d+\s*for\s*\$?\d+/i,  // "2 for $40", "3 for 60"
                /\d+\/\$?\d+/i           // "2/$40", "4/100"
            ];
            
            // Score each promotion
            const scored = allPromos.map(promo => {
                const name = (promo.Name || '').toLowerCase();
                let score = 0;
                let matchesFilter = true;
                let hasBrandMatch = false;  // v12.6: Track if brand matches
                
                // v12.6 FIX: Check for brand match FIRST
                // Check for brand word matches in title
                brandWords.forEach(word => {
                    if (name.includes(word)) {
                        score += 30;
                        hasBrandMatch = true;
                    }
                });
                
                // Exact brand name match
                if (name.includes(brand)) {
                    score += 50;
                    hasBrandMatch = true;
                }
                
                // Check alternate brands for exact match too
                alternateBrands.forEach(alt => {
                    if (name.includes(alt.toLowerCase())) {
                        score += 50;
                        hasBrandMatch = true;
                    }
                });
                
                // v12.6 FIX: If no brand match at all, return score 0 immediately
                if (!hasBrandMatch) {
                    return { promo, score: 0 };
                }
                
                // Apply filter type (ONLY after confirming brand match)
                if (filterType === 'BOGO') {
                    matchesFilter = name.includes('bogo');
                } else if (filterType === 'B2G1') {
                    matchesFilter = name.includes('b2g1');
                } else if (filterType === 'BULK') {
                    matchesFilter = bulkPatterns.some(pattern => pattern.test(promo.Name || ''));
                }
                // NONE = no additional filter (but still requires brand match)
                
                if (!matchesFilter) {
                    return { promo, score: 0 };
                }
                
                // Active status bonus
                if (promo.Status === 'Active') {
                    score += 10;
                }
                
                return { promo, score };
            });
            
            // Filter (require brand match) and sort by score - NO LIMIT
            return scored
                .filter(s => s.score > 0)
                .sort((a, b) => b.score - a.score)
                .map(s => s.promo);
        }
        
        function renderBlazePromoList(promos, type) {
            if (!promos || promos.length === 0) {
                return '<div style="padding: 10px; text-align: center; color: #999;">No promotions found</div>';
            }
            
            return promos.map(promo => {
                const isSelected = blazeModalData.selectedTitles.includes(promo.Name);
                const statusColor = promo.Status === 'Active' ? '#198754' : '#dc3545';
                const bgColor = isSelected ? '#d4edda' : '#fff';
                
                // v12.7: Add View button for each promo
                return `
                    <div style="padding: 8px 12px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 10px; background: ${bgColor};"
                         onmouseover="this.style.background='${isSelected ? '#c3e6cb' : '#f8f9fa'}'"
                         onmouseout="this.style.background='${bgColor}'">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} style="cursor: pointer;" 
                               onclick="toggleBlazeSelection('${escapeHtml(promo.Name)}')">
                        <div style="flex: 1; min-width: 0; cursor: pointer;" onclick="toggleBlazeSelection('${escapeHtml(promo.Name)}')">
                            <div style="font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${escapeHtml(promo.Name)}">
                                ${escapeHtml(promo.Name)}
                            </div>
                            <div style="font-size: 0.8em; color: #6c757d;">
                                <span style="color: ${statusColor};">${promo.Status}</span>
                                ${promo['Discount Value'] ? ' | ' + promo['Discount Value'] + ' ' + (promo['Discount Value Type'] || '') : ''}
                                ${promo['Start Date'] ? ' | ' + promo['Start Date'] : ''}
                            </div>
                        </div>
                        <button class="btn btn-info btn-sm" style="padding: 2px 6px; font-size: 0.75em; white-space: nowrap;" 
                                onclick="event.stopPropagation(); showDetailModal(${JSON.stringify(promo).replace(/"/g, '&quot;')}, true)">
                            <i class="bi bi-eye"></i> View
                        </button>
                    </div>
                `;
            }).join('');
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }
        
        function toggleBlazeSelection(promoName) {
            const idx = blazeModalData.selectedTitles.indexOf(promoName);
            if (idx >= 0) {
                blazeModalData.selectedTitles.splice(idx, 1);
            } else {
                blazeModalData.selectedTitles.push(promoName);
            }
            
            // Re-render lists
            renderBlazeQueue();
            
            // v12.5: Use current filter settings for suggestions
            const match = matchesData[blazeModalData.rowIdx];
            const suggestions = generateBlazeSuggestions(
                match, 
                blazeModalData.allPromotions,
                blazeModalData.filterType,
                blazeModalData.alternateBrands
            );
            document.getElementById('blaze-suggestions-container').innerHTML = renderBlazePromoList(suggestions, 'suggestion');
            
            // Update count
            const countEl = document.getElementById('suggestion-count');
            if (countEl) countEl.textContent = suggestions.length;
            
            // Re-render library with current search and status filter
            filterBlazeLibrary();
        }
        
        function renderBlazeQueue() {
            const container = document.getElementById('blaze-queue-container');
            if (!container) return;
            
            // v12.6: Update counter
            const counterSpan = document.getElementById('queue-counter');
            if (counterSpan) {
                counterSpan.textContent = blazeModalData.selectedTitles.length;
            }
            
            if (blazeModalData.selectedTitles.length === 0) {
                container.innerHTML = '<span style="color: #999; font-style: italic;">No discounts selected</span>';
                return;
            }
            
            // v12.7: Render items with different styling for not-found titles
            container.innerHTML = blazeModalData.selectedTitles.map((title, idx) => {
                const isNotFound = blazeModalData.notFoundTitles.includes(title);
                
                // Find promo to get View button
                const promo = blazeModalData.allPromotions.find(p => 
                    (p.Name || '').toLowerCase() === title.toLowerCase()
                );
                
                if (isNotFound) {
                    // Not found in Blaze - show warning with Create button
                    return `
                        <div class="blaze-queue-item" data-idx="${idx}" data-not-found="true"
                             style="background: #f8f9fa; border: 1px solid #6c757d; border-radius: 4px; padding: 4px 8px; 
                                    display: flex; align-items: center; gap: 5px; opacity: 0.7;">
                            <span style="font-weight: bold; color: #6c757d;">${idx + 1}.</span>
                            <i class="bi bi-exclamation-triangle" style="color: #ffc107;" title="Not found in Blaze"></i>
                            <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; color: #6c757d;" title="${escapeHtml(title)}">
                                ${escapeHtml(title)}
                            </span>
                            <button class="btn btn-success btn-sm" style="padding: 1px 4px; font-size: 0.75em;" 
                                    onclick="event.stopPropagation(); createBlazeDiscountFromQueue('${escapeHtml(title)}')">
                                <i class="bi bi-plus-circle"></i> Create
                            </button>
                            <button class="btn btn-sm" style="padding: 0 4px; color: #dc3545;" onclick="event.stopPropagation(); removeFromBlazeQueue(${idx})">
                                <i class="bi bi-x"></i>
                            </button>
                        </div>
                    `;
                } else {
                    // Found in Blaze - normal item with drag and View button
                    return `
                        <div class="blaze-queue-item" draggable="true" data-idx="${idx}"
                             style="background: #fff; border: 1px solid #ffc107; border-radius: 4px; padding: 4px 8px; 
                                    display: flex; align-items: center; gap: 5px; cursor: move;">
                            <span style="font-weight: bold; color: #856404;">${idx + 1}.</span>
                            <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 120px;" title="${escapeHtml(title)}">
                                ${escapeHtml(title)}
                            </span>
                            ${promo ? `
                                <button class="btn btn-info btn-sm" style="padding: 1px 4px; font-size: 0.75em;" 
                                        onclick="event.stopPropagation(); showDetailModal(${JSON.stringify(promo).replace(/"/g, '&quot;')}, true)">
                                    <i class="bi bi-eye"></i> View
                                </button>
                            ` : ''}
                            <button class="btn btn-sm" style="padding: 0 4px; color: #dc3545;" onclick="event.stopPropagation(); removeFromBlazeQueue(${idx})">
                                <i class="bi bi-x"></i>
                            </button>
                        </div>
                    `;
                }
            }).join('');
            
            // Add drag-and-drop handlers only to items that are found (draggable)
            const items = container.querySelectorAll('.blaze-queue-item[draggable="true"]');
            items.forEach(item => {
                item.addEventListener('dragstart', handleQueueDragStart);
                item.addEventListener('dragover', handleQueueDragOver);
                item.addEventListener('drop', handleQueueDrop);
                item.addEventListener('dragend', handleQueueDragEnd);
            });
        }
        
        let queueDraggedItem = null;
        
        function handleQueueDragStart(e) {
            queueDraggedItem = this;
            this.style.opacity = '0.5';
        }
        
        function handleQueueDragOver(e) {
            e.preventDefault();
            this.style.borderLeft = '3px solid #0d6efd';
        }
        
        function handleQueueDrop(e) {
            e.preventDefault();
            this.style.borderLeft = '';
            
            if (queueDraggedItem === this) return;
            
            const fromIdx = parseInt(queueDraggedItem.dataset.idx);
            const toIdx = parseInt(this.dataset.idx);
            
            // Reorder array
            const [removed] = blazeModalData.selectedTitles.splice(fromIdx, 1);
            blazeModalData.selectedTitles.splice(toIdx, 0, removed);
            
            renderBlazeQueue();
        }
        
        function handleQueueDragEnd(e) {
            this.style.opacity = '1';
            document.querySelectorAll('.blaze-queue-item').forEach(item => {
                item.style.borderLeft = '';
            });
        }
        
        function removeFromBlazeQueue(idx) {
            blazeModalData.selectedTitles.splice(idx, 1);
            renderBlazeQueue();
            
            // v12.5: Use current filter settings for suggestions
            const match = matchesData[blazeModalData.rowIdx];
            const suggestions = generateBlazeSuggestions(
                match, 
                blazeModalData.allPromotions,
                blazeModalData.filterType,
                blazeModalData.alternateBrands
            );
            document.getElementById('blaze-suggestions-container').innerHTML = renderBlazePromoList(suggestions, 'suggestion');
            
            // Update count
            const countEl = document.getElementById('suggestion-count');
            if (countEl) countEl.textContent = suggestions.length;
            
            filterBlazeLibrary();
        }
        
        function filterBlazeLibrary() {
            const container = document.getElementById('blaze-library-container');
            if (!container) return;
            
            const searchTerm = (document.getElementById('blaze-library-search')?.value || '').toLowerCase();
            const statusFilter = document.getElementById('blaze-library-status')?.value || 'All';
            
            blazeModalData.libraryStatusFilter = statusFilter;
            
            let filtered = blazeModalData.allPromotions;
            
            // Apply search term filter
            if (searchTerm) {
                filtered = filtered.filter(p => 
                    (p.Name || '').toLowerCase().includes(searchTerm)
                );
            }
            
            // Apply status filter
            if (statusFilter !== 'All') {
                filtered = filtered.filter(p => p.Status === statusFilter);
            }
            
            container.innerHTML = renderBlazePromoList(filtered.slice(0, 50), 'library');
        }
        
        // v12.5: Add alternate brand name
        function addAlternateBrand() {
            const input = document.getElementById('blaze-alt-brand-input');
            if (!input) return;
            
            const value = input.value.trim();
            if (!value) return;
            
            // Check for duplicates
            if (blazeModalData.alternateBrands.includes(value)) {
                input.value = '';
                return;
            }
            
            blazeModalData.alternateBrands.push(value);
            input.value = '';
            
            renderAlternateBrands();
            updateBlazeSuggestions();
        }
        
        // v12.5: Remove alternate brand name
        function removeAlternateBrand(idx) {
            blazeModalData.alternateBrands.splice(idx, 1);
            renderAlternateBrands();
            updateBlazeSuggestions();
        }
        
        // v12.5: Render alternate brands list
        function renderAlternateBrands() {
            const container = document.getElementById('blaze-alt-brands-container');
            if (!container) return;
            
            if (blazeModalData.alternateBrands.length === 0) {
                container.innerHTML = '<span style="color: #999; font-size: 0.85em; font-style: italic;">No alternate brands added</span>';
                return;
            }
            
            container.innerHTML = blazeModalData.alternateBrands.map((brand, idx) => `
                <span style="background: #e7f1ff; border: 1px solid #0d6efd; border-radius: 15px; padding: 2px 10px; 
                             font-size: 0.85em; display: inline-flex; align-items: center; gap: 5px;">
                    ${escapeHtml(brand)}
                    <button class="btn btn-sm" style="padding: 0 2px; color: #dc3545; line-height: 1;" 
                            onclick="removeAlternateBrand(${idx})" title="Remove">
                        <i class="bi bi-x"></i>
                    </button>
                </span>
            `).join('');
        }
        
        // v12.5: Update suggestions based on filter and alternate brands
        function updateBlazeSuggestions() {
            const filterSelect = document.getElementById('blaze-suggestion-filter');
            const filterType = filterSelect?.value || 'NONE';
            blazeModalData.filterType = filterType;
            
            const match = matchesData[blazeModalData.rowIdx];
            if (!match) return;
            
            const suggestions = generateBlazeSuggestions(
                match, 
                blazeModalData.allPromotions, 
                filterType, 
                blazeModalData.alternateBrands
            );
            
            // Update count
            const countEl = document.getElementById('suggestion-count');
            if (countEl) countEl.textContent = suggestions.length;
            
            // Update list
            document.getElementById('blaze-suggestions-container').innerHTML = renderBlazePromoList(suggestions, 'suggestion');
        }
        
        function confirmBlazeSelection() {
            const match = matchesData[blazeModalData.rowIdx];
            if (!match) return;
            
            // Update approvedMatches
            if (!approvedMatches[match.google_row]) {
                approvedMatches[match.google_row] = {
                    mis_ids: [],
                    brands: [],
                    section: match.section || 'weekly',
                    blaze_titles: [],
                    blaze_titles_not_found: []  // v12.7: Track not-found titles
                };
            }
            
            approvedMatches[match.google_row].blaze_titles = [...blazeModalData.selectedTitles];
            approvedMatches[match.google_row].blaze_titles_not_found = [...blazeModalData.notFoundTitles];  // v12.7
            
            // Update the Blaze button in the table
            const row = document.getElementById('match-row-' + blazeModalData.rowIdx);
            if (row) {
                const blazeBtn = row.querySelector('.btn-blaze');
                if (blazeBtn) {
                    if (blazeModalData.selectedTitles.length > 0) {
                        blazeBtn.classList.remove('btn-outline-primary');
                        blazeBtn.classList.add('btn-primary');
                        blazeBtn.innerHTML = '<i class="bi bi-lightning-charge-fill"></i> ' + blazeModalData.selectedTitles.length;
                        blazeBtn.title = blazeModalData.selectedTitles.join('\\n');
                    } else {
                        blazeBtn.classList.remove('btn-primary');
                        blazeBtn.classList.add('btn-outline-primary');
                        blazeBtn.innerHTML = '<i class="bi bi-lightning-charge"></i>';
                        blazeBtn.title = 'Select Blaze Discount';
                    }
                }
            }
            
            // Update visibility of apply buttons
            updateApplyButtonsVisibility();
            
            // Close modal
            document.getElementById('blaze-modal-overlay').remove();
        }
        
        // v12.6: Toggle Full Library section visibility
        function toggleFullLibrary() {
            const content = document.getElementById('full-library-content');
            const icon = document.getElementById('library-toggle-icon');
            
            if (!content || !icon) return;
            
            const isCurrentlyVisible = content.style.display !== 'none';
            content.style.display = isCurrentlyVisible ? 'none' : 'block';
            icon.textContent = isCurrentlyVisible ? '[EMOJI]' : '[EMOJI]';
        }
        
        // v12.7: Create Blaze Discount Modal and Automation
        let createBlazeModalData = {
            rowIdx: null,
            suggestedTitle: '',
            typedTitle: '',
            canUndo: false
        };
        
        function openCreateBlazeModal(rowIdx) {
            const match = matchesData[rowIdx];
            if (!match) return;
            
            // Store for later use
            createBlazeModalData.rowIdx = rowIdx;
            createBlazeModalData.suggestedTitle = '';
            createBlazeModalData.typedTitle = '';
            createBlazeModalData.canUndo = false;
            
            // Generate suggested title variations
            const brand = match.brand || '';
            const discount = match.discount !== null ? match.discount + '%' : '';
            const weekday = match.weekday || '';
            
            const suggestions = [
                `${brand} ${discount} ${weekday}`.trim(),
                `${brand} ${discount} Off ${weekday}`.trim(),
                `${weekday} ${brand} ${discount}`.trim(),
                `${discount} Off ${brand} - ${weekday}`.trim()
            ].filter(s => s.length > 0);
            
            // Auto-detect discount type from pattern
            const dealInfo = (match.deal_info || '').toLowerCase();
            let detectedType = '';
            if (dealInfo.includes('bogo') || dealInfo.includes('buy') && dealInfo.includes('get')) {
                detectedType = 'BOGO';
            } else if (dealInfo.includes('bundle')) {
                detectedType = 'Bundle';
            } else if (dealInfo.includes('bulk') || dealInfo.includes('mix')) {
                detectedType = 'BULK (likely Global Product Discount)';
            } else {
                detectedType = 'Unknown (manual selection required)';
            }
            
            // Create modal
            const existing = document.getElementById('create-blaze-overlay');
            if (existing) existing.remove();
            
            const overlay = document.createElement('div');
            overlay.id = 'create-blaze-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #fff; padding: 25px; border-radius: 12px;
                box-shadow: 0 8px 30px rgba(0,0,0,0.4);
                width: 600px; max-width: 95%;
            `;
            
            const currentDate = new Date().toLocaleString();
            
            modal.innerHTML = `
                <h4 style="margin: 0 0 15px 0; color: #198754;">
                    <i class="bi bi-plus-circle-fill"></i> Create Blaze Discount
                </h4>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">Title:</label>
                    <div style="position: relative;">
                        <input type="text" id="create-blaze-title" class="form-control" placeholder="Enter discount title..."
                               onfocus="showTitleSuggestions()"
                               oninput="handleTitleInput(event)"
                               onblur="setTimeout(() => hideTitleSuggestions(), 150)">
                        <div id="title-suggestions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; 
                                background: white; border: 1px solid #ccc; border-top: none; max-height: 150px; overflow-y: auto; z-index: 1000;">
                            ${suggestions.map(s => `
                                <div style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee;"
                                     onmouseover="this.style.background='#f8f9fa'"
                                     onmouseout="this.style.background='white'"
                                     onclick="selectTitleSuggestion('${escapeHtml(s)}')">
                                    ${escapeHtml(s)}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <button id="title-undo-btn" class="btn btn-sm btn-outline-warning mt-1" style="display: none;" onclick="undoTitleSelection()">
                        <i class="bi bi-arrow-counterclockwise"></i> Undo
                    </button>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">Discount Type:</label>
                    <select id="create-blaze-type" class="form-select">
                        <option value="">-- Select Type --</option>
                        <option value="Bundle">Bundle</option>
                        <option value="BOGO">BOGO</option>
                        <option value="Global Product Discount">Global Product Discount</option>
                        <option value="Collection Discount">Collection Discount</option>
                    </select>
                    <small style="color: #6c757d; font-style: italic;">Suggested: ${detectedType}</small>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">Description:</label>
                    <textarea id="create-blaze-description" class="form-control" rows="4" placeholder="Enter description..."></textarea>
                    <button class="btn btn-sm btn-outline-secondary mt-1" onclick="autofillDescription()">
                        <i class="bi bi-magic"></i> Autofill
                    </button>
                </div>
                
                <div style="display: flex; justify-content: flex-end; gap: 10px; border-top: 1px solid #dee2e6; padding-top: 15px;">
                    <button class="btn btn-outline-secondary" onclick="document.getElementById('create-blaze-overlay').remove()">Cancel</button>
                    <button class="btn btn-success" onclick="executeCreateBlazeAutomation()">
                        <i class="bi bi-check-lg"></i> Create in Blaze
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Close on outside click
            overlay.onclick = function(e) {
                if (e.target === overlay) overlay.remove();
            };
        }
        
        function createBlazeDiscountFromQueue(title) {
            // Find the row index and open create modal with pre-filled title
            const rowIdx = createBlazeModalData.rowIdx || blazeModalData.rowIdx;
            if (rowIdx === null) return;
            
            openCreateBlazeModal(rowIdx);
            
            // Pre-fill title after modal opens
            setTimeout(() => {
                const titleInput = document.getElementById('create-blaze-title');
                if (titleInput) {
                    titleInput.value = title;
                    createBlazeModalData.typedTitle = title;
                }
            }, 100);
        }
        
        function showTitleSuggestions() {
            const dropdown = document.getElementById('title-suggestions');
            if (dropdown) dropdown.style.display = 'block';
        }
        
        function hideTitleSuggestions() {
            const dropdown = document.getElementById('title-suggestions');
            if (dropdown) dropdown.style.display = 'none';
        }
        
        function handleTitleInput(event) {
            createBlazeModalData.typedTitle = event.target.value;
            // Hide undo button if user types new text
            if (createBlazeModalData.canUndo && event.target.value !== createBlazeModalData.suggestedTitle) {
                createBlazeModalData.canUndo = false;
                const undoBtn = document.getElementById('title-undo-btn');
                if (undoBtn) undoBtn.style.display = 'none';
            }
        }
        
        function selectTitleSuggestion(suggestion) {
            const titleInput = document.getElementById('create-blaze-title');
            const undoBtn = document.getElementById('title-undo-btn');
            const dropdown = document.getElementById('title-suggestions');
            
            if (titleInput) {
                titleInput.value = suggestion;
                createBlazeModalData.suggestedTitle = suggestion;
                createBlazeModalData.canUndo = true;
                
                if (undoBtn) undoBtn.style.display = 'inline-block';
            }
            
            if (dropdown) dropdown.style.display = 'none';
        }
        
        function undoTitleSelection() {
            const titleInput = document.getElementById('create-blaze-title');
            const undoBtn = document.getElementById('title-undo-btn');
            
            if (titleInput) {
                titleInput.value = createBlazeModalData.typedTitle;
                createBlazeModalData.canUndo = false;
                
                if (undoBtn) undoBtn.style.display = 'none';
            }
        }
        
        function autofillDescription() {
            const match = matchesData[createBlazeModalData.rowIdx];
            if (!match) return;
            
            const descArea = document.getElementById('create-blaze-description');
            if (!descArea) return;
            
            const brand = match.brand || '-';
            const discountType = document.getElementById('create-blaze-type')?.value || 'Not Selected';
            const discountValue = match.discount !== null ? match.discount + '%' : '-';
            const locations = match.locations || '-';
            const creationDate = new Date().toLocaleString();
            
            descArea.value = `Brand: ${brand}\nDiscount Type: ${discountType}\nDiscount Value: ${discountValue}\nLocations: ${locations}\nCreation Date + Time: ${creationDate}`;
        }
        
        async function executeCreateBlazeAutomation() {
            const title = document.getElementById('create-blaze-title')?.value.trim();
            const type = document.getElementById('create-blaze-type')?.value;
            const description = document.getElementById('create-blaze-description')?.value.trim();
            
            if (!title) {
                alert('Please enter a title');
                return;
            }
            
            if (!type) {
                alert('Please select a discount type');
                return;
            }
            
            // Check for duplicate names in Blaze
            const existingPromo = blazeModalData.allPromotions.find(p => 
                (p.Name || '').toLowerCase() === title.toLowerCase()
            );
            
            if (existingPromo) {
                const userChoice = confirm(
                    `A discount with the name "${title}" already exists in Blaze.\n\n` +
                    `Do you want to:\n` +
                    `- OK: Select the existing discount\n` +
                    `- Cancel: Continue creating with a modified name`
                );
                
                if (userChoice) {
                    // User chose to use existing - add it to queue
                    if (!blazeModalData.selectedTitles.includes(title)) {
                        blazeModalData.selectedTitles.push(title);
                        renderBlazeQueue();
                    }
                    document.getElementById('create-blaze-overlay').remove();
                    return;
                } else {
                    // User wants to create anyway - ask for note
                    const note = prompt('Enter a note to append to the title (e.g., "v2", "2025"):', 'v2');
                    if (note) {
                        document.getElementById('create-blaze-title').value = `${title} ${note}`;
                        return; // Don't proceed, let user review and click Create again
                    } else {
                        return; // User cancelled
                    }
                }
            }
            
            // Proceed with automation
            console.log('[CREATE-BLAZE] Starting automation...');
            console.log('[CREATE-BLAZE] Title:', title);
            console.log('[CREATE-BLAZE] Type:', type);
            console.log('[CREATE-BLAZE] Description:', description);
            
            try {
                // Call backend to execute Blaze automation
                const response = await fetch('/api/blaze/create-discount', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ title, type, description })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert('Discount creation started in Blaze!\n\nThe title has been filled in. Please complete the remaining fields manually.');
                    document.getElementById('create-blaze-overlay').remove();
                } else {
                    alert('Error starting automation: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('[CREATE-BLAZE] Error:', error);
                alert('Error communicating with server: ' + error.message);
            }
        }

        function displayAuditResults(resultsObj) {
            const containerId = 'audit-results';
            const titles = {'weekly': ' WEEKLY DEALS', 'monthly': ' MONTHLY DEALS', 'sale': ' SALE DEALS'};
            
            // Count items per section
            const counts = {
                weekly: (resultsObj.weekly || []).length,
                monthly: (resultsObj.monthly || []).length,
                sale: (resultsObj.sale || []).length
            };
            
            // Header
            let headerHtml = '<h3>Audit Results</h3>';
            headerHtml += generateDealTypeTabsHTML(containerId, counts);
            
            // Build content for each section
            const sectionContents = {};
            
            ['weekly', 'monthly', 'sale'].forEach(key => {
                const results = resultsObj[key] || [];
                let sectionHtml = '';
                
                sectionHtml += `<h5 class="mt-2 border-bottom pb-2">${titles[key]} (${results.length} Items)</h5>`;
                
                if (results.length === 0) {
                    sectionHtml += '<p class="text-muted">No data.</p>';
                } else {
                    sectionHtml += '<div class="scrollable-table-container" style="max-height:500px;">';
                    sectionHtml += '<table class="table table-sm"><thead>';
                    sectionHtml += '<tr><th>Row</th><th>MIS ID</th><th>Brand</th><th>Weekday</th><th>Notes</th><th>Deal Info</th><th>Discount</th><th>Vendor %</th><th>Locations</th><th>Categories</th><th>Status</th><th>Issues</th><th>Action</th></tr>';
                    sectionHtml += '</thead><tbody>';
                    
                    const renderedGroups = new Set();
                    
                    results.forEach((r, idx) => {
                        const isGrouped = r.multi_day_group !== null && r.multi_day_group !== undefined;
                        const isFirstInGroup = isGrouped && r.multi_day_group.is_first;
                        const groupId = isGrouped ? r.multi_day_group.group_id : null;
                        
                        if (isGrouped && !isFirstInGroup) return;
                        
                        if (isGrouped && isFirstInGroup) {
                            renderedGroups.add(groupId);
                            const groupData = r.multi_day_group;
                            const hasMissingWeekday = groupData.has_missing_weekday;
                            const warningIcon = hasMissingWeekday ? '<span class="weekday-missing-icon">[!] [EMOJI][EMOJI] </span>' : '';
                            
                            sectionHtml += `<tr class="group-header-row" onclick="toggleGroup('${groupId}')" title="Click to collapse/expand">`;
                            sectionHtml += `<td colspan="13">`;
                            sectionHtml += `<span class="group-toggle-icon" id="toggle-${groupId}">->[EMOJI]</span>`;
                            sectionHtml += `${warningIcon}<strong>${r.brand}</strong>`;
                            sectionHtml += `<span class="multi-day-badge">&#x3030;[EMOJI][EMOJI][EMOJI][EMOJI] ${groupData.total_days}-Day Deal</span>`;
                            sectionHtml += ` (Rows: ${groupData.row_numbers.join(', ')})`;
                            sectionHtml += `</td></tr>`;
                            
                            const groupResults = results.filter(gr => 
                                gr.multi_day_group && gr.multi_day_group.group_id === groupId
                            );
                            
                            groupResults.forEach((gr) => {
                                const grIdx = results.indexOf(gr);
                                sectionHtml += renderAuditRow(gr, grIdx + key, groupId, hasMissingWeekday);
                            });
                            
                        } else {
                            sectionHtml += renderAuditRow(r, idx + key, null, false);
                        }
                    });
                    
                    sectionHtml += '</tbody></table></div>';
                }
                
                sectionContents[key] = sectionHtml;
            });
            
            // Build the "All Deals" view (stacked)
            let allHtml = sectionContents.weekly + sectionContents.monthly + sectionContents.sale;
            
            // Build final HTML with containers
            let finalHtml = headerHtml;
            finalHtml += `<div id="${containerId}-weekly" class="deal-type-content">${sectionContents.weekly}</div>`;
            finalHtml += `<div id="${containerId}-monthly" class="deal-type-content">${sectionContents.monthly}</div>`;
            finalHtml += `<div id="${containerId}-sale" class="deal-type-content">${sectionContents.sale}</div>`;
            finalHtml += `<div id="${containerId}-all" class="deal-type-content active" style="display:block;">${allHtml}</div>`;
            
            document.getElementById('audit-results').innerHTML = finalHtml;
        }

// ============================================
// SEARCH ENHANCEMENT: Click-to-Search
// ============================================
function setupSearchEnhancements() {
    // Find all search inputs
    document.querySelectorAll('input[type="search"]').forEach(searchInput => {
        // Check if there's a button/icon next to it
        const parent = searchInput.parentElement;
        
        // Look for magnifying glass icon (common patterns)
        const searchIcon = parent.querySelector('.bi-search, .fa-search, [class*="search-icon"]');
        
        if (searchIcon) {
            searchIcon.style.cursor = 'pointer';
            searchIcon.addEventListener('click', function() {
                // Trigger ENTER key on the search input
                const enterEvent = new KeyboardEvent('keypress', {
                    key: 'Enter',
                    code: 'Enter',
                    keyCode: 13,
                    which: 13,
                    bubbles: true
                });
                searchInput.dispatchEvent(enterEvent);
                
                // Also trigger change event for DataTables
                searchInput.dispatchEvent(new Event('input', { bubbles: true }));
            });
        }
        
        // Add ENTER key handler if not already present
        if (!searchInput.dataset.enterHandlerAdded) {
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Trigger search
                    this.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
            searchInput.dataset.enterHandlerAdded = 'true';
        }
    });
    
    // Find all buttons near search inputs
    document.querySelectorAll('button').forEach(btn => {
        const btnText = btn.textContent.trim().toLowerCase();
        if (btnText.includes('search') || btnText.includes('filter')) {
            const nearbySearch = btn.parentElement?.querySelector('input[type="search"]') ||
                                btn.closest('.filter-group')?.querySelector('input[type="search"]');
            
            if (nearbySearch) {
                btn.style.cursor = 'pointer';
                btn.addEventListener('click', function() {
                    const enterEvent = new KeyboardEvent('keypress', {
                        key: 'Enter',
                        code: 'Enter',
                        keyCode: 13,
                        which: 13,
                        bubbles: true
                    });
                    nearbySearch.dispatchEvent(enterEvent);
                    nearbySearch.dispatchEvent(new Event('input', { bubbles: true }));
                });
            }
}
    });
}

// ============================================
        // AUTO-LOAD CREDENTIALS
        // ============================================
        async function autoLoadCredentials() {
            try {
                const response = await fetch('/api/get-credentials');
                const data = await response.json();
                
                if (data.success && data.credentials) {
                    const creds = data.credentials;
                    
                    // Auto-fill MIS credentials
                    if (creds.mis) {
                        document.getElementById('mis-username').value = creds.mis.username || '';
                        document.getElementById('mis-password').value = creds.mis.password || '';
                        console.log('[AUTO-FILL] MIS credentials loaded');
                    }
                    
                    // Auto-fill Blaze credentials
                    if (creds.blaze) {
                        document.getElementById('blaze-email').value = creds.blaze.email || '';
                        document.getElementById('blaze-password').value = creds.blaze.password || '';
                        console.log('[AUTO-FILL] Blaze credentials loaded');
                    }
                    
                    // Auto-fill and load Google Sheet
                    if (creds.google_sheet && creds.google_sheet.default_url) {
                        const urlInput = document.getElementById('mis-sheet-url');
                        urlInput.value = creds.google_sheet.default_url;
                        console.log('[AUTO-FILL] Google Sheet URL loaded');
                        
                        // Auto-trigger load tabs
                        setTimeout(function() {
                            autoLoadSheetTabs();
                        }, 2000); // Wait 2 seconds after auth
                    }
                }
            } catch (error) {
                console.log('[INFO] No credentials config found (this is optional)');
            }
        }
        
        async function autoLoadSheetTabs() {
            const urlInput = document.getElementById('mis-sheet-url');
            const url = urlInput.value;
            
            if (!url) return;
            
            console.log('[AUTO-LOAD] Loading sheet tabs...');
            
            try {
                const response = await fetch('/api/mis/load-sheet', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({url: url})
                });
                const data = await response.json();
                
                if (data.success) {
                    misData.allLoadedTabs = data.tabs;
                    // v12.1: Store spreadsheet ID globally for goToSheetRow
                    window.globalSpreadsheetId = data.spreadsheet_id || '';
                    renderTabOptions();
                    if (document.getElementById('mis-tab').options.length > 0) {
                        misData.tabName = document.getElementById('mis-tab').value;
                    }
                    console.log('[AUTO-LOAD] Sheet tabs loaded successfully');
                } else {
                    console.log('[AUTO-LOAD] Failed to load sheet tabs:', data.error);
                }
            } catch (error) {
                console.log('[AUTO-LOAD] Error loading sheet tabs:', error.message);
            }
        }

async function autoAuthenticateGoogle() {
            console.log('[AUTO-AUTH] Attempting Google Sheets authentication...');
            
            try {
                // Wait for browser to be ready
                let attempts = 0;
                while (!document.getElementById('browser-ready-text').textContent.includes('Ready') && attempts < 10) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    attempts++;
                }
                
                const response = await fetch('/api/auth', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('auth-status').innerHTML = '<p class="alert alert-success">[OK] Auto-authenticated successfully!</p>';
                    console.log('[AUTO-AUTH] Google Sheets authenticated');
                } else {
                    document.getElementById('auth-status').innerHTML = '<p class="alert alert-warning">[!] [EMOJI][EMOJI]  Auto-auth failed. Please authenticate manually.</p>';
                    console.log('[AUTO-AUTH] Failed:', data.error);
                }
            } catch (error) {
                console.log('[AUTO-AUTH] Error:', error.message);
            }
        }

        // ============================================
        // DATATABLE SEARCH: Add Search Button
        // ============================================
        function enhanceDataTableSearch() {
            // Wait for DataTable to exist
            if ($.fn.DataTable && $.fn.DataTable.isDataTable('#promotionsTable')) {
                const table = $('#promotionsTable').DataTable();
                
                // Find the DataTables search input (auto-generated)
                const dtSearch = $('.dataTables_filter input[type="search"]');
                
                if (dtSearch.length > 0) {
                    // Check if button already exists
                    if (!dtSearch.next('.search-trigger-btn').length) {
                        // Create search button
                        const searchBtn = $('<button>')
                            .addClass('btn btn-sm btn-primary search-trigger-btn')
                            .html('<i class="bi bi-search"></i>')
                            .css({
                                'marginLeft': '5px',
                                'padding': '4px 12px'
                            })
                            .on('click', function() {
                                const searchValue = dtSearch.val();
                                table.search(searchValue).draw();
                            });
                        
                        // Insert button after search input
                        dtSearch.after(searchBtn);
                        
                        console.log('[SEARCH] DataTable search button added');
                    }
                }
            }
        }

        function renderAuditRow(r, idx, groupId, hasMissingWeekday) {
            const statusClass = r.status.includes('MATCH') ? 'status-match' : 
                               r.status.includes('NOT FOUND') ? 'status-error' : 'status-warning';
            
            const rowBtn = renderRowButton(r.google_row);
            const brandCell = renderBrandCell(r.brand, idx, 'audit');
            const misIdCell = renderMisIdCell(r.mis_id, r);  // Pass full row data for validation
            
            let weekdayDisplay = r.weekday || '-';
            if (!r.weekday || r.weekday.trim() === '') {
                weekdayDisplay = '<span class="weekday-missing-icon">[!] [EMOJI][EMOJI] </span><span style="color:#dc3545; font-style:italic;">MISSING</span>';
            }
            
            const hasDiscrepancies = r.discrepancies && r.discrepancies.length > 0;
            let reviewBtn = '-';
            if (hasDiscrepancies && !(hasMissingWeekday && (!r.weekday || r.weekday.trim() === ''))) {
                reviewBtn = `<button class="btn-review" onclick="reviewDiscrepancy('${r.mis_id}', ${r.google_row})">Review</button>`;
            }
            
            const truncate = (text, len) => {
                if (!text) return '-';
                text = String(text);
                return text.length > len ? text.substring(0, len) + '...' : text;
            };
            
            // v12.1: Format locations with numbered list for tooltip
            const formatLocationsNumbered = (locStr) => {
                if (!locStr || locStr === '-') return '-';
                const locs = locStr.split(',').map(l => l.trim()).filter(l => l);
                return locs.map((loc, i) => (i + 1) + '. ' + loc).join('&#10;');
            };
            const locationsTooltip = formatLocationsNumbered(r.locations);
            
            const rowClass = groupId ? `group-member-row group-${groupId}` : '';
            const warningClass = (hasMissingWeekday && (!r.weekday || r.weekday.trim() === '')) ? 'missing-weekday-warning' : '';
            
            // --- YELLOW BACKGROUND LOGIC ---
            // If this row is part of a group, force the background color to yellow
            const bgStyle = groupId ? 'style="background-color: #fff3cd !important;"' : '';
            
            return `<tr id="audit-row-${idx}" class="${rowClass} ${warningClass}" ${bgStyle}>
                <td>${rowBtn}</td>
                <td>${misIdCell}</td>
                <td>${brandCell}</td>
                <td>${weekdayDisplay}</td>
                <td title="${r.special_notes}">${truncate(r.special_notes, 15)}</td>
                <td title="${r.deal_info}">${truncate(r.deal_info, 15)}</td>
                <td>${r.discount}%</td>
                <td>${r.vendor_contrib}%</td>
                <td title="${locationsTooltip}">${truncate(r.locations, 25)}</td>
                <td title="${r.categories}">${truncate(r.categories, 15)}</td>
                <td><span class="status-badge ${statusClass}">${r.status}</span></td>
                <td>${r.discrepancies.join('<br>') || '-'}</td>
                <td>${reviewBtn}</td>
            </tr>`;
        }

        async function reviewDiscrepancy(misId, googleRow) {
            const btn = event.target;
            const originalText = btn.innerText;
            btn.innerText = '...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/mis/review-discrepancy', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ mis_id: misId, google_row: googleRow })
                });
                const data = await response.json();
                if (!data.success) {
                    alert('Error: ' + data.error);
                }
            } catch (e) {
                alert('Error: ' + e.message);
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        async function authenticateGoogle() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Authenticating...';
            
            try {
                const response = await fetch('/api/auth', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('auth-status').innerHTML = '<p class="alert alert-success">[OK] Success!</p>';
                } else {
                    document.getElementById('auth-status').innerHTML = '<p class="alert alert-error">Error: ' + data.error + '</p>';
                }
            } catch (error) {
                document.getElementById('auth-status').innerHTML = '<p class="alert alert-error">Error: ' + error.message + '</p>';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Authenticate Google Sheets';
            }
        }

        async function loadMISSheetTabs() {
            const url = document.getElementById('mis-sheet-url').value;
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const response = await fetch('/api/mis/load-sheet', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({url: url})
                });
                const data = await response.json();
                
                if (data.success) {
                    misData.allLoadedTabs = data.tabs;
                    // v12.1: Store spreadsheet ID globally for goToSheetRow
                    window.globalSpreadsheetId = data.spreadsheet_id || '';
                    renderTabOptions();
                    if (document.getElementById('mis-tab').options.length > 0) {
                        misData.tabName = document.getElementById('mis-tab').value;
                    }
                } else {
                    alert('Error: ' + data.error);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Load Tabs';
            }
        }

        function renderTabOptions() {
            const select = document.getElementById('mis-tab');
            const showAll = document.getElementById('mis-show-all-tabs').checked;
            const currentSelection = select.value;
            
            const filteredTabs = showAll ? misData.allLoadedTabs : misData.allLoadedTabs.filter(tab => {
                const parts = tab.trim().split(' ');
                if (parts.length !== 2) return false;
                const month = parts[0].toLowerCase();
                const year = parts[1];
                return VALID_MONTHS.includes(month) && /^\d{4}$/.test(year);
            });
            
            if (filteredTabs.length === 0) {
                select.innerHTML = '<option value="">-- No matching tabs --</option>';
            } else {
                select.innerHTML = filteredTabs.map(t => `<option value="${t}">${t}</option>`).join('');
            }
            
            if (currentSelection && filteredTabs.includes(currentSelection)) {
                select.value = currentSelection;
            } else if (filteredTabs.length > 0) {
                select.value = filteredTabs[0];
            }
        }

        async function initializeSheetPage(btnElement) {
            const tab = document.getElementById('mis-tab').value;
            if (!tab) {
                alert('Select a tab first');
                return;
            }
            
            // Use the passed element
            const btn = btnElement;
            
            btn.disabled = true;
            btn.textContent = 'Opening...';
            
            try {
                const response = await fetch('/api/mis/init-sheet-page', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({tab: tab})
                });
                const data = await response.json();
                
                // Alert result
                if (data.success) {
                    // Optional: auto-close alert after 2s or just show it
                    alert('[OK] ' + data.message);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Network/Server Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Open Sheet';
            }
        }

function handleMISCSV(input) {
    if (input.files.length > 0) {
        // Manual upload overrides pulled CSV
        misData.csvFile = input.files[0];
        misData.csvFilename = input.files[0].name;
        misData.pulledCSVPath = null; // Clear pulled path
        
        // Re-enable the input
        input.disabled = false;
        input.style.opacity = '1';
        
        document.getElementById('mis-csv-status').innerHTML = `
            <div class="alert alert-info p-2 mb-0" style="font-size: 0.9rem;">
                <strong> Manual Upload:</strong> ${misData.csvFilename}
            </div>
        `;
        
        console.log('[MANUAL-CSV] User uploaded:', misData.csvFilename);
    }
}

        // v10.7: Open MIS Reports folder in file explorer
        async function openMisReportsFolder() {
            try {
                const response = await fetch('/api/open-mis-reports-folder');
                const data = await response.json();
                if (!data.success) {
                    alert('Could not open folder: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }
        
        // v10.7: Load MIS Reports folder path on page load
        async function loadMisReportsFolderPath() {
            try {
                const response = await fetch('/api/get-mis-reports-folder');
                const data = await response.json();
                if (data.success) {
                    document.getElementById('mis-csv-folder-path').innerHTML = 
                        '<i class="bi bi-folder"></i> ' + data.path;
                }
            } catch (e) {
                console.log('Could not load MIS folder path');
            }
        }

        async function pullMisCsv(btn) {
            btn.disabled = true;
            const originalHtml = btn.innerHTML;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
            
            try {
                // Get credentials from Setup tab
                const misUsername = document.getElementById('mis-username').value;
                const misPassword = document.getElementById('mis-password').value;
                
                const response = await fetch('/api/mis/pull-csv', { 
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mis_username: misUsername,
                        mis_password: misPassword
                    })
                });
                const data = await response.json();
                
                if (data.success) {
                    misData.localPath = data.path;
                    misData.csvFile = null; // Auto-pull overrides manual file
                    
                    // Store globally so Matcher and Audit can use it
                    misData.csvFilename = data.filename;
                    misData.pulledCSVPath = data.path;
                    
                    // Clear the file input visually so user knows automation took over
                    // Can't set file input value (security), but create a visual "Active CSV" indicator
                    document.getElementById('mis-csv').value = ''; 
                    document.getElementById('mis-csv-status').innerHTML = `
                        <div class="alert alert-success p-2 mb-0" style="font-size: 0.9rem;">
                            <strong>[OK][EMOJI][EMOJI][EMOJI][EMOJI] Active CSV:</strong> ${data.filename}
                            <br><small class="text-muted">This CSV will be automatically used by ID Matcher and Audit tabs</small>
                        </div>
                    `;

                    // Also disable the file input to show automation is active
                    document.getElementById('mis-csv').disabled = true;
                    document.getElementById('mis-csv').style.opacity = '0.5';
                    
                    console.log('[CSV-PULL] CSV stored and ready for Matcher/Audit tabs');
                    console.log('[CSV-PULL] Filename:', data.filename);
                    console.log('[CSV-PULL] Path:', data.path);
                } else {
                    alert("Pull Failed: " + data.error);
                }
            } catch (e) {
                alert("Network Error: " + e.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalHtml;
            }
        }

        async function initializeAllSystems(btnElement) {
            const btn = btnElement;
            btn.disabled = true;
            btn.textContent = 'Initializing...';
            
            try {
                const response = await fetch('/api/init-all', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mis: {
                            username: document.getElementById('mis-username').value,
                            password: document.getElementById('mis-password').value
                        },
                        blaze: {
                            email: document.getElementById('blaze-email').value,
                            password: document.getElementById('blaze-password').value
                        }
                    })
                });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('init-status').innerHTML = '<p class="alert alert-success">' + data.message + '</p>';
                    
                    if (data.message.includes("Blaze login successful")) {
                        console.log("Triggering ONE-TIME auto-fetch for Blaze...");
                        const blazeBtn = document.querySelector("button[onclick='fetchBlazeData()']");
                        if (blazeBtn) blazeBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Auto-Syncing...';
                        setTimeout(() => { fetchBlazeData(true); }, 5000);
                    }
                } else {
                    document.getElementById('init-status').innerHTML = '<p class="alert alert-error">Error: ' + data.error + '</p>';
                }
            } catch (error) {
                document.getElementById('init-status').innerHTML = '<p class="alert alert-error">Network Error: ' + error.message + '</p>';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Initialize Browser & Login to Both Systems';
            }
        }

            function displayGeneratedCSV(data) {
            const containerId = 'gen-results';
            const sections = data.sections;
            
            const sectionTitles = {
                'weekly': ' WEEKLY DEALS',
                'monthly': ' MONTHLY DEALS',
                'sale': ' SALE DEALS'
            };
            
            // Count items per section
            const counts = {
                weekly: (sections.weekly?.rows || []).length,
                monthly: (sections.monthly?.rows || []).length,
                sale: (sections.sale?.rows || []).length
            };
            
            // Header and download buttons
            let headerHtml = '<h3>Generated MIS CSV (Multi-Section)</h3>';
            headerHtml += '<div style="margin-bottom:20px; display:flex; gap:10px; flex-wrap:wrap;">';
            headerHtml += '<button class="btn btn-success" onclick="downloadCSV(\'all\')"> Download ALL</button>';
            headerHtml += '<button class="btn btn-outline-primary" onclick="downloadCSV(\'weekly\')"> Weekly Only</button>';
            headerHtml += '<button class="btn btn-outline-info" onclick="downloadCSV(\'monthly\')"> Monthly Only</button>';
            headerHtml += '<button class="btn btn-outline-warning" onclick="downloadCSV(\'sale\')"> Sale Only</button>';
            headerHtml += '<button class="btn btn-secondary" onclick="generateCSV()"> Regenerate</button>';
            headerHtml += '<button class="btn btn-purple" style="background:#6f42c1; color:white; border:none;" onclick="generateNewsletterTable()"> Generate Newsletter Table</button>';
            headerHtml += '</div>';
            
            // Generate deal type tabs
            headerHtml += generateDealTypeTabsHTML(containerId, counts);
            
            // Helper function to build a section's HTML
            function buildSectionHTML(secKey) {
                const secData = sections[secKey];
                const rows = secData?.rows || [];
                const title = sectionTitles[secKey];
                let sectionHtml = '';
                
                sectionHtml += `<div class="card mb-4 shadow-sm">`;
                sectionHtml += `<div class="card-header bg-light"><strong>${title}</strong> (${rows.length} rows)</div>`;
                sectionHtml += `<div class="card-body p-0">`;
                
                if (rows.length === 0) {
                    sectionHtml += '<div class="p-3 text-muted">No data in this section.</div>';
                } else {
                    sectionHtml += '<div class="scrollable-table-container" style="max-height:500px;">';
                    sectionHtml += '<table class="table table-sm table-striped mb-0" style="font-size:0.85em; border-collapse: separate; border-spacing: 0;">';
                    sectionHtml += '<thead style="position:sticky; top:0; z-index:5; background:white;"><tr>';
                    sectionHtml += '<th style="width:40px;">[OK]</th><th>Weekday</th><th>Brand</th><th>Linked</th><th>Notes</th><th>Info</th><th>Disc</th><th>Vend%</th><th>Store</th><th>Cat</th><th>Type</th><th>Flag</th>';
                    sectionHtml += '</tr></thead><tbody>';
                    
                    rows.forEach(r => {
                        const isMultiDay = r.MULTI_DAY_FLAG !== 'NO';
                        const isSplit = r.SPLIT_GROUP_ID && r.SPLIT_GROUP_ID !== "";
                        
                        let bgStyle = '';
                        if (isMultiDay) bgStyle = 'background:#fff3cd;'; 
                        if (isSplit) bgStyle = 'background:#e2e3e5;';    
                        
                        let borderStyle = 'border-bottom: 1px solid #dee2e6;';
                        if (isSplit) {
                            const borderColor = '#6c757d'; 
                            const borderWidth = '2px';
                            borderStyle = `border-left: ${borderWidth} solid ${borderColor}; border-right: ${borderWidth} solid ${borderColor};`;
                            if (r.ROW_UI_CLASS === 'split-group-start') {
                                borderStyle += `border-top: ${borderWidth} solid ${borderColor}; border-bottom: 1px dotted #ccc;`;
                            } else if (r.ROW_UI_CLASS === 'split-group-end') {
                                borderStyle += `border-bottom: ${borderWidth} solid ${borderColor};`;
                            } else {
                                borderStyle += `border-bottom: 1px dotted #ccc;`;
                            }
                        }

                        const checkboxCellStyle = 'border-bottom: 1px solid #dee2e6; background: #fff; text-align: center; vertical-align: middle;';

                        let weekdayHtml = r.Weekday;
                        const days = r.Weekday.split(', ');
                        if (days.length > 4) {
                            const chunks = [];
                            for (let i = 0; i < days.length; i += 4) {
                                chunks.push(days.slice(i, i + 4).join(', '));
                            }
                            weekdayHtml = chunks.join(',<br>');
                        }

                        const buildCellContent = (dataArray, keyName) => {
                            if (!dataArray || dataArray.length === 0) return { display: '<span style="color:#ccc;">-</span>', tooltip: '' };
                            const firstVal = dataArray[0][keyName]; 
                            const truncated = firstVal.length > 25 ? firstVal.substring(0, 22) + '...' : firstVal;
                            let display = dataArray.length > 1 ? `<span style="font-weight:500;">${truncated} <span style="color:#667eea; font-weight:bold;">(...)</span></span>` : `<span>${truncated}</span>`;
                            const lines = dataArray.map(item => `<strong>Row ${item.row} (${item.day}):</strong> ${item[keyName]}`);
                            const tooltip = lines.join('<br>').replace(/"/g, '&quot;');
                            return { display: display, tooltip: tooltip };
                        };

                        const notesObj = buildCellContent(r.UI_SPECIAL_NOTES, 'note');
                        const infoObj = buildCellContent(r.UI_DEAL_INFO, 'info');

                        let rebateDisplay = r.UI_REBATE_DISPLAY;
                        let rebateStyle = borderStyle;
                        if (rebateDisplay === 'Retail') rebateStyle += ' color:#dc3545; font-weight:bold;';
                        else if (rebateDisplay === 'Wholesale') rebateStyle += ' color:#198754; font-weight:500;';

                        const locRaw = r.DISPLAY_STORE || r.Store || '-';
                        let locHtml = locRaw;
                        let locStyle = '';
                        if (locRaw === 'All Locations') {
                            locStyle = 'color: #28a745; font-weight: bold;';
                        } else if (String(locRaw).startsWith('All Locations Except')) {
                            locStyle = 'color: #dc3545; font-weight: bold;';
                            const match = locRaw.match(/: (.*)/);
                            if (match) {
                                const parts = match[1].split(',').map(s => s.trim());
                                if (parts.length > 2) locHtml = `All Locations Except: ${parts[0]}, ${parts[1]}...`;
                            }
                        } else {
                            const parts = String(locRaw).split(',').map(s => s.trim());
                            if (parts.length > 2) locHtml = `${parts[0]}, ${parts[1]}...`;
                        }

                        let flagContent = r.MULTI_DAY_FLAG;
                        if (isMultiDay && flagContent.includes('YES')) {
                            flagContent = flagContent.replace('YES (', 'YES<br>(');
                        }

                        const flagBadge = isMultiDay 
                            ? `<span style="background:#ffc107; padding:4px 8px; border-radius:12px; font-size:0.75em; font-weight:bold; display:inline-block; text-align:center; line-height:1.1;">&#x3030;[EMOJI][EMOJI][EMOJI][EMOJI] ${flagContent}</span>`
                            : '<span style="color:#999;">-</span>';
                        
                        const displayCat = r.DISPLAY_CATEGORY || r.Category || '-';

                        let warningEmoji = '';
                        const rebateType = r.UI_REBATE_DISPLAY || r['Rebate type'] || '';
                        if (rebateType === 'Retail') {
                            warningEmoji = '<span style="font-size:1.2em; margin-right:5px;" title="Retail Rebate Reporting">[EMOJI][EMOJI][EMOJI][EMOJI]</span>';
                        } else if (!rebateType || rebateType.trim() === '') {
                            warningEmoji = '<span style="font-size:1.2em; margin-right:5px;" title="Wholesale/Retail Value = BLANK">[!] [EMOJI][EMOJI] </span>';
                        }

                        sectionHtml += `<tr style="${bgStyle}">`;
                        sectionHtml += `<td style="${checkboxCellStyle}">${warningEmoji}<input type="checkbox" style="cursor: pointer; width: 18px; height: 18px;"></td>`;
                        sectionHtml += `<td style="${borderStyle} white-space:nowrap;"><strong>${weekdayHtml}</strong></td>`;
                        sectionHtml += `<td style="${borderStyle} font-weight:bold;">${r.Brand}</td>`;
                        sectionHtml += `<td style="${borderStyle} color:#666;">${r['Linked Brand (if applicable)'] || '-'}</td>`;
                        sectionHtml += `<td style="${borderStyle} cursor:help;" data-bs-toggle="tooltip" data-bs-html="true" title="${notesObj.tooltip}">${notesObj.display}</td>`;
                        sectionHtml += `<td style="${borderStyle} cursor:help;" data-bs-toggle="tooltip" data-bs-html="true" title="${infoObj.tooltip}">${infoObj.display}</td>`;
                        sectionHtml += `<td style="${borderStyle}">${r['Daily Deal Discount']}%</td>`;
                        sectionHtml += `<td style="${borderStyle}">${r['Discount paid by vendor']}%</td>`;
                        sectionHtml += `<td style="${borderStyle} ${locStyle}" title="${locRaw}">${locHtml}</td>`;
                        sectionHtml += `<td style="${borderStyle}">${displayCat}</td>`;
                        sectionHtml += `<td style="${rebateStyle}">${rebateDisplay}</td>`;
                        sectionHtml += `<td style="${borderStyle}">${flagBadge}</td>`;
                        sectionHtml += `</tr>`;
                    });
                    
                    sectionHtml += '</tbody></table></div>';
                }
                sectionHtml += '</div></div>';
                return sectionHtml;
            }
            
            // Build content for each section
            const sectionContents = {
                weekly: buildSectionHTML('weekly'),
                monthly: buildSectionHTML('monthly'),
                sale: buildSectionHTML('sale')
            };
            
            // Build the "All Deals" view (stacked)
            let allHtml = sectionContents.weekly + sectionContents.monthly + sectionContents.sale;
            
            // Build final HTML with containers
            let finalHtml = headerHtml;
            finalHtml += `<div id="${containerId}-weekly" class="deal-type-content">${sectionContents.weekly}</div>`;
            finalHtml += `<div id="${containerId}-monthly" class="deal-type-content">${sectionContents.monthly}</div>`;
            finalHtml += `<div id="${containerId}-sale" class="deal-type-content">${sectionContents.sale}</div>`;
            finalHtml += `<div id="${containerId}-all" class="deal-type-content active" style="display:block;">${allHtml}</div>`;
            
            document.getElementById('gen-results').innerHTML = finalHtml;
            
            setTimeout(function() {
                const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
                tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl);
                });
            }, 500);
        }

        async function generateCSV() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Generating...';
            
            try {
                const tab = document.getElementById('mis-tab').value;
                const response = await fetch('/api/mis/generate-csv', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({tab: tab})
                });
                const data = await response.json();
                
                if (data.success) {
                    displayGeneratedCSV(data);
                } else {
                    alert('Error: ' + data.error);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Generate CSV';
            }
        }

        async function downloadCSV(type = 'all') {
            window.location.href = `/api/mis/download-csv?type=${type}`;
        }

        async function generateNewsletterTable() {
            // Generate Newsletter files (Excel + DOCX) and save to REPORTS/Newsletter folder
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Generating...';
            
            try {
                const response = await fetch('/api/mis/generate-newsletter', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Show success message with folder path
                    const folderPath = data.folder;
                    const counts = data.counts;
                    
                    let message = '[OK][EMOJI] Newsletter files generated successfully!\\n\\n';
                    message += ' Saved to:\\n' + folderPath + '\\n\\n';
                    message += ' Files created:\\n';
                    if (data.files.excel) message += '  &#x2022; Excel (6 tabs)\\n';
                    if (data.files.club420_docx) message += '  &#x2022; CLUB420_Newsletter.docx\\n';
                    if (data.files.tat_legacy_docx) message += '  &#x2022; TAT_LEGACY_Newsletter.docx\\n';
                    message += '\\n[EMOJI] Deal counts:\\n';
                    message += '  CLUB420: Weekly=' + counts.club420.weekly + ', Monthly=' + counts.club420.monthly + ', Sale=' + counts.club420.sale + '\\n';
                    message += '  TAT LEGACY: Weekly=' + counts.tat_legacy.weekly + ', Monthly=' + counts.tat_legacy.monthly + ', Sale=' + counts.tat_legacy.sale;
                    
                    alert(message);
                } else {
                    alert('Error: ' + (data.error || 'Failed to generate newsletter'));
                }
            } catch (error) {
                alert('Network Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }

    async function runMatcher() {
    const tab = document.getElementById('mis-tab').value;
    if (!tab) {
        alert('Please select a sheet tab in Setup first');
        return;
    }
    // Note: Removed csvFile check - backend will handle both uploaded and pulled CSV
            
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Running...';
            
            const focusEnabled = document.getElementById('matcher-focus-enable').checked;
            const focusDate = document.getElementById('matcher-focus-date').value;
            const expandMonth = document.getElementById('matcher-focus-expand').checked;

            if (focusEnabled && !focusDate) {
                alert("Please select a date for Focus mode.");
                btn.disabled = false; btn.textContent = 'Run Matcher';
                return;
            }

            const formData = new FormData();
            formData.append('tab', tab);
            
            // ATTACH FILE OR PATH (Updated logic)
            if (misData.csvFile) {
                formData.append('csv', misData.csvFile);
            } else if (misData.localPath) {
                formData.append('local_csv_path', misData.localPath);
            }

            formData.append('focus_enabled', focusEnabled);
            formData.append('focus_date', focusDate);
            formData.append('expand_month', expandMonth);
            
            try {
                const response = await fetch('/api/mis/match', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (data.success) {
                    matchesData = data.matches; 
                    displayMatchResults(data.matches);
                    // v12.5: Reset apply buttons visibility after new matcher run
                    approvedMatches = {};
                    updateApplyButtonsVisibility();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch(e) { alert(e); } 
            finally {
                btn.disabled = false;
                btn.textContent = 'Run Matcher';
            }
        }

        // ============================================
        // v12.1: ID Matcher Subtab Switching
        // ============================================
        function switchIdMatcherSubTab(tabName, clickedElement) {
            // Hide all subtab content
            document.querySelectorAll('.id-matcher-subtab-content').forEach(el => {
                el.style.display = 'none';
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('#idMatcherSubTabs .nav-link').forEach(el => {
                el.classList.remove('active');
            });
            
            // Show selected subtab
            const targetEl = document.getElementById('id-matcher-subtab-' + tabName);
            if (targetEl) {
                targetEl.style.display = 'block';
            }
            
            // Add active class to clicked tab
            if (clickedElement) {
                clickedElement.classList.add('active');
            }
        }

        // ============================================
        // v12.1: MAudit - Google Sheet vs MIS CSV Verification
        // ============================================
        async function runMAudit() {
            const statusEl = document.getElementById('maudit-status');
            const resultsEl = document.getElementById('maudit-results');
            
            statusEl.textContent = 'Running verification...';
            resultsEl.innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary"></div><div class="mt-2">Verifying deals against MIS CSV...</div></div>';
            
            try {
                const tab = document.getElementById('mis-tab').value;
                if (!tab) {
                    alert('Please select a sheet tab in Setup first');
                    statusEl.textContent = '';
                    resultsEl.innerHTML = '<p class="text-muted">Select a sheet tab first.</p>';
                    return;
                }
                
                const formData = new FormData();
                formData.append('tab', tab);
                
                if (misData.csvFile) {
                    formData.append('csv', misData.csvFile);
                } else if (misData.localPath) {
                    formData.append('local_csv_path', misData.localPath);
                }
                
                const response = await fetch('/api/mis/maudit', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (data.success) {
                    statusEl.textContent = 'Verification complete';
                    renderMAuditResults(data.results);
                } else {
                    statusEl.textContent = 'Error';
                    resultsEl.innerHTML = `<div class="alert alert-danger">Error: ${data.error}</div>`;
                }
            } catch (error) {
                statusEl.textContent = 'Error';
                resultsEl.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        }
        
        function renderMAuditResults(results) {
            const container = document.getElementById('maudit-results');
            
            if (!results || (results.verified.length === 0 && results.mismatches.length === 0 && 
                results.not_found.length === 0 && results.missing_id.length === 0)) {
                container.innerHTML = '<div class="alert alert-info">No results to display. Make sure the sheet has data and MIS CSV is loaded.</div>';
                return;
            }
            
            let html = '';
            
            // Summary stats
            const totalVerified = results.verified?.length || 0;
            const totalMismatches = results.mismatches?.length || 0;
            const totalNotFound = results.not_found?.length || 0;
            const totalMissingId = results.missing_id?.length || 0;
            const total = totalVerified + totalMismatches + totalNotFound + totalMissingId;
            
            html += `<div class="d-flex gap-3 mb-3 flex-wrap">
                <span class="badge bg-success fs-6">Verified: ${totalVerified}</span>
                <span class="badge bg-warning text-dark fs-6">Mismatches: ${totalMismatches}</span>
                <span class="badge bg-danger fs-6">Not Found: ${totalNotFound}</span>
                <span class="badge bg-secondary fs-6">Missing MIS ID: ${totalMissingId}</span>
                <span class="badge bg-dark fs-6">Total: ${total}</span>
            </div>`;
            
            // Missing MIS ID section
            if (results.missing_id && results.missing_id.length > 0) {
                html += `<div class="card mb-3 border-secondary">
                    <div class="card-header bg-secondary text-white">
                        <strong>Missing MIS ID (${results.missing_id.length})</strong>
                        <small class="ms-2">- Deals without MIS IDs in Google Sheet</small>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered mb-0">
                                <thead class="table-light">
                                    <tr><th style="width:60px;">Row</th><th>Section</th><th>Brand</th><th>Day/Dates</th><th>Discount</th><th>Locations</th></tr>
                                </thead>
                                <tbody>`;
                
                results.missing_id.forEach(item => {
                    const sectionBadge = getSectionBadge(item.section);
                    const rowBtn = window.globalSpreadsheetId ? 
                        `<button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${item.row})" title="Go to row ${item.row}">${item.row}</button>` : 
                        item.row;
                    html += `<tr>
                        <td>${rowBtn}</td>
                        <td>${sectionBadge}</td>
                        <td>${item.brand || '-'}</td>
                        <td>${item.weekday || item.start_date || '-'}</td>
                        <td>${item.discount || '-'}</td>
                        <td><small>${item.locations || '-'}</small></td>
                    </tr>`;
                });
                
                html += `</tbody></table></div></div></div>`;
            }
            
            // Not Found in CSV section
            if (results.not_found && results.not_found.length > 0) {
                html += `<div class="card mb-3 border-danger">
                    <div class="card-header bg-danger text-white">
                        <strong>Not Found in CSV (${results.not_found.length})</strong>
                        <small class="ms-2">- MIS IDs not found in uploaded CSV</small>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered mb-0">
                                <thead class="table-light">
                                    <tr><th style="width:60px;">Row</th><th>Section</th><th>Brand</th><th>MIS ID</th><th>Day/Dates</th><th>Discount</th></tr>
                                </thead>
                                <tbody>`;
                
                results.not_found.forEach(item => {
                    const sectionBadge = getSectionBadge(item.section);
                    const rowBtn = window.globalSpreadsheetId ? 
                        `<button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${item.row})" title="Go to row ${item.row}">${item.row}</button>` : 
                        item.row;
                    
                    // Enhanced MIS ID button with row data for validation
                    const rowDataJson = JSON.stringify({
                        brand: item.brand || '',
                        linked_brand: item.linked_brand || '',
                        weekday: item.weekday || '',
                        categories: item.categories || '',
                        discount: item.discount || '',
                        vendor_contrib: item.vendor_contrib || '',
                        locations: item.locations || 'All Locations',
                        rebate_type: item.rebate_type || '',
                        after_wholesale: item.after_wholesale || false
                    }).replace(/"/g, '&quot;');
                    
                    const misIdBtn = item.mis_id ? 
                        `<button class="btn btn-outline-secondary btn-sm py-0 px-2" 
                                 data-row='${rowDataJson}' 
                                 onclick="lookupMisIdWithValidation(this, '${item.mis_id}')"
                                 title="Click to lookup and validate">${item.mis_id}</button>` : '-';
                    html += `<tr>
                        <td>${rowBtn}</td>
                        <td>${sectionBadge}</td>
                        <td>${item.brand || '-'}</td>
                        <td>${misIdBtn}</td>
                        <td>${item.weekday || item.start_date || '-'}</td>
                        <td>${item.discount || '-'}</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div></div></div>`;
            }
            
            // Mismatches section
            if (results.mismatches && results.mismatches.length > 0) {
                html += `<div class="card mb-3 border-warning">
                    <div class="card-header bg-warning text-dark">
                        <strong>Field Mismatches (${results.mismatches.length})</strong>
                        <small class="ms-2">- Deals with field differences between Sheet and CSV</small>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered mb-0">
                                <thead class="table-light">
                                    <tr><th style="width:60px;">Row</th><th>Section</th><th>Brand</th><th>MIS ID</th><th>Match %</th><th>Issues</th></tr>
                                </thead>
                                <tbody>`;
                
                results.mismatches.forEach(item => {
                    const sectionBadge = getSectionBadge(item.section);
                    const rowBtn = window.globalSpreadsheetId ? 
                        `<button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${item.row})" title="Go to row ${item.row}">${item.row}</button>` : 
                        item.row;
                    
                    // Enhanced MIS ID button with row data for validation
                    const rowDataJson = JSON.stringify({
                        brand: item.brand || '',
                        linked_brand: item.linked_brand || '',
                        weekday: item.weekday || '',
                        categories: item.categories || '',
                        discount: item.discount || '',
                        vendor_contrib: item.vendor_contrib || '',
                        locations: item.locations || 'All Locations',
                        rebate_type: item.rebate_type || '',
                        after_wholesale: item.after_wholesale || false
                    }).replace(/"/g, '&quot;');
                    
                    const misIdBtn = item.mis_id ? 
                        `<button class="btn btn-outline-secondary btn-sm py-0 px-2" 
                                 data-row='${rowDataJson}' 
                                 onclick="lookupMisIdWithValidation(this, '${item.mis_id}')"
                                 title="Click to lookup and validate">${item.mis_id}</button>` : '-';
                    const pct = item.match_percent || 0;
                    const pctClass = pct >= 80 ? 'text-success' : pct >= 50 ? 'text-warning' : 'text-danger';
                    const issues = item.issues ? item.issues.join(', ') : '-';
                    html += `<tr>
                        <td>${rowBtn}</td>
                        <td>${sectionBadge}</td>
                        <td>${item.brand || '-'}</td>
                        <td>${misIdBtn}</td>
                        <td class="${pctClass} fw-bold">${pct}%</td>
                        <td><small class="text-danger">${issues}</small></td>
                    </tr>`;
                });
                
                html += `</tbody></table></div></div></div>`;
            }
            
            // Verified section
            if (results.verified && results.verified.length > 0) {
                html += `<div class="card mb-3 border-success">
                    <div class="card-header bg-success text-white">
                        <strong>Verified (${results.verified.length})</strong>
                        <small class="ms-2">- All fields match between Sheet and CSV</small>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered mb-0">
                                <thead class="table-light">
                                    <tr><th style="width:60px;">Row</th><th>Section</th><th>Brand</th><th>MIS ID</th><th>Day/Dates</th><th>Discount</th></tr>
                                </thead>
                                <tbody>`;
                
                results.verified.forEach(item => {
                    const sectionBadge = getSectionBadge(item.section);
                    const rowBtn = window.globalSpreadsheetId ? 
                        `<button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${item.row})" title="Go to row ${item.row}">${item.row}</button>` : 
                        item.row;
                    
                    // Enhanced MIS ID button with row data for validation
                    const rowDataJson = JSON.stringify({
                        brand: item.brand || '',
                        linked_brand: item.linked_brand || '',
                        weekday: item.weekday || '',
                        categories: item.categories || '',
                        discount: item.discount || '',
                        vendor_contrib: item.vendor_contrib || '',
                        locations: item.locations || 'All Locations',
                        rebate_type: item.rebate_type || '',
                        after_wholesale: item.after_wholesale || false
                    }).replace(/"/g, '&quot;');
                    
                    const misIdBtn = item.mis_id ? 
                        `<button class="btn btn-outline-success btn-sm py-0 px-2" 
                                 data-row='${rowDataJson}' 
                                 onclick="lookupMisIdWithValidation(this, '${item.mis_id}')"
                                 title="Click to lookup and validate">${item.mis_id}</button>` : '-';
                    html += `<tr>
                        <td>${rowBtn}</td>
                        <td>${sectionBadge}</td>
                        <td>${item.brand || '-'}</td>
                        <td>${misIdBtn}</td>
                        <td>${item.weekday || item.start_date || '-'}</td>
                        <td>${item.discount || '-'}</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div></div></div>`;
            }
            
            container.innerHTML = html;
        }
        
        function getSectionBadge(section) {
            if (!section) return '';
            const s = section.toLowerCase();
            if (s.includes('week')) return '<span class="badge bg-primary">Weekly</span>';
            if (s.includes('month')) return '<span class="badge bg-success">Monthly</span>';
            if (s.includes('sale')) return '<span class="badge bg-warning text-dark">Sale</span>';
            return `<span class="badge bg-secondary">${section}</span>`;
        }

async function runAudit() {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Running...';

        document.getElementById('audit-results').innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary"></div><div class="mt-2">Auditing Data...</div></div>';

        try {
            // Get current tab selection from dropdown (not stale misData.tabName)
            const currentTab = document.getElementById('mis-tab').value;
            
            if (!currentTab) {
                document.getElementById('audit-results').innerHTML = 
                    '<div class="alert alert-warning">Please select a Google Sheet tab in the Setup section first.</div>';
                return;
            }
            
            const formData = new FormData();
            formData.append('tab', currentTab);

            // Attach CSV if available (same logic as Matcher/Conflict)
            if (misData.csvFile) {
                formData.append('csv', misData.csvFile);
            }

            const response = await fetch('/api/mis/audit', {
                method: 'POST',
                body: formData
            });

            const data = await response.json();

            if (data.success) {
                displayAuditResults(data.results);
            } else {
                document.getElementById('audit-results').innerHTML = 
                    `<div class="alert alert-danger">[X] Error: ${data.error}</div>`;
            }
        } catch (e) {
            document.getElementById('audit-results').innerHTML = 
                `<div class="alert alert-danger">[X] Network Error: ${e.message}</div>`;
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

// ============================================
// v12.25.0: COMPREHENSIVE AUDIT TAB
// ============================================

// Global state for comprehensive audit
let comprehensiveAuditState = {
    deals: [],           // Filtered deals to audit
    currentIndex: 0,     // Current position in sequential audit
    results: {},         // { rowNumber: { status, notes, auditedAt } }
    settings: {
        mode: 'full',    // 'full' or 'custom'
        sections: ['weekly', 'monthly', 'sale'],
        weekdays: [],
        specificDate: null
    },
    auditId: null,
    tabName: '',
    startedAt: null,
    inProgress: false
};

// Toggle audit mode (Full vs Custom)
function toggleAuditMode() {
    const mode = document.querySelector('input[name="auditMode"]:checked').value;
    const customOptions = document.getElementById('customAuditOptions');
    
    comprehensiveAuditState.settings.mode = mode;
    customOptions.style.display = mode === 'custom' ? 'block' : 'none';
}

// Toggle weekend (Sat+Sun) checkboxes
function toggleWeekendAudit() {
    const satCheck = document.getElementById('auditWeekSat');
    const sunCheck = document.getElementById('auditWeekSun');
    const weekendOn = !(satCheck.checked && sunCheck.checked);
    satCheck.checked = weekendOn;
    sunCheck.checked = weekendOn;
}

// Get selected sections from checkboxes
function getSelectedAuditSections() {
    const sections = [];
    if (document.getElementById('auditSectionWeekly').checked) sections.push('weekly');
    if (document.getElementById('auditSectionMonthly').checked) sections.push('monthly');
    if (document.getElementById('auditSectionSale').checked) sections.push('sale');
    return sections;
}

// Get selected weekdays from checkboxes
function getSelectedAuditWeekdays() {
    const weekdays = [];
    document.querySelectorAll('.audit-weekday-check:checked').forEach(cb => {
        weekdays.push(cb.value);
    });
    return weekdays;
}

// Check if a date falls on selected weekdays
function dateMatchesWeekdays(dateStr, selectedWeekdays) {
    if (!dateStr || selectedWeekdays.length === 0) return true;
    
    // Parse date
    const parsed = parseDateString(dateStr);
    if (!parsed) return true;
    
    const date = new Date(parsed.year, parsed.month, parsed.day);
    const dayIndex = date.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
    const dayNames = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
    return selectedWeekdays.includes(dayNames[dayIndex]);
}

// Parse date string to {year, month, day}
function parseDateString(dateStr) {
    if (!dateStr || dateStr === '-' || dateStr === 'N/A') return null;
    // Try YYYY-MM-DD
    let m = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
    if (m) return { year: parseInt(m[1]), month: parseInt(m[2]) - 1, day: parseInt(m[3]) };
    // Try MM/DD/YYYY
    m = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (m) return { year: parseInt(m[3]), month: parseInt(m[1]) - 1, day: parseInt(m[2]) };
    // Try MM/DD/YY
    m = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
    if (m) return { year: 2000 + parseInt(m[3]), month: parseInt(m[1]) - 1, day: parseInt(m[2]) };
    return null;
}

// Check if deal matches weekday filter (applies to all section types)
// v12.25.0: Weekly deals + Specific Date fix
// Weekly deals should be included if:
// 1. Weekly section toggle is ON
// 2. AND deal weekday matches selected weekday toggle (if any)
// NOTE: Weekly deals run every week, so specific date only filters by weekday match
function dealMatchesWeekdayFilter(match, selectedWeekdays) {
    if (selectedWeekdays.length === 0) return true; // No filter = all pass
    
    const section = (match.section || '').toLowerCase();
    
    // Weekly deals: Check weekday field directly
    if (section.includes('weekly')) {
        const dealWeekday = (match.weekday || '').toLowerCase().substring(0, 3);
        return selectedWeekdays.includes(dealWeekday);
    }
    
    // Monthly/Sale deals: The "weekday" column contains day-of-month values like "10th" or "10th, 15th"
    // We need to calculate what weekday those dates fall on for the current tab month
    // NOTE (FUTURE CHANGE): This column format may change - all logic referencing this will need updating
    if (section.includes('monthly') || section.includes('sale')) {
        const weekdayCol = match.weekday || '';
        
        // If it's already a weekday name (Thu, Mon, etc), use it directly
        const weekdayNames = ['mon','tue','wed','thu','fri','sat','sun'];
        const lowerWeekday = weekdayCol.toLowerCase();
        if (weekdayNames.some(d => lowerWeekday.includes(d))) {
            const dealWeekday = lowerWeekday.substring(0, 3);
            return selectedWeekdays.includes(dealWeekday);
        }
        
        // Parse day-of-month values like "10th", "15th", "10th, 15th"
        const dayNumbers = parseDayOfMonthValues(weekdayCol);
        if (dayNumbers.length > 0) {
            // Get current tab's month/year context
            const tabName = document.getElementById('mis-tab')?.value || '';
            const monthYear = parseTabNameToMonthYear(tabName);
            
            if (monthYear) {
                // Check if any of the day-of-month dates fall on a selected weekday
                for (const dayNum of dayNumbers) {
                    const dateObj = new Date(monthYear.year, monthYear.month, dayNum);
                    const dayIndex = dateObj.getDay();
                    const dayName = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'][dayIndex];
                    if (selectedWeekdays.includes(dayName)) {
                        return true;
                    }
                }
                return false; // None of the dates matched selected weekdays
            }
        }
        
        // Fallback: if has start_date, check if that date matches
        if (match.start_date) {
            return dateMatchesWeekdays(match.start_date, selectedWeekdays);
        }
    }
    
    return true;
}

// v12.25.0: Parse day-of-month values from "10th", "15th", "10th, 15th" format
// NOTE (FUTURE CHANGE): This column format may change - update this function when it does
function parseDayOfMonthValues(str) {
    if (!str) return [];
    const dayNumbers = [];
    // Match patterns like "10th", "15th", "1st", "2nd", "3rd", "21st", etc.
    const matches = String(str).match(/(\d{1,2})(?:st|nd|rd|th)?/gi);
    if (matches) {
        matches.forEach(m => {
            const num = parseInt(m.replace(/\D/g, ''), 10);
            if (num >= 1 && num <= 31) {
                dayNumbers.push(num);
            }
        });
    }
    return dayNumbers;
}

// v12.25.0: Parse tab name like "February 2026" to {month: 1, year: 2026}
function parseTabNameToMonthYear(tabName) {
    if (!tabName) return null;
    const months = ['january','february','march','april','may','june','july','august','september','october','november','december'];
    const lower = tabName.toLowerCase();
    
    let monthIndex = -1;
    for (let i = 0; i < months.length; i++) {
        if (lower.includes(months[i])) {
            monthIndex = i;
            break;
        }
    }
    
    const yearMatch = tabName.match(/\d{4}/);
    const year = yearMatch ? parseInt(yearMatch[0], 10) : new Date().getFullYear();
    
    if (monthIndex >= 0) {
        return { month: monthIndex, year: year };
    }
    return null;
}

// v12.25.0: Check if deal matches specific date filter
// Weekly deals: Include if the selected date's weekday matches the deal's weekday
// Monthly/Sale deals: Include if the date falls within the deal's date range OR matches day-of-month
function dealMatchesDateFilter(match, specificDate) {
    if (!specificDate) return true;
    
    const filterDate = new Date(specificDate);
    const section = (match.section || '').toLowerCase();
    
    // For Weekly deals: Check if the specific date falls on the deal's weekday
    if (section.includes('weekly')) {
        const dayIndex = filterDate.getDay();
        const dayNames = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
        const dealWeekday = (match.weekday || '').toLowerCase().substring(0, 3);
        return dealWeekday === dayNames[dayIndex];
    }
    
    // For Monthly/Sale deals: Check both date range AND day-of-month column
    if (section.includes('monthly') || section.includes('sale')) {
        // First check: Does the specific date match a day-of-month value in the weekday column?
        const weekdayCol = match.weekday || '';
        const dayNumbers = parseDayOfMonthValues(weekdayCol);
        const filterDayOfMonth = filterDate.getDate();
        
        if (dayNumbers.length > 0 && dayNumbers.includes(filterDayOfMonth)) {
            return true;
        }
        
        // Second check: Does the date fall within the deal's date range?
        if (match.start_date && match.end_date) {
            const start = parseDateString(match.start_date);
            const end = parseDateString(match.end_date);
            if (start && end) {
                const startDate = new Date(start.year, start.month, start.day);
                const endDate = new Date(end.year, end.month, end.day);
                return filterDate >= startDate && filterDate <= endDate;
            }
        }
    }
    
    return true;
}

// Load deals for audit from matchesData
function loadAuditDeals() {
    // Check if matchesData has been populated
    if (!matchesData || matchesData.length === 0) {
        alert('No deals loaded. Please run the ID Matcher first to load deals.');
        return;
    }
    
    const mode = document.querySelector('input[name="auditMode"]:checked').value;
    const sections = mode === 'custom' ? getSelectedAuditSections() : ['weekly', 'monthly', 'sale'];
    const weekdays = mode === 'custom' ? getSelectedAuditWeekdays() : [];
    const specificDate = mode === 'custom' ? document.getElementById('auditSpecificDate').value : null;
    
    // Update state
    comprehensiveAuditState.settings = { mode, sections, weekdays, specificDate };
    comprehensiveAuditState.tabName = document.getElementById('mis-tab')?.value || 'Unknown';
    
    // Filter deals based on settings
    let filteredDeals = matchesData.filter(match => {
        // Section filter
        const dealSection = (match.section || '').toLowerCase();
        const matchesSection = sections.some(s => dealSection.includes(s));
        if (!matchesSection) return false;
        
        // Weekday filter (Custom mode only)
        if (mode === 'custom' && weekdays.length > 0) {
            if (!dealMatchesWeekdayFilter(match, weekdays)) return false;
        }
        
        // Date filter (Custom mode only)
        if (mode === 'custom' && specificDate) {
            if (!dealMatchesDateFilter(match, specificDate)) return false;
        }
        
        return true;
    });
    
    // Store filtered deals with their original indices
    comprehensiveAuditState.deals = filteredDeals.map((deal, idx) => ({
        ...deal,
        originalIndex: matchesData.indexOf(deal),
        auditIndex: idx
    }));
    
    // Reset audit state
    comprehensiveAuditState.currentIndex = 0;
    comprehensiveAuditState.results = {};
    comprehensiveAuditState.inProgress = false;
    
    // Update UI
    renderAuditOverview();
    
    // Enable buttons
    document.getElementById('startAuditBtn').disabled = filteredDeals.length === 0;
    document.getElementById('exportAuditBtn').disabled = true;
    document.getElementById('auditDealCount').textContent = `${filteredDeals.length} deals loaded`;
    document.getElementById('auditDealCount').className = filteredDeals.length > 0 ? 'badge bg-success fs-6' : 'badge bg-warning fs-6';
    
    // Hide placeholder, show overview
    document.getElementById('auditPlaceholder').style.display = 'none';
    document.getElementById('auditOverviewContainer').style.display = 'block';
    
    // Try to load any saved audit state
    loadAuditStateFromServer();
}

// Render the audit overview table
function renderAuditOverview() {
    const deals = comprehensiveAuditState.deals;
    const results = comprehensiveAuditState.results;
    
    // Count by section
    const counts = { weekly: 0, monthly: 0, sale: 0, total: deals.length };
    deals.forEach(d => {
        const section = (d.section || '').toLowerCase();
        if (section.includes('weekly')) counts.weekly++;
        else if (section.includes('monthly')) counts.monthly++;
        else if (section.includes('sale')) counts.sale++;
    });
    
    // Summary counts
    const summaryHtml = `
        <div class="col-md-3">
            <div class="card text-center border-primary">
                <div class="card-body py-2">
                    <h5 class="card-title mb-0 text-primary">${counts.weekly}</h5>
                    <small class="text-muted">Weekly</small>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card text-center border-success">
                <div class="card-body py-2">
                    <h5 class="card-title mb-0 text-success">${counts.monthly}</h5>
                    <small class="text-muted">Monthly</small>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card text-center border-warning">
                <div class="card-body py-2">
                    <h5 class="card-title mb-0 text-warning">${counts.sale}</h5>
                    <small class="text-muted">Sale</small>
                </div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="card text-center border-dark">
                <div class="card-body py-2">
                    <h5 class="card-title mb-0">${counts.total}</h5>
                    <small class="text-muted">Total</small>
                </div>
            </div>
        </div>
    `;
    document.getElementById('auditSummaryCounts').innerHTML = summaryHtml;
    
    // Table rows
    let tableHtml = '';
    deals.forEach((deal, idx) => {
        const result = results[deal.google_row] || {};
        const auditStatusBadge = getAuditStatusBadge(result.status);
        const section = (deal.section || '').toLowerCase();
        const sectionBadge = section.includes('weekly') ? '<span class="badge bg-primary">W</span>' :
                            section.includes('monthly') ? '<span class="badge bg-success">M</span>' :
                            section.includes('sale') ? '<span class="badge bg-warning text-dark">S</span>' : '';
        
        // Multi-brand indicator
        let brandDisplay = deal.brand || '-';
        if (deal.is_multi_brand) {
            brandDisplay = `<span class="badge bg-info text-dark me-1">${deal.multi_brand_index + 1}/${deal.multi_brand_total}</span> ${brandDisplay}`;
        }
        
        // Linked brand
        const linkedDisplay = deal.linked_brand ? `<small class="text-muted">${deal.linked_brand}</small>` : '-';
        
        // Discount display
        let discountDisplay = '-';
        if (deal.discount !== null && deal.discount !== undefined && deal.discount !== '') {
            discountDisplay = `${deal.discount}%`;
        }
        
        // Vendor display
        let vendorDisplay = '-';
        if (deal.vendor_contrib !== null && deal.vendor_contrib !== undefined && deal.vendor_contrib !== '') {
            vendorDisplay = `${deal.vendor_contrib}%`;
        }
        
        // MIS ID display - v12.25.1: Parse multiple IDs properly
        let misIdDisplay = '<span class="text-muted">No ID</span>';
        if (deal.current_sheet_id) {
            const parsedIds = parseMultipleMisIdsForAudit(deal.current_sheet_id);
            if (parsedIds.length > 0) {
                // Create a button for each MIS ID
                misIdDisplay = parsedIds.map(rawId => {
                    const cleanId = cleanMisIdForAudit(rawId);
                    return `<button class="btn btn-outline-secondary btn-sm py-0 px-1 me-1 mb-1" onclick="lookupMisId('${cleanId}')" style="font-size:0.75em;">${rawId}</button>`;
                }).join('');
            }
        }
        
        // Confidence badge
        const statusClass = deal.status === 'HIGH' ? 'status-high' : deal.status === 'MEDIUM' ? 'status-medium' : 'status-low';
        
        tableHtml += `
            <tr data-audit-idx="${idx}" data-row="${deal.google_row}">
                <td><button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${deal.google_row})">${deal.google_row}</button></td>
                <td>${brandDisplay}</td>
                <td>${linkedDisplay}</td>
                <td>${deal.weekday || '-'}</td>
                <td title="${deal.special_notes || ''}">${(deal.special_notes || '-').substring(0, 15)}${(deal.special_notes || '').length > 15 ? '...' : ''}</td>
                <td title="${deal.deal_info || ''}">${(deal.deal_info || '-').substring(0, 15)}${(deal.deal_info || '').length > 15 ? '...' : ''}</td>
                <td>${discountDisplay}</td>
                <td>${vendorDisplay}</td>
                <td title="${deal.locations || ''}">${(deal.locations || '-').substring(0, 15)}${(deal.locations || '').length > 15 ? '...' : ''}</td>
                <td title="${deal.categories || ''}">${(deal.categories || '-').substring(0, 15)}${(deal.categories || '').length > 15 ? '...' : ''}</td>
                <td><span class="badge ${statusClass}">${deal.status || '-'}</span></td>
                <td>${misIdDisplay}</td>
                <td>${auditStatusBadge}</td>
                <td>
                    <button class="btn btn-outline-primary btn-sm py-0" onclick="showAuditPopup(${idx})" title="Audit this deal">
                        <i class="bi bi-clipboard-check"></i> Audit
                    </button>
                </td>
            </tr>
        `;
    });
    
    document.getElementById('auditDealsTableBody').innerHTML = tableHtml || '<tr><td colspan="14" class="text-center text-muted">No deals match the current filters</td></tr>';
}

// Get badge for audit status
function getAuditStatusBadge(status) {
    if (!status) return '<span class="badge bg-secondary">Pending</span>';
    if (status === 'verified') return '<span class="badge bg-success">Ã¢Å“â€œ Verified</span>';
    if (status === 'attention') return '<span class="badge bg-warning text-dark">Ã¢Å¡Â  Attention</span>';
    if (status === 'skipped') return '<span class="badge bg-secondary">Ã¢ÂÂ­ Skipped</span>';
    return `<span class="badge bg-secondary">${status}</span>`;
}

// Start sequential audit
function startSequentialAudit() {
    const deals = comprehensiveAuditState.deals;
    if (deals.length === 0) {
        alert('No deals to audit.');
        return;
    }
    
    // Confirmation popup
    const confirmMsg = `${deals.length} deals to audit - Ready?`;
    if (!confirm(confirmMsg)) return;
    
    comprehensiveAuditState.inProgress = true;
    comprehensiveAuditState.startedAt = new Date().toISOString();
    comprehensiveAuditState.auditId = 'audit_' + Date.now();
    
    // Find first unaudited deal
    let startIdx = 0;
    for (let i = 0; i < deals.length; i++) {
        if (!comprehensiveAuditState.results[deals[i].google_row]) {
            startIdx = i;
            break;
        }
    }
    
    comprehensiveAuditState.currentIndex = startIdx;
    showAuditPopup(startIdx);
}

// Show audit popup for a specific deal
function showAuditPopup(auditIdx) {
    const deals = comprehensiveAuditState.deals;
    if (auditIdx < 0 || auditIdx >= deals.length) return;
    
    comprehensiveAuditState.currentIndex = auditIdx;
    const deal = deals[auditIdx];
    const results = comprehensiveAuditState.results;
    const existingResult = results[deal.google_row] || {};
    
    // Remove existing popup
    const existingPopup = document.getElementById('comprehensive-audit-popup-overlay');
    if (existingPopup) existingPopup.remove();
    
    // Create overlay
    const overlay = document.createElement('div');
    overlay.id = 'comprehensive-audit-popup-overlay';
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.6); z-index: 9998;
        display: flex; justify-content: center; align-items: center;
    `;
    overlay.onclick = function(e) {
        if (e.target === overlay) {
            if (confirm('Exit audit? Progress will be saved.')) {
                saveAuditProgress();
                overlay.remove();
            }
        }
    };
    
    // Modal sizing
    const screenWidth = window.innerWidth;
    const modalWidth = Math.min(1600, screenWidth - 40);
    
    // Create modal
    const modal = document.createElement('div');
    modal.style.cssText = `
        background: #fff; padding: 0; border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        width: ${modalWidth}px; max-width: 98%; max-height: 90vh;
        overflow-y: auto; z-index: 9999; position: relative;
    `;
    
    // Build popup content
    let html = buildAuditPopupContent(deal, auditIdx, existingResult);
    
    modal.innerHTML = html;
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
}

// Build the content for audit popup (3 sections)
function buildAuditPopupContent(deal, auditIdx, existingResult) {
    const deals = comprehensiveAuditState.deals;
    const totalDeals = deals.length;
    const progress = Math.round(((auditIdx + 1) / totalDeals) * 100);
    
    // Section badge
    const section = (deal.section || '').toLowerCase();
    const sectionBadge = section.includes('weekly') ? '<span class="badge bg-primary me-2">Weekly</span>' :
                        section.includes('monthly') ? '<span class="badge bg-success me-2">Monthly</span>' :
                        section.includes('sale') ? '<span class="badge bg-warning text-dark me-2">Sale</span>' : '';
    
    // v12.25.0: Fixed column widths for alignment between tables
    const colWidths = {
        row: '60px',
        weekday: '80px',
        brand: '140px',
        category: '120px',
        discount: '70px',
        vendor: '70px',
        locations: '120px',
        dealInfo: '130px',
        notes: '100px',
        start: '90px',
        end: '90px',
        action: '60px'
    };
    
    let html = `
        <!-- HEADER with navigation -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px 30px; border-radius: 8px 8px 0 0;">
            <div class="d-flex justify-content-between align-items-center">
                <div style="flex: 1;"></div>
                <div style="flex: 2; text-align: center;">
                    <h3 class="mb-1" style="font-weight: bold;">
                        <i class="bi bi-clipboard-check"></i> Audit: ${deal.brand || 'Unknown Brand'}
                    </h3>
                    <div>${sectionBadge}<small>Row ${deal.google_row} | Deal ${auditIdx + 1} of ${totalDeals}</small></div>
                </div>
                <div style="flex: 1; display: flex; justify-content: flex-end; gap: 10px; align-items: center;">
                    <div class="progress" style="width: 120px; height: 8px;">
                        <div class="progress-bar bg-success" style="width: ${progress}%"></div>
                    </div>
                    <span>${progress}%</span>
                    <button class="btn btn-outline-light btn-sm" onclick="exitAuditPopup()">
                        <i class="bi bi-x-lg"></i> Exit
                    </button>
                </div>
            </div>
        </div>
        
        <div style="padding: 20px;">
    `;
    
    // SECTION 1: Google Sheet Data - aligned columns
    html += `
        <div class="card mb-3 border-primary">
            <div class="card-header bg-primary text-white">
                <strong><i class="bi bi-file-earmark-spreadsheet"></i> Section 1: Google Sheet Data</strong>
            </div>
            <div class="card-body p-2">
                <div style="overflow-x: auto;">
                    <table class="table table-sm table-bordered mb-0" style="font-size: 0.85em; table-layout: fixed;">
                        <thead style="background:#e9ecef; color:#212529;">
                            <tr>
                                <th style="width:${colWidths.row};">Row</th>
                                <th style="width:${colWidths.weekday};">Weekday</th>
                                <th style="width:${colWidths.brand};">Brand / Linked</th>
                                <th style="width:${colWidths.category};">Category</th>
                                <th style="width:${colWidths.discount};">Discount</th>
                                <th style="width:${colWidths.vendor};">Vendor</th>
                                <th style="width:${colWidths.locations};">Locations</th>
                                <th style="width:${colWidths.dealInfo};">Deal Info</th>
                                <th style="width:${colWidths.notes};">Notes</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="background: #e7f1ff;">
                                <td><button class="btn btn-sm btn-outline-primary py-0 px-2" onclick="openSheetRow(${deal.google_row})">${deal.google_row}</button></td>
                                <td><strong>${deal.weekday || '-'}</strong></td>
                                <td><strong>${deal.brand || '-'}</strong>${deal.linked_brand ? '<br><small class="text-muted">' + deal.linked_brand + '</small>' : ''}</td>
                                <td title="${deal.categories || ''}" style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${deal.categories || '-'}</td>
                                <td><strong>${deal.discount !== null && deal.discount !== '' ? deal.discount + '%' : '-'}</strong></td>
                                <td>${deal.vendor_contrib !== null && deal.vendor_contrib !== '' ? deal.vendor_contrib + '%' : '-'}</td>
                                <td title="${deal.locations || ''}" style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${deal.locations || '-'}</td>
                                <td title="${deal.deal_info || ''}" style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${deal.deal_info || '-'}</td>
                                <td title="${deal.special_notes || ''}" style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${deal.special_notes || '-'}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    `;
    
    // SECTION 2: Assigned MIS ID Entries
    html += buildMISSection(deal, colWidths);
    
    // SECTION 3: Blaze Discounts (if assigned)
    html += buildBlazeSection(deal);
    
    // Multi-brand checklist (if applicable)
    if (deal.is_multi_brand) {
        html += buildMultiBrandChecklist(deal);
    }
    
    // Audit Actions and Notes - v12.25.0: Fixed button colors
    html += `
        <div class="card mt-3 border-secondary">
            <div class="card-header bg-secondary text-white">
                <strong><i class="bi bi-pencil-square"></i> Audit Actions</strong>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <label class="form-label fw-bold">Notes</label>
                        <textarea id="auditNotes" class="form-control" rows="3" placeholder="Add notes about this deal...">${existingResult.notes || ''}</textarea>
                    </div>
                    <div class="col-md-6">
                        <label class="form-label fw-bold">Mark As</label>
                        <div class="d-flex gap-2 flex-wrap">
                            <button class="btn" style="background-color:#28a745; color:white; border-color:#28a745;" onclick="markAuditDeal(${auditIdx}, 'verified')">
                                <i class="bi bi-check-circle"></i> Verified
                            </button>
                            <button class="btn" style="background-color:#fd7e14; color:white; border-color:#fd7e14;" onclick="markAuditDeal(${auditIdx}, 'attention')">
                                <i class="bi bi-exclamation-triangle"></i> Needs Attention
                            </button>
                            <button class="btn" style="background-color:#6c757d; color:#212529; border-color:#6c757d;" onclick="markAuditDeal(${auditIdx}, 'skipped')">
                                <i class="bi bi-skip-forward"></i> Skip
                            </button>
                        </div>
                        <hr>
                        <div class="d-flex gap-2">
                            <button class="btn btn-outline-primary" onclick="navigateAudit(-1)" ${auditIdx === 0 ? 'disabled' : ''}>
                                <i class="bi bi-arrow-left"></i> Previous
                            </button>
                            <button class="btn btn-outline-primary" onclick="navigateAudit(1)" ${auditIdx === totalDeals - 1 ? 'disabled' : ''}>
                                Next <i class="bi bi-arrow-right"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    html += `</div>`; // Close padding div
    
    return html;
}

// Build MIS section of audit popup
function buildMISSection(deal, colWidths) {
    const assignedIdRaw = deal.current_sheet_id ? String(deal.current_sheet_id).trim() : '';
    const suggestions = deal.suggestions || [];
    
    // v12.25.0: Parse multiple MIS IDs (same logic as ID Matcher)
    // Filter out "STIIIZY MONTHLY + WEEKLY DEAL PLANNER" as it's a note, not an MIS ID
    const assignedIds = parseMultipleMisIdsForAudit(assignedIdRaw);
    const hasAssignedIds = assignedIds.length > 0;
    
    let html = `
        <div class="card mb-3 border-success">
            <div class="card-header bg-success text-white d-flex justify-content-between">
                <strong><i class="bi bi-database"></i> Section 2: Assigned MIS ID Entries</strong>
                ${hasAssignedIds ? `<span class="badge bg-light text-dark">Assigned: ${assignedIds.join(', ')}</span>` : '<span class="badge bg-danger">NO MIS ID ASSIGNED</span>'}
            </div>
            <div class="card-body p-2">
    `;
    
    if (!hasAssignedIds) {
        html += `
            <div class="alert alert-warning mb-0">
                <i class="bi bi-exclamation-triangle"></i> <strong>WARNING:</strong> No MIS ID is assigned to this deal in Google Sheet.
            </div>
        `;
    } else {
        // v12.25.0: Process each assigned MIS ID
        let foundMatches = [];
        let notFoundIds = [];
        
        assignedIds.forEach(rawId => {
            const cleanId = cleanMisIdForAudit(rawId);
            const matchingSuggestion = suggestions.find(s => String(s.mis_id) === cleanId);
            if (matchingSuggestion) {
                foundMatches.push({ rawId, cleanId, suggestion: matchingSuggestion });
            } else {
                notFoundIds.push({ rawId, cleanId });
            }
        });
        
        // Show found matches
        if (foundMatches.length > 0) {
            const matchingSuggestions = foundMatches.map(m => m.suggestion);
            html += renderMISSuggestionTable(matchingSuggestions, deal, true, colWidths);
        }
        
        // Show not found IDs
        if (notFoundIds.length > 0) {
            html += `
                <div class="alert alert-danger mb-2">
                    <i class="bi bi-x-circle"></i> <strong>MIS ID(s) NOT FOUND IN CSV:</strong> ${notFoundIds.map(n => n.rawId).join(', ')}
                </div>
            `;
        }
        
        // Show other suggestions if available (exclude already-matched IDs)
        const matchedCleanIds = foundMatches.map(m => m.cleanId);
        const otherSuggestions = suggestions.filter(s => !matchedCleanIds.includes(String(s.mis_id)));
        if (otherSuggestions.length > 0) {
            html += `
                <details class="mt-2">
                    <summary class="text-muted" style="cursor: pointer;">
                        <i class="bi bi-list"></i> Other suggestions (${otherSuggestions.length})
                    </summary>
                    <div class="mt-2">
                        ${renderMISSuggestionTable(otherSuggestions, deal, false, colWidths)}
                    </div>
                </details>
            `;
        }
    }
    
    html += `</div></div>`;
    return html;
}

// v12.25.0: Parse multiple MIS IDs from raw value, filtering out notes
// Ignores "STIIIZY MONTHLY + WEEKLY DEAL PLANNER" and similar non-ID text
function parseMultipleMisIdsForAudit(rawValue) {
    if (!rawValue) return [];
    const str = String(rawValue).trim();
    
    // Filter out known notes/non-ID text (case insensitive)
    const ignorePhrases = [
        'stiiizy monthly + weekly deal planner',
        'stiiizy monthly+ weekly deal planner',
        'stiiizy monthly and weekly deal planner',
        'deal planner',
        'monthly + weekly',
        'monthly+ weekly'
    ];
    
    // Check if entire string is just a note to ignore
    const lowerStr = str.toLowerCase();
    if (ignorePhrases.some(phrase => lowerStr === phrase)) {
        return [];
    }
    
    // Split by newlines and/or commas
    let parts = str.split(/[\n\r,]+/).map(p => p.trim()).filter(p => p);
    
    // If only one part, check if it contains multiple tagged IDs (space-separated tags like "W1 12345 W2 67890")
    if (parts.length === 1 && !parts[0].match(/^\d+$/)) {
        // Try to find multiple tagged IDs
        const multiTagMatch = str.match(/([A-Za-z]+\d*\s+\d+)/g);
        if (multiTagMatch && multiTagMatch.length > 1) {
            parts = multiTagMatch;
        } else {
            // Try splitting by spaces for simple numeric IDs
            const spaceParts = str.split(/\s+/).map(p => p.trim()).filter(p => p && /\d/.test(p));
            if (spaceParts.length > 1) {
                // Check if these look like IDs (numbers or tagged numbers)
                const allLookLikeIds = spaceParts.every(p => /^([A-Za-z]*\d*\s*)?\d+$/.test(p));
                if (allLookLikeIds) {
                    parts = spaceParts;
                }
            }
        }
    }
    
    // Filter out ignore phrases and non-numeric entries
    return parts.filter(p => {
        const lower = p.toLowerCase();
        // Skip if matches ignore phrase
        if (ignorePhrases.some(phrase => lower.includes(phrase))) {
            return false;
        }
        // Skip standalone text that doesn't contain digits
        if (!/\d/.test(p)) {
            return false;
        }
        return true;
    });
}

// Clean MIS ID by stripping tag prefixes (reuse from showSuggestionTooltip pattern)
function cleanMisIdForAudit(rawId) {
    if (!rawId) return '';
    const str = String(rawId).trim();
    const tagMatch = str.match(/^([A-Za-z]+\d*)\s+(\d+)$/);
    if (tagMatch) return tagMatch[2];
    const numMatch = str.match(/(\d+)\s*$/);
    if (numMatch) return numMatch[1];
    return str;
}

// Render MIS suggestion table
function renderMISSuggestionTable(suggestions, deal, isAssigned, colWidths) {
    const currentTabName = document.getElementById('mis-tab')?.value || '';
    
    // v12.25.0: Include linked brand for comparison
    const sheetBrand = deal.brand || '';
    const sheetLinkedBrand = deal.linked_brand || '';
    const combinedSheetBrand = sheetLinkedBrand ? `${sheetBrand} / ${sheetLinkedBrand}` : sheetBrand;
    
    // Use provided colWidths or defaults
    const widths = colWidths || {
        row: '60px', weekday: '80px', brand: '140px', category: '120px',
        discount: '70px', vendor: '70px', locations: '120px',
        dealInfo: '130px', notes: '100px', start: '90px', end: '90px', action: '60px'
    };
    
    let html = `
        <div style="overflow-x: auto;">
            <table class="table table-sm table-bordered mb-0" style="font-size: 0.85em; table-layout: fixed; ${isAssigned ? 'border: 2px solid #198754;' : ''}">
                <thead style="background: ${isAssigned ? '#d4edda' : '#e9ecef'}; color:#212529;">
                    <tr>
                        <th style="width:${widths.row};">MIS ID</th>
                        <th style="width:${widths.weekday};">Weekday</th>
                        <th style="width:${widths.brand};">Brand / Linked</th>
                        <th style="width:${widths.category};">Category</th>
                        <th style="width:${widths.discount};">Discount</th>
                        <th style="width:${widths.vendor};">Vendor</th>
                        <th style="width:${widths.locations};">Locations</th>
                        <th style="width:${widths.start};">Start</th>
                        <th style="width:${widths.end};">End</th>
                        <th style="width:${widths.action};">Action</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    suggestions.forEach(s => {
        const data = s.mis_data || {};
        const endDateColor = getEndDateColorForAudit(data.end_date, currentTabName);
        
        // v12.25.0: Combine MIS Brand + Linked Brand for display
        const misBrand = data.brand || '';
        const misLinkedBrand = data.linked_brand && data.linked_brand !== 'N/A' ? data.linked_brand : '';
        const combinedMisBrand = misLinkedBrand ? `${misBrand}<br><small class="text-muted">${misLinkedBrand}</small>` : misBrand || '-';
        
        // Compare both brand AND linked brand
        const brandStyle = getBrandAndLinkedStyleForAudit(sheetBrand, sheetLinkedBrand, misBrand, misLinkedBrand);
        
        html += `
            <tr>
                <td>
                    <button class="btn btn-sm btn-outline-primary py-0 px-2" 
                            onclick="lookupMisIdWithValidation(this, '${s.mis_id}')"
                            title="Click to lookup in MIS">${s.mis_id}</button>
                </td>
                <td style="${getWeekdayStyleForAudit(deal.weekday, data.weekdays)}">${data.weekdays || '-'}</td>
                <td style="${brandStyle}">${combinedMisBrand}</td>
                <td style="${getCategoryStyleForAudit(deal.categories, data.category)}" title="${data.category || ''}" class="text-truncate">${data.category || '-'}</td>
                <td style="${getMatchStyleForAudit(deal.discount, data.discount, true)}">${data.discount !== null ? data.discount + '%' : '-'}</td>
                <td style="${getMatchStyleForAudit(deal.vendor_contrib, data.vendor_contribution, true)}">${data.vendor_contribution !== null ? data.vendor_contribution + '%' : '-'}</td>
                <td style="${getLocationStyleForAudit(deal.locations, data.locations)}" title="${data.locations || ''}" class="text-truncate">${data.locations || '-'}</td>
                <td>${data.start_date || '-'}</td>
                <td>
                    <button class="btn btn-sm py-0 px-2" style="${endDateColor.style}" title="${endDateColor.tooltip}">
                        ${data.end_date || '-'}
                    </button>
                </td>
                <td>
                    <button class="btn btn-sm btn-outline-info py-0 px-1" onclick="showMoreInfoForAudit('${s.mis_id}', ${JSON.stringify(data).replace(/"/g, '&quot;')})" title="View all MIS fields">
                        <i class="bi bi-info-circle"></i>
                    </button>
                </td>
            </tr>
        `;
    });
    
    html += `</tbody></table></div>`;
    return html;
}

// v12.25.0: Compare brand AND linked brand together
function getBrandAndLinkedStyleForAudit(sheetBrand, sheetLinked, misBrand, misLinked) {
    const sb = String(sheetBrand || '').toLowerCase().trim();
    const sl = String(sheetLinked || '').toLowerCase().trim();
    const mb = String(misBrand || '').toLowerCase().trim();
    const ml = String(misLinked || '').toLowerCase().trim();
    
    // Check various match scenarios:
    // 1. Sheet brand matches MIS brand (direct match)
    // 2. Sheet linked matches MIS brand (linked brand used as primary in MIS)
    // 3. Sheet brand matches MIS linked (inverse linked match)
    // 4. Sheet linked matches MIS linked (linked brands match)
    // 5. Fuzzy match (contains check)
    
    let brandMatch = sb === mb || sb.includes(mb) || mb.includes(sb);
    let linkedMatch = (sl && ml) ? (sl === ml || sl.includes(ml) || ml.includes(sl)) : true;
    let crossMatch1 = sl && mb && (sl === mb || sl.includes(mb) || mb.includes(sl));
    let crossMatch2 = sb && ml && (sb === ml || sb.includes(ml) || ml.includes(sb));
    
    // GREEN: Direct brand match or cross-match found
    if (brandMatch || crossMatch1 || crossMatch2) {
        return 'background:#d4edda; color:#155724;';
    }
    
    // YELLOW: Missing data on one side
    if (!sb || !mb) {
        return 'background:#fff3cd; color:#856404;';
    }
    
    // RED: Mismatch
    return 'background:#f8d7da; color:#721c24;';
}

// Get end date color (reuse logic from showSuggestionTooltip)
function getEndDateColorForAudit(endDateStr, tabName) {
    const months = ['january','february','march','april','may','june','july','august','september','october','november','december'];
    const parts = tabName.toLowerCase().trim().split(/\s+/);
    let tabMonth = -1, tabYear = -1;
    for (const p of parts) {
        const mIdx = months.indexOf(p);
        if (mIdx >= 0) tabMonth = mIdx;
        if (/^\d{4}$/.test(p)) tabYear = parseInt(p);
    }
    
    if (tabMonth < 0 || tabYear < 0) {
        return { style: 'background:#6c757d; border-color:#6c757d; color:white;', tooltip: 'Cannot parse tab name' };
    }
    
    const parsed = parseDateString(endDateStr);
    if (!parsed) {
        return { style: 'background:#6c757d; border-color:#6c757d; color:white;', tooltip: 'Invalid date' };
    }
    
    const tabYM = tabYear * 12 + tabMonth;
    const endYM = parsed.year * 12 + parsed.month;
    
    if (endYM < tabYM) {
        return { style: 'background:#dc3545; border-color:#dc3545; color:white;', tooltip: 'EXPIRED - needs update' };
    } else if (endYM === tabYM) {
        return { style: 'background:#28a745; border-color:#28a745; color:white;', tooltip: 'Current month' };
    } else {
        return { style: 'background:#fd7e14; border-color:#fd7e14; color:white;', tooltip: 'Future month' };
    }
}

// Comparison style helpers (simplified versions)
function getMatchStyleForAudit(src, tgt, isNumeric = false) {
    if (!src && !tgt) return '';
    if (!src || !tgt) return 'background:#fff3cd; color:#856404;';
    
    let matches = false;
    if (isNumeric) {
        const s = parseFloat(String(src).replace(/[%$,]/g, '')) || 0;
        const t = parseFloat(String(tgt).replace(/[%$,]/g, '')) || 0;
        matches = Math.abs(s - t) < 0.01;
    } else {
        matches = String(src).toLowerCase().trim() === String(tgt).toLowerCase().trim();
    }
    return matches ? 'background:#d4edda; color:#155724;' : 'background:#f8d7da; color:#721c24;';
}

function getBrandStyleForAudit(srcBrand, tgtBrand) {
    if (!srcBrand || !tgtBrand) return 'background:#fff3cd; color:#856404;';
    const s = String(srcBrand).toLowerCase().trim();
    const t = String(tgtBrand).toLowerCase().trim();
    if (s === t || s.includes(t) || t.includes(s)) return 'background:#d4edda; color:#155724;';
    return 'background:#f8d7da; color:#721c24;';
}

function getWeekdayStyleForAudit(srcWeekday, tgtWeekdays) {
    if (!srcWeekday || !tgtWeekdays) return 'background:#fff3cd; color:#856404;';
    const src = srcWeekday.toLowerCase().substring(0, 3);
    const tgt = tgtWeekdays.toLowerCase();
    if (tgt.includes(src)) return 'background:#d4edda; color:#155724;';
    return 'background:#f8d7da; color:#721c24;';
}

// v12.25.0: SET-BASED category comparison (order independent) + NaN/blank = All
function getCategoryStyleForAudit(srcCat, tgtCat) {
    const s = String(srcCat || '').toLowerCase().trim();
    const t = String(tgtCat || '').toLowerCase().trim();
    
    // Treat blank/NaN as "All"
    const srcAll = !s || s === 'all' || s === '-' || s.includes('all categories') || s === 'nan' || s === 'null';
    const tgtAll = !t || t === 'all' || t === '-' || t === 'n/a' || t === 'nan' || t === 'null';
    
    // Both All = GREEN
    if (srcAll && tgtAll) return 'background:#d4edda; color:#155724;';
    
    // One All, one specific = YELLOW
    if (srcAll !== tgtAll) return 'background:#fff3cd; color:#856404;';
    
    // Both specific - SET comparison (order independent)
    const srcSet = new Set(s.split(',').map(x => x.trim().toLowerCase()).filter(x => x));
    const tgtSet = new Set(t.split(',').map(x => x.trim().toLowerCase()).filter(x => x));
    const setsEqual = srcSet.size === tgtSet.size && [...srcSet].every(x => tgtSet.has(x));
    return setsEqual ? 'background:#d4edda; color:#155724;' : 'background:#fff3cd; color:#856404;';
}

// v12.25.0: SET-BASED location comparison (order independent) + NaN/blank = All
function getLocationStyleForAudit(srcLoc, tgtLoc) {
    const s = String(srcLoc || '').toLowerCase().trim();
    const t = String(tgtLoc || '').toLowerCase().trim();
    
    // Treat blank/NaN as "All"
    const srcAll = !s || s === 'all' || s === '-' || s.includes('all locations') || s === 'nan' || s === 'null';
    const tgtAll = !t || t === 'all' || t === '-' || t === 'n/a' || t === 'nan' || t === 'null';
    
    // Both All = GREEN
    if (srcAll && tgtAll) return 'background:#d4edda; color:#155724;';
    
    // One All, one specific = YELLOW
    if (srcAll !== tgtAll) return 'background:#fff3cd; color:#856404;';
    
    // Both specific - SET comparison (order independent)
    const srcSet = new Set(s.split(',').map(x => x.trim().toLowerCase()).filter(x => x));
    const tgtSet = new Set(t.split(',').map(x => x.trim().toLowerCase()).filter(x => x));
    const setsEqual = srcSet.size === tgtSet.size && [...srcSet].every(x => tgtSet.has(x));
    return setsEqual ? 'background:#d4edda; color:#155724;' : 'background:#fff3cd; color:#856404;';
}

// Build Blaze section (Section 3)
function buildBlazeSection(deal) {
    // v12.25.1: Check multiple sources for Blaze data
    // PRIORITY ORDER:
    // 1. blaze_discount_title from Google Sheet (already applied = already approved)
    // 2. approvedMatches (where Blaze titles are stored when approved in ID Matcher)
    // 3. deal.blaze_titles directly attached
    // 4. blazeMatches global
    
    let blazeTitles = [];
    
    // v12.25.1: FIRST check Google Sheet column "Blaze Discount Title"
    // If this has a value, the discount was already applied to the sheet = already approved
    const sheetBlazeTitle = (deal.blaze_discount_title || '').trim();
    if (sheetBlazeTitle && blazeData && blazeData.currentRows && blazeData.currentRows.length > 0) {
        // Parse multiple titles (may be comma or newline separated)
        const sheetTitles = sheetBlazeTitle.split(/[,\n]+/).map(t => t.trim()).filter(t => t);
        
        sheetTitles.forEach(titleToFind => {
            // Search for this title in Blaze data
            const matchingBlaze = blazeData.currentRows.find(row => {
                const blazeName = (row.Name || '').trim().toLowerCase();
                const searchTitle = titleToFind.toLowerCase();
                // Exact match or contains (for partial title matching)
                return blazeName === searchTitle || blazeName.includes(searchTitle) || searchTitle.includes(blazeName);
            });
            
            if (matchingBlaze) {
                // Found in Blaze data - add full details
                blazeTitles.push({
                    id: matchingBlaze.Id || matchingBlaze.id || '-',
                    name: matchingBlaze.Name || titleToFind,
                    active: (matchingBlaze.Status || '').toLowerCase() === 'active',
                    type: matchingBlaze['Discount Value Type'] || '-',
                    value: matchingBlaze['Discount Value'] || '-',
                    locations: matchingBlaze.Locations || '-',
                    start_date: matchingBlaze['Start Date'] || '-',
                    end_date: matchingBlaze['End Date'] || '-',
                    source: 'sheet'  // Mark as from Google Sheet
                });
            } else {
                // Title in sheet but not found in Blaze data - still show it
                blazeTitles.push({
                    id: '-',
                    name: titleToFind,
                    active: null,  // Unknown
                    type: '-',
                    value: '-',
                    locations: '-',
                    start_date: '-',
                    end_date: '-',
                    source: 'sheet_only'  // Only in sheet, not found in Blaze
                });
            }
        });
    }
    
    // If no sheet titles found, try approvedMatches (primary source for newly approved)
    if (blazeTitles.length === 0) {
        const approvedData = approvedMatches[deal.google_row];
        if (approvedData && approvedData.blaze_titles && approvedData.blaze_titles.length > 0) {
            blazeTitles = approvedData.blaze_titles;
        }
    }
    
    // Also check if deal has blaze_titles directly attached
    if (blazeTitles.length === 0 && deal.blaze_titles && deal.blaze_titles.length > 0) {
        blazeTitles = deal.blaze_titles;
    }
    
    // Check blazeMatches global (if it exists) - alternative storage for Blaze data
    if (blazeTitles.length === 0 && typeof blazeMatches !== 'undefined' && blazeMatches[deal.google_row]) {
        const blazeData = blazeMatches[deal.google_row];
        if (blazeData.titles && blazeData.titles.length > 0) {
            blazeTitles = blazeData.titles;
        }
    }
    
    if (blazeTitles.length === 0) {
        return `
            <div class="card mb-3 border-info">
                <div class="card-header bg-info text-white">
                    <strong><i class="bi bi-lightning"></i> Section 3: Blaze Discounts</strong>
                </div>
                <div class="card-body">
                    <p class="text-muted mb-0"><i class="bi bi-info-circle"></i> No Blaze discounts assigned to this deal.</p>
                    <small class="text-muted">Tip: If a Blaze discount title is in the Google Sheet, it will appear here after syncing Blaze data.</small>
                </div>
            </div>
        `;
    }
    
    let html = `
        <div class="card mb-3 border-info">
            <div class="card-header bg-info text-white">
                <strong><i class="bi bi-lightning"></i> Section 3: Blaze Discounts (${blazeTitles.length})</strong>
            </div>
            <div class="card-body p-2">
                <div style="overflow-x: auto;">
                    <table class="table table-sm table-bordered mb-0" style="font-size: 0.85em;">
                        <thead style="background:#e9ecef; color:#212529;">
                            <tr>
                                <th>ID</th>
                                <th>Name</th>
                                <th>Status</th>
                                <th>Type</th>
                                <th>Value</th>
                                <th>Locations</th>
                                <th>Start</th>
                                <th>End</th>
                            </tr>
                        </thead>
                        <tbody>
    `;
    
    blazeTitles.forEach(title => {
        // v12.25.1: Handle different status scenarios
        let statusBadge;
        if (title.source === 'sheet_only') {
            statusBadge = '<span class="badge bg-warning text-dark" title="Title in Google Sheet but not found in current Blaze data">In Sheet Only</span>';
        } else if (title.active === true) {
            statusBadge = '<span class="badge bg-success">Active</span>';
        } else if (title.active === false) {
            statusBadge = '<span class="badge bg-secondary">Inactive</span>';
        } else {
            statusBadge = '<span class="badge bg-light text-dark">Unknown</span>';
        }
        
        // Highlight source from sheet
        const nameStyle = title.source === 'sheet' || title.source === 'sheet_only' ? 'background:#e7f1ff;' : '';
        
        html += `
            <tr style="${nameStyle}">
                <td>${title.id || '-'}</td>
                <td>${title.name || '-'}${title.source === 'sheet' ? ' <small class="text-success">(from Sheet)</small>' : ''}</td>
                <td>${statusBadge}</td>
                <td>${title.type || '-'}</td>
                <td>${title.value || '-'}</td>
                <td title="${title.locations || ''}" style="max-width:150px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${title.locations || '-'}</td>
                <td>${title.start_date || '-'}</td>
                <td>${title.end_date || '-'}</td>
            </tr>
        `;
    });
    
    html += `</tbody></table></div></div></div>`;
    return html;
}

// Build multi-brand checklist
function buildMultiBrandChecklist(deal) {
    const brands = (deal.brand_raw || deal.brand || '').split(',').map(b => b.trim()).filter(b => b);
    
    let html = `
        <div class="card mb-3 border-warning">
            <div class="card-header bg-warning text-dark">
                <strong><i class="bi bi-tags"></i> Multi-Brand Verification (${brands.length} brands)</strong>
            </div>
            <div class="card-body">
                <div class="list-group">
    `;
    
    brands.forEach((brand, idx) => {
        html += `
            <div class="list-group-item d-flex justify-content-between align-items-center">
                <span><strong>${idx + 1}.</strong> ${brand}</span>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="multiBrandCheck${idx}">
                    <label class="form-check-label" for="multiBrandCheck${idx}">Verified</label>
                </div>
            </div>
        `;
    });
    
    html += `</div></div></div>`;
    return html;
}

// Mark a deal in audit
function markAuditDeal(auditIdx, status) {
    const deals = comprehensiveAuditState.deals;
    const deal = deals[auditIdx];
    const notes = document.getElementById('auditNotes')?.value || '';
    
    comprehensiveAuditState.results[deal.google_row] = {
        status: status,
        notes: notes,
        auditedAt: new Date().toISOString()
    };
    
    // Update table row
    renderAuditOverview();
    
    // Save progress
    saveAuditProgress();
    
    // If in sequential mode and not at end, move to next
    if (comprehensiveAuditState.inProgress && auditIdx < deals.length - 1) {
        navigateAudit(1);
    } else if (auditIdx === deals.length - 1) {
        // Completed all
        showAuditCompletionSummary();
    }
}

// Navigate in audit (prev/next)
function navigateAudit(direction) {
    const newIdx = comprehensiveAuditState.currentIndex + direction;
    const deals = comprehensiveAuditState.deals;
    
    if (newIdx >= 0 && newIdx < deals.length) {
        showAuditPopup(newIdx);
    }
}

// Exit audit popup
function exitAuditPopup() {
    if (confirm('Exit audit? Progress will be saved.')) {
        saveAuditProgress();
        const overlay = document.getElementById('comprehensive-audit-popup-overlay');
        if (overlay) overlay.remove();
        document.getElementById('exportAuditBtn').disabled = false;
    }
}

// Show completion summary
function showAuditCompletionSummary() {
    const results = comprehensiveAuditState.results;
    const deals = comprehensiveAuditState.deals;
    
    let verified = 0, attention = 0, skipped = 0, pending = 0;
    deals.forEach(d => {
        const r = results[d.google_row];
        if (!r) pending++;
        else if (r.status === 'verified') verified++;
        else if (r.status === 'attention') attention++;
        else if (r.status === 'skipped') skipped++;
    });
    
    const overlay = document.getElementById('comprehensive-audit-popup-overlay');
    if (overlay) {
        overlay.innerHTML = `
            <div style="background: #fff; padding: 30px; border-radius: 8px; text-align: center; max-width: 500px;">
                <h3><i class="bi bi-check-circle-fill text-success"></i> Audit Complete!</h3>
                <hr>
                <div class="row text-center mb-3">
                    <div class="col"><h4 class="text-success mb-0">${verified}</h4><small>Verified</small></div>
                    <div class="col"><h4 class="text-warning mb-0">${attention}</h4><small>Attention</small></div>
                    <div class="col"><h4 class="text-secondary mb-0">${skipped}</h4><small>Skipped</small></div>
                </div>
                ${attention > 0 ? `<button class="btn btn-warning me-2" onclick="reviewAttentionItems()">Review ${attention} Attention Items</button>` : ''}
                <button class="btn btn-info me-2" onclick="exportAuditReport()">Export Report</button>
                <button class="btn btn-secondary" onclick="document.getElementById('comprehensive-audit-popup-overlay').remove()">Close</button>
            </div>
        `;
    }
    
    comprehensiveAuditState.inProgress = false;
    document.getElementById('exportAuditBtn').disabled = false;
}

// Review attention items
function reviewAttentionItems() {
    const deals = comprehensiveAuditState.deals;
    const results = comprehensiveAuditState.results;
    
    // Find first attention item
    for (let i = 0; i < deals.length; i++) {
        const r = results[deals[i].google_row];
        if (r && r.status === 'attention') {
            showAuditPopup(i);
            return;
        }
    }
}

// Save audit progress to server
async function saveAuditProgress() {
    const state = comprehensiveAuditState;
    const payload = {
        audit_id: state.auditId || 'audit_' + Date.now(),
        tab_name: state.tabName,
        started_at: state.startedAt,
        settings: state.settings,
        total_deals: state.deals.length,
        current_index: state.currentIndex,
        results: Object.entries(state.results).map(([row, data]) => ({
            row_number: parseInt(row),
            status: data.status,
            notes: data.notes,
            audited_at: data.auditedAt
        }))
    };
    
    try {
        await fetch('/api/audit/save-state', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        // Also save to localStorage as backup
        localStorage.setItem('comprehensiveAuditState', JSON.stringify(payload));
    } catch (e) {
        console.error('Failed to save audit state:', e);
        // Still save to localStorage
        localStorage.setItem('comprehensiveAuditState', JSON.stringify(payload));
    }
}

// Load audit state from server
async function loadAuditStateFromServer() {
    const tabName = document.getElementById('mis-tab')?.value || '';
    
    try {
        const response = await fetch(`/api/audit/load-state?tab=${encodeURIComponent(tabName)}`);
        const data = await response.json();
        
        if (data.success && data.state && data.state.results && data.state.results.length > 0) {
            const completedCount = data.state.results.length;
            const totalCount = data.state.total_deals;
            
            // v12.25.0: Custom Yes/No popup instead of confirm()
            showResumeAuditPopup(completedCount, totalCount, data.state);
        }
    } catch (e) {
        // Try localStorage backup
        const localState = localStorage.getItem('comprehensiveAuditState');
        if (localState) {
            try {
                const parsed = JSON.parse(localState);
                if (parsed.tab_name === tabName && parsed.results && parsed.results.length > 0) {
                    showResumeAuditPopup(parsed.results.length, parsed.total_deals, parsed, true);
                }
            } catch (parseErr) {
                console.error('Failed to parse local state:', parseErr);
            }
        }
    }
}

// v12.25.0: Custom Yes/No popup for resuming audit
function showResumeAuditPopup(completedCount, totalCount, savedState, isLocal = false) {
    const sourceText = isLocal ? 'local backup' : 'incomplete audit';
    const content = `
        <div id="resumeAuditPopup" style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:10002; display:flex; align-items:center; justify-content:center;">
            <div style="background:white; padding:30px; border-radius:12px; max-width:450px; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.3);">
                <div style="margin-bottom:20px;">
                    <i class="bi bi-question-circle" style="font-size:3em; color:#667eea;"></i>
                </div>
                <h4 style="margin-bottom:15px;">Resume Previous Audit?</h4>
                <p style="color:#6c757d; margin-bottom:25px;">
                    Found ${sourceText}:<br>
                    <strong>${completedCount} of ${totalCount}</strong> deals completed.<br>
                    Would you like to continue where you left off?
                </p>
                <div style="display:flex; gap:15px; justify-content:center;">
                    <button class="btn btn-lg" style="background-color:#28a745; color:white; min-width:100px;" onclick="resumeAuditFromState(${JSON.stringify(savedState).replace(/"/g, '&quot;')}); document.getElementById('resumeAuditPopup').remove();">
                        <i class="bi bi-check-lg"></i> Yes
                    </button>
                    <button class="btn btn-lg" style="background-color:#dc3545; color:white; min-width:100px;" onclick="document.getElementById('resumeAuditPopup').remove();">
                        <i class="bi bi-x-lg"></i> No
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', content);
}

// v12.25.0: Resume audit from saved state
function resumeAuditFromState(savedState) {
    // Parse if string
    let state = savedState;
    if (typeof savedState === 'string') {
        try {
            state = JSON.parse(savedState.replace(/&quot;/g, '"'));
        } catch (e) {
            console.error('Failed to parse saved state:', e);
            return;
        }
    }
    
    // Restore state
    if (state.results) {
        state.results.forEach(r => {
            comprehensiveAuditState.results[r.row_number] = {
                status: r.status,
                notes: r.notes,
                auditedAt: r.audited_at
            };
        });
    }
    comprehensiveAuditState.currentIndex = state.current_index || 0;
    comprehensiveAuditState.auditId = state.audit_id;
    comprehensiveAuditState.startedAt = state.started_at;
    
    // Update UI
    renderAuditOverview();
}

// Export audit report as CSV
async function exportAuditReport() {
    const state = comprehensiveAuditState;
    const deals = state.deals;
    const results = state.results;
    
    if (deals.length === 0) {
        alert('No deals to export.');
        return;
    }
    
    // Build CSV content
    let csv = 'Row Number,Section,Brand(s),Linked Brand,Weekday,MIS ID(s),Audit Status,Issues Found,Audited Date,Notes\n';
    
    deals.forEach(deal => {
        const r = results[deal.google_row] || {};
        const section = (deal.section || '').replace(/,/g, ';');
        const brand = (deal.brand || '').replace(/,/g, ';');
        const linked = (deal.linked_brand || '').replace(/,/g, ';');
        const weekday = (deal.weekday || '').replace(/,/g, ';');
        const misId = (deal.current_sheet_id || '').replace(/,/g, ';');
        const status = r.status || 'pending';
        const issues = ''; // Could be enhanced to detect issues
        const auditedAt = r.auditedAt || '';
        const notes = (r.notes || '').replace(/,/g, ';').replace(/\n/g, ' ');
        
        csv += `${deal.google_row},"${section}","${brand}","${linked}","${weekday}","${misId}","${status}","${issues}","${auditedAt}","${notes}"\n`;
    });
    
    // Create download
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
    a.href = url;
    a.download = `Audit_${state.tabName.replace(/\s+/g, '_')}_${timestamp}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Helper: Show more info for MIS entry - full details popup
function showMoreInfoForAudit(misId, misData) {
    // Parse the data if it's a string
    let data = misData;
    if (typeof misData === 'string') {
        try {
            data = JSON.parse(misData.replace(/&quot;/g, '"'));
        } catch (e) {
            data = {};
        }
    }
    
    // Build detailed info popup
    let content = `
        <div style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:10001; display:flex; align-items:center; justify-content:center;" onclick="this.remove()">
            <div style="background:white; padding:20px; border-radius:8px; max-width:600px; max-height:80vh; overflow-y:auto; box-shadow:0 4px 20px rgba(0,0,0,0.3);" onclick="event.stopPropagation()">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:2px solid #667eea; padding-bottom:10px;">
                    <h5 style="margin:0; color:#667eea;"><i class="bi bi-database"></i> MIS Entry: ${misId}</h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="this.closest('div[style*=position]').remove()"><i class="bi bi-x"></i></button>
                </div>
                <table class="table table-sm table-bordered" style="font-size:0.9em;">
                    <tbody>
                        <tr><th style="width:35%; background:#f8f9fa;">MIS ID</th><td><strong>${misId}</strong></td></tr>
                        <tr><th style="background:#f8f9fa;">Brand</th><td>${data.brand || '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Linked Brand</th><td>${data.linked_brand || '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Weekdays</th><td>${data.weekdays || '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Category</th><td>${data.category || '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Discount</th><td>${data.discount !== null && data.discount !== undefined ? data.discount + '%' : '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Vendor Contribution</th><td>${data.vendor_contribution !== null && data.vendor_contribution !== undefined ? data.vendor_contribution + '%' : '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Locations</th><td>${data.locations || '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Start Date</th><td>${data.start_date || '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">End Date</th><td>${data.end_date || '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Deal Name</th><td>${data.deal_name || '-'}</td></tr>
                        <tr><th style="background:#f8f9fa;">Notes</th><td>${data.notes || '-'}</td></tr>
                    </tbody>
                </table>
                <div class="text-center mt-3">
                    <button class="btn btn-primary btn-sm" onclick="lookupMisIdWithValidation(this, '${misId}'); this.closest('div[style*=position]').remove();">
                        <i class="bi bi-search"></i> Lookup in MIS
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', content);
}

// ============================================
// GOOGLE SHEET CONFLICT AUDIT (Pre-Flight Check)
// ============================================
async function runGSheetConflictAudit() {
    const btn = event.target;
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Scanning Google Sheet...';
    
    document.getElementById('gsheet-audit-results').innerHTML = '';
    document.getElementById('gsheet-audit-stats').innerText = 'Scanning...';
    document.getElementById('gsheet-audit-stats').className = 'badge bg-info fs-6 me-2';

    try {
        const tab = document.getElementById('mis-tab').value;
        
        if (!tab) {
            alert('Please select a Google Sheet tab in the Setup section first.');
            document.getElementById('gsheet-audit-stats').innerText = 'No Tab Selected';
            document.getElementById('gsheet-audit-stats').className = 'badge bg-danger fs-6 me-2';
            return;
        }
        
        const response = await fetch('/api/mis/gsheet-conflict-audit', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ tab: tab })
        });
        const data = await response.json();

        if (data.success) {
            displayGSheetConflictResults(data);
            
            const conflictCount = data.conflicts ? data.conflicts.length : 0;
            if (conflictCount > 0) {
                document.getElementById('gsheet-audit-stats').innerText = 
                    `[!] [EMOJI][EMOJI] ${conflictCount} Cross-Section Conflicts Found`;
                document.getElementById('gsheet-audit-stats').className = 'badge bg-warning text-dark fs-6 me-2';
            } else {
                document.getElementById('gsheet-audit-stats').innerText = 
                    `[OK][EMOJI] No Cross-Section Conflicts`;
                document.getElementById('gsheet-audit-stats').className = 'badge bg-success fs-6 me-2';
            }
        } else {
            document.getElementById('gsheet-audit-results').innerHTML = 
                `<div class="alert alert-danger">[X] Error: ${data.error}</div>`;
            document.getElementById('gsheet-audit-stats').innerText = 'Error';
            document.getElementById('gsheet-audit-stats').className = 'badge bg-danger fs-6 me-2';
        }
    } catch (e) {
        document.getElementById('gsheet-audit-results').innerHTML = 
            `<div class="alert alert-danger">[X] Network Error: ${e.message}</div>`;
        document.getElementById('gsheet-audit-stats').innerText = 'Error';
        document.getElementById('gsheet-audit-stats').className = 'badge bg-danger fs-6 me-2';
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
    }
}

function displayGSheetConflictResults(data) {
            const container = document.getElementById('gsheet-audit-results');
            const dateConflicts = data.date_conflicts || [];
            const brandConflicts = data.brand_conflicts || [];
            const summary = data.summary || {};
            const dateContext = data.date_context || 'Unknown';
            
            // --- 1. Summary Header ---
            let html = `
                <div class="card mb-4 shadow-sm">
                    <div class="card-header bg-light d-flex justify-content-between align-items-center">
                        <strong> Sheet Analysis Summary</strong>
                        <span class="badge bg-dark fs-6">[EMOJI] Context: ${dateContext}</span>
                    </div>
                    <div class="card-body">
                        <div class="row text-center">
                            <div class="col-md-3">
                                <div class="border rounded p-3">
                                    <h4 class="text-primary mb-0">${summary.weekly_count || 0}</h4>
                                    <small class="text-muted">&#x1F4C5; Weekly Deals</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="border rounded p-3">
                                    <h4 class="text-info mb-0">${summary.monthly_count || 0}</h4>
                                    <small class="text-muted"> Monthly Deals</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="border rounded p-3">
                                    <h4 class="text-warning mb-0">${summary.sale_count || 0}</h4>
                                    <small class="text-muted"> Sale Deals</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="border rounded p-3">
                                    <h4 class="text-secondary mb-0">${summary.unique_brands || 0}</h4>
                                    <small class="text-muted"> Unique Brands</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // --- 2. Tab Navigation ---
            html += `
                <ul class="nav nav-tabs mb-3" id="auditSubTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active fw-bold" id="tab-date-conflicts" data-bs-toggle="tab" data-bs-target="#pane-date-conflicts" type="button" role="tab">
                             Conflictions by Date 
                            <span class="badge bg-danger ms-2">${dateConflicts.length}</span>
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link fw-bold" id="tab-brand-conflicts" data-bs-toggle="tab" data-bs-target="#pane-brand-conflicts" type="button" role="tab">
                             Conflictions by Brand
                            <span class="badge bg-secondary ms-2">${brandConflicts.length}</span>
                        </button>
                    </li>
                </ul>
                
                <div class="tab-content" id="auditSubTabsContent">
            `;

            // --- 3. Pane A: Date Conflicts ---
            html += `<div class="tab-pane fade show active" id="pane-date-conflicts" role="tabpanel">`;
            
            if (dateConflicts.length === 0) {
                html += `
                    <div class="text-center p-4 border rounded bg-light text-success">
                        <h4><i class="bi bi-check-circle-fill"></i> No Date-Based Conflicts</h4>
                        <p class="mb-0">No brands overlap on the exact same dates.</p>
                    </div>`;
            } else {
                html += `
                    <div class="alert alert-warning">
                        <h6 class="mb-1"><i class="bi bi-exclamation-triangle-fill"></i> STRICT OVERLAP</h6>
                        These brands have deals scheduled on the <strong>exact same date</strong> in different sections.
                    </div>
                    <div class="accordion" id="accDateConflicts">`;
                
                dateConflicts.forEach((conflict, idx) => {
                    const groupID = `dc${idx}`;
                    const sectionBadges = conflict.sections.map(s => `<span class="badge bg-secondary me-1">${s.toUpperCase()}</span>`).join('');
                    const datesBadges = conflict.conflicting_dates.map(d => `<span class="badge bg-danger me-1">${d.date}</span>`).join('');
                    
                    html += `
                        <div class="card mb-3 shadow-sm" style="border-left: 5px solid #dc3545;">
                            <div class="card-header bg-white collapsed" data-bs-toggle="collapse" data-bs-target="#${groupID}" style="cursor:pointer;">
                                <div class="d-flex justify-content-between">
                                    <div><span class="fw-bold fs-5"> ${conflict.brand}</span> <span class="ms-2">${sectionBadges}</span></div>
                                    <span class="badge bg-danger">${conflict.total_conflict_dates} dates</span>
                                </div>
                                <div class="mt-1 small text-muted">Overlapping: ${datesBadges}</div>
                            </div>
                            <div id="${groupID}" class="collapse" data-bs-parent="#accDateConflicts">
                                <div class="card-body p-0 table-responsive">
                                    ${renderAuditTable(conflict.rows, true)}
                                </div>
                            </div>
                        </div>`;
                });
                html += `</div>`; // End Accordion
            }
            html += `</div>`; // End Pane A

            // --- 4. Pane B: Brand Conflicts ---
            html += `<div class="tab-pane fade" id="pane-brand-conflicts" role="tabpanel">`;
            
            if (brandConflicts.length === 0) {
                html += `
                    <div class="text-center p-4 border rounded bg-light text-success">
                        <h4><i class="bi bi-check-circle-fill"></i> No Brand Overlaps</h4>
                        <p class="mb-0">Every brand appears in only one section type.</p>
                    </div>`;
            } else {
                html += `
                    <div class="alert alert-secondary" style="border-left: 5px solid #6c757d;">
                        <h6 class="mb-1"><i class="bi bi-info-circle-fill"></i> BROAD OVERLAP</h6>
                        These brands appear in multiple sections (e.g., Weekly AND Sale) but <strong>do not necessarily overlap dates</strong>.
                    </div>
                    <div class="accordion" id="accBrandConflicts">`;

                brandConflicts.forEach((conflict, idx) => {
                    const groupID = `bc${idx}`;
                    const sectionBadges = conflict.sections.map(s => `<span class="badge bg-secondary me-1">${s.toUpperCase()}</span>`).join('');
                    
                    html += `
                        <div class="card mb-3 shadow-sm" style="border-left: 5px solid #6c757d;">
                            <div class="card-header bg-white collapsed" data-bs-toggle="collapse" data-bs-target="#${groupID}" style="cursor:pointer;">
                                <div class="d-flex justify-content-between">
                                    <div><span class="fw-bold fs-5"> ${conflict.brand}</span> <span class="ms-2">${sectionBadges}</span></div>
                                    <span class="badge bg-secondary">${conflict.rows.length} rows</span>
                                </div>
                            </div>
                            <div id="${groupID}" class="collapse" data-bs-parent="#accBrandConflicts">
                                <div class="card-body p-0 table-responsive">
                                    ${renderAuditTable(conflict.rows, false)}
                                </div>
                            </div>
                        </div>`;
                });
                html += `</div>`; // End Accordion
            }
            html += `</div>`; // End Pane B
            
            html += `</div>`; // End Tab Content
            
            container.innerHTML = html;
            initTooltips();
        }

// Helper to render table rows (reused for both tabs)
        // UPDATED: Tight padding, recalculated widths to prevent scrolling
        function renderAuditTable(rows, showConflictDate) {
            // Added explicit padding style to th/td to reduce gaps
            const cellStyle = 'padding: 2px 4px; vertical-align: middle; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
            const wrapStyle = 'padding: 2px 4px; vertical-align: middle; white-space: normal; word-break: break-word;'; // For Notes/Locations
            
            let table = `<table class="table table-sm table-hover mb-0" style="font-size:0.85em; table-layout: fixed; width: 100%;">
                <thead class="table-light">
                    <tr>`;
            
            // Total width must equal 100% to avoid scrollbars
            if (showConflictDate) {
                // Scenario A: WITH Conflict Date (Total 100%)
                table += `<th style="width: 9%; ${cellStyle}">Conflict Date</th>`;
                table += `
                    <th style="width: 7%; ${cellStyle}">Section</th>
                    <th style="width: 4%; ${cellStyle}">Row</th>
                    <th style="width: 9%; ${wrapStyle}">Date/Day</th>
                    <th style="width: 6%; ${cellStyle}">Discount</th>
                    <th style="width: 6%; ${cellStyle}">Vendor %</th>
                    <th style="width: 20%; ${wrapStyle}">Locations</th>
                    <th style="width: 28%; ${wrapStyle}">Notes</th>
                    <th style="width: 6%; ${cellStyle}">MIS ID</th>
                    <th style="width: 5%; ${cellStyle}">Action</th>`;
            } else {
                // Scenario B: Brand View (No Conflict Date) (Total 100%)
                // Distributed extra space to Notes & Locations
                table += `
                    <th style="width: 7%; ${cellStyle}">Section</th>
                    <th style="width: 4%; ${cellStyle}">Row</th>
                    <th style="width: 9%; ${wrapStyle}">Date/Day</th>
                    <th style="width: 6%; ${cellStyle}">Discount</th>
                    <th style="width: 6%; ${cellStyle}">Vendor %</th>
                    <th style="width: 22%; ${wrapStyle}">Locations</th>
                    <th style="width: 35%; ${wrapStyle}">Notes</th>
                    <th style="width: 6%; ${cellStyle}">MIS ID</th>
                    <th style="width: 5%; ${cellStyle}">Action</th>`;
            }
            
            table += `</tr></thead><tbody>`;

            rows.forEach(row => {
                const sectionColors = { 'weekly': 'primary', 'monthly': 'info', 'sale': 'warning' };
                const badge = `<span class="badge bg-${sectionColors[row.section] || 'secondary'}">${row.section.charAt(0).toUpperCase()}</span>`; // Abbreviated Badge
                
                // Stack Date/Weekday Values
                let dateDisplay = row.weekday_raw || '-';
                if (dateDisplay.includes(',')) {
                    dateDisplay = dateDisplay.replace(/,\s*/g, '<br>');
                }

                // Color Code Locations
                let locText = row.locations || '-';
                let locStyle = 'color: #fd7e14;'; 
                if (locText.includes('All Locations Except')) {
                    locStyle = 'color: #dc3545; font-weight: bold;'; 
                } else if (locText.trim() === 'All Locations') {
                    locStyle = 'color: #198754; font-weight: bold;'; 
                }

                const truncate = (t, l) => t && t.length > l ? t.substring(0, l) + '...' : (t || '-');
                
                // Truncate based on width
                const notes = row.notes ? `<span title="${row.notes.replace(/"/g, '&quot;')}">${truncate(row.notes, 45)}</span>` : '-';
                const locDisplay = `<span style="${locStyle}" title="${locText.replace(/"/g, '&quot;')}">${truncate(locText, 35)}</span>`;
                
                let misLink = '-';
                if(row.mis_id && row.mis_id !== '-') {
                    misLink = row.mis_id.split(',').map(id => 
                        `<a href="#" onclick="lookupMisId('${id.trim()}'); return false;" style="font-weight:bold; text-decoration:underline;">${id.trim()}</a>`
                    ).join(', ');
                }

                table += `<tr>`;
                if (showConflictDate) table += `<td style="${cellStyle}"><span class="badge bg-danger">${row.conflict_date}</span></td>`;
                table += `
                    <td style="${cellStyle}">${badge}</td>
                    <td style="${cellStyle} text-align:center; font-weight:bold;">${row.row_num}</td>
                    <td style="${wrapStyle} line-height: 1.1;">${dateDisplay}</td>
                    <td style="${cellStyle}">${row.discount}</td>
                    <td style="${cellStyle}">${row.vendor_contrib}</td>
                    <td style="${wrapStyle}">${locDisplay}</td>
                    <td style="${wrapStyle}">${notes}</td>
                    <td style="${cellStyle}">${misLink}</td>
                    <td style="${cellStyle}"><button class="btn btn-sm btn-outline-primary py-0 px-1" style="font-size: 0.8em;" onclick="openSheetRow(${row.row_num})">Row ->[EMOJI][EMOJI][EMOJI]</button></td>
                </tr>`;
            });
            table += `</tbody></table>`;
            return table;
        }

        function initTooltips() {
            setTimeout(function() {
                var tooltipTriggerList = [].slice.call(document.querySelectorAll('[title]'));
                tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl);
                });
            }, 500);
        }

        // ============================================
        // CLEANUP AUDIT - Find stale MIS entries
        // ============================================
        let cleanupAuditData = { fullMatch: [], idOnly: [] };
        
        function switchCleanupMethod(method, btnElement) {
            // Hide all method contents
            document.querySelectorAll('.cleanup-method-content').forEach(el => {
                el.style.display = 'none';
            });
            
            // Deactivate all tabs
            document.querySelectorAll('#cleanupMethodTabs .nav-link').forEach(el => {
                el.classList.remove('active');
            });
            
            // Show selected method
            const targetEl = document.getElementById('cleanup-method-' + method);
            if (targetEl) {
                targetEl.style.display = 'block';
            }
            
            // Activate button
            if (btnElement) {
                btnElement.classList.add('active');
            }
        }
        
        function filterCleanupSection(method, section, btnElement) {
            const containerId = method === 'full-match' ? 'cleanup-full-match-results' : 'cleanup-id-only-results';
            const tabsId = method === 'full-match' ? 'cleanupFullMatchSectionTabs' : 'cleanupIdOnlySectionTabs';
            
            // Update active state on pills
            document.querySelectorAll(`#${tabsId} .nav-link`).forEach(el => {
                el.classList.remove('active');
            });
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            // Filter rows in the table
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const rows = container.querySelectorAll('tbody tr[data-section]');
            rows.forEach(row => {
                const rowSection = row.getAttribute('data-section');
                if (section === 'all' || rowSection === section) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update visible count
            const visibleCount = container.querySelectorAll('tbody tr[data-section]:not([style*="display: none"])').length;
            const countBadge = container.querySelector('.cleanup-count-badge');
            if (countBadge) {
                countBadge.textContent = visibleCount + ' entries';
            }
        }
        
        async function runCleanupAudit() {
            const statsEl = document.getElementById('cleanup-audit-stats');
            const fullMatchResultsEl = document.getElementById('cleanup-full-match-results');
            const idOnlyResultsEl = document.getElementById('cleanup-id-only-results');
            
            statsEl.textContent = 'Scanning...';
            statsEl.className = 'badge bg-warning fs-6 me-2';
            fullMatchResultsEl.innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary"></div><div class="mt-2">Scanning MIS CSV for stale entries...</div></div>';
            idOnlyResultsEl.innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary"></div><div class="mt-2">Scanning MIS CSV for stale entries...</div></div>';
            
            try {
                const tab = document.getElementById('mis-tab').value;
                if (!tab) {
                    alert('Please select a sheet tab in Setup first');
                    statsEl.textContent = 'Ready';
                    statsEl.className = 'badge bg-secondary fs-6 me-2';
                    fullMatchResultsEl.innerHTML = '<p class="text-muted">Select a sheet tab first.</p>';
                    idOnlyResultsEl.innerHTML = '<p class="text-muted">Select a sheet tab first.</p>';
                    return;
                }
                
                const formData = new FormData();
                formData.append('tab', tab);
                
                if (misData.csvFile) {
                    formData.append('csv', misData.csvFile);
                } else if (misData.localPath) {
                    formData.append('local_csv_path', misData.localPath);
                }
                
                const response = await fetch('/api/mis/cleanup-audit', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (data.success) {
                    cleanupAuditData = data.results;
                    const totalIssues = (data.results.fullMatch?.length || 0) + (data.results.idOnly?.length || 0);
                    statsEl.textContent = totalIssues + ' potential issues';
                    statsEl.className = totalIssues > 0 ? 'badge bg-danger fs-6 me-2' : 'badge bg-success fs-6 me-2';
                    renderCleanupResults('full-match', data.results.fullMatch || []);
                    renderCleanupResults('id-only', data.results.idOnly || []);
                } else {
                    statsEl.textContent = 'Error';
                    statsEl.className = 'badge bg-danger fs-6 me-2';
                    fullMatchResultsEl.innerHTML = `<div class="alert alert-danger">Error: ${data.error}</div>`;
                    idOnlyResultsEl.innerHTML = `<div class="alert alert-danger">Error: ${data.error}</div>`;
                }
            } catch (error) {
                statsEl.textContent = 'Error';
                statsEl.className = 'badge bg-danger fs-6 me-2';
                fullMatchResultsEl.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
                idOnlyResultsEl.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        }
        
        function renderCleanupResults(method, results) {
            const containerId = method === 'full-match' ? 'cleanup-full-match-results' : 'cleanup-id-only-results';
            const container = document.getElementById(containerId);
            
            if (!results || results.length === 0) {
                container.innerHTML = `<div class="alert alert-success"><i class="bi bi-check-circle"></i> No stale entries found using ${method === 'full-match' ? 'Full Field Match' : 'MIS ID Only'} detection.</div>`;
                return;
            }
            
            // Count by section
            const sectionCounts = { weekly: 0, monthly: 0, sale: 0 };
            results.forEach(r => {
                const section = (r.section || 'weekly').toLowerCase();
                if (sectionCounts.hasOwnProperty(section)) {
                    sectionCounts[section]++;
                }
            });
            
            let html = `<div class="d-flex justify-content-between align-items-center mb-2">
                <span class="cleanup-count-badge badge bg-danger">${results.length} entries</span>
                <small class="text-muted">Weekly: ${sectionCounts.weekly} | Monthly: ${sectionCounts.monthly} | Sale: ${sectionCounts.sale}</small>
            </div>`;
            
            html += `<div class="table-responsive"><table class="table table-sm table-bordered table-hover">
                <thead class="table-dark">
                    <tr>
                        <th style="width:80px;">MIS ID</th>
                        <th style="width:150px;">Brand</th>
                        <th style="width:80px;">Weekday</th>
                        <th style="width:70px;">Discount</th>
                        <th style="width:70px;">Vendor %</th>
                        <th style="width:150px;">Locations</th>
                        <th style="width:90px;">Start Date</th>
                        <th style="width:90px;">End Date</th>
                        <th style="width:80px;">Section</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>`;
            
            results.forEach((r, idx) => {
                const section = (r.section || 'weekly').toLowerCase();
                const sectionBadgeClass = section === 'weekly' ? 'bg-primary' : (section === 'monthly' ? 'bg-success' : 'bg-warning text-dark');
                
                // Format locations with numbered tooltip
                const locs = r.locations || 'All Locations';
                const locParts = locs.split(',').map(l => l.trim()).filter(l => l);
                const locDisplay = locParts.slice(0, 2).join('<br>') + (locParts.length > 2 ? '<br>...' : '');
                const locTooltip = locParts.map((l, i) => (i + 1) + '. ' + l).join('&#10;');
                
                // Format weekday vertically
                const weekday = r.weekday || '-';
                const weekdayParts = weekday.split(',').map(w => w.trim()).filter(w => w);
                const weekdayDisplay = weekdayParts.slice(0, 3).join('<br>') + (weekdayParts.length > 3 ? '<br>...' : '');
                const weekdayTooltip = weekdayParts.join('&#10;');
                
                // Status styling
                let statusHtml = '';
                if (r.status === 'NOT_IN_SHEET') {
                    statusHtml = '<span class="badge bg-danger">NOT IN SHEET</span>';
                } else if (r.status === 'PARTIAL_MATCH') {
                    statusHtml = `<span class="badge bg-warning text-dark" title="${r.partial_match_details || ''}">PARTIAL MATCH</span>`;
                    if (r.partial_match_details) {
                        statusHtml += `<br><small class="text-muted">${r.partial_match_details}</small>`;
                    }
                } else if (r.status === 'ID_NOT_TRACKED') {
                    statusHtml = '<span class="badge bg-info">ID NOT TRACKED</span>';
                } else {
                    statusHtml = `<span class="badge bg-secondary">${r.status || 'UNKNOWN'}</span>`;
                }
                
                html += `<tr data-section="${section}">
                    <td>
                        <button class="btn btn-sm btn-outline-secondary py-0 px-2" 
                                onclick="lookupMisId('${r.mis_id}')" 
                                style="font-weight:bold;" 
                                title="Click to lookup in MIS">
                            ${r.mis_id}
                        </button>
                    </td>
                    <td>${r.brand || '-'}</td>
                    <td title="${weekdayTooltip}" style="font-size:0.85em;">${weekdayDisplay}</td>
                    <td>${r.discount || '-'}%</td>
                    <td>${r.vendor_pct || '-'}%</td>
                    <td title="${locTooltip}" style="font-size:0.85em;">${locDisplay}</td>
                    <td>${r.start_date || '-'}</td>
                    <td>${r.end_date || '-'}</td>
                    <td><span class="badge ${sectionBadgeClass}">${section.toUpperCase()}</span></td>
                    <td>${statusHtml}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

async function runConflictAudit() {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Scanning...';
        
        document.getElementById('conflict-results').innerHTML = '';
        document.getElementById('conflict-stats').innerText = 'Scanning...';

        try {
            const formData = new FormData();
            // Attach active CSV if available
            if (misData.csvFile) {
                formData.append('csv', misData.csvFile);
            } else if (misData.localPath) {
                formData.append('local_csv_path', misData.localPath);
            } else if (misData.mis_csv_filename) {
                 // Fallback if we stored filename but logic needs path
                 formData.append('local_csv_path', misData.pulledCSVPath);
            }

            const response = await fetch('/api/mis/conflict-audit', {
                method: 'POST',
                body: formData
            });
            const data = await response.json();

            if (data.success) {
                renderConflictResults(data.conflicts);
                document.getElementById('conflict-stats').innerText = 
                    `${data.conflict_groups} Conflict Groups Found (${data.total_active} Active Deals Scanned)`;
            } else {
                alert('Error: ' + data.error);
                document.getElementById('conflict-stats').innerText = 'Error';
            }
        } catch (e) {
            alert('Network Error: ' + e.message);
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

    function renderConflictResults(conflicts) {
        const containerId = 'conflict-results';
        const container = document.getElementById(containerId);
        
        // Note: Conflict audit doesn't categorize by deal type (weekly/monthly/sale)
        // It groups by Brand/Weekday conflicts across all deal types
        const conflictCount = conflicts ? conflicts.length : 0;
        
        // Header with sub-tabs
        let headerHtml = '<h3>Conflict Analysis Results</h3>';
        
        // Generate deal type tabs with informational counts
        // Since conflicts aren't categorized by type, we show N/A for individual types
        headerHtml += `
            <div class="deal-type-tabs">
                <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'weekly', this)">
                    &#x1F4C5; Weekly Deals <span class="badge bg-secondary">N/A</span>
                </button>
                <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'monthly', this)">
                     Monthly Deals <span class="badge bg-secondary">N/A</span>
                </button>
                <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'sale', this)">
                     Sale Deals <span class="badge bg-secondary">N/A</span>
                </button>
                <button class="deal-type-btn active" onclick="switchDealTypeTab('${containerId}', 'all', this)">
                     All Conflicts <span class="badge bg-warning text-dark">${conflictCount} groups</span>
                </button>
            </div>
        `;
        
        // Info message for individual deal type tabs
        const infoMessage = `
            <div class="alert alert-info">
                <i class="bi bi-info-circle"></i> 
                <strong>Note:</strong> Conflict detection works across all deal types. Conflicts are grouped by 
                <strong>Brand + Weekday</strong> regardless of whether they are Weekly, Monthly, or Sale deals.
                <br><br>
                View the <strong>"All Conflicts"</strong> tab to see all detected conflicts.
            </div>
        `;
        
        // Build content for "All" tab
        let allContent = '';
        
        if (!conflicts || conflicts.length === 0) {
            allContent = `
                <div class="text-center p-5 text-muted" style="background:#f8f9fa; border-radius:10px;">
                    <h3 style="color:#28a745;"><i class="bi bi-check-circle-fill"></i> No Conflicts Found!</h3>
                    <p>All active deals appear unique based on Brand/Discount/Category/Weekday.</p>
                </div>`;
        } else {
            allContent = '<div class="accordion" id="conflictAccordion">';
            
            conflicts.forEach((group, idx) => {
                const groupID = `conflictGroup${idx}`;
                
                allContent += `
                <div class="card mb-3 shadow-sm" style="border-left: 5px solid #ffc107;">
                    <div class="card-header bg-white" id="heading${idx}">
                        <div class="d-flex justify-content-between align-items-center" 
                             style="cursor:pointer;" 
                             data-bs-toggle="collapse" 
                             data-bs-target="#${groupID}">
                            
                            <div>
                                <span class="badge bg-warning text-dark me-2">${group.count} Conflicts</span>
                                <span class="fw-bold" style="font-size:1.1em;">${group.title}</span>
                            </div>
                            <i class="bi bi-chevron-down text-muted"></i>
                        </div>
                    </div>

                    <div id="${groupID}" class="collapse show" data-bs-parent="#conflictAccordion">
                        <div class="card-body p-0">
                            <table class="table table-sm table-hover mb-0" style="font-size:0.9em;">
                                <thead class="table-light">
                                    <tr>
                                        <th>MIS ID</th>
                                        <th>Start Date</th>
                                        <th>End Date</th>
                                        <th>Locations</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                
                group.rows.forEach(row => {
                    const actionBtn = `<button class="btn btn-sm btn-outline-primary py-0" onclick="lookupMisId('${row.mis_id}')">View ${row.mis_id}</button>`;

                    allContent += `
                                    <tr>
                                        <td class="fw-bold text-primary">${row.mis_id}</td>
                                        <td>${row.start}</td>
                                        <td>${row.end}</td>
                                        <td>${row.locations}</td>
                                        <td>${actionBtn}</td>
                                    </tr>`;
                });

                allContent += `       </tbody>
                            </table>
                        </div>
                    </div>
                </div>`;
            });

            allContent += '</div>';
        }
        
        // Build final HTML with containers
        let finalHtml = headerHtml;
        finalHtml += `<div id="${containerId}-weekly" class="deal-type-content">${infoMessage}</div>`;
        finalHtml += `<div id="${containerId}-monthly" class="deal-type-content">${infoMessage}</div>`;
        finalHtml += `<div id="${containerId}-sale" class="deal-type-content">${infoMessage}</div>`;
        finalHtml += `<div id="${containerId}-all" class="deal-type-content active" style="display:block;">${allContent}</div>`;
        
        container.innerHTML = finalHtml;
    }

async function navBlaze(type, id) {
            let url = "";
            // Use the specific Setup Anchor
            if (type === 'promo') url = `https://retail.blaze.me/company-promotions/promotions/${id}#setup`;
            if (type === 'coll') url = `https://retail.blaze.me/company-promotions/smart-collections/${id}`;
            
            await fetch('/api/blaze/navigate', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ url: url })
            });
        }

// --- OTD Price Modal Logic (With Marketing Audit) ---
function showOtdModal(rowIndex) {
    // 1. Get row data from global storage
    const row = blazeData.currentRows[rowIndex];
    if (!row) return;

    // 2. Parse Base Price
    const discountValueStr = String(row['Discount Value']).replace(/[^0-9.-]/g, '');
    const discValue = parseFloat(discountValueStr);
    
    if (isNaN(discValue)) {
        alert("Invalid price value");
        return;
    }

    // 3. Prepare Modal Elements
    const modal = document.getElementById('detailModal');
    const backdrop = document.getElementById('detailModalBackdrop');
    
    document.getElementById('detailModalTitle').textContent = "OTD Price Breakdown";
    document.getElementById('detailModalId').textContent = `Base Price: $${discValue.toFixed(2)}`;
    document.getElementById('detailModalType').textContent = row.Name;

    // 4. Determine Applicable Stores
    let applicableStores = [];
    const locRaw = row.Locations || '';
    
    const ALL_LOCATIONS_LIST = [
        "Beverly Hills", "Davis", "Dixon", "El Sobrante", "Fresno (Palm)",
        "Fresno Shaw", "Hawthorne", "Koreatown", "Laguna Woods", 
        "Oxnard", "Riverside", "West Hollywood"
    ];

    if (locRaw === 'All Locations') {
        applicableStores = ALL_LOCATIONS_LIST;
    } else {
        applicableStores = locRaw.split(',').map(l => l.trim()).filter(l => l);
    }

// --- MARKETING AUDIT SETUP ---
    let targetOtd = null;
    let skipAudit = false;
    
    // Check for Exclusion Verbiage
    if (/BOGO|B2G1/i.test(row.Name)) {
        skipAudit = true;
    } else {
        // Regex for "4 for $20", "2 for 30", etc.
        const bulkMatch = row.Name.match(/(\d+)\s+for\s+\$([0-9.]+)/i);
        if (bulkMatch) {
            // FIX: Use total price directly (Group 2)
            targetOtd = parseFloat(bulkMatch[2]);
        }
    }

    // 5. Build Content HTML
    let bodyHTML = '<div class="section-header" style="color: #28a745;"> OUT THE DOOR PRICES</div>';
    
    if (typeof TAX_RATES === 'undefined' || Object.keys(TAX_RATES).length === 0) {
        bodyHTML += '<div class="alert alert-warning">Tax rates not loaded yet. Please wait or check Setup tab.</div>';
    } else {
        const sortedStores = Object.keys(TAX_RATES).sort();
        let foundAny = false;

        sortedStores.forEach(store => {
            const isApplicable = applicableStores.some(loc => 
                loc.includes(store) || store.includes(loc)
            );

            if (isApplicable) {
                foundAny = true;
                const rate = TAX_RATES[store];
                const otdPrice = (discValue * rate); 
                const otdDisplay = otdPrice.toFixed(2);
                
                // AUDIT LOGIC
                let rowColor = "color:#198754;"; // Default Green
                let auditInfo = "";
                let fixAction = "";

                if (!skipAudit && targetOtd !== null && STRICT_OTD_STORES.includes(store)) {
                    // FIX: Round to 2 decimals BEFORE comparing to catch visual penny variances
                    const otdRounded = parseFloat(otdDisplay);
                    const diff = Math.abs(otdRounded - targetOtd);
                    
                    // Match Logic
                    if (diff < 0.009) {
                        // Exact Match (Green)
                        auditInfo = ` <span style="color:#198754; font-size:0.8em;">([OK][EMOJI] Target: $${targetOtd.toFixed(2)})</span>`;
                    } else if (diff <= 0.019) {
                        // Penny Variance (Orange)
                        rowColor = "color:#fd7e14;";
                        auditInfo = ` <span style="color:#fd7e14; font-size:0.8em;">([!] [EMOJI][EMOJI] Target: $${targetOtd.toFixed(2)})</span>`;
                    } else {
                        // Mismatch (Red)
                        rowColor = "color:#dc3545; font-weight:bold;";
                        auditInfo = ` <span style="color:#dc3545; font-size:0.8em;">([X] Target: $${targetOtd.toFixed(2)})</span>`;
                        
                        // Calculate Fix
                        const correctPreTax = (targetOtd / rate).toFixed(2);
                        fixAction = `
                            <button class="btn btn-sm btn-outline-danger" 
                                style="padding: 0px 6px; font-size: 0.75em; margin-left: 10px;" 
                                onclick="copyToClipboard('${correctPreTax}'); this.innerText='Copied!';">
                                Copy Fix: $${correctPreTax}
                            </button>
                        `;
                    }
                }

                bodyHTML += `
                    <div class="data-row" style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #eee; padding:6px 0;">
                        <div>
                            <span class="data-label" style="font-size:1.1em;">${store}</span>
                            ${auditInfo}
                        </div>
                        <div style="display:flex; align-items:center;">
                            <span class="data-value" style="${rowColor} font-size:1.1em;">$${otdDisplay}</span>
                            ${fixAction}
                        </div>
                    </div>`;
            }
        });

        if (!foundAny) {
            bodyHTML += '<div class="data-row">No matching stores found for this promotion configuration.</div>';
        }
    }

    document.getElementById('detailModalBody').innerHTML = bodyHTML;
    modal.style.display = 'block';
    backdrop.style.display = 'block';
}

// --- SHARED RENDER HELPER ---
    async function renderBlazeTable(rows) {
        // [CRITICAL] Store rows globally so buttons can access data by index
        blazeData.currentRows = rows || [];

        // 0. PRE-FETCH TAX RATES (Blocking) - Ensures Audit Logic has data
        let TAX_RATES = {};
        try {
            const response = await fetch('/api/tax-rates');
            const data = await response.json();
            if (data.success) {
                TAX_RATES = data.rates;
            }
        } catch (e) {
            console.error("Failed to pre-fetch tax rates:", e);
        }

// 1. CALCULATE GLOBAL TOTALS
        let totActive = 0;
        let totInactive = 0;
        let totZombie = 0;
        
        if (rows && Array.isArray(rows)) {
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Midnight Local Time
            
            rows.forEach(r => {
                const status = (r.Status || '').trim();
                if (status === 'Active') totActive++;
                else if (status === 'Inactive') totInactive++;
                
                if (status === 'Active') {
                    const endDateStr = (r['End Date'] || '').trim();
                    if (endDateStr) {
                        try {
                            // FIX: Parse strictly as Local Time to avoid UTC shift errors
                            const parts = endDateStr.split('-'); // Assumes YYYY-MM-DD
                            if (parts.length === 3) {
                                const endDate = new Date(parts[0], parts[1] - 1, parts[2]);
                                endDate.setHours(0, 0, 0, 0);
                                
                                // LOGIC: If End Date is STRICTLY LESS than Today, it's a Zombie.
                                // If End Date == Today, it is still running (Active).
                                if (endDate.getTime() < today.getTime()) {
                                    totZombie++;
                                }
                            }
                        } catch (e) {}
                    }
                }
            });
        }

        // Update DOM - Group 1 (Totals)
        document.getElementById('totalCount').innerText = (rows ? rows.length : 0) + " Total Promotions";
        document.getElementById('totalActive').innerText = totActive + " Active";
        document.getElementById('totalInactive').innerText = totInactive + " Inactive";
        document.getElementById('totalZombie').innerText = " " + totZombie + " Zombie";

        // Cleanup old table
        if ($.fn.DataTable.isDataTable('#promotionsTable')) {
            $('#promotionsTable').DataTable().destroy();
        }
        
        const tbody = document.querySelector('#promotionsTable tbody');
        tbody.innerHTML = '';
        
        // Helper: Get ALL location names for comparison
        const ALL_LOCATIONS_LIST = [
            "Beverly Hills", "Davis", "Dixon", "El Sobrante", "Fresno (Palm)", 
            "Fresno Shaw", "Hawthorne", "Koreatown", "Laguna Woods", 
            "Oxnard", "Riverside", "West Hollywood"
        ].sort();
        
        if (rows && Array.isArray(rows)) {
            rows.forEach((row, index) => {
                const tr = document.createElement('tr');
                
                // --- STATUS BADGE LOGIC ---
                const status = (row.Status || '').trim();
                const statusBadge = status === 'Active' 
                    ? '<span class="badge bg-success">Active</span>' 
                    : '<span class="badge bg-danger">Inactive</span>';
                
// --- DAYS UNTIL END CALCULATION ---
                const startDateStr = row['Start Date'] || '';
                const endDateStr = row['End Date'] || '';
                let daysDisplay = '-';
                let isExpired = false;
                
                if (endDateStr && endDateStr !== '') {
                    try {
                        // 1. Setup Dates (Local Time 00:00:00)
                        const today = new Date();
                        today.setHours(0, 0, 0, 0); 
                        
                        // Helper to parse YYYY-MM-DD cleanly to local time
                        const parseLocal = (dateStr) => {
                            if (!dateStr) return null;
                            const parts = dateStr.split('-');
                            if (parts.length === 3) {
                                const d = new Date(parts[0], parts[1] - 1, parts[2]);
                                d.setHours(0, 0, 0, 0);
                                return d;
                            }
                            // Fallback
                            const d = new Date(dateStr);
                            d.setHours(0,0,0,0);
                            return d;
                        };

                        const endDate = parseLocal(endDateStr);
                        const startDate = parseLocal(startDateStr);

                        if (endDate) {
                            // --- NEW: CHECK FOR FUTURE START ---
                            if (startDate && startDate.getTime() > today.getTime()) {
                                // Calculate "Starts in X Days"
                                const startDiff = startDate.getTime() - today.getTime();
                                const daysToStart = Math.round(startDiff / (1000 * 3600 * 24));
                                
                                // Calculate "Runs for X Days"
                                const durationDiff = endDate.getTime() - startDate.getTime();
                                const durationDays = Math.round(durationDiff / (1000 * 3600 * 24));
                                
                                daysDisplay = `<div style="line-height:1.2;">
                                    <span style="color:#0d6efd; font-weight:bold;">Starts in ${daysToStart} Day${daysToStart===1?'':'s'}</span><br>
                                    <span style="color:#6c757d; font-size:0.85em;">Runs for ${durationDays} Day${durationDays===1?'':'s'}</span>
                                </div>`;
                            } 
                            // --- EXISTING LOGIC (Active or Ended) ---
                            else {
                                const diffTime = endDate.getTime() - today.getTime();
                                const diffDays = Math.round(diffTime / (1000 * 3600 * 24));
                                
                                if (diffDays === 0) {
                                    daysDisplay = '<span style="color:#d63384; font-weight:bold;">Ends Today!</span>';
                                } else if (diffDays > 0) {
                                    daysDisplay = `Ends in ${diffDays} Day${diffDays === 1 ? '' : 's'}`;
                                } else {
                                    const absDays = Math.abs(diffDays);
                                    daysDisplay = `Ended ${absDays} Day${absDays === 1 ? '' : 's'} ago`;
                                    isExpired = true;
                                }
                            }
                        }
                    } catch (e) {
                        console.error(e);
                        daysDisplay = 'Invalid Date';
                    }
                }
                
                // --- ROW HIGHLIGHTING ---
                const isExpiredAlt = daysDisplay.includes('Ended') && daysDisplay.includes('ago');

                if (status === 'Active' && (isExpired || isExpiredAlt)) {
                    tr.style.backgroundColor = '#dc3545'; // Bootstrap danger red
                    tr.style.color = '#ffffff'; // White text
                    tr.style.fontWeight = 'bold';
                    tr.style.border = '3px solid #a02030';
                } else if (status === 'Inactive') {
                    tr.style.backgroundColor = '#f4cccc'; // Light pink
                }

                if (isExpiredAlt && !isExpired && status === 'Active') {
                    tr.style.color = '#dc3545'; 
                    tr.style.fontWeight = 'bold';
                }
                
                // --- ID COLUMN ---
                const idButton = `
                    <button onclick="navBlaze('promo', '${row.ID}'); return false;" 
                            class="btn btn-sm btn-primary" 
                            style="font-size: 0.75rem; padding: 2px 8px;"
                            title="ID: ${row.ID}">
                        View Discount
                    </button>
                `;
                
                // --- LOCATIONS SIMPLIFICATION ---
                let locationsRaw = row.Locations || '';
                let locationsDisplay = '';
                let applicableStores = [];

                if (locationsRaw === 'All Locations') {
                    applicableStores = ALL_LOCATIONS_LIST;
                    const tooltipHTML = ALL_LOCATIONS_LIST.join('<br>');
                    locationsDisplay = `<span class="badge bg-info text-white" 
                                              style="cursor: help;" 
                                              data-bs-toggle="tooltip" 
                                              data-bs-html="true" 
                                              data-bs-placement="right"
                                              title="${tooltipHTML}">All Locations</span>`;
                } else {
                    applicableStores = locationsRaw.split(',').map(l => l.trim()).filter(l => l);
                    let displayText = locationsRaw;
                    if (displayText.length > 50) {
                        displayText = displayText.substring(0, 47) + '...';
                    }
                    const locationsList = locationsRaw.split(',').map(l => l.trim()).filter(l => l).sort();
                    const tooltipHTML = locationsList.join('<br>');
                    
                    locationsDisplay = `<span style="cursor: help; text-decoration: underline dotted;" 
                                              data-bs-toggle="tooltip" 
                                              data-bs-html="true" 
                                              data-bs-placement="right"
                                              title="${tooltipHTML}">${displayText}</span>`;
                }
                
                // --- DETAIL COLUMN ---
                const detailCell = `<button 
                    class="btn btn-sm btn-outline-secondary py-0 px-2"
                    style="font-size: 0.75rem; font-weight: bold;" 
                    onmouseenter="showDetailModal(blazeData.currentRows[${index}], false)"
                    onmouseleave="hideDetailModal()"
                    onclick="toggleDetailPin(blazeData.currentRows[${index}]); event.stopPropagation();">
                    DETAIL
                </button>`;
                
                // --- AUTO/MANUAL COLUMN ---
                const autoManualText = row.auto_apply ? 'Automatic' : 'Manual';
                const autoManualColor = row.auto_apply ? '#0066ff' : '#ff8800';
                const autoManualCell = `<span style="color: ${autoManualColor}; font-weight: bold;">${autoManualText}</span>`;
                
                // --- GROUP LINKS ---
                const makeGroupLinks = (groups) => {
                    if (!groups || groups.length === 0) return '-';
                    const list = Array.isArray(groups) ? groups : []; 
                    return list.map(g => {
                        const displayName = g.name.length > 20 ? g.name.substring(0, 20) + '...' : g.name;
                        const fullName = g.name; 
                        return `<a href="#" onclick="navBlaze('coll', '${g.id}'); return false;" 
                           class="badge bg-light text-dark border" 
                           style="margin:1px; text-decoration:none; display:block; width:fit-content; margin-bottom:2px;"
                           title="${fullName}">
                           ${displayName}
                         </a>`;
                    }).join(''); 
                };

// --- DISCOUNT VALUE (BUTTON & AUDIT LOGIC) ---
                let discountValueContent = row['Discount Value'];
                const discType = row['Discount Value Type'] || '';
                const isFinalPrice = discType.toLowerCase().includes('final');
                
                // IF FINAL PRICE: RENDER BUTTON WITH AUDIT
                if (isFinalPrice && discountValueContent && discountValueContent !== '-') {
                    
                    // --- AUDIT LOGIC START ---
                    // Default Style: Blue Text, Blue Border, Tag Emoji
                    let btnStyle = "color:#0d6efd; border:1px solid #0d6efd;"; 
                    let btnEmoji = "";
                    
                    // 1. Check for bulk deal pattern in Name (e.g. "4 for $20")
                    const bulkMatch = row.Name.match(/(\d+)\s+for\s+\$([0-9.]+)/i);
                    const isBogo = /BOGO|B2G1/i.test(row.Name);
                    
                    if (!isBogo && bulkMatch && Object.keys(TAX_RATES).length > 0) {
                        // FIX: Use total price directly from Regex Group 2
                        const targetOtd = parseFloat(bulkMatch[2]);
                        const discValue = parseFloat(String(discountValueContent).replace(/[^0-9.-]/g, ''));
                        
                        let maxDiff = 0;
                        
                        // Check applicable STRICT stores
                        STRICT_OTD_STORES.forEach(strictStore => {
                            // Check if this strict store is in the applicable list for this row
                            const isApplicable = applicableStores.some(loc => 
                                loc.includes(strictStore) || strictStore.includes(loc)
                            );
                            
                            if (isApplicable && TAX_RATES[strictStore]) {
                                const rate = TAX_RATES[strictStore];
                                const calculatedOtd = discValue * rate;
                                // FIX: Round to 2 decimals before comparing
                                const calculatedRounded = parseFloat(calculatedOtd.toFixed(2));
                                const diff = Math.abs(calculatedRounded - targetOtd);
                                if (diff > maxDiff) maxDiff = diff;
                            }
                        });
                        
                        // Determine Style based on worst variance found
                        if (maxDiff >= 0.02) {
                            // Mismatch (> 2 cents): RED TEXT + CAUTION
                            btnStyle = "color:#dc3545; border:1px solid #dc3545;"; 
                            btnEmoji = "[!] [EMOJI][EMOJI]";
                        } else if (maxDiff > 0.009) {
                            // Penny Variance: ORANGE TEXT + CAUTION
                            btnStyle = "color:#fd7e14; border:1px solid #fd7e14;"; 
                            btnEmoji = "[!] [EMOJI][EMOJI]";
                        }
                    }
                    // --- AUDIT LOGIC END ---

                    // RENDER BUTTON (Using inline styles to force color)
                    discountValueContent = `
                        <button class="btn btn-sm" 
                                style="font-weight:bold; padding:0px 6px; background:white; ${btnStyle}"
                                onclick="showOtdModal(${index})">
                            ${discountValueContent} ${btnEmoji}
                        </button>`;
                }

                tr.innerHTML = `
                    <td>${detailCell}</td>
                    <td>${idButton}</td>
                    <td>${row.Name}</td>
                    <td>${statusBadge}</td>
                    <td>${autoManualCell}</td>
                    <td>${locationsDisplay}</td>
                    <td>${makeGroupLinks(row.buy_groups)}</td>
                    <td>${makeGroupLinks(row.get_groups)}</td>
                    <td>${row['Discount Value Type']}</td>
                    <td>${discountValueContent}</td>
                    <td>${row['Start Date']}</td>
                    <td>${row['End Date']}</td>
                    <td><span style="font-size: 0.85rem; font-style: italic;">${daysDisplay}</span></td>
                `;
                tbody.appendChild(tr);
                
                // Attach row data to detail cell span for event handlers
                const detailSpan = tr.querySelector('td:first-child span');
                if (detailSpan) {
                    detailSpan.rowData = row;
                }
            });
        }
        
        // Initialize DataTable
        const table = $('#promotionsTable').DataTable({ 
            paging: false, 
            scrollY: '60vh', 
            scrollCollapse: false,  // Don't collapse - maintain scroll area
            dom: 't',
            autoWidth: true,
            deferRender: true
        });
        
        // Force redraw if container was hidden during initialization
        const promoContent = document.getElementById('blaze-promo-content');
        if (promoContent && promoContent.style.display !== 'none') {
            setTimeout(function() {
                table.columns.adjust().draw(false);
            }, 50);
        }
        
        // Initialize Bootstrap tooltips
        setTimeout(function() {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        }, 300);

        // 2. SETUP DYNAMIC FILTER COUNTER
        table.on('draw', function () {
            const filteredData = table.rows({ search: 'applied' }).data();
            let filtActive = 0;
            let filtInactive = 0;
            let filtZombie = 0;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            filteredData.each(function (value, index) {
                const statusHTML = String(value[3] || ''); // Index 3 is Status
                const endDateHTML = String(value[11] || ''); // Index 11 is End Date
                
                if (statusHTML.includes('Active')) {
                    filtActive++;
                    const dateMatch = endDateHTML.match(/\d{4}-\d{2}-\d{2}/);
                    if (dateMatch) {
                        try {
                            const endDate = new Date(dateMatch[0]);
                            endDate.setHours(0, 0, 0, 0);
                            // UPDATE: Strict inequality for Zombie count
                            if (endDate < today) {
                                filtZombie++;
                            }
                        } catch (e) {}
                    }
                } else if (statusHTML.includes('Inactive')) {
                    filtInactive++;
                }
            });

            document.getElementById('filteredCount').innerText = filteredData.length + " Total";
            document.getElementById('filteredActive').innerText = filtActive + " Active";
            document.getElementById('filteredInactive').innerText = filtInactive + " Inactive";
            document.getElementById('filteredZombie').innerText = " " + filtZombie + " Zombie";

            const nameFilter = document.getElementById('blazeNameSearch').value;
            const subFilter = document.getElementById('blazeSubSearch').value;
            const filteredGroup = document.getElementById('filteredStatsGroup');
            const downloadFilteredBtn = document.getElementById('downloadFilteredBtn');
            
            // Check if any filter is active (including zombie filter)
            const hasActiveFilter = nameFilter.trim().length > 0 || subFilter.trim().length > 0 || $.fn.dataTable.ext.search.length > 0;
            
            if (hasActiveFilter) {
                filteredGroup.style.display = 'block';
                downloadFilteredBtn.style.display = 'block';
            } else {
                filteredGroup.style.display = 'none';
                downloadFilteredBtn.style.display = 'none';
            }
        });

        table.draw();

        // PERSISTENCE
        const primaryVal = document.getElementById('blazeNameSearch').value;
        const subVal = document.getElementById('blazeSubSearch').value;
        const subContainer = document.getElementById('subSearchContainer');
        
        if (primaryVal.trim().length > 0) {
            subContainer.style.display = 'flex';
            table.column(2).search(primaryVal);  
            table.search(subVal);                 
            table.draw();
        } else if (subVal.trim().length > 0) {
            document.getElementById('blazeSubSearch').value = '';
            subContainer.style.display = 'none';
        }
    }

// 3. FULL REPORT EXPORT FUNCTION
        async function exportData(mode) {
            if (mode === 'full') {
                window.location.href = '/api/blaze/export-csv';
            } else {
                console.log('Export mode not implemented:', mode);
            }
        }

// ============================================
// DOWNLOAD FILTERED - Export visible rows only
// ============================================
async function exportFilteredData() {
    if (!$.fn.DataTable.isDataTable('#promotionsTable')) {
        alert('Table not initialized');
        return;
    }
    
    const table = $('#promotionsTable').DataTable();
    const filteredData = table.rows({ search: 'applied' }).data();
    
    if (filteredData.length === 0) {
        alert('No filtered data to export');
        return;
    }
    
    // Collect visible row IDs
    const visibleIds = [];
    filteredData.each(function(rowData) {
        // Extract ID from the button HTML in column 0 (Detail column has the View Discount button)
        // The ID is in column 1 which contains just the ID text
        const idCell = rowData[1]; // ID column
        // Extract numeric ID from potential HTML or text
        const idMatch = String(idCell).match(/(\d+)/);
        if (idMatch) {
            visibleIds.push(idMatch[1]);
        }
    });
    
    if (visibleIds.length === 0) {
        alert('Could not extract IDs from filtered data');
        return;
    }
    
    // Send to backend for CSV generation
    try {
        const response = await fetch('/api/blaze/export-filtered-csv', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ids: visibleIds })
        });
        
        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `blaze_filtered_report_${new Date().toISOString().slice(0,19).replace(/[:-]/g, '')}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        } else {
            const errorText = await response.text();
            alert('Export failed: ' + errorText);
        }
    } catch (e) {
        alert('Export error: ' + e.message);
    }
}

// ============================================
// ZOMBIE CLEANUP - State Management
// ============================================
let zombieCleanupState = {
    isActive: false,
    isManualMode: false,
    zombieIds: [],
    currentIndex: 0,
    originalFilters: {
        nameFilter: '',
        subFilter: ''
    }
};

function toggleZombieCleanupMode() {
    const toggle = document.getElementById('zombieCleanupToggle');
    const btn = document.getElementById('zombieCleanupBtn');
    
    if (toggle.checked) {
        btn.style.display = 'inline-block';
    } else {
        btn.style.display = 'none';
        // If cleanup was active, reset everything
        if (zombieCleanupState.isActive) {
            finishZombieCleanup();
        }
    }
}

function startZombieCleanup() {
    // Save current filter state
    zombieCleanupState.originalFilters.nameFilter = document.getElementById('blazeNameSearch').value;
    zombieCleanupState.originalFilters.subFilter = document.getElementById('blazeSubSearch').value;
    
    // Find all zombie IDs from the current data
    const zombieIds = findZombieIds();
    
    if (zombieIds.length === 0) {
        alert('No zombie deals found! All active deals have valid end dates.');
        return;
    }
    
    zombieCleanupState.zombieIds = zombieIds;
    zombieCleanupState.currentIndex = 0;
    
    // Update modal count
    document.getElementById('zombieCountDisplay').textContent = zombieIds.length;
    
    // Show modal
    document.getElementById('zombieModalBackdrop').style.display = 'block';
    document.getElementById('zombieModal').style.display = 'block';
    document.getElementById('zombieActionButtons').style.display = 'flex';
    document.getElementById('zombieProgressContainer').style.display = 'none';
}

function findZombieIds() {
            const zombieIds = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (blazeData.currentRows && Array.isArray(blazeData.currentRows)) {
                blazeData.currentRows.forEach(row => {
                    const status = (row.Status || '').trim();
                    const endDateStr = (row['End Date'] || '').trim();

                    if (status === 'Active' && endDateStr) {
                        try {
                            // FIX: Parse strictly as Local Time
                            const parts = endDateStr.split('-');
                            if (parts.length === 3) {
                                const endDate = new Date(parts[0], parts[1] - 1, parts[2]);
                                endDate.setHours(0, 0, 0, 0);
                                
                                // LOGIC: Only kill if End Date is BEFORE today (Yesterday or older)
                                if (endDate.getTime() < today.getTime()) {
                                    zombieIds.push(row.ID);
                                }
                            }
                        } catch (e) {
                            console.error("Date parse error", e);
                        }
                    }
                });
            }
            return zombieIds;
        }

function applyZombieFilter() {
    if (!$.fn.DataTable.isDataTable('#promotionsTable')) return;
    
    const table = $('#promotionsTable').DataTable();
    
    // Clear existing filters
    document.getElementById('blazeNameSearch').value = '';
    document.getElementById('blazeSubSearch').value = '';
    table.column(2).search('');
    table.search('');
    
    // Apply custom filter for zombies only
    $.fn.dataTable.ext.search.push(function(settings, data, dataIndex) {
        if (settings.nTable.id !== 'promotionsTable') return true;
        
        const statusHTML = data[3] || '';
        const endDateHTML = data[11] || '';
        
        // Must be Active
        if (!statusHTML.includes('Active')) return false;
        
        // Must have end date in past
        const dateMatch = endDateHTML.match(/\d{4}-\d{2}-\d{2}/);
        if (!dateMatch) return false;
        
        try {
            const endDate = new Date(dateMatch[0]);
            const today = new Date();
            endDate.setHours(0, 0, 0, 0);
            today.setHours(0, 0, 0, 0);
            
            return endDate < today;
        } catch (e) {
            return false;
        }
    });
    
    table.draw();
}

function clearZombieFilter() {
    // Remove custom zombie filter
    $.fn.dataTable.ext.search.pop();
    
    if (!$.fn.DataTable.isDataTable('#promotionsTable')) return;
    
    const table = $('#promotionsTable').DataTable();
    table.draw();
}

function runManualCleanup() {
    zombieCleanupState.isActive = true;
    zombieCleanupState.isManualMode = true;
    
    // Hide modal
    document.getElementById('zombieModalBackdrop').style.display = 'none';
    document.getElementById('zombieModal').style.display = 'none';
    
    // Apply zombie filter
    applyZombieFilter();
    
    // Change button to "Finish Cleanup"
    const btn = document.getElementById('zombieCleanupBtn');
    btn.innerHTML = '[OK][EMOJI] Finish Cleanup';
    btn.classList.add('cleanup-mode');
    btn.onclick = finishZombieCleanup;
}

async function runAutoCleanup() {
    zombieCleanupState.isActive = true;
    zombieCleanupState.isManualMode = false;
    zombieCleanupState.currentIndex = 0;
    
    // Show progress, hide buttons
    document.getElementById('zombieActionButtons').style.display = 'none';
    document.getElementById('zombieProgressContainer').style.display = 'block';
    
    // Apply zombie filter to table
    applyZombieFilter();
    
    // Change main button to show in-progress
    const btn = document.getElementById('zombieCleanupBtn');
    btn.innerHTML = '<span class="spin"></span> Processing...';
    btn.disabled = true;
    
    // Process each zombie
    const total = zombieCleanupState.zombieIds.length;
    
    for (let i = 0; i < total; i++) {
        zombieCleanupState.currentIndex = i;
        const promoId = zombieCleanupState.zombieIds[i];
        
        // Update progress
        const percent = Math.round(((i + 1) / total) * 100);
        document.getElementById('zombieProgressFill').style.width = percent + '%';
        document.getElementById('zombieProgressText').textContent = 
            `Processing ${i + 1} of ${total}: ID ${promoId}`;
        
        try {
            const response = await fetch('/api/blaze/zombie-disable', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ promo_id: promoId })
            });
            
            const result = await response.json();
            
            if (!result.success) {
                console.error(`Failed to disable ${promoId}: ${result.error}`);
                document.getElementById('zombieProgressText').textContent = 
                    `[!] [EMOJI][EMOJI] Error on ID ${promoId}: ${result.error}. Continuing...`;
                await new Promise(r => setTimeout(r, 2000));
            }
        } catch (e) {
            console.error(`Error disabling ${promoId}:`, e);
            document.getElementById('zombieProgressText').textContent = 
                `[!] [EMOJI][EMOJI] Network error on ID ${promoId}. Continuing...`;
            await new Promise(r => setTimeout(r, 2000));
        }
        
        // Small delay between operations
        await new Promise(r => setTimeout(r, 500));
    }
    
    // Complete
    document.getElementById('zombieProgressText').textContent = 
        `[OK][EMOJI] Completed! Disabled ${total} zombie deal(s).`;
    document.getElementById('zombieProgressFill').style.width = '100%';
    document.getElementById('zombieProgressFill').style.background = '#28a745';
    
    // Wait 2 seconds then finish
    await new Promise(r => setTimeout(r, 2000));
    finishZombieCleanup();
    
    // Refresh data
    fetchBlazeData();
}

function cancelZombieCleanup() {
    // Hide modal
    document.getElementById('zombieModalBackdrop').style.display = 'none';
    document.getElementById('zombieModal').style.display = 'none';
    
    // Reset state
    zombieCleanupState.isActive = false;
    zombieCleanupState.zombieIds = [];
}

function finishZombieCleanup() {
    // Clear zombie filter
    clearZombieFilter();
    
    // Hide modal if visible
    document.getElementById('zombieModalBackdrop').style.display = 'none';
    document.getElementById('zombieModal').style.display = 'none';
    
    // Reset progress UI
    document.getElementById('zombieActionButtons').style.display = 'flex';
    document.getElementById('zombieProgressContainer').style.display = 'none';
    document.getElementById('zombieProgressFill').style.width = '0%';
    document.getElementById('zombieProgressFill').style.background = 'linear-gradient(90deg, #dc3545, #fd7e14)';
    
    // Reset button
    const btn = document.getElementById('zombieCleanupBtn');
    btn.innerHTML = ' Zombie Cleanup';
    btn.classList.remove('cleanup-mode');
    btn.onclick = startZombieCleanup;
    btn.disabled = false;
    
    // Restore original filters
    document.getElementById('blazeNameSearch').value = zombieCleanupState.originalFilters.nameFilter;
    document.getElementById('blazeSubSearch').value = zombieCleanupState.originalFilters.subFilter;
    
    // Re-apply original filters
    applyBlazeFilters();
    
    // Reset state
    zombieCleanupState.isActive = false;
    zombieCleanupState.isManualMode = false;
    zombieCleanupState.zombieIds = [];
    zombieCleanupState.currentIndex = 0;
}

        document.addEventListener('click', function(event) {
            const tooltip = document.getElementById('suggestion-tooltip');
            if (!event.target.closest('.suggestion-indicator') && !event.target.closest('.tooltip-container')) {
                tooltip.style.display = 'none';
            }
            
            const brandPopup = document.getElementById('brand-sticky-popup');
            if (!event.target.closest('.brand-multi') && !event.target.closest('.brand-popup')) {
                brandPopup.style.display = 'none';
            }
        });

        let hasAutoSynced = false; // Flag to prevent looping

        async function checkBrowserStatus() {
            try {
                const response = await fetch('/api/browser-status');
                const data = await response.json();
                
                const statusDiv = document.getElementById('browser-ready-status');
                const statusText = document.getElementById('browser-ready-text');
                
                if (data.ready) {
                    statusDiv.className = 'alert alert-success';
                    statusDiv.style.display = 'block';
                    statusText.textContent = 'Ready!';
                    
                    // v10.7: REMOVED AUTO-SYNC - was causing browser crash by opening Blaze tabs
                    // User should manually click "Initialize Browser" or "Refresh / Sync Data"
                    // when they're ready to connect to Blaze
                    console.log("[STARTUP] Browser Ready. Auto-sync disabled - use manual sync.");
                } else {
                    statusDiv.className = 'alert alert-info';
                    statusDiv.style.display = 'block';
                    statusText.textContent = 'Initializing...';
                    setTimeout(checkBrowserStatus, 1000);
                }
            } catch (error) {
                setTimeout(checkBrowserStatus, 2000);
            }
        }
        
// --- BLAZE FILTER LOGIC ---
        function handlePrimaryInput() {
            const primaryVal = document.getElementById('blazeNameSearch').value;
            const subContainer = document.getElementById('subSearchContainer');
            const subInput = document.getElementById('blazeSubSearch');

            if (primaryVal.trim().length > 0) {
                subContainer.style.display = 'flex';
            } else {
                subContainer.style.display = 'none';
                subInput.value = ''; 
            }
            applyBlazeFilters();
        }

// 2. Applies both filters to the DataTable
        function applyBlazeFilters() {
            if (!$.fn.DataTable.isDataTable('#promotionsTable')) return;
            
            const table = $('#promotionsTable').DataTable();
            const primaryVal = document.getElementById('blazeNameSearch').value;
            const subVal = document.getElementById('blazeSubSearch').value;
            
            // Step 1: Apply Name Filter (Column 2) - v63 FIX: Column index changed after adding Detail column
            // Column 0 = Detail, Column 1 = ID, Column 2 = Name
            table.column(2).search(primaryVal);
            
            // Step 2: Apply Global "Sub" Search
            // This searches WITHIN the results remaining from Step 1
            table.search(subVal);
            
            // Step 3: Draw once to show the final result
            table.draw();
        }


        async function fetchBlazeData(isAuto = false) {
            const btn = document.querySelector("button[onclick='fetchBlazeData()']");
            const statusDiv = document.getElementById('blaze-sync-status');
            
            // UI Feedback
            if (btn) { 
                btn.disabled = true; 
                btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> ' + (isAuto ? 'Auto-Syncing...' : 'Syncing...'); 
            }
            if (isAuto && statusDiv) {
                statusDiv.innerHTML = '<span class="text-muted">Checking Blaze Token...</span>';
            }
            
            try {
                const response = await fetch('/api/blaze/refresh');
                if (!response.ok) throw new Error("Server Error");
                const data = await response.json();
                
                if (data.success) {
                    renderBlazeTable(data.data);
                    lastUpdateTS = Date.now() / 1000; 
                    if (isAuto) {
                        console.log("[AUTO] Sync successful.");
                        if(statusDiv) statusDiv.innerHTML = '<span class="text-success fw-bold">[OK] Connected</span>';
                    }
                } else {
                    // ERROR HANDLING
                    const errorMsg = data.message || "Unknown Error";
                    
                    if (isAuto) {
                        console.log("[AUTO] Sync failed: " + errorMsg);
                        // Notify user in the setup tab without popup
                        if(statusDiv) {
                            statusDiv.innerHTML = `<span class="text-danger fw-bold">[!] [EMOJI][EMOJI][EMOJI][EMOJI] ${errorMsg}</span>`;
                        }
                    } else {
                        alert("Sync Failed: " + errorMsg);
                    }
                }
            } catch (e) {
                if (!isAuto) alert('Sync Error: ' + e.message);
                if (isAuto && statusDiv) statusDiv.innerHTML = `<span class="text-danger">Error: ${e.message}</span>`;
            } finally {
                if (btn) { 
                    btn.disabled = false; 
                    btn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Refresh / Sync Data'; 
                }
            }
        }

        // --- BACKGROUND UPDATE (THE POLL) ---
        async function loadTableFromCache() {
            try {
                const response = await fetch('/api/blaze/get-cache');
                if (!response.ok) return;
                const data = await response.json();
                if (data.success) {
                    console.log("Background update applied.");
                    renderBlazeTable(data.data);
                    lastUpdateTS = data.ts; 
                }
            } catch (e) { console.log("Background load error:", e); }
        }

        // --- AUTO REFRESH POLLING ---
        let lastUpdateTS = Date.now() / 1000;
        setInterval(() => {
            // Only poll promotions if we're on Blaze tab AND not viewing Inventory
            // AND not running zombie cleanup automation
            const invContent = document.getElementById('blaze-inv-content');
            const isInventoryVisible = invContent && invContent.style.display !== 'none';
            const isZombieCleanupActive = zombieCleanupState && zombieCleanupState.isActive && !zombieCleanupState.isManualMode;
            
            if (currentMainTab === 'blaze' && !isInventoryVisible && !isZombieCleanupActive) {
                fetch(`/api/blaze/poll-update?ts=${lastUpdateTS}`)
                    .then(r => r.json())
                    .then(data => {
                        if (data.update) loadTableFromCache(); 
                    })
                    .catch(e => console.log("Poll error:", e));
            }
        }, 2000);
// Initialize
        window.addEventListener('load', function() {
            checkBrowserStatus();
            setupSearchEnhancements();
            autoLoadCredentials(); // Auto-fill credentials from config file
            autoAuthenticateGoogle(); // Auto-authenticate Google Sheets
            loadMisReportsFolderPath(); // v10.7: Show MIS reports folder path
            autoSyncBlazeData(); // v12.1: Auto-sync Company Promotions if token exists
        });
        
        // v12.1: Auto-sync Blaze data if token is available
        async function autoSyncBlazeData() {
            console.log('[AUTO-SYNC] Checking for Blaze token...');
            try {
                // Wait a bit for page to fully load
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Check if we have Blaze credentials/token by calling the refresh endpoint
                const response = await fetch('/api/blaze/refresh');
                const data = await response.json();
                
                if (data.success) {
                    console.log('[AUTO-SYNC] Blaze data synced successfully on startup');
                    renderBlazeTable(data.data);
                    
                    // Update status in Setup tab
                    const statusDiv = document.getElementById('blaze-sync-status');
                    if (statusDiv) {
                        statusDiv.innerHTML = '<span class="text-success fw-bold">[OK] Auto-synced on startup</span>';
                    }
                } else {
                    console.log('[AUTO-SYNC] Blaze sync skipped:', data.message || 'No token or error');
                }
            } catch (error) {
                console.log('[AUTO-SYNC] Blaze auto-sync not available:', error.message);
            }
        }

// --- NEW FOCUS LOGIC ---
        function toggleFocus(type) {
            const isEnabled = document.getElementById(`${type}-focus-enable`).checked;
            const controls = document.getElementById(`${type}-focus-controls`);
            const panel = document.getElementById(`${type}-focus-panel`);
            
            if (isEnabled) {
                controls.style.opacity = '1';
                controls.style.pointerEvents = 'auto';
                panel.classList.add('active');
            } else {
                controls.style.opacity = '0.5';
                controls.style.pointerEvents = 'none';
                panel.classList.remove('active');
            }
        }



/* ==================================================================
   BLAZE DETAIL MODAL - Dual-State JavaScript (Hover + Pin)
   ================================================================== */
let detailModalState = {
    isPinned: false,
    currentPromoId: null,
    hoverTimeout: null
};

function showDetailModal(row, isPinned = false) {
    const modal = document.getElementById('detailModal');
    const backdrop = document.getElementById('detailModalBackdrop');
    
    if (!modal || !backdrop) {
        console.error('[DETAIL] Modal elements not found');
        return;
    }
    
    // Update modal content
    document.getElementById('detailModalTitle').textContent = row.Name || 'N/A';
    document.getElementById('detailModalId').textContent = `ID: ${row.ID || 'N/A'}`;
    document.getElementById('detailModalType').textContent = `Type: ${row['Discount Value Type'] || 'N/A'}`;
    
    // Build body content
    let bodyHTML = '';
    
    // SETUP SECTION
    bodyHTML += '<div class="section-header" style="color: #0066cc;"> SETUP</div>';
    bodyHTML += `<div class="data-row"><span class="data-label">Description:</span> ${row.description || 'None'}</div>`;
    
    // Buy Requirements
    if (row.buy_requirements && row.buy_requirements.length > 0) {
        bodyHTML += '<div class="data-row"><span class="data-label">Buy Requirements:</span></div>';
        row.buy_requirements.forEach(req => {
            bodyHTML += `<div class="data-row" style="padding-left: 30px;">&#x2022; Qty: ${req.quantity} | Items: ${req.items.join(', ')}</div>`;
        });
    } else {
        bodyHTML += '<div class="data-row"><span class="data-label">Buy Requirements:</span> None</div>';
    }
    
    bodyHTML += `<div class="data-row"><span class="data-label">Get/Target:</span> ${row.target_type || 'N/A'} - ${row.target_value || 'N/A'}</div>`;
    
    // ADVANCED SECTION
    bodyHTML += '<div class="section-header" style="color: #cc6600;">&#x2699;[EMOJI][EMOJI] ADVANCED</div>';
    bodyHTML += `<div class="data-row"><span class="data-label">Auto Apply:</span> ${row.auto_apply ? 'Yes' : 'No'}</div>`;
    bodyHTML += `<div class="data-row"><span class="data-label">Stackable:</span> ${row.stackable ? 'Yes' : 'No'}</div>`;
    bodyHTML += `<div class="data-row"><span class="data-label">Lowest Price First:</span> ${row.apply_lowest_price_first ? 'Yes' : 'No'}</div>`;
    bodyHTML += `<div class="data-row"><span class="data-label">Priority:</span> ${row.priority || '5 - Lowest'}</div>`;
    
    if (row.enable_promo_code) {
        bodyHTML += `<div class="data-row"><span class="data-label">Promo Code:</span> ${row.promo_code || 'N/A'}</div>`;
    }
    
    bodyHTML += `<div class="data-row"><span class="data-label">Max Uses (Total):</span> ${row.max_uses || 'Unlimited'}</div>`;
    bodyHTML += `<div class="data-row"><span class="data-label">Max Uses (Per Member):</span> ${row.max_uses_per_consumer || 'Unlimited'}</div>`;
    
    // Restrictions
    if (row.restrictions) {
        const hasRestrictions = row.restrictions.member_groups.length > 0 || 
                              row.restrictions.consumer_types.length > 0 || 
                              row.restrictions.sales_channels.length > 0;
        if (hasRestrictions) {
            bodyHTML += '<div class="data-row"><span class="data-label">Restrictions:</span></div>';
            if (row.restrictions.member_groups.length > 0) {
                bodyHTML += `<div class="data-row" style="padding-left: 30px;">&#x2022; Member Groups: ${row.restrictions.member_groups.join(', ')}</div>`;
            }
            if (row.restrictions.consumer_types.length > 0) {
                bodyHTML += `<div class="data-row" style="padding-left: 30px;">&#x2022; Consumer Types: ${row.restrictions.consumer_types.join(', ')}</div>`;
            }
            if (row.restrictions.sales_channels.length > 0) {
                bodyHTML += `<div class="data-row" style="padding-left: 30px;">&#x2022; Sales Channels: ${row.restrictions.sales_channels.join(', ')}</div>`;
            }
        }
    }
    
    // SCHEDULE SECTION
    bodyHTML += '<div class="section-header" style="color: #009933;"> SCHEDULE</div>';
    bodyHTML += `<div class="data-row"><span class="data-label">Date Range:</span> ${row['Start Date']} to ${row['End Date']}</div>`;
    
    if (row.time_constraint) {
        if (row.time_constraint.days && row.time_constraint.days.length > 0) {
            bodyHTML += `<div class="data-row"><span class="data-label">Days:</span> ${row.time_constraint.days.join(', ')}</div>`;
        }
        if (row.time_constraint.start_time && row.time_constraint.end_time) {
            bodyHTML += `<div class="data-row"><span class="data-label">Time:</span> ${row.time_constraint.start_time} - ${row.time_constraint.end_time}</div>`;
        }
    }
    
    document.getElementById('detailModalBody').innerHTML = bodyHTML;
    
    // Update state
    detailModalState.isPinned = isPinned;
    detailModalState.currentPromoId = row.ID;
    
    // Show modal
    modal.style.display = 'block';
    if (isPinned) {
        backdrop.style.display = 'block';
    }
}

function hideDetailModal() {
    if (detailModalState.isPinned) {
        return; // Don't hide if pinned
    }
    
    const modal = document.getElementById('detailModal');
    const backdrop = document.getElementById('detailModalBackdrop');
    
    if (modal) modal.style.display = 'none';
    if (backdrop) backdrop.style.display = 'none';
    
    detailModalState.currentPromoId = null;
}

function closeDetailModal() {
    const modal = document.getElementById('detailModal');
    const backdrop = document.getElementById('detailModalBackdrop');
    
    if (modal) modal.style.display = 'none';
    if (backdrop) backdrop.style.display = 'none';
    
    detailModalState.isPinned = false;
    detailModalState.currentPromoId = null;
}

function toggleDetailPin(row) {
    if (detailModalState.isPinned && detailModalState.currentPromoId === row.ID) {
        // Unpin and close
        closeDetailModal();
    } else {
        // Pin or switch to new promo
        if (detailModalState.currentPromoId && detailModalState.currentPromoId !== row.ID) {
            closeDetailModal(); // Close old one
        }
        showDetailModal(row, true); // Open and pin new one
    }
}

// Setup backdrop click handler
document.addEventListener('DOMContentLoaded', function() {
    const backdrop = document.getElementById('detailModalBackdrop');
    if (backdrop) {
        backdrop.addEventListener('click', function() {
            closeDetailModal();
        });
    }
});


    </script>
    
    <!-- BLAZE DETAIL MODAL -->
    <div id="detailModalBackdrop"></div>
    <div id="detailModal">
        <div class="modal-header">
            <button class="close-btn" onclick="closeDetailModal()">X[EMOJI][EMOJI]</button>
            <div class="modal-title" id="detailModalTitle"></div>
            <div class="modal-id" id="detailModalId"></div>
            <div class="modal-type" id="detailModalType"></div>
        </div>
        <div class="modal-body" id="detailModalBody"></div>
    </div>

    <!-- ZOMBIE CLEANUP MODAL -->
    <div id="zombieModalBackdrop" class="zombie-modal-backdrop"></div>
    <div id="zombieModal" class="zombie-modal">
        <h3> Zombie Cleanup Mode</h3>
        <p>
            <strong>Zombie Deals</strong> are promotions that are still <span style="color: #28a745; font-weight: bold;">Active</span> 
            but have an <span style="color: #dc3545; font-weight: bold;">End Date in the past</span>. 
            These should be disabled to prevent confusion.
        </p>
        <p>
            <strong>Found: <span id="zombieCountDisplay">0</span> Zombie Deal(s)</strong>
        </p>
        <div id="zombieActionButtons" class="btn-group-vertical">
            <button onclick="runManualCleanup()" class="btn btn-outline-primary">
                 Run Manual <small style="display:block; font-weight:normal;">(Disable zombies yourself, click "Finish" when done)</small>
            </button>
            <button onclick="runAutoCleanup()" class="btn btn-danger">
                 Run Auto <small style="display:block; font-weight:normal;">(Automatically disable all zombies one-by-one)</small>
            </button>
            <button onclick="cancelZombieCleanup()" class="btn btn-secondary">
                [X] Cancel
            </button>
        </div>
        <div id="zombieProgressContainer" class="zombie-progress-container">
            <div class="zombie-progress-bar">
                <div id="zombieProgressFill" class="zombie-progress-fill"></div>
            </div>
            <div id="zombieProgressText" class="zombie-progress-text">Initializing...</div>
        </div>
    </div>
    
    <!-- v63: TAX CALCULATOR MODAL -->
<div id="calcModal">
        <div class="calc-content">
            <div class="calc-header">
                <h2> Tax Calculator</h2>
                <button class="calc-close" onclick="toggleCalcModal()">X[EMOJI][EMOJI]</button>
            </div>
            
            <div class="store-selector">
                <label for="calcStoreSelect">Select Store (for Tax Calcs):</label>
                <select id="calcStoreSelect" onchange="updateTaxRateDisplay(); runAllCalculations();">
                    <option value="">-- Loading Stores --</option>
                </select>
                <div class="tax-rate-display" id="calcTaxDisplay">Tax Rate: Not selected</div>
            </div>

            <div style="background: #e9ecef; padding: 10px; border-radius: 8px; margin-bottom: 20px;">
                <label for="calcTypeSelect" style="font-weight:bold; display:block; margin-bottom:5px; color:#495057;">Select Tool:</label>
                <select id="calcTypeSelect" class="form-select" onchange="switchCalculator()" style="width:100%; padding:8px; border-radius:4px; border:1px solid #ced4da;">
                    <option value="postTax"> Post-Tax Calculator</option>
                    <option value="preTax"> Pre-Tax Calculator</option>
                    <option value="percent"> Percentage Calculator</option>
                    <option value="rebate"> Vendor Rebate Calculator</option>
                    <option value="reprice"> Correct Percent Off Discount (Pre-Tax)</option>
                </select>
            </div>
            
            <div id="calc-postTax" class="calc-section">
                <h3> Post-Tax Calculator</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">Calculate after-tax price from discount value</p>
                <div class="calc-row">
                    <label>Discount Value:</label>
                    <input type="number" id="postTaxInput" step="0.01" placeholder="e.g., 10.00" oninput="calculatePostTax()">
                </div>
                <div class="calc-row">
                    <label>After Tax:</label>
                    <div class="result" id="postTaxResult">--</div>
                </div>
            </div>
            
            <div id="calc-preTax" class="calc-section" style="display:none;">
                <h3> Pre-Tax Calculator</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">Calculate discount value from after-tax price</p>
                <div class="calc-row">
                    <label>After-Tax Price:</label>
                    <input type="number" id="preTaxInput" step="0.01" placeholder="e.g., 10.98" oninput="calculatePreTax()">
                </div>
                <div class="calc-row">
                    <label>Discount Value:</label>
                    <div class="result" id="preTaxResult">--</div>
                </div>
            </div>
            
            <div id="calc-percent" class="calc-section" style="display:none;">
                <h3> Percentage Calculator</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">Calculate percentage from base and result</p>
                <div class="calc-row">
                    <label>Base Amount:</label>
                    <input type="number" id="percBaseInput" step="0.01" placeholder="e.g., 50.00" oninput="calculatePercentage()">
                </div>
                <div class="calc-row">
                    <label>Result Amount:</label>
                    <input type="number" id="percResultInput" step="0.01" placeholder="e.g., 45.00" oninput="calculatePercentage()">
                </div>
                <div class="calc-row">
                    <label>Percentage Off:</label>
                    <div class="result" id="percResult">--</div>
                </div>
            </div>
            
            <div id="calc-rebate" class="calc-section" style="display:none;">
                <h3> Vendor Rebate Calculator</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">Calculate vendor contribution from discount and rebate percentage</p>
                <div class="calc-row">
                    <label>Discount Value:</label>
                    <input type="number" id="vendorDiscountInput" step="0.01" placeholder="e.g., 10.00" oninput="calculateVendorRebate()">
                </div>
                <div class="calc-row">
                    <label>Rebate %:</label>
                    <input type="number" id="vendorRebateInput" step="0.01" placeholder="e.g., 50" oninput="calculateVendorRebate()">
                </div>
                <div class="calc-row">
                    <label>Vendor Contribution:</label>
                    <div class="result" id="vendorResult">--</div>
                </div>
            </div>

            <div id="calc-reprice" class="calc-section" style="display:none;">
                <h3>[!][EMOJI][EMOJI] Reprice / Stack Fixer</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">
                    Calculate required flat discount to bridge the gap between current price and desired % off. (Example: Is 45% Off but needs to be 50% Off)<br>
                    <strong>(PRE-TAX VALUES ONLY)</strong>
                </p>
                <div class="calc-row">
                    <label>Original Price:</label>
                    <input type="number" id="repriceOriginal" step="0.01" placeholder="Slash-out Price (e.g. 95.51)" oninput="calculateReprice()">
                </div>
                <div class="calc-row">
                    <label>Current Price:</label>
                    <input type="number" id="repriceCurrent" step="0.01" placeholder="Current Price (e.g. 57.31)" oninput="calculateReprice()">
                </div>
                <div class="calc-row">
                    <label>Desired % Off:</label>
                    <input type="number" id="repriceTargetPerc" step="0.1" placeholder="Target % (e.g. 50)" oninput="calculateReprice()">
                </div>
                <div class="calc-row" style="background:#e7f5ff; padding:10px; border-radius:5px; margin-top:10px;">
                    <label style="color:#000;">Flat Discount to Enter:</label>
                    <div class="result" id="repriceResult" style="background:white; border:2px solid #667eea; font-size:1.2em;">--</div>
                </div>
            </div>
        </div>
    </div>

<!-- Register Profile Modal -->
<div class="modal fade" id="registerProfileModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header" style="background: linear-gradient(135deg, #4285F4 0%, #34A853 50%, #FBBC05 75%, #EA4335 100%);">
                <h5 class="modal-title text-white"><i class="bi bi-person-plus"></i> Register New Google Profile</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Step Indicator -->
                <div class="d-flex justify-content-center mb-4">
                    <div id="step-indicator" class="d-flex align-items-center gap-2">
                        <span id="step1-badge" class="badge bg-primary rounded-pill px-3 py-2">1. Enter Handle</span>
                        <i class="bi bi-arrow-right text-muted"></i>
                        <span id="step2-badge" class="badge bg-secondary rounded-pill px-3 py-2">2. Add Credentials</span>
                        <i class="bi bi-arrow-right text-muted"></i>
                        <span id="step3-badge" class="badge bg-secondary rounded-pill px-3 py-2">3. Complete</span>
                    </div>
                </div>

                <!-- Step 1: Enter Handle -->
                <div id="register-step1">
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle"></i> 
                        Enter your <strong>email handle</strong> - the part before the @ symbol.
                        <br><span class="text-muted">Example: For john.doe@company.com, enter <code>john.doe</code></span>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label fw-bold">Email Handle</label>
                        <div class="input-group">
                            <input type="text" id="new-profile-handle" class="form-control form-control-lg" 
                                   placeholder="john.doe" pattern="[a-z0-9._-]+"
                                   oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9._-]/g, '')">
                            <span class="input-group-text text-muted">@email.com</span>
                        </div>
                        <div id="handle-error" class="text-danger mt-2" style="display: none;"></div>
                    </div>
                    
                    <div class="text-center">
                        <button class="btn btn-primary btn-lg px-5" onclick="registerStep1Next()">
                            Next <i class="bi bi-arrow-right"></i>
                        </button>
                    </div>
                </div>

                <!-- Step 2: Add Credentials File -->
                <div id="register-step2" style="display: none;">
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i> 
                        <strong>Credentials file not found!</strong>
                    </div>
                    
                    <div class="card mb-3">
                        <div class="card-header bg-light">
                            <strong>Required File:</strong>
                        </div>
                        <div class="card-body">
                            <code id="expected-creds-path" class="d-block p-2 bg-dark text-light rounded">config/google_credentials/credentials_[handle].json</code>
                        </div>
                    </div>
                    
                    <div class="card mb-3">
                        <div class="card-header bg-light">
                            <strong>How to get this file:</strong>
                        </div>
                        <div class="card-body small">
                            <ol class="mb-0">
                                <li>Go to <a href="https://console.cloud.google.com/" target="_blank">Google Cloud Console</a></li>
                                <li>Create a project and enable <strong>Google Sheets API</strong></li>
                                <li>Go to <strong>OAuth Consent Screen</strong> [EMOJI] Add your email as a Test User</li>
                                <li>Go to <strong>Credentials</strong> [EMOJI] Create <strong>OAuth Client ID</strong> (Desktop App)</li>
                                <li>Download the JSON and rename it as shown above</li>
                                <li>Place it in the <code>config/google_credentials/</code> folder</li>
                            </ol>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <button class="btn btn-outline-secondary me-2" onclick="registerGoBack()">
                            <i class="bi bi-arrow-left"></i> Back
                        </button>
                        <button class="btn btn-success btn-lg px-4" onclick="registerCheckCredentials()">
                            <i class="bi bi-arrow-clockwise"></i> Check Again
                        </button>
                    </div>
                </div>

                <!-- Step 3: Success -->
                <div id="register-step3" style="display: none;">
                    <div class="text-center py-4">
                        <div style="font-size: 4em; color: #34A853;"><i class="bi bi-check-circle-fill"></i></div>
                        <h4 class="text-success mt-3">Profile Registered Successfully!</h4>
                        <p class="text-muted" id="register-success-msg">Profile "john.doe" has been created.</p>
                        <p class="text-muted">The application will restart to load your new profile.</p>
                    </div>
                    
                    <div class="text-center">
                        <button class="btn btn-primary btn-lg px-5" onclick="restartAfterRegister()">
                            <i class="bi bi-power"></i> Restart Now
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- First Run Modal (shown when no profiles exist) -->
<div class="modal fade" id="firstRunModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header" style="background: linear-gradient(135deg, #4285F4 0%, #34A853 50%, #FBBC05 75%, #EA4335 100%);">
                <h5 class="modal-title text-white"><i class="bi bi-stars"></i> Welcome to BLAZE MIS Audit Pro!</h5>
            </div>
            <div class="modal-body text-center py-4">
                <div style="font-size: 3em; color: #4285F4;"><i class="bi bi-person-badge"></i></div>
                <h5 class="mt-3">No Google Profiles Found</h5>
                <p class="text-muted">To get started, you'll need to register a Google account profile.</p>
                <p class="text-muted small">This connects your Google Sheets for deal management.</p>
            </div>
            <div class="modal-footer justify-content-center">
                <button class="btn btn-lg px-5" onclick="openRegisterFromFirstRun()" 
                        style="background: linear-gradient(135deg, #34A853 0%, #4285F4 100%); color: white; font-weight: 600;">
                    <i class="bi bi-plus-lg"></i> Register Profile
                </button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="helpModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header bg-danger text-white">
                    <h5 class="modal-title"><i class="bi bi-life-preserver"></i> System Help & Account Setup</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <!-- Tab Navigation -->
                    <ul class="nav nav-tabs mb-3" id="helpTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="help-troubleshoot-tab" data-bs-toggle="tab" data-bs-target="#help-troubleshoot" type="button" role="tab">
                                <i class="bi bi-wrench"></i> Troubleshooting
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="help-newaccount-tab" data-bs-toggle="tab" data-bs-target="#help-newaccount" type="button" role="tab">
                                <i class="bi bi-person-plus"></i> New Account Setup
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="help-structure-tab" data-bs-toggle="tab" data-bs-target="#help-structure" type="button" role="tab">
                                <i class="bi bi-folder"></i> Folder Structure
                            </button>
                        </li>
                    </ul>

                    <!-- Tab Content -->
                    <div class="tab-content" id="helpTabContent">
                        
                        <!-- TROUBLESHOOTING TAB -->
                        <div class="tab-pane fade show active" id="help-troubleshoot" role="tabpanel">
                            <div class="alert alert-warning">
                                <strong><i class="bi bi-exclamation-triangle"></i> Moving to a new computer?</strong><br>
                                If the script crashes or fails to login on a new machine, delete your profile's <code>chrome_profiles/chrome_[handle]/</code> folder and <code>config/tokens/token_[handle].json</code> file.
                            </div>

                            <h5 class="text-danger mt-4 border-bottom pb-2">Common Fixes</h5>
                            <div class="accordion" id="helpAccordion">
                                <div class="accordion-item">
                                    <h2 class="accordion-header">
                                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#fix1">
                                            Script crashes immediately on startup
                                        </button>
                                    </h2>
                                    <div id="fix1" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                                        <div class="accordion-body">
                                            This usually means the <strong>Chrome Profile</strong> is corrupted. 
                                            <br><strong>Fix:</strong> Delete your profile folder in <code>chrome_profiles/</code> and restart.
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item">
                                    <h2 class="accordion-header">
                                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#fix2">
                                            "Google Login Failed" or 400 Error
                                        </button>
                                    </h2>
                                    <div id="fix2" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                                        <div class="accordion-body">
                                            Your Google session token is invalid.
                                            <br><strong>Fix:</strong> Delete <code>config/tokens/token_[handle].json</code>. Restart the script and re-authorize with Google.
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item">
                                    <h2 class="accordion-header">
                                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#fix3">
                                            "Profile not found" on startup
                                        </button>
                                    </h2>
                                    <div id="fix3" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                                        <div class="accordion-body">
                                            The system scans <code>config/tokens/</code> for existing profiles.
                                            <br><strong>Fix:</strong> Select "Register New Profile" to set up a new account.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- NEW ACCOUNT SETUP TAB -->
                        <div class="tab-pane fade" id="help-newaccount" role="tabpanel">
                            <div class="alert alert-info">
                                <strong><i class="bi bi-info-circle"></i> Multi-Account System</strong><br>
                                This tool supports multiple Google accounts. Each account uses an "email handle" (the part before @) as its identifier.
                                <br>Example: For <code>john.doe@company.com</code>, the handle is <code>john.doe</code>
                            </div>

                            <h5 class="text-primary mt-4 border-bottom pb-2"><i class="bi bi-cloud"></i> Step 1: Google Cloud Console Setup</h5>
                            <div class="card mb-3">
                                <div class="card-body small">
                                    <ol>
                                        <li>Log into <a href="https://console.cloud.google.com/" target="_blank">Google Cloud Console</a> with your <strong>NEW email</strong>.</li>
                                        <li>Create a <strong>New Project</strong> (e.g., "MIS Audit Tool").</li>
                                        <li>Go to <strong>APIs &amp; Services &gt; Library</strong> and Enable:
                                            <ul>
                                                <li><strong>Google Sheets API</strong></li>
                                                <li><strong>Google Drive API</strong></li>
                                            </ul>
                                        </li>
                                        <li>Go to <strong>OAuth Consent Screen</strong>:
                                            <ul>
                                                <li>Select <strong>External</strong>.</li>
                                                <li>Fill in App Name and Support Email.</li>
                                                <li class="text-danger"><strong>CRITICAL:</strong> Add your email to "Test Users"!</li>
                                            </ul>
                                        </li>
                                        <li>Go to <strong>Credentials</strong>:
                                            <ul>
                                                <li>Click <strong>+ CREATE CREDENTIALS</strong> &gt; <strong>OAuth client ID</strong>.</li>
                                                <li>Application Type: <strong>Desktop App</strong>.</li>
                                                <li>Download the JSON file.</li>
                                            </ul>
                                        </li>
                                    </ol>
                                </div>
                            </div>

                            <h5 class="text-success mt-4 border-bottom pb-2"><i class="bi bi-file-earmark-arrow-down"></i> Step 2: File Setup</h5>
                            <div class="card mb-3">
                                <div class="card-body small">
                                    <ol>
                                        <li>Rename the downloaded JSON to: <code>credentials_[your_email_prefix].json</code>
                                            <br><span class="text-muted">Example: <code>credentials_john.doe.json</code></span>
                                        </li>
                                        <li>Place it in: <code>config/google_credentials/</code></li>
                                    </ol>
                                    <div class="alert alert-secondary mt-2 mb-0 py-2">
                                        <strong>Expected path:</strong> <code>config/google_credentials/credentials_john.doe.json</code>
                                    </div>
                                </div>
                            </div>

                            <h5 class="text-warning mt-4 border-bottom pb-2"><i class="bi bi-play-circle"></i> Step 3: Registration</h5>
                            <div class="card mb-3">
                                <div class="card-body small">
                                    <ol>
                                        <li>Restart this script.</li>
                                        <li>Select <strong>"Register New Profile"</strong> from the menu.</li>
                                        <li>Enter your email handle when prompted.</li>
                                        <li>Complete the Google sign-in in the browser popup.</li>
                                        <li>Done! Your profile is now saved.</li>
                                    </ol>
                                </div>
                            </div>

                            <h5 class="text-info mt-4 border-bottom pb-2"><i class="bi bi-gear"></i> Step 4: Configure MIS/Blaze Credentials (Optional)</h5>
                            <div class="card mb-3">
                                <div class="card-body small">
                                    <p>To auto-fill MIS and Blaze login credentials, edit:</p>
                                    <code>config/blaze_configs/blaze_config_[handle].json</code>
                                    <pre class="bg-dark text-light p-2 mt-2 rounded" style="font-size: 0.8em;">{
    "mis_username": "your_mis_username",
    "mis_password": "your_mis_password",
    "blaze_email": "your_blaze_email",
    "blaze_password": "your_blaze_password",
    "default_spreadsheet_id": "your_google_sheet_id"
}</pre>
                                </div>
                            </div>
                        </div>

                        <!-- FOLDER STRUCTURE TAB -->
                        <div class="tab-pane fade" id="help-structure" role="tabpanel">
                            <h5 class="text-primary border-bottom pb-2"><i class="bi bi-folder2-open"></i> Directory Structure</h5>
                            <p class="text-muted">The script automatically creates this structure on first run:</p>
                            <pre class="bg-dark text-light p-3 rounded" style="font-size: 0.85em;">project_folder/
[EMOJI] DASHBOARD.py                    # Main script
[EMOJI] config/
[EMOJI]   [EMOJI] google_credentials/         # OAuth JSON files
[EMOJI]   [EMOJI]   [EMOJI] credentials_john.doe.json
[EMOJI]   [EMOJI]   [EMOJI] credentials_jane.smith.json
[EMOJI]   [EMOJI] tokens/                     # Google auth tokens (auto-generated)
[EMOJI]   [EMOJI]   [EMOJI] token_john.doe.json
[EMOJI]   [EMOJI]   [EMOJI] token_jane.smith.json
[EMOJI]   [EMOJI] blaze_configs/              # MIS/Blaze credentials per profile
[EMOJI]       [EMOJI] blaze_config_john.doe.json
[EMOJI]       [EMOJI] blaze_config_jane.smith.json
[EMOJI] chrome_profiles/                # Isolated browser profiles
[EMOJI]   [EMOJI] chrome_john.doe/
[EMOJI]   [EMOJI] chrome_jane.smith/
[EMOJI] reports/
    [EMOJI] MIS_CSV_REPORTS/            # Downloaded MIS exports
    [EMOJI] BLAZE_CSV_REPORTS/
        [EMOJI] INVENTORY/              # Inventory scan results</pre>

                            <h5 class="text-success mt-4 border-bottom pb-2">Files You Provide</h5>
                            <table class="table table-sm table-bordered">
                                <thead class="table-light">
                                    <tr><th>File</th><th>Description</th></tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>credentials_[handle].json</code></td>
                                        <td>OAuth JSON from Google Cloud Console</td>
                                    </tr>
                                    <tr>
                                        <td><code>blaze_config_[handle].json</code></td>
                                        <td>MIS/Blaze login credentials (optional)</td>
                                    </tr>
                                </tbody>
                            </table>

                            <h5 class="text-warning mt-4 border-bottom pb-2">Auto-Generated Files (Safe to Delete)</h5>
                            <table class="table table-sm table-bordered">
                                <thead class="table-light">
                                    <tr><th>File/Folder</th><th>Description</th><th>When to Delete</th></tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>chrome_profiles/chrome_[handle]/</code></td>
                                        <td>Browser cookies/state</td>
                                        <td>Browser crashes or moving computers</td>
                                    </tr>
                                    <tr>
                                        <td><code>config/tokens/token_[handle].json</code></td>
                                        <td>Google session token</td>
                                        <td>Google login fails or token expired</td>
                                    </tr>
                                    <tr>
                                        <td><code>blaze_groups.json</code></td>
                                        <td>Promotion group cache</td>
                                        <td>Missing group names in dashboard</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>    
    <script>
    // ============================================================================
    // PROFILE MANAGEMENT FUNCTIONS
    // ============================================================================
    
    let currentProfileHandle = null;
    let pendingProfileHandle = null;
    
    // Load profiles on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadProfiles();
    });
    
    async function loadProfiles() {
        try {
            const response = await fetch('/api/profiles');
            const data = await response.json();
            
            if (!data.success) {
                console.error('Failed to load profiles:', data.error);
                return;
            }
            
            const selector = document.getElementById('profile-selector');
            selector.innerHTML = '';
            
            if (data.profiles.length === 0) {
                // No profiles - show first run modal
                selector.innerHTML = '<option value="">No Profiles</option>';
                setTimeout(() => {
                    const firstRunModal = new bootstrap.Modal(document.getElementById('firstRunModal'));
                    firstRunModal.show();
                }, 500);
                return;
            }
            
            // Populate dropdown
            data.profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.handle;
                option.textContent = profile.handle;
                if (profile.is_active) {
                    option.selected = true;
                    currentProfileHandle = profile.handle;
                }
                if (!profile.has_credentials) {
                    option.textContent += ' (!)';
                    option.style.color = '#dc3545';
                }
                selector.appendChild(option);
            });
            
            // Update current profile display
            if (data.active_profile) {
                currentProfileHandle = data.active_profile;
            }
            
        } catch (error) {
            console.error('Error loading profiles:', error);
        }
    }
    
    function onProfileChange(newHandle) {
        if (!newHandle || newHandle === currentProfileHandle) return;
        
        // Show confirmation
        if (!confirm(`Switch to profile "${newHandle}"?\n\nThis will require a restart.`)) {
            // Revert selection
            document.getElementById('profile-selector').value = currentProfileHandle;
            return;
        }
        
        switchProfile(newHandle);
    }
    
    async function switchProfile(handle) {
        try {
            const response = await fetch('/api/profile/switch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ handle: handle })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Show restart banner
                showRestartBanner(`Switched to "${handle}".`);
            } else {
                alert('Failed to switch profile: ' + data.error);
                document.getElementById('profile-selector').value = currentProfileHandle;
            }
        } catch (error) {
            alert('Error switching profile: ' + error.message);
            document.getElementById('profile-selector').value = currentProfileHandle;
        }
    }
    
    function showRestartBanner(message) {
        const banner = document.getElementById('restart-banner');
        const text = document.getElementById('restart-banner-text');
        text.textContent = message + ' Restart required to apply changes.';
        banner.style.display = 'block';
    }
    
    function hideRestartBanner() {
        document.getElementById('restart-banner').style.display = 'none';
    }
    
    async function restartApplication() {
        if (!confirm('Restart the application now?')) return;
        
        try {
            document.getElementById('restart-banner').innerHTML = 
                '<strong><i class="bi bi-hourglass-split"></i> Restarting...</strong> Please wait...';
            
            await fetch('/api/restart', { method: 'POST' });
            
            // The page will become unresponsive, show message
            setTimeout(() => {
                document.body.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100vh; flex-direction: column; font-family: sans-serif;">
                        <div style="font-size: 3em; margin-bottom: 20px;"><i class="bi bi-arrow-repeat" style="animation: spin 1s linear infinite;"></i></div>
                        <h2>Application Restarting...</h2>
                        <p>This page will automatically reload when ready.</p>
                        <p style="color: #666;">If it doesn't reload, <a href="/" onclick="location.reload()">click here</a></p>
                    </div>
                    <style>@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>
                `;
                
                // Try to reload every 2 seconds
                const reloadInterval = setInterval(() => {
                    fetch('/api/browser-status')
                        .then(r => r.json())
                        .then(() => {
                            clearInterval(reloadInterval);
                            location.reload();
                        })
                        .catch(() => {});
                }, 2000);
            }, 500);
            
        } catch (error) {
            console.log('Restart initiated');
        }
    }
    
    // ============================================================================
    // REGISTER PROFILE MODAL FUNCTIONS
    // ============================================================================
    
    function openRegisterModal() {
        // Reset state
        document.getElementById('new-profile-handle').value = '';
        document.getElementById('handle-error').style.display = 'none';
        document.getElementById('register-step1').style.display = 'block';
        document.getElementById('register-step2').style.display = 'none';
        document.getElementById('register-step3').style.display = 'none';
        updateStepBadges(1);
        
        const modal = new bootstrap.Modal(document.getElementById('registerProfileModal'));
        modal.show();
    }
    
    function openRegisterFromFirstRun() {
        // Close first run modal
        const firstRunModal = bootstrap.Modal.getInstance(document.getElementById('firstRunModal'));
        if (firstRunModal) firstRunModal.hide();
        
        // Open register modal
        setTimeout(() => openRegisterModal(), 300);
    }
    
    function updateStepBadges(currentStep) {
        const badges = ['step1-badge', 'step2-badge', 'step3-badge'];
        badges.forEach((id, idx) => {
            const badge = document.getElementById(id);
            if (idx + 1 < currentStep) {
                badge.className = 'badge bg-success rounded-pill px-3 py-2';
            } else if (idx + 1 === currentStep) {
                badge.className = 'badge bg-primary rounded-pill px-3 py-2';
            } else {
                badge.className = 'badge bg-secondary rounded-pill px-3 py-2';
            }
        });
    }
    
    async function registerStep1Next() {
        const handle = document.getElementById('new-profile-handle').value.trim().toLowerCase();
        const errorDiv = document.getElementById('handle-error');
        
        // Validate
        if (!handle) {
            errorDiv.textContent = 'Please enter an email handle.';
            errorDiv.style.display = 'block';
            return;
        }
        
        if (!/^[a-z0-9._-]+$/.test(handle)) {
            errorDiv.textContent = 'Handle can only contain: letters, numbers, dots, underscores, hyphens';
            errorDiv.style.display = 'block';
            return;
        }
        
        errorDiv.style.display = 'none';
        pendingProfileHandle = handle;
        
        // Check if credentials exist
        try {
            const response = await fetch(`/api/profile/check-credentials/${handle}`);
            const data = await response.json();
            
            if (data.exists) {
                // Credentials found - try to register
                await registerCompleteProfile(handle);
            } else {
                // Show step 2 - need credentials
                document.getElementById('expected-creds-path').textContent = data.expected_path;
                document.getElementById('register-step1').style.display = 'none';
                document.getElementById('register-step2').style.display = 'block';
                updateStepBadges(2);
            }
        } catch (error) {
            errorDiv.textContent = 'Error checking credentials: ' + error.message;
            errorDiv.style.display = 'block';
        }
    }
    
    function registerGoBack() {
        document.getElementById('register-step1').style.display = 'block';
        document.getElementById('register-step2').style.display = 'none';
        updateStepBadges(1);
    }
    
    async function registerCheckCredentials() {
        try {
            const response = await fetch(`/api/profile/check-credentials/${pendingProfileHandle}`);
            const data = await response.json();
            
            if (data.exists) {
                await registerCompleteProfile(pendingProfileHandle);
            } else {
                alert('Credentials file still not found.\n\nPlease place the file at:\n' + data.expected_path);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }
    
    async function registerCompleteProfile(handle) {
        try {
            const response = await fetch('/api/profile/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ handle: handle })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Show success step
                document.getElementById('register-step1').style.display = 'none';
                document.getElementById('register-step2').style.display = 'none';
                document.getElementById('register-step3').style.display = 'block';
                document.getElementById('register-success-msg').textContent = 
                    `Profile "${handle}" has been created.`;
                updateStepBadges(3);
            } else if (data.error === 'credentials_not_found') {
                // Show step 2
                document.getElementById('expected-creds-path').textContent = data.expected_path;
                document.getElementById('register-step1').style.display = 'none';
                document.getElementById('register-step2').style.display = 'block';
                updateStepBadges(2);
            } else {
                alert('Error: ' + data.error);
            }
        } catch (error) {
            alert('Error registering profile: ' + error.message);
        }
    }
    
    function restartAfterRegister() {
        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('registerProfileModal'));
        if (modal) modal.hide();
        
        // Restart
        restartApplication();
    }

    // ============================================================================
    // TAX RATES EDITING FUNCTIONS (Setup Tab)
    async function loadTaxRatesForEdit() {
        try {
            const resp = await fetch('/api/tax-rates');
            const data = await resp.json();
            
            if (!data.success) {
                alert('Failed to load tax rates: ' + data.error);
                return;
            }
            
            const rates = data.rates;
            const container = document.getElementById('tax-rates-container');
            container.innerHTML = '';
            
            // Sort stores alphabetically
            const stores = Object.keys(rates).sort();
            
            stores.forEach(store => {
                const rate = rates[store];
                const col = document.createElement('div');
                col.className = 'col-md-6 col-lg-4';
                
                col.innerHTML = `
                    <div class="input-group input-group-sm mb-2">
                        <span class="input-group-text" style="width: 140px; font-size: 0.85em;">${store}</span>
                        <input type="number" 
                               class="form-control tax-rate-input" 
                               data-store="${store}" 
                               value="${rate}" 
                               step="0.000001"
                               style="font-size: 0.85em;">
                    </div>
                `;
                
                container.appendChild(col);
            });
            
            document.getElementById('tax-save-status').innerHTML = '';
            
        } catch (err) {
            console.error('Error loading tax rates:', err);
            alert('Error loading tax rates: ' + err.message);
        }
    }
    
    async function saveTaxRates() {
        try {
            const inputs = document.querySelectorAll('.tax-rate-input');
            const rates = {};
            
            inputs.forEach(input => {
                const store = input.dataset.store;
                const value = parseFloat(input.value);
                
                if (isNaN(value)) {
                    throw new Error(`Invalid rate for ${store}: ${input.value}`);
                }
                
                rates[store] = value;
            });
            
            const resp = await fetch('/api/save-tax-rates', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({rates: rates})
            });
            
            const data = await resp.json();
            const statusDiv = document.getElementById('tax-save-status');
            
            if (data.success) {
                statusDiv.innerHTML = '<span class="text-success">[SUCCESS] ' + data.message + '</span>';
                // Reload calculator rates
                await loadTaxRates();
            } else {
                statusDiv.innerHTML = '<span class="text-danger">[X] ' + data.error + '</span>';
            }
            
        } catch (err) {
            console.error('Error saving tax rates:', err);
            document.getElementById('tax-save-status').innerHTML = 
                '<span class="text-danger">[X] Error: ' + err.message + '</span>';
        }
    }
    
    // Load tax rates on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadTaxRatesForEdit();
    });
    
    // v63: Tax Calculator JavaScript
    let TAX_RATES = {};
    let currentStore = '';
    
    // Load tax rates on page load
    async function loadTaxRates() {
        try {
            const resp = await fetch('/api/tax-rates');
            const data = await resp.json();
            
            if (data.success) {
                TAX_RATES = data.rates;
                populateStoreDropdown();
            } else {
                console.error('Failed to load tax rates:', data.error);
                document.getElementById('calcStoreSelect').innerHTML = '<option value="">-- No tax rates found --</option>';
            }
        } catch (err) {
            console.error('Error loading tax rates:', err);
            document.getElementById('calcStoreSelect').innerHTML = '<option value="">-- Error loading rates --</option>';
        }
    }
    
    // Populate store dropdown (alphabetically)
    function populateStoreDropdown() {
        const select = document.getElementById('calcStoreSelect');
        const stores = Object.keys(TAX_RATES).sort();
        
        select.innerHTML = '<option value="">-- Select Store --</option>';
        stores.forEach(store => {
            const option = document.createElement('option');
            option.value = store;
            option.textContent = store;
            select.appendChild(option);
        });
        
        // Set default to first store
        if (stores.length > 0) {
            select.value = stores[0];
            currentStore = stores[0];
            updateTaxRateDisplay();
        }
    }
    
    // Update tax rate display when store changes
    function updateTaxRateDisplay() {
        const select = document.getElementById('calcStoreSelect');
        currentStore = select.value;
        const display = document.getElementById('calcTaxDisplay');
        
        if (currentStore && TAX_RATES[currentStore]) {
            const rate = TAX_RATES[currentStore];
            const percentage = ((rate - 1) * 100).toFixed(2);
            display.textContent = `Tax Rate: ${rate.toFixed(4)} (${percentage}% tax)`;
        } else {
            display.textContent = 'Tax Rate: Not selected';
        }
    }
    
    // Simple toggle function for calculator modal
    function toggleCalcModal() {
        const modal = document.getElementById('calcModal');
        if (modal.classList.contains('show')) {
            modal.classList.remove('show');
        } else {
            modal.classList.add('show');
        }
    }
    
    // Close on backdrop click
    document.getElementById('calcModal').addEventListener('click', function(e) {
        if (e.target === this) {
            toggleCalcModal();
        }
    });
    
    // Close with Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const modal = document.getElementById('calcModal');
            if (modal.classList.contains('show')) {
                toggleCalcModal();
            }
        }
    });
    
    // Calculator Functions
// Helper to trigger all calcs if store changes
    function runAllCalculations() {
        calculatePostTax();
        calculatePreTax();
        calculatePercentage();
        calculateVendorRebate();
        calculateReprice();
    }

    // Toggle Visibility based on Dropdown
    function switchCalculator() {
        const selected = document.getElementById('calcTypeSelect').value;
        const sections = ['calc-postTax', 'calc-preTax', 'calc-percent', 'calc-rebate', 'calc-reprice'];
        
        sections.forEach(id => {
            const el = document.getElementById(id);
            if (id === 'calc-' + selected) {
                el.style.display = 'block';
            } else {
                el.style.display = 'none';
            }
        });
    }

    // 1. Post-Tax
    function calculatePostTax() {
        if (!currentStore || !TAX_RATES[currentStore]) {
            document.getElementById('postTaxResult').textContent = '-- (Select Store)';
            return;
        }
        const inputVal = document.getElementById('postTaxInput').value;
        if (inputVal === '') {
            document.getElementById('postTaxResult').textContent = '--';
            return;
        }
        const discountValue = parseFloat(inputVal);
        const taxRate = TAX_RATES[currentStore];
        const afterTax = discountValue * taxRate;
        document.getElementById('postTaxResult').textContent = '$' + afterTax.toFixed(2);
    }
    
    // 2. Pre-Tax
    function calculatePreTax() {
        if (!currentStore || !TAX_RATES[currentStore]) {
            document.getElementById('preTaxResult').textContent = '-- (Select Store)';
            return;
        }
        const inputVal = document.getElementById('preTaxInput').value;
        if (inputVal === '') {
            document.getElementById('preTaxResult').textContent = '--';
            return;
        }
        const afterTaxPrice = parseFloat(inputVal);
        const taxRate = TAX_RATES[currentStore];
        const discountValue = afterTaxPrice / taxRate;
        document.getElementById('preTaxResult').textContent = '$' + discountValue.toFixed(2);
    }
    
    // 3. Percentage
    function calculatePercentage() {
        const baseVal = document.getElementById('percBaseInput').value;
        const resVal = document.getElementById('percResultInput').value;
        
        if (baseVal === '' || resVal === '') {
            document.getElementById('percResult').textContent = '--';
            return;
        }
        const base = parseFloat(baseVal);
        const result = parseFloat(resVal);
        
        if (base === 0) {
            document.getElementById('percResult').textContent = 'Error';
            return;
        }
        const percentage = ((base - result) / base) * 100;
        document.getElementById('percResult').textContent = percentage.toFixed(2) + '%';
    }
    
    // 4. Vendor Rebate
    function calculateVendorRebate() {
        const discVal = document.getElementById('vendorDiscountInput').value;
        const rebateVal = document.getElementById('vendorRebateInput').value;
        
        if (discVal === '' || rebateVal === '') {
            document.getElementById('vendorResult').textContent = '--';
            return;
        }
        const discountValue = parseFloat(discVal);
        const rebatePercentage = parseFloat(rebateVal);
        
        const vendorContribution = (discountValue * rebatePercentage) / 100;
        document.getElementById('vendorResult').textContent = '$' + vendorContribution.toFixed(2);
    }

    // 5. NEW: Reprice Calculator
    function calculateReprice() {
        const origVal = document.getElementById('repriceOriginal').value;
        const currVal = document.getElementById('repriceCurrent').value;
        const targetVal = document.getElementById('repriceTargetPerc').value;

        if (origVal === '' || currVal === '' || targetVal === '') {
            document.getElementById('repriceResult').textContent = '--';
            return;
        }

        const originalPrice = parseFloat(origVal);
        const currentPrice = parseFloat(currVal);
        const targetPercent = parseFloat(targetVal);

        if (originalPrice === 0) return;

        // Step 1: Calculate what the price SHOULD be at the target %
        // e.g. 95.51 * (1 - 0.50) = 47.755
        const desiredFinalPrice = originalPrice * (1 - (targetPercent / 100));

        // Step 2: Calculate the difference needed to reach that price from current
        // e.g. 57.31 - 47.755 = 9.555
        const differenceNeeded = currentPrice - desiredFinalPrice;

        // Display with 3 decimal places as requested for precision
        document.getElementById('repriceResult').textContent = '$' + differenceNeeded.toFixed(3);
    }

async function runTierUpdate(btn) {
        if (!confirm("[!] [EMOJI][EMOJI][EMOJI][EMOJI] This will take control of the browser to update 'Bag Day' tags across all valid stores.\n\nEnsure you are not actively using the browser.\n\nProceed?")) return;
        
        btn.disabled = true;
        const originalHtml = btn.innerHTML;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Running...';
        
        try {
            // Pass credentials just in case auto-login is needed
            const misUsername = document.getElementById('mis-username').value;
            const misPassword = document.getElementById('mis-password').value;

            const response = await fetch('/api/blaze/update-tags', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    mis_username: misUsername,
                    mis_password: misPassword
                })
            });
            const data = await response.json();
            
            if (data.success) {
                alert("[SUCCESS] " + data.message + "\n\nWatch the terminal console for progress.");
            } else {
                alert("[X] Error: " + data.error);
            }
        } catch (e) {
            alert("[X] Network Error: " + e.message);
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHtml;
        }
    }

    // v12.24.1: Blaze Ecom Sync to Tymber (Mission Control API)
    async function syncToTymber(btn) {
        const storeSelect = document.getElementById('ecom-sync-store');
        const statusDiv = document.getElementById('ecom-sync-status');
        const selectedStore = storeSelect.value;
        
        // Validate store selection
        if (!selectedStore) {
            statusDiv.innerHTML = '<span style="color: #dc3545;">ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â Please select a store first</span>';
            return;
        }
        
        // Get Blaze credentials from UI
        const blazeEmail = document.getElementById('blaze-email').value.trim();
        const blazePassword = document.getElementById('blaze-password').value.trim();
        
        if (!blazeEmail || !blazePassword) {
            statusDiv.innerHTML = '<span style="color: #dc3545;">ÃƒÂ¢Ã…Â¡Ã‚Â ÃƒÂ¯Ã‚Â¸Ã‚Â Enter Blaze email/password above first</span>';
            return;
        }
        
        // Confirm action
        if (!confirm(`Sync inventory to Tymber for ${selectedStore}?\n\nThis will update the ecommerce menu with current inventory data.`)) {
            return;
        }
        
        // Update UI to syncing state
        btn.disabled = true;
        storeSelect.disabled = true;
        const originalHtml = btn.innerHTML;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Syncing...';
        statusDiv.innerHTML = '<span style="color: #0d6efd;">ÃƒÂ¢Ã‚ÂÃ‚Â³ Authenticating...</span>';
        
        try {
            const response = await fetch('/api/blaze/ecom-sync', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ 
                    store: selectedStore,
                    email: blazeEmail,
                    password: blazePassword
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                statusDiv.innerHTML = `<span style="color: #198754;">ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ ${data.message || 'Sync Complete'}</span>`;
                console.log('[ECOM-SYNC] Success:', data);
            } else {
                // Differentiate error types for better UX
                let errorMsg = data.error || 'Unknown error';
                let errorColor = '#dc3545';
                
                if (errorMsg.includes('credentials') || errorMsg.includes('Authentication')) {
                    errorMsg = 'ÃƒÂ°Ã…Â¸Ã¢â‚¬ÂÃ¢â‚¬Ëœ ' + errorMsg;
                } else if (errorMsg.includes('UUID') || errorMsg.includes('not found')) {
                    errorMsg = 'ÃƒÂ°Ã…Â¸Ã¢â‚¬Å“Ã‚Â ' + errorMsg;
                } else if (errorMsg.includes('permission')) {
                    errorMsg = 'ÃƒÂ°Ã…Â¸Ã…Â¡Ã‚Â« ' + errorMsg;
                }
                
                statusDiv.innerHTML = `<span style="color: ${errorColor};">ÃƒÂ¢Ã‚ÂÃ…â€™ ${errorMsg}</span>`;
                console.error('[ECOM-SYNC] Error:', data.error);
            }
        } catch (e) {
            statusDiv.innerHTML = `<span style="color: #dc3545;">ÃƒÂ¢Ã‚ÂÃ…â€™ Network Error: ${e.message}</span>`;
            console.error('[ECOM-SYNC] Network Error:', e);
        } finally {
            btn.disabled = false;
            storeSelect.disabled = false;
            btn.innerHTML = originalHtml;
            
            // Reset status after 15 seconds
            setTimeout(() => {
                statusDiv.innerHTML = '<span style="color: #6c757d;">Ready</span>';
            }, 15000);
        }
    }

    // Initialize tax rates on page load (Restored)
    document.addEventListener('DOMContentLoaded', function() {
        loadTaxRates();
    });
        // --- BLAZE TAB SWITCHING ---
        function switchBlazeTab(mode) {
            const promoContent = document.getElementById('blaze-promo-content');
            const invContent = document.getElementById('blaze-inv-content');
            const promoBtn = document.getElementById('btn-blaze-promo');
            const invBtn = document.getElementById('btn-blaze-inv');

            if (mode === 'promo') {
                promoContent.style.display = 'block';
                invContent.style.display = 'none';
                promoBtn.classList.add('active');
                invBtn.classList.remove('active');
                // Recalculate DataTable after tab becomes visible
                setTimeout(function() {
                    if ($.fn.DataTable.isDataTable('#promotionsTable')) {
                        const table = $('#promotionsTable').DataTable();
                        table.columns.adjust();
                        table.draw(false);
                        $(window).trigger('resize');
                    }
                }, 100);
            } else {
                promoContent.style.display = 'none';
                invContent.style.display = 'block';
                promoBtn.classList.remove('active');
                invBtn.classList.add('active');
            }
        }

// --- INVENTORY REPORTER LOGIC ---
// Simplified single-table storage
let currentInventoryData = [];  // Full unfiltered dataset
let currentStoreName = '';       // Current store name  
let currentDataSource = '';      // 'fresh' or 'file'
let currentDataTimestamp = '';   // When loaded
let searchDebounceTimer = null;  // For debouncing  // For debouncing search input

// Debug Log Variables
let debugTimer = null;
let debugStartTime = null;
let debugPollInterval = null;
let debugLogMessages = [];

// Debug Log Helper Functions
function showDebugLog() {
    const panel = document.getElementById('debugLogPanel');
    const messages = document.getElementById('debugMessages');
    panel.style.display = 'block';
    messages.innerHTML = '';
    debugLogMessages = [];
    debugStartTime = Date.now();
    updateDebugTimer();
    debugTimer = setInterval(updateDebugTimer, 1000);
}

function hideDebugLog() {
    const panel = document.getElementById('debugLogPanel');
    panel.style.display = 'none';
    if (debugTimer) clearInterval(debugTimer);
    if (debugPollInterval) clearInterval(debugPollInterval);
    debugTimer = null;
    debugPollInterval = null;
}

function addDebugLog(message, type = 'info') {
    const messages = document.getElementById('debugMessages');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `> ${message}`;
    messages.appendChild(entry);
    messages.scrollTop = messages.scrollHeight;
    debugLogMessages.push({ message, type, time: Date.now() });
}

function updateDebugTimer() {
    if (!debugStartTime) return;
    const elapsed = Math.floor((Date.now() - debugStartTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('debugTimer').textContent = 
        `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

function updateDebugProgress(current, total, currentAction = '') {
    const percent = total > 0 ? Math.round((current / total) * 100) : 0;
    const progressBar = document.getElementById('debugProgress');
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
    
    // Calculate ETA
    if (debugStartTime && current > 0) {
        const elapsed = (Date.now() - debugStartTime) / 1000;
        const avgTimePerItem = elapsed / current;
        const remaining = (total - current) * avgTimePerItem;
        const etaMinutes = Math.floor(remaining / 60);
        const etaSeconds = Math.floor(remaining % 60);
        
        if (etaMinutes > 0) {
            document.getElementById('debugETA').textContent = `${etaMinutes}m ${etaSeconds}s`;
        } else {
            document.getElementById('debugETA').textContent = `${etaSeconds}s`;
        }
    }
    
    if (currentAction) {
        addDebugLog(currentAction);
    }
}

// Poll status endpoint for real-time updates
function startDebugPolling() {
    debugPollInterval = setInterval(async () => {
        try {
            const response = await fetch('/api/blaze/inventory/status');
            const data = await response.json();
            
            if (data.running) {
                // Parse logs for progress info
                const logs = data.logs || [];
                const lastLog = logs[logs.length - 1] || '';
                
                // Look for page info (e.g., "Fetching Page 3 (Items 2000-3000)...")
                const pageMatch = lastLog.match(/Page (\d+)/);
                if (pageMatch) {
                    const currentPage = parseInt(pageMatch[1]);
                    // Estimate total pages (we'll update this dynamically)
                    const estimatedTotal = Math.max(currentPage + 2, 5); // Rough estimate
                    updateDebugProgress(currentPage, estimatedTotal, lastLog);
                }
            } else {
                // Operation completed
                if (debugPollInterval) {
                    clearInterval(debugPollInterval);
                    debugPollInterval = null;
                }
            }
        } catch (err) {
            console.error('Debug poll error:', err);
        }
    }, 1000); // Poll every second
}

// Initialize: Load available saved reports on page load
async function loadSavedReportsList() {
    try {
        const response = await fetch('/api/blaze/inventory/list-reports');
        const data = await response.json();
        
        const dropdown = document.getElementById('savedReportsDropdown');
        dropdown.innerHTML = '<option value="">-- Select Report --</option>';
        
        if (data.success && data.reports.length > 0) {
            data.reports.forEach(filename => {
                dropdown.innerHTML += `<option value="${filename}">${filename}</option>`;
            });
        }
    } catch (err) {
        console.error('Failed to load saved reports list:', err);
    }
}

// Load saved report from file
async function loadSavedReport() {
    const dropdown = document.getElementById('savedReportsDropdown');
    const filename = dropdown.value;
    
    if (!filename) {
        alert('Please select a report file first.');
        return;
    }

    // Extract store name from filename (e.g., "Koreatown_BLAZE_INVENTORY_2024_12_09.csv")
    const storeName = filename.split('_BLAZE_INVENTORY_')[0].replace(/_/g, ' ');

    try {
        const response = await fetch('/api/blaze/inventory/load-report', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ filename: filename })
        });

        const data = await response.json();

        if (data.success && data.data) {
            // Store data globally for single-table view
            currentInventoryData = data.data;
            currentStoreName = storeName;
            currentDataSource = 'file';
            currentDataTimestamp = filename;  // Use filename as timestamp for loaded files
            
            // Populate filters and render table
            populateFilters(currentInventoryData);
            clearInventoryFilters();  // Reset filters
            renderInventoryTable(currentInventoryData);
            
            // Show status bar
            showInventoryStatus();
        } else {
            alert(`Failed to load report: ${data.error || 'Unknown error'}`);
        }
    } catch (err) {
        alert(`Network error: ${err.message}`);
    }
}

// Fetch fresh data from Blaze
async function fetchInventoryData() {
    const storeSelect = document.getElementById('invStoreSelect');
    const store = storeSelect.value;
    
    const btn = document.getElementById('btnFetchFresh');
    const originalText = btn ? btn.innerHTML : 'Fetch';

    if (!store) {
        alert('Please select a store first.');
        return;
    }

    const storeName = storeSelect.options[storeSelect.selectedIndex].text;

    // SHOW DEBUG LOG & START TIMER
    showDebugLog();
    addDebugLog(`Starting fetch for: ${storeName}`, 'info');
    addDebugLog('Initializing connection to Blaze API...', 'info');

    // LOCK UI
    if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Fetching...';
    }

    // START STATUS POLLING
    startDebugPolling();

    try {
        addDebugLog('Sending fetch request...', 'info');
        
        // STEP 1: Fetch and cache data
        const fetchResponse = await fetch('/api/blaze/inventory/fetch', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ 
                store: store, 
                fresh: true,
                force_reset: true
            })
        });

        const fetchData = await fetchResponse.json();

        if (!fetchData.success) {
            addDebugLog(`[OK][EMOJI][EMOJI] Error: ${fetchData.error || 'Unknown error'}`, 'error');
            alert(`Failed to fetch data: ${fetchData.error || 'Unknown error'}`);
            setTimeout(() => hideDebugLog(), 5000);
            return;
        }

        addDebugLog(`[OK] Data cached successfully (${fetchData.row_count} rows)`, 'success');
        updateDebugProgress(100, 100, 'Loading data from cache...');
        
        // STEP 2: Load data from cache
        const loadResponse = await fetch('/api/blaze/inventory/get-tab-data', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ store: store })
        });

        const loadData = await loadResponse.json();

        if (loadData.success && loadData.data) {
            addDebugLog(`[OK] Loaded ${loadData.data.length} items from cache`, 'success');
            
            // Store data globally for single-table view
            currentInventoryData = loadData.data;
            currentStoreName = storeName;
            currentDataSource = 'fresh';
            currentDataTimestamp = new Date().toLocaleString();
            
            // Populate filters and render table
            populateFilters(currentInventoryData);
            clearInventoryFilters();  // Reset filters
            renderInventoryTable(currentInventoryData);
            
            // Show status bar
            showInventoryStatus();
            
            addDebugLog('[OK] All done!', 'success');
            setTimeout(() => hideDebugLog(), 3000);
        } else {
            addDebugLog(`[OK][EMOJI][EMOJI] Error loading from cache: ${loadData.error}`, 'error');
            alert(`Failed to load data: ${loadData.error || 'Unknown error'}`);
            setTimeout(() => hideDebugLog(), 5000);
        }
    } catch (err) {
        addDebugLog(`[OK][EMOJI][EMOJI] Network error: ${err.message}`, 'error');
        alert(`Network error: ${err.message}`);
        setTimeout(() => hideDebugLog(), 5000);
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }
}

// Show inventory status bar with current data info
function showInventoryStatus() {
    const statusCard = document.getElementById('inventoryStatusCard');
    const statusText = document.getElementById('inventoryStatusText');
    
    if (statusCard && statusText) {
        let statusMsg = `<strong>${currentStoreName}</strong> - `;
        if (currentDataSource === 'fresh') {
            statusMsg += `Fresh Fetch - ${currentDataTimestamp}`;
        } else {
            statusMsg += `Loaded File: ${currentDataTimestamp}`;
        }
        statusMsg += ` (${currentInventoryData.length} items)`;
        
        statusText.innerHTML = statusMsg;
        statusCard.style.display = 'block';
    }
}

// Render tab navigation (DEPRECATED - tabs removed for performance)
function renderInventoryTabs() {
    // No-op: tabs removed in v7.6 for performance
}

// Switch to inventory tab (DEPRECATED - tabs removed for performance)
async function switchInventoryTab(tabId) {
    // No-op: tabs removed in v7.6 for performance
}


// Save current UI filter state to active tab
function saveCurrentFilters() {
    // No-op: filter persistence removed with tabs in v7.6
}


// Restore tab's saved filters to UI
function restoreTabFilters(tabId) {
    // No-op: filter persistence removed with tabs in v7.6
}


// Debounced search (300ms delay)
function debouncedInventorySearch() {
    if (searchDebounceTimer) {
        clearTimeout(searchDebounceTimer);
    }
    searchDebounceTimer = setTimeout(() => {
        applyInventoryFilters();
    }, 300);
}

// Clear individual search field
function clearSearchField(fieldId) {
    document.getElementById(fieldId).value = '';
    applyInventoryFilters();
}

// Show status bar with tab info (DEPRECATED - replaced by showInventoryStatus)
function showInventoryStatusBar(tabId) {
    // No-op: replaced by showInventoryStatus() in v7.6
}

// Close current tab
function closeCurrentInventoryTab() {
    // No-op: tabs removed in v7.6 for performance
}


// Populate brand and category filters
function populateFilters(data) {
    const brands = [...new Set(data.map(row => row.Brand))].filter(Boolean).sort();
    const categories = [...new Set(data.map(row => row.Category))].filter(Boolean).sort();

    const brandSelect = document.getElementById('invFilterBrand');
    const catSelect = document.getElementById('invFilterCategory');

    brandSelect.innerHTML = '<option value="">All Brands</option>' + 
        brands.map(b => `<option value="${b}">${b}</option>`).join('');
    
    catSelect.innerHTML = '<option value="">All Categories</option>' + 
        categories.map(c => `<option value="${c}">${c}</option>`).join('');
}

// Apply filters with waterfall logic
function applyInventoryFilters() {
    if (!currentInventoryData || currentInventoryData.length === 0) return;
    
    // Get filter values
    const search1 = document.getElementById('invSearchName').value.toLowerCase();
    const search2 = document.getElementById('invSearchName2').value.toLowerCase();
    const selectedBrand = document.getElementById('invFilterBrand').value;
    const selectedCategory = document.getElementById('invFilterCategory').value;
    const hideZeroQty = document.getElementById('invHideZeroQty').checked;
    
    // Start with full data
    let filtered = [...currentInventoryData];
    
    // STEP 1: Apply Primary Search (Product Name only)
    if (search1) {
        filtered = filtered.filter(row => 
            (row['Product Name'] || '').toLowerCase().includes(search1)
        );
    }
    
    // STEP 2: Apply Secondary Search (filters results of Step 1 - Product Name only)
    if (search2) {
        filtered = filtered.filter(row =>
            (row['Product Name'] || '').toLowerCase().includes(search2)
        );
    }
    
    // STEP 3: Apply Brand filter
    if (selectedBrand) {
        filtered = filtered.filter(row => row.Brand === selectedBrand);
    }
    
    // STEP 4: Apply Category filter
    if (selectedCategory) {
        filtered = filtered.filter(row => row.Category === selectedCategory);
    }
    
    // STEP 5: Apply Hide Zero Quantity filter
    if (hideZeroQty) {
        filtered = filtered.filter(row => {
            const qty = row['Total Quantity'];
            // Keep rows with null/undefined, only hide rows that are exactly 0
            return qty !== 0;
        });
    }
    
    // Re-render table with filtered data
    renderInventoryTable(filtered);
    
    // Save current filters to tab
    saveCurrentFilters();
}

// Clear all filters
function clearInventoryFilters() {
    // Clear UI fields
    document.getElementById('invSearchName').value = '';
    document.getElementById('invSearchName2').value = '';
    document.getElementById('invFilterBrand').value = '';
    document.getElementById('invFilterCategory').value = '';
    document.getElementById('invHideZeroQty').checked = false;
    
    // Reapply filters (will show all data)
    applyInventoryFilters();
}

// Render table with data
function renderInventoryTable(data) {
    const rowCount = document.getElementById('invRowCount');
    rowCount.textContent = `${data.length} Items`;

    // Check if DataTable already exists
    if ($.fn.DataTable.isDataTable('#inventoryTable')) {
        // Destroy existing DataTable
        $('#inventoryTable').DataTable().destroy();
    }

    // Clear table body
    const tbody = document.getElementById('inventoryTableBody');
    
    if (!data || data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted py-4">No data available</td></tr>';
        return;
    }

    // Build rows
    tbody.innerHTML = data.map((row, index) => {
        const blazeId = row['BLAZE ID'] || '';
        const sku = row.SKU || 'N/A';
        const name = row['Product Name'] || '';
        const brand = row.Brand || 'N/A';
        const category = row.Category || 'N/A';
        const price = parseFloat(row['Unit Price ($)'] || 0).toFixed(2);
        const qty = parseFloat(row['Total Quantity'] || 0).toFixed(2);
        const weight = row['Weight / Unit'] || 'N/A';

        return `
            <tr>
                <td>
                    <button class="btn btn-sm btn-outline-primary sku-button" 
                            onclick="handleSkuClick('${sku}', '${blazeId}')">
                        ${sku}
                    </button>
                </td>
                <td>
                    <div class="name-cell-wrapper">
                        <span class="product-name clickable-name" 
                              id="product-name-${index}"
                              data-blaze-id="${blazeId}"
                              data-sku="${sku}"
                              onclick="handleProductNameClick(this, '${blazeId}', '${sku}')">
                            ${name}
                        </span>
                    </div>
                </td>
                <td>${brand}</td>
                <td>${category}</td>
                <td class="text-end">$${price}</td>
                <td class="text-end">${qty}</td>
                <td class="text-end">${weight}</td>
            </tr>
        `;
    }).join('');

    // Initialize DataTable with no pagination (scrolling list)
    $('#inventoryTable').DataTable({
        paging: false,           // Disable pagination
        searching: false,        // We handle search manually
        info: false,             // Hide "Showing X of Y entries"
        ordering: true,          // Allow column sorting
        scrollY: '60vh',         // Enable vertical scrolling
        scrollCollapse: true,    // Allow table to be smaller than scrollY
        order: [[1, 'asc']]      // Default sort by Product Name
    });

    // Setup persistent tooltips for product names (will be triggered by click)
    setupPersistentTooltips();
}

// ============================================================================
// PERSISTENT TOOLTIP SYSTEM FOR PRODUCT NAMES
// ============================================================================
let activeTooltip = null;  // Track currently visible tooltip
let activeTooltipElement = null;  // Track element with active tooltip

function setupPersistentTooltips() {
    // Initialize tooltips for all product names (but don't trigger them yet)
    const productNames = document.querySelectorAll('.product-name');
    
    productNames.forEach(element => {
        const blazeId = element.getAttribute('data-blaze-id');
        const sku = element.getAttribute('data-sku');
        
        // Create tooltip content
        const tooltipContent = `
            <div class='text-start'>
                <strong>BLAZE ID:</strong> ${blazeId} 
                <i class='bi bi-paperclip' style='cursor:pointer' onclick='copyToClipboard("${blazeId}")'></i>
                <br>
                <strong>SKU:</strong> ${sku} 
                <i class='bi bi-paperclip' style='cursor:pointer' onclick='copyToClipboard("${sku}")'></i>
            </div>
        `;
        
        // Initialize Bootstrap tooltip (manual trigger)
        const tooltip = new bootstrap.Tooltip(element, {
            html: true,
            title: tooltipContent,
            trigger: 'manual',  // We'll control show/hide manually
            placement: 'right'
        });
        
        // Store tooltip instance on element
        element._tooltipInstance = tooltip;
    });
    
    // Add click-outside listener to dismiss active tooltip
    document.addEventListener('click', function(e) {
        // If clicking outside any product name and outside tooltip
        if (!e.target.closest('.product-name') && !e.target.closest('.tooltip')) {
            dismissActiveTooltip();
        }
    });
}

function handleProductNameClick(element, blazeId, sku) {
    // If clicking the same element that already has tooltip open, do nothing
    if (activeTooltipElement === element) {
        return;
    }
    
    // Dismiss any currently active tooltip
    dismissActiveTooltip();
    
    // Show tooltip for clicked element
    if (element._tooltipInstance) {
        element._tooltipInstance.show();
        activeTooltip = element._tooltipInstance;
        activeTooltipElement = element;
    }
}

function dismissActiveTooltip() {
    if (activeTooltip) {
        activeTooltip.hide();
        activeTooltip = null;
        activeTooltipElement = null;
    }
}

// ============================================================================
// SKU BUTTON CLICK HANDLER (PLACEHOLDER FOR FUTURE FUNCTIONALITY)
// ============================================================================
async function handleSkuClick(sku, blazeId) {
    // Get current store name from global state
    if (!currentStoreName) {
        alert('Error: No inventory data loaded');
        return;
    }
    
    console.log(`[SKU CLICK] Navigating to product ${blazeId} in store ${currentStoreName}`);
    
    // Show status message
    const statusText = document.getElementById('inventoryStatusText');
    const originalStatus = statusText.innerHTML;
    statusText.innerHTML = '<span class="text-primary"><i class="bi bi-arrow-repeat spin"></i> Navigating to product page...</span>';
    
    try {
        const response = await fetch('/api/blaze/inventory/navigate-to-product', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                store_name: currentStoreName,
                blaze_id: blazeId
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Success message
            statusText.innerHTML = '<span class="text-success"><i class="bi bi-check-circle"></i> [OK] Navigated to product page!</span>';
            console.log(`[SKU CLICK] Success: ${result.message}`);
            
            // Restore original status after 3 seconds
            setTimeout(() => {
                statusText.innerHTML = originalStatus;
            }, 3000);
        } else {
            // Error message
            statusText.innerHTML = `<span class="text-danger"><i class="bi bi-x-circle"></i> Error: ${result.error}</span>`;
            console.error(`[SKU CLICK] Error: ${result.error}`);
            
            // Restore after 5 seconds
            setTimeout(() => {
                statusText.innerHTML = originalStatus;
            }, 5000);
        }
    } catch (err) {
        statusText.innerHTML = `<span class="text-danger"><i class="bi bi-x-circle"></i> Network error: ${err.message}</span>`;
        console.error(`[SKU CLICK] Network error: ${err}`);
        
        // Restore after 5 seconds
        setTimeout(() => {
            statusText.innerHTML = originalStatus;
        }, 5000);
    }
}

// Copy to clipboard utility
function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        const statusText = document.getElementById('inventoryStatusText');
        const original = statusText.innerHTML;
        statusText.innerHTML = '<span class="text-success">[OK] Copied to clipboard</span>';
        setTimeout(() => {
            statusText.innerHTML = original;
        }, 1500);
    });
}

// Open export modal
function openInventoryExportModal() {
    // Check if data is loaded
    if (!currentInventoryData || currentInventoryData.length === 0) {
        alert('No data loaded. Please fetch or load data first.');
        return;
    }
    
    const exportTabsList = document.getElementById('exportTabsList');
    const exportNoTabs = document.getElementById('exportNoTabs');
    const exportTabsSection = document.getElementById('exportTabsSection');
    const exportDownloadBtn = document.getElementById('exportDownloadBtn');
    
    exportNoTabs.style.display = 'none';
    exportTabsSection.style.display = 'block';
    exportDownloadBtn.disabled = false;
    
    // Show current data info
    exportTabsList.innerHTML = `
        <div class="alert alert-info">
            <strong>Current Data:</strong> ${currentStoreName}<br>
            <strong>Items:</strong> ${currentInventoryData.length}<br>
            <strong>Source:</strong> ${currentDataSource === 'fresh' ? 'Fresh Fetch' : 'Loaded File'}
        </div>
    `;
    
    const modal = new bootstrap.Modal(document.getElementById('inventoryExportModal'));
    modal.show();
}

// Toggle all tabs selection (deprecated)
function toggleAllTabsExport(checkbox) {
    // No-op: tabs removed in v7.6
}

// Update export button state (deprecated)
function updateExportButton() {
    // No-op: tabs removed in v7.6
}

// Generate inventory report
async function generateInventoryReport() {
    if (!currentInventoryData || currentInventoryData.length === 0) {
        alert('No data to export.');
        return;
    }

    // Prepare single-store export data
    const exportData = {};
    exportData[currentStoreName] = currentInventoryData;

    try {
        const response = await fetch('/api/blaze/inventory/export-tabs', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ tabs: exportData })
        });

        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Single store always exports as CSV
            const timestamp = new Date().toISOString().slice(0,10).replace(/-/g, '');
            const safeName = currentStoreName.replace(/[^a-zA-Z0-9]/g, '_');
            a.download = `${safeName}_Inventory_${timestamp}.csv`;
            
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById('inventoryExportModal')).hide();
        } else {
            const error = await response.json();
            alert(`Export failed: ${error.error || 'Unknown error'}`);
        }
    } catch (err) {
        alert(`Network error: ${err.message}`);
    }
}

// Auto-load saved reports list on page load
document.addEventListener('DOMContentLoaded', () => {
    loadSavedReportsList();
});

    </script>
</body>
</html>
"""

# ============================================================================
# FLASK ROUTES (CONTINUED FROM PREVIOUS SECTION)
# ============================================================================

@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

# ============================================================================
# PROFILE MANAGEMENT API ENDPOINTS
# ============================================================================

@app.route('/api/profiles')
def api_get_profiles():
    """Get list of all available profiles."""
    try:
        profiles = get_available_profiles()
        profile_list = []
        for p in profiles:
            profile_list.append({
                'handle': p,
                'has_credentials': check_credentials_for_handle(p),
                'is_active': ACTIVE_PROFILE.get('handle') == p
            })
        return jsonify({
            'success': True,
            'profiles': profile_list,
            'active_profile': ACTIVE_PROFILE.get('handle')
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/current')
def api_get_current_profile():
    """Get current active profile info."""
    try:
        return jsonify({
            'success': True,
            'handle': ACTIVE_PROFILE.get('handle'),
            'has_credentials': check_credentials_for_handle(ACTIVE_PROFILE.get('handle')) if ACTIVE_PROFILE.get('handle') else False
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/switch', methods=['POST'])
def api_switch_profile():
    """Switch to a different profile (requires restart)."""
    try:
        data = request.get_json() or {}
        handle = data.get('handle', '').strip().lower()
        
        if not handle:
            return jsonify({'success': False, 'error': 'No handle provided'})
        
        profiles = get_available_profiles()
        if handle not in profiles:
            return jsonify({'success': False, 'error': f'Profile "{handle}" not found'})
        
        if not check_credentials_for_handle(handle):
            return jsonify({'success': False, 'error': f'Credentials missing for "{handle}"'})
        
        # Save as last used profile
        save_last_used_profile(handle)
        
        return jsonify({
            'success': True,
            'message': f'Profile switched to "{handle}". Restart required.',
            'restart_required': True
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/register', methods=['POST'])
def api_register_profile():
    """Register a new profile."""
    try:
        data = request.get_json() or {}
        handle = data.get('handle', '')
        
        result = register_profile_api(handle)
        
        if result['success']:
            # Save as last used profile
            save_last_used_profile(handle.strip().lower())
        
        return jsonify(result)
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/check-credentials/<handle>')
def api_check_credentials(handle):
    """Check if credentials file exists for a handle."""
    try:
        handle = handle.strip().lower()
        exists = check_credentials_for_handle(handle)
        expected_path = str(GOOGLE_CREDS_DIR / f'credentials_{handle}.json')
        return jsonify({
            'success': True,
            'exists': exists,
            'expected_path': expected_path
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/restart', methods=['POST'])
def api_restart():
    """Restart the application."""
    try:
        import os
        import sys
        
        print("\n" + "="*70)
        print("[RESTART] Restarting application...")
        print("="*70 + "\n")
        
        # Use os.execv to restart the script
        os.execv(sys.executable, [sys.executable] + sys.argv)
        
        # This line won't be reached, but included for completeness
        return jsonify({'success': True})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/delete', methods=['POST'])
def api_delete_profile():
    """Delete a profile (removes token file only, keeps credentials)."""
    try:
        data = request.get_json() or {}
        handle = data.get('handle', '').strip().lower()
        
        if not handle:
            return jsonify({'success': False, 'error': 'No handle provided'})
        
        if handle == ACTIVE_PROFILE.get('handle'):
            return jsonify({'success': False, 'error': 'Cannot delete active profile'})
        
        # Remove token file (this "unregisters" the profile)
        token_file = TOKENS_DIR / f'token_{handle}.json'
        if token_file.exists():
            token_file.unlink()
        
        return jsonify({'success': True, 'message': f'Profile "{handle}" deleted'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# ============================================================================
# EXISTING API ROUTES
# ============================================================================

@app.route('/api/auth', methods=['POST'])
def api_auth():
    try:
        service = authenticate_google_sheets()
        if service:
            GLOBAL_DATA['sheets_service'] = service
            return jsonify({'success': True})
        return jsonify({'success': False, 'error': 'Authentication failed'})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/browser-status')
def api_browser_status():
    return jsonify({
        'ready': GLOBAL_DATA['browser_ready'],
        'instance': GLOBAL_DATA['browser_instance'] is not None
    })

@app.route('/api/get-mis-reports-folder')
def api_get_mis_reports_folder():
    """v10.7: Return the MIS Reports folder path."""
    return jsonify({
        'success': True,
        'path': str(MIS_REPORTS_DIR)
    })

@app.route('/api/open-mis-reports-folder')
def api_open_mis_reports_folder():
    """v10.7: Open the MIS Reports folder in the system file explorer."""
    try:
        import subprocess
        import platform
        
        folder_path = str(MIS_REPORTS_DIR)
        
        if platform.system() == 'Windows':
            subprocess.Popen(['explorer', folder_path])
        elif platform.system() == 'Darwin':  # macOS
            subprocess.Popen(['open', folder_path])
        else:  # Linux
            subprocess.Popen(['xdg-open', folder_path])
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/get-credentials')
def api_get_credentials():
    """Get credentials from config file for auto-fill."""
    try:
        config = load_credentials_config()
        return jsonify({
            'success': True,
            'credentials': config
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        })


# ============================================
# v12.17: Settings Dropdown Data Endpoint
# ============================================
@app.route('/api/get-settings-dropdowns', methods=['GET'])
def api_get_settings_dropdowns():
    """
    v12.17: Fetch dropdown options from Settings tab for Enhanced Create Popup.
    Returns stores, categories, and brand->linked brand mappings.
    """
    try:
        # Try both possible locations for spreadsheet_id
        spreadsheet_id = GLOBAL_DATA.get('mis', {}).get('spreadsheet_id') or GLOBAL_DATA.get('current_spreadsheet_id')
        if not spreadsheet_id:
            return jsonify({
                'success': False,
                'error': 'No spreadsheet loaded. Please select a Google Sheet first.'
            })
        
        data = load_settings_dropdown_data(spreadsheet_id)
        
        return jsonify({
            'success': True,
            'stores': data.get('stores', []),
            'categories': data.get('categories', []),
            'brand_linked_map': data.get('brand_linked_map', {})
        })
    except Exception as e:
        print(f"[ERROR] api_get_settings_dropdowns: {e}")
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        })


@app.route('/api/init-all', methods=['POST'])
def api_init_all():
    try:
        data = request.get_json()
        mis_creds = data.get('mis', {})
        blaze_creds = data.get('blaze', {})
        
        GLOBAL_DATA['mis']['credentials'] = mis_creds
        GLOBAL_DATA['blaze']['credentials'] = blaze_creds
        
        # SILENT OPERATION: Save original tab to return to it at the end
        driver = GLOBAL_DATA.get('browser_instance')
        original_tab = None
        if driver:
            try:
                original_tab = driver.current_window_handle
            except:
                pass
        
        # 1. Initialize Browser
        if not GLOBAL_DATA['browser_ready']:
            driver = init_browser()
            if not driver:
                return jsonify({'success': False, 'error': 'Failed to initialize browser'})
            driver.get("http://127.0.0.1:5100")
            time.sleep(1)
            # Update original tab after browser init
            try:
                original_tab = driver.current_window_handle
            except:
                pass
        else:
            driver = GLOBAL_DATA['browser_instance']
        
        # 2. MIS Login
        mis_success = False
        if mis_creds.get('username') and mis_creds.get('password'):
            mis_success = mis_login(driver, mis_creds['username'], mis_creds['password'], new_tab=True)
        
        # 3. Blaze Login Logic (Smart)
        blaze_success = False
        if blaze_creds.get('email') and blaze_creds.get('password'):
            
            # A. CHECK TOKEN VALIDITY FIRST
            stored_token = load_stored_token()
            is_token_valid = validate_token(stored_token)
            
            if is_token_valid:
                print("[INIT] Existing token is VALID. Skipping sniffer.")
                # Just perform the visual login/navigation
                robust_login(blaze_creds['email'], blaze_creds['password'])
                GLOBAL_DATA['blaze']['token'] = stored_token
                blaze_success = True
                
            else:
                print("[INIT] Token invalid or missing. Running full capture sequence...")
                # Run full logic: Login -> Navigate -> Sniff
                login_status = robust_login(blaze_creds['email'], blaze_creds['password'])
                
                if login_status:
                    blaze_success = True
                    print("[INIT] Blaze Login successful. Searching for Blaze Tab...")
                    
                    # Find Blaze Tab
                    blaze_handle = None
                    for h in driver.window_handles:
                        driver.switch_to.window(h)
                        if "blaze.me" in driver.current_url:
                            blaze_handle = h
                            break
                    
                    if blaze_handle:
                        print(f"[INIT] Found Blaze Tab! Switching focus to handle: {blaze_handle}")
                        driver.switch_to.window(blaze_handle)
                        
                        # Force Navigation to PROMOTIONS (Master Token Source)
                        print("[INIT] Navigating to Main Promotions Page to force Master Token generation...")
                        driver.get("https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=100")
                        time.sleep(5) # Wait for full load
                        
                        # Sniff Logs
                        logs = driver.get_log('performance')
                        found_token = None
                        
                        for entry in logs:
                            try:
                                msg = json.loads(entry['message'])['message']
                                if msg['method'] == 'Network.requestWillBeSent':
                                    req = msg['params']['request']
                                    if 'company/promotions' in req['url']:
                                        headers = req.get('headers', {})
                                        auth = next((v for k, v in headers.items() if k.lower() == 'authorization'), None)
                                        if auth and 'Token' in auth:
                                            found_token = auth.replace('Token ', '').strip()
                                            break
                            except: continue
                        
                        if found_token:
                            print(f"[INIT] SUCCESS: Captured Master Token: {found_token[:10]}...")
                            GLOBAL_DATA['blaze']['token'] = found_token
                            save_stored_token(found_token)
                        else:
                            print("[INIT] WARN: Could not sniff Master Token. Check manual login.")
                    else:
                        print("[INIT] ERROR: Could not find Blaze tab.")

        messages = []
        if mis_success: messages.append("MIS login successful")
        if blaze_success: messages.append("Blaze login & Sync successful")
        
        # V2: Inject persistent validator if MIS login successful
        if mis_success and driver:
            try:
                print("[INIT] [EMOJI] Injecting Validation V2 (persistent, message-passing)")
                # Find MIS tab and inject V2 validator + listeners
                for handle in driver.window_handles:
                    try:
                        driver.switch_to.window(handle)
                        if 'daily-discount' in driver.current_url:
                            inject_mis_validation(driver, expected_data=None)  # Inject with manual mode
                            inject_mis_browser_click_listeners(driver)  # Inject click detection
                            print("[INIT] [EMOJI] Validation V2 + MIS Browser listeners injected")
                            messages.append("Validation V2 ready")
                            break
                    except:
                        continue
            except Exception as e:
                print(f"[INIT] [EMOJI] Could not inject V2 validator: {e}")
        
        # SILENT OPERATION: Return to original tab
        if original_tab and driver:
            try:
                driver.switch_to.window(original_tab)
                print("[INIT] Returned to original tab silently")
            except:
                print("[INIT] Could not return to original tab (may have been closed)")
        
        return jsonify({'success': True, 'message': ' | '.join(messages)})

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/load-sheet', methods=['POST'])
def api_mis_load_sheet():
    try:
        data = request.get_json()
        url = data.get('url', '')
        spreadsheet_id = extract_spreadsheet_id(url)
        if not spreadsheet_id:
            return jsonify({'success': False, 'error': 'Invalid URL'})
        GLOBAL_DATA['mis']['spreadsheet_id'] = spreadsheet_id
        tabs = get_available_tabs(spreadsheet_id)
        if not tabs:
            return jsonify({'success': False, 'error': 'No tabs found'})
        # v12.1: Return spreadsheet_id for goToSheetRow functionality
        return jsonify({'success': True, 'tabs': tabs, 'spreadsheet_id': spreadsheet_id})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/init-sheet-page', methods=['POST'])
def api_mis_init_sheet_page():
    try:
        data = request.get_json()
        tab_name = data.get('tab')
        spreadsheet_id = GLOBAL_DATA['mis'].get('spreadsheet_id')
        if not spreadsheet_id:
            return jsonify({'success': False, 'error': 'No spreadsheet loaded'})
        if not GLOBAL_DATA.get('browser_ready'):
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        GLOBAL_DATA['mis']['current_sheet'] = tab_name
        if open_google_sheet_in_browser(spreadsheet_id, tab_name):
            return jsonify({'success': True, 'message': f'Opened tab "{tab_name}"'})
        return jsonify({'success': False, 'error': 'Failed to open sheet'})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/generate-csv', methods=['POST'])
def api_mis_generate_csv():
    try:
        data = request.get_json()
        tab_name = data.get('tab')
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab selected'})
        
        # 1. Fetch Sections (Returns Dict)
        sections_data = fetch_google_sheet_data(tab_name)
        
        # 2. Process Each Section
        results = {}
        total_count = 0
        
        for section_name in ['weekly', 'monthly', 'sale']:
            df = sections_data.get(section_name, pd.DataFrame())
            
            if df.empty:
                results[section_name] = {'rows': [], 'summary': {}}
            else:
                # PASS section_name HERE
                rows, summary = generate_mis_csv_with_multiday(df, section_type=section_name)
                results[section_name] = {'rows': rows, 'summary': summary}
                total_count += len(rows)
            
        # Store structured results globally
        GLOBAL_DATA['mis']['generated_sections'] = results
        
        return jsonify({
            'success': True, 
            'sections': results,
            'total_rows': total_count
        })
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/download-csv')
def api_mis_download_csv():
    try:
        export_type = request.args.get('type', 'all') # all, weekly, monthly, sale
        sections = GLOBAL_DATA['mis'].get('generated_sections', {})
        
        if not sections:
            return "No CSV generated. Please click 'Generate CSV' first.", 400
        
        # Gather rows based on type
        final_rows = []
        
        if export_type == 'all':
            for key in ['weekly', 'monthly', 'sale']:
                if key in sections:
                    final_rows.extend(sections[key]['rows'])
        elif export_type in sections:
            final_rows = sections[export_type]['rows']
        else:
            return f"Invalid export type: {export_type}", 400
            
        if not final_rows:
            return "No data found for selected section.", 400
            
        df = pd.DataFrame(final_rows)
        
        # Drop internal tracking columns
        df = df.drop(columns=['GOOGLE_ROWS', 'MULTI_DAY_FLAG', 'WEEKDAY_SORT_KEY', 'NOTES', 
                              'SPLIT_GROUP_ID', 'ROW_UI_CLASS', 'DISPLAY_CATEGORY', 
                              'DISPLAY_STORE', 'UI_SPECIAL_NOTES', 'UI_DEAL_INFO', 'UI_REBATE_DISPLAY'], 
                     errors='ignore')
        
        # Column Ordering
        column_order = [
            'ID', 'Weekday', 'Store', 'Brand', 'Linked Brand (if applicable)',
            'Category', 'Daily Deal Discount', 'Rebate type', 
            'Discount paid by vendor', 'Rebate After Wholesale Discount?',
            'Include clearance items?', 'Specialty Discount (non-daily deal)?',
            'Start date', 'End date', 'Minimum Weight', 'Maximum Weight', 'Actions'
        ]
        
        for col in column_order:
            if col not in df.columns: df[col] = ''
        
        df = df[column_order]
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'MIS_Deals_{export_type.upper()}_{timestamp}.csv'
        filepath = BASE_DIR / filename
        df.to_csv(filepath, index=False)
        
        return send_file(filepath, as_attachment=True, download_name=filename)
    except Exception as e:
        traceback.print_exc()
        return str(e), 500


@app.route('/api/mis/generate-newsletter', methods=['POST'])
def api_mis_generate_newsletter():
    """
    Generate Newsletter files:
    1. Excel file with 6 tabs (CLUB420 and TAT LEGACY x Weekly/Monthly/Sale)
    2. Two DOCX files (CLUB420_Newsletter.docx and TAT_LEGACY_Newsletter.docx)
    
    Each DOCX contains 3 tables (Weekly, Monthly, Sale) with day-of-week columns.
    """
    try:
        sections = GLOBAL_DATA['mis'].get('generated_sections', {})
        
        if not sections:
            return jsonify({'success': False, 'error': "No CSV generated. Please click 'Generate CSV' first."}), 400
        
        # Define CLUB420 locations (Davis and Dixon)
        CLUB420_LOCATIONS = ['Davis', 'Dixon']
        
        # Define patterns that indicate ONLY Davis/Dixon (should be excluded from TAT LEGACY)
        DAVIS_DIXON_ONLY_PATTERNS = [
            'Davis',
            'Dixon',
            'Davis, Dixon',
            'Dixon, Davis',
            'All Locations Except: Davis, Dixon',
            'All Locations Except: Dixon, Davis',
            'All Locations Except: Davis',
            'All Locations Except: Dixon'
        ]
        
        def is_club420_deal(store_value: str) -> bool:
            """Check if deal is available at CLUB420 locations (Davis/Dixon)"""
            if not store_value:
                return False
            store = str(store_value).strip()
            
            if store == 'All Locations':
                return True
            
            for loc in CLUB420_LOCATIONS:
                if loc in store:
                    if store.startswith('All Locations Except:'):
                        continue
                    return True
            
            return False
        
        def is_tat_legacy_deal(store_value: str) -> bool:
            """Check if deal is available at TAT Legacy locations (not just Davis/Dixon)"""
            if not store_value:
                return False
            store = str(store_value).strip()
            
            if store == 'All Locations':
                return True
            
            store_normalized = store.strip()
            
            for pattern in DAVIS_DIXON_ONLY_PATTERNS:
                if store_normalized == pattern:
                    return False
            
            store_parts = [s.strip() for s in store.split(',')]
            if all(part in CLUB420_LOCATIONS for part in store_parts):
                return False
            
            if store.startswith('All Locations Except:'):
                return True
            
            return True
        
        def format_discount(row) -> str:
            """Format discount value for newsletter"""
            deal_info = ''
            
            ui_deal_info = row.get('UI_DEAL_INFO', [])
            if ui_deal_info and isinstance(ui_deal_info, list) and len(ui_deal_info) > 0:
                first_info = ui_deal_info[0].get('info', '') if isinstance(ui_deal_info[0], dict) else ''
                deal_info = str(first_info).strip()
            
            if not deal_info:
                deal_info = str(row.get('Deal Information', '') or row.get('Deal Info', '')).strip()
            
            deal_info_upper = deal_info.upper()
            if 'BOGO FOR $1' in deal_info_upper or 'B2G1 FOR $1' in deal_info_upper:
                bogo_match = re.search(r'(BOGO\s+for\s+\$\d+|B2G1\s+for\s+\$\d+)', deal_info, re.IGNORECASE)
                if bogo_match:
                    return bogo_match.group(0)
                if 'BOGO' in deal_info_upper:
                    return 'BOGO for $1'
                if 'B2G1' in deal_info_upper:
                    return 'B2G1 for $1'
            
            discount_val = row.get('Daily Deal Discount', '')
            if discount_val:
                discount_str = str(discount_val).strip().replace('%', '').strip()
                try:
                    discount_num = float(discount_str)
                    if discount_num == int(discount_num):
                        return f"{int(discount_num)}% Off"
                    else:
                        return f"{discount_num}% Off"
                except (ValueError, TypeError):
                    if discount_str:
                        return f"{discount_str}% Off"
            
            return discount_val or ''
        
        def format_deal_info(discount: str, categories: str) -> str:
            """Format the Deal Info column for DOCX table"""
            if not discount:
                return ''
            
            # If it's a BOGO deal, return as-is with " - Like-Products" suffix if not already present
            if 'BOGO' in discount.upper() or 'B2G1' in discount.upper():
                if 'Like-Products' not in discount and 'like-products' not in discount.lower():
                    return f"{discount} - Like-Products"
                return discount
            
            # Format as "X% Off [category]"
            if not categories or categories.strip().lower() == 'all categories':
                return f"{discount} all Products"
            else:
                return f"{discount} {categories}"
        
        def parse_weekdays_weekly(weekday_str: str) -> dict:
            """Parse weekday string for WEEKLY deals - puts day abbreviation in column"""
            days = {
                'Mon.': '', 'Tues.': '', 'Wed.': '', 
                'Thurs.': '', 'Fri.': '', 'Sat.': '', 'Sun.': ''
            }
            
            if not weekday_str:
                return days
            
            weekday_lower = weekday_str.lower()
            
            # Map full day name to column key and display abbreviation
            day_mapping = {
                'monday': ('Mon.', 'Mon'),
                'tuesday': ('Tues.', 'Tues'),
                'wednesday': ('Wed.', 'Wed'),
                'thursday': ('Thurs.', 'Thurs'),
                'friday': ('Fri.', 'Fri'),
                'saturday': ('Sat.', 'Sat'),
                'sunday': ('Sun.', 'Sun')
            }
            
            for full_day, (col_key, display_abbrev) in day_mapping.items():
                if full_day in weekday_lower:
                    days[col_key] = display_abbrev
            
            return days
        
        def parse_weekdays_monthly(weekday_str: str) -> dict:
            """Parse weekday for MONTHLY deals - puts the weekday value in Mon. column"""
            days = {
                'Mon.': '', 'Tues.': '', 'Wed.': '', 
                'Thurs.': '', 'Fri.': '', 'Sat.': '', 'Sun.': ''
            }
            
            if weekday_str:
                # Put the raw weekday value in the Mon. column
                days['Mon.'] = str(weekday_str).strip()
            
            return days
        
        def process_row(row, section_type: str = 'weekly') -> dict:
            """Process a single row into newsletter format"""
            store = row.get('Store', '') or row.get('DISPLAY_STORE', '') or ''
            formatted_discount = format_discount(row)
            categories = row.get('Category', '') or row.get('DISPLAY_CATEGORY', '')
            weekday = row.get('Weekday', '')
            brand = row.get('Brand', '')
            
            # Use different day parsing based on section type
            if section_type == 'monthly':
                days = parse_weekdays_monthly(weekday)
            else:
                # Weekly and Sale both use the weekly format (day abbreviations)
                days = parse_weekdays_weekly(weekday)
            
            return {
                'Weekday': weekday,
                'Brand': brand,
                'Discount': formatted_discount,
                'Categories': categories,
                'Deal_Info': format_deal_info(formatted_discount, categories),
                'Days': days,
                'Store': store
            }
        
        # Process each section separately
        section_data = {
            'weekly': {'club420': [], 'tat_legacy': []},
            'monthly': {'club420': [], 'tat_legacy': []},
            'sale': {'club420': [], 'tat_legacy': []}
        }
        
        for section_key in ['weekly', 'monthly', 'sale']:
            section_rows = sections.get(section_key, {}).get('rows', [])
            
            for row in section_rows:
                processed = process_row(row, section_key)
                store = processed['Store']
                
                if is_club420_deal(store):
                    section_data[section_key]['club420'].append(processed)
                
                if is_tat_legacy_deal(store):
                    section_data[section_key]['tat_legacy'].append(processed)
        
        # ===== CREATE OUTPUT FOLDER =====
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        current_month = datetime.now().strftime('%B')
        
        # Create Newsletter folder structure: REPORTS/Newsletter/NEWSLETTER_YYYYMMDD_HHMMSS/
        newsletter_base_dir = BASE_DIR / 'REPORTS' / 'Newsletter'
        newsletter_base_dir.mkdir(parents=True, exist_ok=True)
        
        newsletter_folder = newsletter_base_dir / f'NEWSLETTER_{timestamp}'
        newsletter_folder.mkdir(parents=True, exist_ok=True)
        
        print(f"[NEWSLETTER] Output folder: {newsletter_folder}")
        
        # ===== GENERATE EXCEL FILE (6 tabs) =====
        excel_filename = f'Newsletter_Table_{timestamp}.xlsx'
        excel_filepath = newsletter_folder / excel_filename
        
        column_order = ['Weekday', 'Brand', 'Discount', 'Categories']
        
        with pd.ExcelWriter(excel_filepath, engine='openpyxl') as writer:
            for section_key, section_title in [('weekly', 'Weekly Deals'), ('monthly', 'Monthly Deals'), ('sale', 'Sale Deals')]:
                # CLUB420 tab
                club420_rows = section_data[section_key]['club420']
                df_club420 = pd.DataFrame([{k: r[k] for k in column_order} for r in club420_rows]) if club420_rows else pd.DataFrame(columns=column_order)
                for col in column_order:
                    if col not in df_club420.columns:
                        df_club420[col] = ''
                df_club420 = df_club420[column_order]
                df_club420.to_excel(writer, sheet_name=f'CLUB420 - {section_title}', index=False)
                
                # TAT LEGACY tab
                tat_legacy_rows = section_data[section_key]['tat_legacy']
                df_tat_legacy = pd.DataFrame([{k: r[k] for k in column_order} for r in tat_legacy_rows]) if tat_legacy_rows else pd.DataFrame(columns=column_order)
                for col in column_order:
                    if col not in df_tat_legacy.columns:
                        df_tat_legacy[col] = ''
                df_tat_legacy = df_tat_legacy[column_order]
                df_tat_legacy.to_excel(writer, sheet_name=f'TAT LEGACY - {section_title}', index=False)
        
        print(f"[NEWSLETTER] Excel generated: {excel_filepath}")
        
        # ===== GENERATE DOCX FILES (using python-docx) =====
        from docx import Document as DocxDocument
        from docx.shared import Inches, Pt, RGBColor
        from docx.enum.text import WD_ALIGN_PARAGRAPH
        from docx.enum.table import WD_TABLE_ALIGNMENT
        from docx.oxml.ns import nsdecls
        from docx.oxml import parse_xml
        
        def create_newsletter_docx(location_name: str, location_data: dict, output_path: Path):
            """Create a newsletter DOCX file with tables for each section"""
            doc = DocxDocument()
            
            # Set narrow margins
            for section in doc.sections:
                section.top_margin = Inches(0.5)
                section.bottom_margin = Inches(0.5)
                section.left_margin = Inches(0.5)
                section.right_margin = Inches(0.5)
            
            # Title
            title = doc.add_paragraph()
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            title_run = title.add_run(location_name)
            title_run.bold = True
            title_run.font.size = Pt(18)
            title_run.font.name = 'Arial'
            
            # Subtitle with month
            subtitle = doc.add_paragraph()
            subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
            subtitle_run = subtitle.add_run(f"{current_month} Daily Deal Schedule Notes:")
            subtitle_run.bold = True
            subtitle_run.font.size = Pt(14)
            subtitle_run.font.name = 'Arial'
            
            # Add spacing after subtitle
            doc.add_paragraph()
            
            def add_section_table(section_title: str, section_rows: list):
                """Add a section with title and table"""
                # Section title
                sec_title = doc.add_paragraph()
                sec_title_run = sec_title.add_run(section_title)
                sec_title_run.bold = True
                sec_title_run.font.size = Pt(12)
                sec_title_run.font.name = 'Arial'
                
                if not section_rows:
                    no_data = doc.add_paragraph()
                    no_data_run = no_data.add_run("No deals in this section.")
                    no_data_run.italic = True
                    no_data_run.font.size = Pt(10)
                    no_data_run.font.name = 'Arial'
                    no_data_run.font.color.rgb = RGBColor(102, 102, 102)
                    doc.add_paragraph()  # Spacer
                    return
                
                # Create table: Brand, Deal Info, Mon, Tues, Wed, Thurs, Fri, Sat, Sun
                table = doc.add_table(rows=1 + len(section_rows), cols=9)
                table.style = 'Table Grid'
                table.alignment = WD_TABLE_ALIGNMENT.CENTER
                
                # Set column widths
                widths = [Inches(1.2), Inches(2.3), Inches(0.5), Inches(0.5), Inches(0.5), Inches(0.5), Inches(0.5), Inches(0.5), Inches(0.5)]
                for row in table.rows:
                    for idx, cell in enumerate(row.cells):
                        cell.width = widths[idx]
                
                # Header row
                headers = ['Brand', 'Deal Info', 'Mon.', 'Tues.', 'Wed.', 'Thurs.', 'Fri.', 'Sat.', 'Sun.']
                header_row = table.rows[0]
                for idx, header_text in enumerate(headers):
                    cell = header_row.cells[idx]
                    cell.text = ''
                    para = cell.paragraphs[0]
                    para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                    run = para.add_run(header_text)
                    run.bold = True
                    run.font.size = Pt(9)
                    run.font.name = 'Arial'
                    # Light blue background for header
                    shading = parse_xml(f'<w:shd {nsdecls("w")} w:fill="D9E2F3"/>')
                    cell._tc.get_or_add_tcPr().append(shading)
                
                # Data rows
                for row_idx, row_data in enumerate(section_rows):
                    data_row = table.rows[row_idx + 1]
                    days = row_data.get('Days', {})
                    
                    cell_values = [
                        row_data.get('Brand', ''),
                        row_data.get('Deal_Info', ''),
                        days.get('Mon.', ''),
                        days.get('Tues.', ''),
                        days.get('Wed.', ''),
                        days.get('Thurs.', ''),
                        days.get('Fri.', ''),
                        days.get('Sat.', ''),
                        days.get('Sun.', '')
                    ]
                    
                    for col_idx, cell_value in enumerate(cell_values):
                        cell = data_row.cells[col_idx]
                        cell.text = ''
                        para = cell.paragraphs[0]
                        # Center align day columns (index 2-8)
                        if col_idx >= 2:
                            para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                        run = para.add_run(str(cell_value))
                        run.font.size = Pt(9)
                        run.font.name = 'Arial'
                
                # Add spacer after table
                doc.add_paragraph()
            
            # Add each section
            add_section_table("Weekly Deals", location_data.get('weekly', []))
            add_section_table("Monthly Deals", location_data.get('monthly', []))
            add_section_table("Sale Deals", location_data.get('sale', []))
            
            # Save document
            doc.save(str(output_path))
            print(f"[NEWSLETTER] DOCX saved: {output_path}")
        
        # Generate CLUB420 document - save directly to newsletter folder
        club420_docx = newsletter_folder / f'CLUB420_Newsletter_{timestamp}.docx'
        try:
            club420_data = {
                'weekly': section_data['weekly']['club420'],
                'monthly': section_data['monthly']['club420'],
                'sale': section_data['sale']['club420']
            }
            create_newsletter_docx("CLUB420", club420_data, club420_docx)
        except Exception as e:
            print(f"[NEWSLETTER] Error creating CLUB420 DOCX: {e}")
            traceback.print_exc()
        
        # Generate TAT LEGACY document - save directly to newsletter folder
        tat_legacy_docx = newsletter_folder / f'TAT_LEGACY_Newsletter_{timestamp}.docx'
        try:
            tat_legacy_data = {
                'weekly': section_data['weekly']['tat_legacy'],
                'monthly': section_data['monthly']['tat_legacy'],
                'sale': section_data['sale']['tat_legacy']
            }
            create_newsletter_docx("TAT LEGACY", tat_legacy_data, tat_legacy_docx)
        except Exception as e:
            print(f"[NEWSLETTER] Error creating TAT LEGACY DOCX: {e}")
            traceback.print_exc()
        
        # Check what was created
        excel_created = excel_filepath.exists()
        club420_created = club420_docx.exists()
        tat_legacy_created = tat_legacy_docx.exists()
        
        # Log summary
        print(f"[NEWSLETTER] ========== GENERATION COMPLETE ==========")
        print(f"[NEWSLETTER] Output folder: {newsletter_folder}")
        print(f"[NEWSLETTER] Excel created: {excel_created}")
        print(f"[NEWSLETTER] CLUB420 DOCX created: {club420_created}")
        print(f"[NEWSLETTER] TAT LEGACY DOCX created: {tat_legacy_created}")
        print(f"[NEWSLETTER] CLUB420 - Weekly: {len(section_data['weekly']['club420'])}, Monthly: {len(section_data['monthly']['club420'])}, Sale: {len(section_data['sale']['club420'])}")
        print(f"[NEWSLETTER] TAT LEGACY - Weekly: {len(section_data['weekly']['tat_legacy'])}, Monthly: {len(section_data['monthly']['tat_legacy'])}, Sale: {len(section_data['sale']['tat_legacy'])}")
        print(f"[NEWSLETTER] ==========================================")
        
        # Return success with folder path
        return jsonify({
            'success': True,
            'folder': str(newsletter_folder),
            'files': {
                'excel': str(excel_filepath) if excel_created else None,
                'club420_docx': str(club420_docx) if club420_created else None,
                'tat_legacy_docx': str(tat_legacy_docx) if tat_legacy_created else None
            },
            'counts': {
                'club420': {
                    'weekly': len(section_data['weekly']['club420']),
                    'monthly': len(section_data['monthly']['club420']),
                    'sale': len(section_data['sale']['club420'])
                },
                'tat_legacy': {
                    'weekly': len(section_data['weekly']['tat_legacy']),
                    'monthly': len(section_data['monthly']['tat_legacy']),
                    'sale': len(section_data['sale']['tat_legacy'])
                }
            }
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================================
# FIXED MIS AUTOMATION: PULL CSV WITH SMART VALIDATION & RETRY
# ============================================================================
def pull_mis_csv_report_background(driver) -> Tuple[bool, str, str]:
    """
    Background version of pull_mis_csv_report that uses provided driver.
    Navigates to MIS, clears search, ensures 'ALL' rows visible, downloads CSV.
    
    NEW: Smart Validation & Retry Logic
    - Verifies table is fully populated before clicking CSV button
    - Validates downloaded file size (< 1KB = misfire/empty)
    - Retries up to 3 times if misfire detected
    
    Returns: (Success, Full Path or Error Message, Filename)
    """
    if not driver:
        return False, "Browser not ready", ""
    
    target_url = "https://mis.theartisttree.com/daily-discount"
    MAX_RETRY_ATTEMPTS = 3
    MIN_VALID_FILE_SIZE = 1024  # 1KB minimum for valid CSV
    
    try:
        # Already on MIS tab from execute_in_background
        # Wait for page to be ready
        time.sleep(2)
            
        # 1. Clear Search Bar
        print("[MIS CSV] Clearing Search Bar...")
        search_input = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
        )
        search_input.clear()
        search_input.send_keys(Keys.CONTROL + "a")
        search_input.send_keys(Keys.DELETE)

        # 2. Set table to show ALL entries
        print("[MIS CSV] Verifying table length setting...")
        try:
            dropdown_element = WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.NAME, "daily-discount_length"))
            )
            
            select = Select(dropdown_element)
            current_val = select.first_selected_option.get_attribute("value")
            
            if current_val != "-1":
                print("[MIS CSV] Switching view to 'All' entries...")
                select.select_by_value("-1")
                
                # Wait for loading to complete
                print("[MIS CSV] Waiting for loading spinner to disappear...")
                try:
                    WebDriverWait(driver, 30).until_not(
                        EC.presence_of_element_located((By.CSS_SELECTOR, "td.dataTables_empty"))
                    )
                    print("[MIS CSV] [OK] Loading spinner disappeared")
                except TimeoutException:
                    print("[WARN] Spinner timeout, proceeding...")
                
        except Exception as e:
            print(f"[WARN] Table setup error: {e}")
        
        # ================================================================
        # SMART VALIDATION: Ensure table is FULLY POPULATED before download
        # ================================================================
        def verify_table_populated():
            """
            Returns True if table has actual data rows (not loading/empty).
            Checks for:
            - No "Loading..." text
            - No "No data available" message
            - At least one real data row with content
            """
            try:
                # Check for empty/loading states
                empty_cells = driver.find_elements(By.CSS_SELECTOR, "td.dataTables_empty")
                for cell in empty_cells:
                    if cell.is_displayed():
                        cell_text = cell.text.lower()
                        if 'loading' in cell_text or 'no data' in cell_text or 'processing' in cell_text:
                            return False
                
                # Check for actual data rows
                data_rows = driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.dataTables_empty)")
                if len(data_rows) == 0:
                    return False
                
                # Verify at least one row has actual content (not empty)
                for row in data_rows[:3]:  # Check first 3 rows
                    try:
                        cells = row.find_elements(By.CSS_SELECTOR, "td")
                        if len(cells) > 0 and any(cell.text.strip() for cell in cells):
                            return True
                    except:
                        continue
                
                return False
            except:
                return False
        
        # Wait for table to be fully populated
        print("[MIS CSV] Waiting for table to be fully populated...")
        for wait_attempt in range(15):  # Up to 15 seconds
            if verify_table_populated():
                row_count = len(driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.dataTables_empty)"))
                print(f"[MIS CSV] [OK] Table populated with {row_count} rows")
                break
            time.sleep(1)
            if wait_attempt == 14:
                print("[WARN] Table population timeout, proceeding anyway...")
        
        # Extra stability wait
        time.sleep(1)
        
        # ================================================================
        # RETRY LOOP: Download CSV with validation and retry on misfire
        # ================================================================
        for attempt in range(1, MAX_RETRY_ATTEMPTS + 1):
            print(f"[MIS CSV] Download attempt {attempt}/{MAX_RETRY_ATTEMPTS}...")
            
            # Snapshot files before download
            existing_files = set(os.listdir(MIS_REPORTS_DIR))
            
            # Click CSV Button
            print("[MIS CSV] Clicking CSV Button...")
            csv_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.buttons-csv"))
            )
            driver.execute_script("arguments[0].click();", csv_btn)
            
            # Wait for new file to appear
            print("[MIS CSV] Waiting for download...")
            new_file_path = None
            for _ in range(30):  # 30 second timeout
                time.sleep(1)
                current_files = set(os.listdir(MIS_REPORTS_DIR))
                new_files = current_files - existing_files
                for f in new_files:
                    if (f.endswith('.csv') or f.endswith('.xlsx')) and not f.endswith('.crdownload'):
                        new_file_path = MIS_REPORTS_DIR / f
                        break
                if new_file_path:
                    break
            
            if not new_file_path:
                print(f"[MIS CSV] [WARN] Download timed out on attempt {attempt}")
                if attempt < MAX_RETRY_ATTEMPTS:
                    print("[MIS CSV] Refreshing and retrying...")
                    driver.refresh()
                    time.sleep(3)
                    continue
                else:
                    return False, "Download timed out after all retry attempts", ""
            
            # ================================================================
            # SIZE VALIDATION: Check if file is a misfire (< 1KB)
            # ================================================================
            time.sleep(0.5)  # Let file finish writing
            file_size = os.path.getsize(new_file_path)
            print(f"[MIS CSV] Downloaded file size: {file_size} bytes")
            
            if file_size < MIN_VALID_FILE_SIZE:
                print(f"[MIS CSV] [MISFIRE] File too small ({file_size} bytes < {MIN_VALID_FILE_SIZE} bytes) - likely empty!")
                
                # Delete the empty/broken file
                try:
                    os.remove(new_file_path)
                    print(f"[MIS CSV] Deleted misfire file: {new_file_path}")
                except Exception as del_err:
                    print(f"[WARN] Could not delete misfire file: {del_err}")
                
                if attempt < MAX_RETRY_ATTEMPTS:
                    print(f"[MIS CSV] Waiting 3 seconds before retry {attempt + 1}...")
                    time.sleep(3)
                    
                    # Refresh table to ensure data is loaded
                    print("[MIS CSV] Refreshing page before retry...")
                    driver.refresh()
                    time.sleep(3)
                    
                    # Re-verify table is populated
                    for wait_attempt in range(10):
                        if verify_table_populated():
                            print("[MIS CSV] Table re-populated, retrying download...")
                            break
                        time.sleep(1)
                    
                    continue  # Try again
                else:
                    return False, f"Download misfire (empty file) after {MAX_RETRY_ATTEMPTS} attempts", ""
            
            # ================================================================
            # SUCCESS: Valid file downloaded
            # ================================================================
            print(f"[MIS CSV] [OK] Valid file downloaded ({file_size} bytes)")
            
            # Rename to standard format
            now = datetime.now()
            final_name = f"MIS_CSV_REPORT_{now.strftime('%Y-%m-%d')}_{now.strftime('%I-%M-%S-%p')}.csv"
            final_path = MIS_REPORTS_DIR / final_name
            
            if final_path.exists():
                os.remove(final_path)
            time.sleep(0.5)
            os.rename(new_file_path, final_path)
            
            print(f"[MIS CSV] [OK] Report Ready: {final_name} ({file_size} bytes)")
            return True, str(final_path), final_name
        
        # Should not reach here, but just in case
        return False, "Unknown error during CSV download", ""

    except Exception as e:
        print(f"[ERROR] MIS CSV Pull failed: {e}")
        traceback.print_exc()
        return False, f"Error: {str(e)}", ""

def pull_mis_csv_report() -> Tuple[bool, str, str]:
    """
    Navigates to MIS, clears search, ENSURES 'ALL' ROWS VISIBLE with validation,
    clicks CSV, downloads, and renames.
    
    NEW: Smart Validation & Retry Logic
    - Verifies table is fully populated before clicking CSV button
    - Validates downloaded file size (< 1KB = misfire/empty)
    - Retries up to 3 times if misfire detected
    
    Returns: (Success, Full Path, Filename)
    """
    driver = GLOBAL_DATA['browser_instance']
    if not driver: return False, "Browser not ready", ""
    
    target_url = "https://mis.theartisttree.com/daily-discount"
    MAX_RETRY_ATTEMPTS = 3
    MIN_VALID_FILE_SIZE = 1024  # 1KB minimum for valid CSV
    
    try:
        # 1. Navigate / Switch Tab
        found = False
        for h in driver.window_handles:
            driver.switch_to.window(h)
            if "daily-discount" in driver.current_url:
                found = True
                break
        
        if not found:
            driver.execute_script(f"window.open('{target_url}', '_blank');")
            driver.switch_to.window(driver.window_handles[-1])
        else:
            driver.get(target_url)  # Refresh to clear state
            
        # 2. Clear Search Bar
        print("[MIS CSV] Clearing Search Bar...")
        search_input = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
        )
        search_input.clear()
        search_input.send_keys(Keys.CONTROL + "a")
        search_input.send_keys(Keys.DELETE)

        # 3. Set table to show ALL entries
        print("[MIS CSV] Verifying table length setting...")
        try:
            dropdown_element = WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.NAME, "daily-discount_length"))
            )
            
            select = Select(dropdown_element)
            current_val = select.first_selected_option.get_attribute("value")
            
            if current_val != "-1":
                print("[MIS CSV] Switching view to 'All' entries...")
                select.select_by_value("-1")
                
                # Wait for loading to complete
                print("[MIS CSV] Waiting for loading spinner to disappear...")
                try:
                    WebDriverWait(driver, 30).until_not(
                        EC.presence_of_element_located((By.CSS_SELECTOR, "td.dataTables_empty"))
                    )
                    print("[MIS CSV] [OK] Loading spinner disappeared")
                except TimeoutException:
                    print("[WARN] Spinner timeout, proceeding...")
                    
        except Exception as e:
            print(f"[WARN] Table setup error: {e}")
        
        # ================================================================
        # SMART VALIDATION: Ensure table is FULLY POPULATED before download
        # ================================================================
        def verify_table_populated():
            """
            Returns True if table has actual data rows (not loading/empty).
            """
            try:
                # Check for empty/loading states
                empty_cells = driver.find_elements(By.CSS_SELECTOR, "td.dataTables_empty")
                for cell in empty_cells:
                    if cell.is_displayed():
                        cell_text = cell.text.lower()
                        if 'loading' in cell_text or 'no data' in cell_text or 'processing' in cell_text:
                            return False
                
                # Check for actual data rows
                data_rows = driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.dataTables_empty)")
                if len(data_rows) == 0:
                    return False
                
                # Verify at least one row has actual content
                for row in data_rows[:3]:
                    try:
                        cells = row.find_elements(By.CSS_SELECTOR, "td")
                        if len(cells) > 0 and any(cell.text.strip() for cell in cells):
                            return True
                    except:
                        continue
                
                return False
            except:
                return False
        
        # Wait for table to be fully populated
        print("[MIS CSV] Waiting for table to be fully populated...")
        for wait_attempt in range(15):
            if verify_table_populated():
                row_count = len(driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.dataTables_empty)"))
                print(f"[MIS CSV] [OK] Table populated with {row_count} rows")
                break
            time.sleep(1)
            if wait_attempt == 14:
                print("[WARN] Table population timeout, proceeding anyway...")
        
        # Extra stability wait
        time.sleep(1)
        
        # ================================================================
        # RETRY LOOP: Download CSV with validation and retry on misfire
        # ================================================================
        for attempt in range(1, MAX_RETRY_ATTEMPTS + 1):
            print(f"[MIS CSV] Download attempt {attempt}/{MAX_RETRY_ATTEMPTS}...")
            
            # Snapshot files before download
            existing_files = set(os.listdir(MIS_REPORTS_DIR))
            
            # Click CSV Button
            print("[MIS CSV] Clicking CSV Button...")
            csv_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.buttons-csv"))
            )
            driver.execute_script("arguments[0].click();", csv_btn)
            
            # Wait for new file to appear
            print("[MIS CSV] Waiting for download...")
            new_file_path = None
            for _ in range(30):
                time.sleep(1)
                current_files = set(os.listdir(MIS_REPORTS_DIR))
                new_files = current_files - existing_files
                for f in new_files:
                    if (f.endswith('.csv') or f.endswith('.xlsx')) and not f.endswith('.crdownload'):
                        new_file_path = MIS_REPORTS_DIR / f
                        break
                if new_file_path:
                    break
            
            if not new_file_path:
                print(f"[MIS CSV] [WARN] Download timed out on attempt {attempt}")
                if attempt < MAX_RETRY_ATTEMPTS:
                    print("[MIS CSV] Refreshing and retrying...")
                    driver.refresh()
                    time.sleep(3)
                    continue
                else:
                    return False, "Download timed out after all retry attempts", ""
            
            # ================================================================
            # SIZE VALIDATION: Check if file is a misfire (< 1KB)
            # ================================================================
            time.sleep(0.5)
            file_size = os.path.getsize(new_file_path)
            print(f"[MIS CSV] Downloaded file size: {file_size} bytes")
            
            if file_size < MIN_VALID_FILE_SIZE:
                print(f"[MIS CSV] [MISFIRE] File too small ({file_size} bytes < {MIN_VALID_FILE_SIZE} bytes) - likely empty!")
                
                # Delete the empty/broken file
                try:
                    os.remove(new_file_path)
                    print(f"[MIS CSV] Deleted misfire file: {new_file_path}")
                except Exception as del_err:
                    print(f"[WARN] Could not delete misfire file: {del_err}")
                
                if attempt < MAX_RETRY_ATTEMPTS:
                    print(f"[MIS CSV] Waiting 3 seconds before retry {attempt + 1}...")
                    time.sleep(3)
                    
                    # Refresh table to ensure data is loaded
                    print("[MIS CSV] Refreshing page before retry...")
                    driver.refresh()
                    time.sleep(3)
                    
                    # Re-verify table is populated
                    for wait_attempt in range(10):
                        if verify_table_populated():
                            print("[MIS CSV] Table re-populated, retrying download...")
                            break
                        time.sleep(1)
                    
                    continue
                else:
                    return False, f"Download misfire (empty file) after {MAX_RETRY_ATTEMPTS} attempts", ""
            
            # ================================================================
            # SUCCESS: Valid file downloaded
            # ================================================================
            print(f"[MIS CSV] [OK] Valid file downloaded ({file_size} bytes)")
            
            # Rename to standard format
            now = datetime.now()
            final_name = f"MIS_CSV_REPORT_{now.strftime('%Y-%m-%d')}_{now.strftime('%I-%M-%S-%p')}.csv"
            final_path = MIS_REPORTS_DIR / final_name
            
            if final_path.exists():
                os.remove(final_path)
            time.sleep(0.5)
            os.rename(new_file_path, final_path)
            
            print(f"[MIS CSV] [OK] Report Ready: {final_name} ({file_size} bytes)")
            return True, str(final_path), final_name
        
        # Should not reach here
        return False, "Unknown error during CSV download", ""

    except Exception as e:
        print(f"[ERROR] MIS CSV Pull failed: {e}")
        traceback.print_exc()
        return False, str(e), ""

@app.route('/api/mis/pull-csv', methods=['POST'])
def api_mis_pull_csv():
    """Pull MIS CSV in background without switching user's visible tab."""
    # Get credentials from request (GUI fields)
    data = request.get_json() or {}
    gui_username = data.get('mis_username', '').strip()
    gui_password = data.get('mis_password', '').strip()
    
    def pull_operation(driver):
        """Inner function for background execution."""
        return pull_mis_csv_report_background(driver)
    
    # Pass credentials to background executor
    result = execute_in_background('mis', pull_operation, gui_username=gui_username, gui_password=gui_password)
    
    if result['success']:
        success, path, filename = result['result']
        if success:
            # Store the filepath globally
            GLOBAL_DATA['mis']['mis_csv_filepath'] = path
            GLOBAL_DATA['mis']['mis_csv_filename'] = filename
            print(f"[CSV-PULL] Stored in GLOBAL_DATA: {filename}")
            return jsonify({'success': True, 'path': path, 'filename': filename})
        else:
            return jsonify({'success': False, 'error': path})  # path contains error message
    else:
        return jsonify({'success': False, 'error': result['error']})

@app.route('/api/debug/token-test', methods=['GET'])
def api_debug_token_test():
    """
    DIAGNOSTIC ROUTE: Tests current token against all Blaze endpoints.
    Access: http://127.0.0.1:5100/api/debug/token-test
    """
    try:
        # 1. Load current token
        token = GLOBAL_DATA['blaze'].get('token') or load_stored_token()
        
        if not token:
            return jsonify({
                'error': 'No token available',
                'action': 'Please login to Blaze first'
            })
        
        # Handle both dict and string formats
        if isinstance(token, dict):
            test_token = token.get('promo_token') or token.get('group_token') or ''
        else:
            test_token = str(token)
        
        headers = {"Authorization": f"Token {test_token}"}
        results = {}
        
        # 2. Test Shops Endpoint
        print("\n[DIAGNOSTIC] Testing Shops endpoint...")
        try:
            r = requests.get("https://api.blaze.me/api/v1/mgmt/shops?start=0&limit=5", 
                           headers=headers, timeout=10)
            results['shops'] = {
                'status_code': r.status_code,
                'success': r.ok,
                'count': len(r.json().get('values', [])) if r.ok else 0,
                'sample': r.json().get('values', [])[:2] if r.ok else None,
                'error': r.text[:200] if not r.ok else None
            }
        except Exception as e:
            results['shops'] = {'error': str(e)}
        
        # 3. Test Collections Endpoint (CRITICAL)
        print("[DIAGNOSTIC] Testing SmartCollections endpoint...")
        try:
            r = requests.get("https://api.blaze.me/api/v1/mgmt/smartcollections?start=0&limit=5",
                           headers=headers, timeout=10)
            results['collections'] = {
                'status_code': r.status_code,
                'success': r.ok,
                'raw_response_type': type(r.json()).__name__ if r.ok else 'N/A',
                'count': len(r.json().get('values', [])) if r.ok and isinstance(r.json(), dict) else (len(r.json()) if r.ok else 0),
                'sample': (r.json().get('values', [])[:2] if isinstance(r.json(), dict) else r.json()[:2]) if r.ok else None,
                'error': r.text[:200] if not r.ok else None
            }
        except Exception as e:
            results['collections'] = {'error': str(e)}
        
        # 4. Test Promotions Endpoint
        print("[DIAGNOSTIC] Testing Promotions endpoint...")
        try:
            r = requests.get("https://api.blaze.me/api/v1/mgmt/company/promotions?start=0&limit=5",
                           headers=headers, timeout=10)
            results['promotions'] = {
                'status_code': r.status_code,
                'success': r.ok,
                'count': len(r.json().get('values', [])) if r.ok else 0,
                'sample': r.json().get('values', [])[:1] if r.ok else None,
                'error': r.text[:200] if not r.ok else None
            }
        except Exception as e:
            results['promotions'] = {'error': str(e)}
        
        # 5. Summary
        summary = {
            'token_preview': test_token[:15] + '...' if test_token else 'MISSING',
            'shops_working': results.get('shops', {}).get('success', False),
            'collections_working': results.get('collections', {}).get('success', False),
            'promotions_working': results.get('promotions', {}).get('success', False)
        }
        
        print("\n[DIAGNOSTIC] Results:")
        print(f"  Shops: {'[OK]' if summary['shops_working'] else '[ERROR]'}")
        print(f"  Collections: {'[OK]' if summary['collections_working'] else '[ERROR]'}")
        print(f"  Promotions: {'[OK]' if summary['promotions_working'] else '[ERROR]'}")
        
        return jsonify({
            'summary': summary,
            'detailed_results': results,
            'diagnosis': diagnose_issue(summary, results)
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'error': str(e)})

def diagnose_issue(summary, results):
    """Analyzes test results and provides diagnosis."""
    diagnosis = []
    
    if not summary['collections_working']:
        coll_result = results.get('collections', {})
        status = coll_result.get('status_code')
        
        if status == 401:
            diagnosis.append(" DIAGNOSIS: Token lacks permissions for SmartCollections endpoint")
            diagnosis.append("   Solution: Need to capture token from a page that loads collections")
        elif status == 403:
            diagnosis.append(" DIAGNOSIS: Token is valid but forbidden from accessing collections")
            diagnosis.append("   Solution: User account may need elevated permissions")
        elif status == 404:
            diagnosis.append(" DIAGNOSIS: Collections endpoint may have moved")
            diagnosis.append("   Solution: Check Blaze API documentation for endpoint changes")
        else:
            diagnosis.append(f" DIAGNOSIS: Collections API returned {status}")
            diagnosis.append(f"   Error: {coll_result.get('error', 'Unknown')}")
    else:
        count = results.get('collections', {}).get('count', 0)
        if count == 0:
            diagnosis.append("[!] [EMOJI][EMOJI][EMOJI][EMOJI] Collections endpoint works but returns 0 items")
            diagnosis.append("   Check: Are there actually Smart Collections in Blaze admin?")
        else:
            diagnosis.append(f"[SUCCESS] Collections working correctly ({count} items found)")
    
    if summary['shops_working'] and summary['promotions_working'] and not summary['collections_working']:
        diagnosis.append("\n PATTERN: Promotions & Shops work, but Collections fail")
        diagnosis.append("   This suggests the token has LIMITED scope")
    
    return diagnosis

@app.route('/api/mis/match', methods=['POST'])
def api_mis_match():
    """Match Google Sheet rows to MIS IDs with brand list AND Settings tab support."""
    try:
        tab_name = request.form.get('tab')
        csv_file = request.files.get('csv')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab'})
        
        # --- NEW: Check both uploaded file AND pulled CSV ---
        mis_df = None
        
        if csv_file:
            # User uploaded a CSV file
            print("[MATCHER] Using uploaded CSV file")
            mis_df = pd.read_csv(csv_file)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            # Use the pulled CSV from disk
            pulled_csv_path = GLOBAL_DATA['mis']['mis_csv_filepath']
            print(f"[MATCHER] Using pulled CSV: {GLOBAL_DATA['mis'].get('mis_csv_filename')}")
            
            if Path(pulled_csv_path).exists():
                mis_df = pd.read_csv(pulled_csv_path)
            else:
                return jsonify({'success': False, 'error': f'Pulled CSV not found: {pulled_csv_path}'})
        else:
            return jsonify({'success': False, 'error': 'No CSV available. Please pull CSV or upload manually.'})
        
        GLOBAL_DATA['mis']['mis_df'] = mis_df
        
        # --- NEW: Update Brand List ---
        brand_list = manage_brand_list(mis_df)
        
        # Fetch Google Sheet data (Returns Dictionary of DataFrames)
        sections_data = fetch_google_sheet_data(tab_name)
        
        # v12.12.5: Combine all sections into single DataFrame for MIS lookup validation
        # v12.12.12: Add _section column to track which section each row came from
        weekly_df = sections_data.get('weekly', pd.DataFrame()).copy()
        monthly_df = sections_data.get('monthly', pd.DataFrame()).copy()
        sale_df = sections_data.get('sale', pd.DataFrame()).copy()
        
        if not weekly_df.empty:
            weekly_df['_section'] = 'weekly'
        if not monthly_df.empty:
            monthly_df['_section'] = 'monthly'
        if not sale_df.empty:
            sale_df['_section'] = 'sale'
        
        combined_df = pd.concat([weekly_df, monthly_df, sale_df], ignore_index=True)
        
        # Also store sections_data for direct access
        GLOBAL_DATA['sections_data'] = sections_data
        
        # v12.12.5: AGGRESSIVE DEBUG
        print(f"\n{'[EMOJI]'*30}")
        print(f"[MATCHER] [EMOJI] STORING COMBINED DATAFRAME [EMOJI]")
        print(f"[MATCHER] Combined DataFrame shape: {combined_df.shape}")
        print(f"[MATCHER] Weekly rows: {len(sections_data.get('weekly', pd.DataFrame()))}")
        print(f"[MATCHER] Monthly rows: {len(sections_data.get('monthly', pd.DataFrame()))}")
        print(f"[MATCHER] Sale rows: {len(sections_data.get('sale', pd.DataFrame()))}")
        GLOBAL_DATA['google_df'] = combined_df  # Store for MIS lookup's SMART FALLBACK
        print(f"[MATCHER] [EMOJI] Stored in GLOBAL_DATA['google_df']")
        print(f"[MATCHER] Verification: GLOBAL_DATA['google_df'] is None? {GLOBAL_DATA.get('google_df') is None}")
        print(f"{'[EMOJI]'*30}\n")
        
        # Check if all empty
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found in any section'})
        
        # --- NEW: Load brand settings from Settings tab ---
        print("[MATCHER] Loading brand settings from Settings tab...")
        # We must pass the spreadsheet_id currently stored in GLOBAL_DATA
        brand_settings = load_brand_settings(GLOBAL_DATA['mis']['spreadsheet_id'])
        if brand_settings:
            print(f"[MATCHER] Loaded {len(brand_settings)} brand relationship rules.")
            # v12.17: Store in GLOBAL_DATA for validation functions to use
            GLOBAL_DATA['brand_settings'] = brand_settings
        else:
            print("[MATCHER] No brand settings found or Settings tab not available.")
            brand_settings = {}
            GLOBAL_DATA['brand_settings'] = {}
        
        # Run matching for each section
        all_matches = {}
        for section in ['weekly', 'monthly', 'sale']:
            df = sections_data.get(section, pd.DataFrame())
            if not df.empty:
                # PASS section_type HERE
                matches = enhanced_match_mis_ids(df, mis_df, brand_list, brand_settings, section_type=section)
                all_matches[section] = matches
                print(f"[MATCHER] Section {section}: {len(matches)} matches generated")
            else:
                all_matches[section] = []
                print(f"[MATCHER] Section {section}: DataFrame is empty")
                
        GLOBAL_DATA['mis']['match_results'] = all_matches
        
        print(f"[MATCHER] Final response: weekly={len(all_matches.get('weekly', []))}, monthly={len(all_matches.get('monthly', []))}, sale={len(all_matches.get('sale', []))}")
        return jsonify({'success': True, 'matches': all_matches})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/apply-matches', methods=['POST'])
def api_mis_apply_matches():
    """
    Apply MIS ID matches from ID MATCHER tab.
    v10.9: Uses section-aware tags (W1, M1, S1) based on deal type.
    """
    try:
        data = request.get_json()
        matches = data.get('matches', {})
        if not matches:
            return jsonify({'success': False, 'error': 'No matches'})
        service = GLOBAL_DATA['sheets_service']
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        sheet_name = GLOBAL_DATA['mis']['current_sheet']
        if not service or not spreadsheet_id or not sheet_name:
            return jsonify({'success': False, 'error': 'Not configured'})
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{sheet_name}'!A1:BZ20"
        ).execute()
        values = result.get('values', [])
        if not values:
            return jsonify({'success': False, 'error': 'Sheet empty'})
        header_row_idx = detect_header_row(values)
        headers = values[header_row_idx]
        mis_id_col = None
        for idx, header in enumerate(headers):
            if 'MIS ID' in str(header) or header == 'ID':
                mis_id_col = idx
                break
        if mis_id_col is None:
            return jsonify({'success': False, 'error': 'MIS ID column not found'})
        
        def get_col_letter(n):
            string = ""
            while n >= 0:
                string = chr((n % 26) + 65) + string
                n = (n // 26) - 1
            return string
        
        target_col_letter = get_col_letter(mis_id_col)
        
        # First, read all current values for the rows we're updating
        row_numbers = [int(r) for r in matches.keys()]
        current_values = {}
        
        # Batch read current values
        ranges = [f"'{sheet_name}'!{target_col_letter}{row}" for row in row_numbers]
        if ranges:
            try:
                batch_result = service.spreadsheets().values().batchGet(
                    spreadsheetId=spreadsheet_id,
                    ranges=ranges
                ).execute()
                
                value_ranges = batch_result.get('valueRanges', [])
                for i, vr in enumerate(value_ranges):
                    vals = vr.get('values', [[]])
                    current_values[row_numbers[i]] = vals[0][0] if vals and vals[0] else ''
            except Exception as e:
                print(f"[APPLY-MATCHES] Warning: Could not batch read: {e}")
        
        # Build updates with section-aware tags
        updates = []
        for google_row, match_data in matches.items():
            sheet_row = int(google_row)
            
            # v12.1: Handle new format with mis_ids array (multi-brand) or legacy formats
            if isinstance(match_data, dict):
                # Check for multi-brand format (mis_ids array)
                if 'mis_ids' in match_data and isinstance(match_data['mis_ids'], list):
                    mis_ids = match_data['mis_ids']
                    is_multi_brand = match_data.get('is_multi_brand', False)
                elif 'mis_id' in match_data:
                    mis_ids = [str(match_data.get('mis_id', '')).strip()]
                    is_multi_brand = False
                else:
                    mis_ids = []
                    is_multi_brand = False
                section = match_data.get('section', 'weekly').lower()
            else:
                # Legacy format: just the MIS ID string
                mis_ids = [str(match_data).strip()]
                section = 'weekly'
                is_multi_brand = False
            
            # Determine tag based on section
            if section == 'monthly':
                tag = 'm1'
                tag_display = 'M1'
            elif section == 'sale':
                tag = 's1'
                tag_display = 'S1'
            else:
                tag = 'w1'
                tag_display = 'W1'
            
            # Get existing content
            existing = current_values.get(sheet_row, '')
            
            # v12.1: For multi-brand, apply each MIS ID sequentially with the same tag
            new_value = existing
            first_id = True  # Track if this is the first ID being added
            for mis_id in mis_ids:
                mis_id = str(mis_id).strip()
                if not mis_id:
                    continue
                    
                if new_value:
                    # Use update function to merge with existing content
                    # v12.1: Use append_mode for multi-brand after first ID
                    append_mode = is_multi_brand and not first_id
                    new_value = update_tagged_mis_cell(new_value, tag, mis_id, append_mode=append_mode)
                else:
                    # No existing content - create new entry with section-based tag
                    new_value = f"{tag_display}: {mis_id}"
                first_id = False
            
            if new_value != existing:  # Only add update if value changed
                updates.append({
                    'range': f"'{sheet_name}'!{target_col_letter}{sheet_row}",
                    'values': [[new_value]]
                })
                
                if is_multi_brand:
                    print(f"[APPLY-MATCHES] Row {sheet_row}: Multi-brand {len(mis_ids)} IDs: {mis_ids} (section: {section})")
                else:
                    print(f"[APPLY-MATCHES] Row {sheet_row}: {tag_display}: {mis_ids[0] if mis_ids else 'N/A'} (section: {section})")
        
        body = {
            'valueInputOption': 'RAW',
            'data': updates
        }
        service.spreadsheets().values().batchUpdate(
            spreadsheetId=spreadsheet_id,
            body=body
        ).execute()
        
        return jsonify({'success': True, 'updated': len(updates)})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# v12.5: New endpoint to apply Blaze Discount Titles to Google Sheet
@app.route('/api/mis/apply-blaze-titles', methods=['POST'])
def api_mis_apply_blaze_titles():
    """
    Apply Blaze Discount Titles from ID MATCHER tab to Google Sheet.
    Writes to the "Blaze Discount Title" column (typically column 28/AC).
    
    v12.5: Writes newline-separated titles to preserve order.
    """
    try:
        data = request.get_json()
        matches = data.get('matches', {})
        if not matches:
            return jsonify({'success': False, 'error': 'No matches'})
        
        service = GLOBAL_DATA['sheets_service']
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        sheet_name = GLOBAL_DATA['mis']['current_sheet']
        
        if not service or not spreadsheet_id or not sheet_name:
            return jsonify({'success': False, 'error': 'Not configured'})
        
        # Get headers to find Blaze Discount Title column
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{sheet_name}'!A1:BZ20"
        ).execute()
        values = result.get('values', [])
        if not values:
            return jsonify({'success': False, 'error': 'Sheet empty'})
        
        header_row_idx = detect_header_row(values)
        headers = values[header_row_idx]
        
        # Find "Blaze Discount Title" column
        blaze_col = None
        for idx, header in enumerate(headers):
            header_clean = str(header).strip().lower()
            if 'blaze' in header_clean and ('discount' in header_clean or 'title' in header_clean):
                blaze_col = idx
                break
        
        if blaze_col is None:
            # Try exact match
            for idx, header in enumerate(headers):
                if str(header).strip() == 'Blaze Discount Title':
                    blaze_col = idx
                    break
        
        if blaze_col is None:
            return jsonify({'success': False, 'error': 'Blaze Discount Title column not found in headers'})
        
        def get_col_letter(n):
            string = ""
            while n >= 0:
                string = chr((n % 26) + 65) + string
                n = (n // 26) - 1
            return string
        
        target_col_letter = get_col_letter(blaze_col)
        print(f"[APPLY-BLAZE] Found Blaze Discount Title at column {target_col_letter} (index {blaze_col})")
        
        # Build updates
        updates = []
        for google_row, match_data in matches.items():
            sheet_row = int(google_row)
            
            # Get blaze_titles from match_data
            blaze_titles = []
            not_found_titles = []  # v12.7: Track which titles don't exist in Blaze
            if isinstance(match_data, dict):
                blaze_titles = match_data.get('blaze_titles', [])
                not_found_titles = match_data.get('blaze_titles_not_found', [])  # v12.7
            
            if not blaze_titles:
                continue  # Skip rows with no Blaze titles selected
            
            # v12.7: Append "(NOTE: Needs to be created)" for not-found titles
            formatted_titles = []
            for title in blaze_titles:
                if title in not_found_titles:
                    formatted_titles.append(f"{title} (NOTE: Needs to be created)")
                else:
                    formatted_titles.append(title)
            
            # Join titles with newlines (preserving order from queue)
            new_value = '\n'.join(formatted_titles)
            
            # TODO (Future Enhancement): Use Google Sheets API's textFormat to make
            # only the "(NOTE: Needs to be created)" text red, not the entire title.
            # This requires spreadsheets.batchUpdate with textFormatRuns instead of values().update()
            
            updates.append({
                'range': f"'{sheet_name}'!{target_col_letter}{sheet_row}",
                'values': [[new_value]]
            })
            
            print(f"[APPLY-BLAZE] Row {sheet_row}: {len(blaze_titles)} titles")
        
        if not updates:
            return jsonify({'success': True, 'updated': 0, 'message': 'No Blaze titles to apply'})
        
        body = {
            'valueInputOption': 'RAW',
            'data': updates
        }
        service.spreadsheets().values().batchUpdate(
            spreadsheetId=spreadsheet_id,
            body=body
        ).execute()
        
        print(f"[APPLY-BLAZE] Successfully updated {len(updates)} rows")
        return jsonify({'success': True, 'updated': len(updates)})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# v88: New endpoint to apply split MIS ID (with append logic)
@app.route('/api/mis/apply-split-id', methods=['POST'])
def api_mis_apply_split_id():
    """
    Apply a MIS ID to a specific Google Sheet row using tagged format.
    
    v10.9: Uses section-based tags (W1/W2/WP, M1/M2/MP, S1/S2/SP)
    
    Parameters:
        google_row: Row number in Google Sheet
        new_mis_id: The MIS ID to apply (just the number, no tag)
        tag: The tag type ('w1', 'w2', 'wp', 'm1', 'm2', 'mp', 's1', 's2', 'sp')
             Also accepts legacy: 'part1', 'part2', 'gap', 'patch'
        section: Optional - 'weekly', 'monthly', or 'sale' (used with legacy tags)
        append: If True, merge with existing content; if False, replace
    
    New format uses newline-separated tagged entries:
        W1: 12345
        WP: 67890
        W2: 54321
    """
    try:
        data = request.get_json()
        google_row = data.get('google_row')
        new_mis_id = str(data.get('new_mis_id', '')).strip()
        tag = data.get('tag', 'w1').lower()  # v10.9: Default to w1
        section = data.get('section', 'weekly').lower()  # v10.9: Section for tag conversion
        append = data.get('append', True)
        
        # Strip any existing tag from the MIS ID (in case it was passed with a tag)
        new_mis_id = strip_mis_id_tag(new_mis_id)
        
        if not google_row or not new_mis_id:
            return jsonify({'success': False, 'error': 'Missing google_row or new_mis_id'})
        
        if not new_mis_id.isdigit():
            return jsonify({'success': False, 'error': f'Invalid MIS ID format: {new_mis_id}'})
        
        service = GLOBAL_DATA['sheets_service']
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        sheet_name = GLOBAL_DATA['mis']['current_sheet']
        
        if not service or not spreadsheet_id or not sheet_name:
            return jsonify({'success': False, 'error': 'Not configured. Please open a Google Sheet tab first.'})
        
        # Get headers to find MIS ID column
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{sheet_name}'!A1:BZ20"
        ).execute()
        values = result.get('values', [])
        if not values:
            return jsonify({'success': False, 'error': 'Sheet empty'})
        
        header_row_idx = detect_header_row(values)
        headers = values[header_row_idx]
        
        mis_id_col = None
        for idx, header in enumerate(headers):
            if 'MIS ID' in str(header) or header == 'ID':
                mis_id_col = idx
                break
        
        if mis_id_col is None:
            return jsonify({'success': False, 'error': 'MIS ID column not found in headers'})
        
        def get_col_letter(n):
            string = ""
            while n >= 0:
                string = chr((n % 26) + 65) + string
                n = (n // 26) - 1
            return string
        
        target_col_letter = get_col_letter(mis_id_col)
        cell_range = f"'{sheet_name}'!{target_col_letter}{google_row}"
        
        # Get current value
        current_value = ''
        try:
            current_result = service.spreadsheets().values().get(
                spreadsheetId=spreadsheet_id,
                range=cell_range
            ).execute()
            current_values = current_result.get('values', [[]])
            current_value = current_values[0][0] if current_values and current_values[0] else ''
            current_value = str(current_value).strip()
        except Exception as e:
            print(f"[SPLIT-ID] Warning: Could not read current value: {e}")
        
        # v10.9: Convert legacy tags to section-based tags
        section_prefix = 'W' if section == 'weekly' else ('M' if section == 'monthly' else 'S')
        
        # Map legacy tags to new format
        tag_mapping = {
            'part1': f'{section_prefix.lower()}1',
            'part2': f'{section_prefix.lower()}2',
            'part3': f'{section_prefix.lower()}3',
            'gap': f'{section_prefix.lower()}1',  # GAP uses interrupting section's tag
            'patch': f'{section_prefix.lower()}p',
        }
        
        # Convert legacy tag if needed
        if tag in tag_mapping:
            tag = tag_mapping[tag]
        
        # Build final value using tagged format
        if append and current_value:
            # Merge with existing content
            final_value = update_tagged_mis_cell(current_value, tag, new_mis_id)
        else:
            # Create new tagged entry with section-based format
            tag_upper = tag.upper()
            final_value = f"{tag_upper}: {new_mis_id}"
        
        # Write the value
        body = {
            'values': [[final_value]]
        }
        service.spreadsheets().values().update(
            spreadsheetId=spreadsheet_id,
            range=cell_range,
            valueInputOption='RAW',
            body=body
        ).execute()
        
        print(f"[SPLIT-ID] Applied {tag.upper()}: {new_mis_id} to row {google_row} (section: {section})")
        print(f"[SPLIT-ID] Final cell value:\n{final_value}")
        
        return jsonify({
            'success': True,
            'google_row': google_row,
            'tag': tag,
            'mis_id': new_mis_id,
            'new_value': final_value,
            'appended': append and current_value != ''
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# ============================================================================
# v12.1: MAudit - Google Sheet vs MIS CSV Verification
# ============================================================================
@app.route('/api/mis/maudit', methods=['POST'])
def api_mis_maudit():
    """
    v12.1: MAudit - Verify Google Sheet deals against MIS CSV data.
    Compares: Discount, Vendor %, Start/End Dates, Brand, Locations
    Groups results by verification status.
    """
    try:
        tab_name = request.form.get('tab')
        csv_file = request.files.get('csv')
        local_csv_path = request.form.get('local_csv_path')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab selected'})
        
        # Load MIS CSV
        mis_df = None
        if csv_file:
            print("[MAUDIT] Using uploaded CSV file")
            mis_df = pd.read_csv(csv_file)
        elif local_csv_path and Path(local_csv_path).exists():
            print(f"[MAUDIT] Using local CSV: {local_csv_path}")
            mis_df = pd.read_csv(local_csv_path)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            pulled_csv_path = GLOBAL_DATA['mis']['mis_csv_filepath']
            print(f"[MAUDIT] Using pulled CSV: {GLOBAL_DATA['mis'].get('mis_csv_filename')}")
            if Path(pulled_csv_path).exists():
                mis_df = pd.read_csv(pulled_csv_path)
            else:
                return jsonify({'success': False, 'error': f'Pulled CSV not found: {pulled_csv_path}'})
        else:
            return jsonify({'success': False, 'error': 'No CSV available. Please pull CSV or upload manually.'})
        
        # Fetch Google Sheet data
        sections_data = fetch_google_sheet_data(tab_name)
        
        results = {
            'verified': [],
            'mismatches': [],
            'not_found': [],
            'missing_id': []
        }
        
        # Find ID column in CSV
        id_col = None
        for col in ['ID', 'id', 'MIS ID', 'Mis Id']:
            if col in mis_df.columns:
                id_col = col
                break
        
        if not id_col:
            return jsonify({'success': False, 'error': 'Cannot find ID column in CSV'})
        
        # Process each section
        for section_name in ['weekly', 'monthly', 'sale']:
            df = sections_data.get(section_name, pd.DataFrame())
            if df.empty:
                continue
            
            for idx, row in df.iterrows():
                row_num = idx + 2  # Account for header row
                brand = str(row.get('Brand', '')).strip()
                mis_id_cell = str(row.get('MIS ID', '')).strip()
                discount = str(row.get('Discount', '')).strip()
                vendor_pct = str(row.get('Vendor %', row.get('Vendor', ''))).strip()
                locations = str(row.get('Location', row.get('Locations', ''))).strip()
                weekday = str(row.get('Weekday', '')).strip() if section_name == 'weekly' else ''
                start_date = str(row.get('Start Date', '')).strip() if section_name != 'weekly' else ''
                end_date = str(row.get('End Date', '')).strip() if section_name != 'weekly' else ''
                
                # Skip empty rows
                if not brand or brand in ['nan', 'None', '-', '']:
                    continue
                
                # Check if MIS ID exists
                if not mis_id_cell or mis_id_cell in ['nan', 'None', '-', '']:
                    results['missing_id'].append({
                        'row': row_num,
                        'section': section_name,
                        'brand': brand,
                        'weekday': weekday,
                        'start_date': start_date,
                        'discount': discount,
                        'locations': locations
                    })
                    continue
                
                # Parse MIS ID (get first part for now)
                parsed = parse_mis_id_cell(mis_id_cell, section_name)
                first_mis_id = None
                section_key = section_name
                if parsed.get(section_key) and parsed[section_key].get('parts'):
                    first_mis_id = parsed[section_key]['parts'][0]
                elif parsed.get('parts'):
                    first_mis_id = parsed['parts'][0] if parsed['parts'] else None
                
                if not first_mis_id:
                    # Try to extract any numeric ID
                    import re
                    ids = re.findall(r'\d{5,7}', mis_id_cell)
                    if ids:
                        first_mis_id = ids[0]
                
                if not first_mis_id:
                    results['missing_id'].append({
                        'row': row_num,
                        'section': section_name,
                        'brand': brand,
                        'weekday': weekday,
                        'start_date': start_date,
                        'discount': discount,
                        'locations': locations,
                        'note': 'Could not parse MIS ID'
                    })
                    continue
                
                # Look up in CSV
                csv_matches = mis_df[mis_df[id_col].astype(str).str.strip() == str(first_mis_id).strip()]
                
                if csv_matches.empty:
                    results['not_found'].append({
                        'row': row_num,
                        'section': section_name,
                        'brand': brand,
                        'mis_id': first_mis_id,
                        'weekday': weekday,
                        'start_date': start_date,
                        'discount': discount
                    })
                    continue
                
                # Compare fields
                csv_row = csv_matches.iloc[0]
                issues = []
                matches = 0
                total_fields = 0
                
                # Compare Brand (fuzzy)
                csv_brand = str(csv_row.get('Brand', '')).strip()
                total_fields += 1
                if fuzz.token_set_ratio(brand.lower(), csv_brand.lower()) >= 80:
                    matches += 1
                else:
                    issues.append(f"Brand: '{brand}' vs '{csv_brand}'")
                
                # Compare Discount
                csv_discount = str(csv_row.get('Discount', '')).strip()
                total_fields += 1
                if discount.replace('%', '').strip() == csv_discount.replace('%', '').strip():
                    matches += 1
                else:
                    issues.append(f"Discount: '{discount}' vs '{csv_discount}'")
                
                # Compare Vendor %
                csv_vendor = str(csv_row.get('Vendor %', csv_row.get('Vendor', ''))).strip()
                total_fields += 1
                if vendor_pct.replace('%', '').strip() == csv_vendor.replace('%', '').strip():
                    matches += 1
                else:
                    issues.append(f"Vendor: '{vendor_pct}' vs '{csv_vendor}'")
                
                # For weekly, compare weekday; for others compare dates
                if section_name == 'weekly':
                    csv_weekday = str(csv_row.get('Weekday', '')).strip()
                    total_fields += 1
                    if weekday.lower() == csv_weekday.lower():
                        matches += 1
                    else:
                        issues.append(f"Weekday: '{weekday}' vs '{csv_weekday}'")
                else:
                    # Compare dates
                    csv_start = str(csv_row.get('Start Date', '')).strip()
                    csv_end = str(csv_row.get('End Date', '')).strip()
                    total_fields += 2
                    if start_date == csv_start:
                        matches += 1
                    else:
                        issues.append(f"Start: '{start_date}' vs '{csv_start}'")
                    if end_date == csv_end:
                        matches += 1
                    else:
                        issues.append(f"End: '{end_date}' vs '{csv_end}'")
                
                match_percent = int((matches / total_fields) * 100) if total_fields > 0 else 0
                
                result_item = {
                    'row': row_num,
                    'section': section_name,
                    'brand': brand,
                    'mis_id': first_mis_id,
                    'weekday': weekday,
                    'start_date': start_date,
                    'discount': discount,
                    'match_percent': match_percent,
                    'issues': issues
                }
                
                if match_percent == 100:
                    results['verified'].append(result_item)
                else:
                    results['mismatches'].append(result_item)
        
        return jsonify({'success': True, 'results': results})
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/mis/cleanup-audit', methods=['POST'])
def api_mis_cleanup_audit():
    """
    Cleanup Audit: Find active MIS entries that should be turned off.
    
    Two detection methods:
    1. Full Field Match: Brand + Weekday + Discount + Vendor% + Locations don't match any Google Sheet row
    2. MIS ID Only: MIS ID doesn't appear anywhere in Google Sheet's MIS ID column
    """
    try:
        tab_name = request.form.get('tab')
        csv_file = request.files.get('csv')
        local_csv_path = request.form.get('local_csv_path')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab selected'})
        
        # Load MIS CSV
        mis_df = None
        if csv_file:
            mis_df = pd.read_csv(csv_file)
        elif local_csv_path and Path(local_csv_path).exists():
            mis_df = pd.read_csv(local_csv_path)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            pulled_csv_path = GLOBAL_DATA['mis']['mis_csv_filepath']
            if Path(pulled_csv_path).exists():
                mis_df = pd.read_csv(pulled_csv_path)
        
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'No MIS CSV available'})
        
        # Fetch Google Sheet data
        sections_data = fetch_google_sheet_data(tab_name)
        
        # Get today's date for "active" check
        from datetime import datetime
        today = datetime.now().date()
        
        # Helper: Parse date string
        def parse_date(date_str):
            if not date_str or str(date_str).lower() in ['', 'nan', 'none', 'nat']:
                return None
            date_str = str(date_str).strip()
            for fmt in ['%m/%d/%Y', '%Y-%m-%d', '%m/%d/%y', '%m-%d-%Y']:
                try:
                    return datetime.strptime(date_str, fmt).date()
                except:
                    continue
            return None
        
        # Helper: Check if MIS entry is "active"
        def is_active(row):
            end_date = parse_date(row.get('End date', ''))
            if end_date is None:
                return True  # No end date = still active
            return end_date >= today
        
        # Helper: Determine section from weekday
        def get_section_from_weekday(weekday_str):
            if not weekday_str or str(weekday_str).lower() in ['', 'nan', 'none']:
                return 'sale'  # No weekday typically means sale/monthly
            weekday_lower = str(weekday_str).lower()
            # Check if it looks like day-of-month numbers
            if any(c.isdigit() for c in weekday_lower):
                if '-' in weekday_lower or '/' in weekday_lower:
                    return 'monthly'  # Date range pattern
            # Check for weekday names
            weekdays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
            if any(day in weekday_lower for day in weekdays):
                return 'weekly'
            return 'monthly'  # Default for non-weekday patterns
        
        # Helper: Normalize location set for comparison
        def normalize_location_set(loc_str):
            if not loc_str or loc_str.lower() in ['all locations', 'all', '-']:
                return frozenset(['all'])
            locs = [l.strip().lower() for l in loc_str.replace('\n', ',').split(',') if l.strip()]
            return frozenset(locs)
        
        # Collect all Google Sheet MIS IDs
        all_sheet_mis_ids = set()
        sheet_entries = []  # For full field matching
        
        for section_name, df in sections_data.items():
            if df is None or df.empty:
                continue
            for _, row in df.iterrows():
                # Get MIS ID column
                mis_id_cell = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                
                # Parse all MIS IDs from the cell
                parsed = parse_mis_id_cell(mis_id_cell)
                for tag, mid in parsed.get('all_tagged', []):
                    all_sheet_mis_ids.add(str(mid).strip())
                for mid in parsed.get('untagged', []):
                    all_sheet_mis_ids.add(str(mid).strip())
                
                # Collect entry data for full field matching
                brand = str(row.get('Brand', '')).strip()
                # v12.22.4: Weekly uses Column A ('Weekday'), Monthly/Sale use Column K ('Weekday/ Day of Month')
                if section_name == 'weekly':
                    weekday = str(get_col(row, ['Weekday', 'Day of Week'], '')).strip()
                else:
                    weekday = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                discount = parse_percentage(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], ''))
                vendor_pct = parse_percentage(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = normalize_location_set(format_location_display(loc_raw, exc_raw))
                
                if brand:
                    # Handle multi-brand
                    individual_brands = parse_multi_brand(brand)
                    for b in individual_brands:
                        sheet_entries.append({
                            'section': section_name,
                            'brand': b.lower().strip(),
                            'weekday': weekday.lower(),
                            'discount': discount,
                            'vendor_pct': vendor_pct,
                            'locations': locations
                        })
        
        # Results containers
        full_match_issues = []
        id_only_issues = []
        
        # Get ID column from MIS CSV
        id_col = None
        for col in ['ID', 'id', 'MIS ID', 'Mis Id']:
            if col in mis_df.columns:
                id_col = col
                break
        
        if not id_col:
            return jsonify({'success': False, 'error': 'MIS CSV missing ID column'})
        
        # Scan MIS CSV for stale entries
        for _, mis_row in mis_df.iterrows():
            # Skip inactive entries
            if not is_active(mis_row):
                continue
            
            mis_id = str(mis_row.get(id_col, '')).strip()
            if mis_id.endswith('.0'):
                mis_id = mis_id[:-2]
            
            if not mis_id or mis_id.lower() in ['', 'nan', 'none']:
                continue
            
            # Get MIS entry data
            mis_brand = str(mis_row.get('Brand', '')).strip()
            mis_weekday = str(mis_row.get('Weekday', '')).strip()
            mis_discount = float(mis_row.get('Daily Deal Discount', 0) or 0)
            mis_vendor = float(mis_row.get('Discount paid by vendor', 0) or 0)
            mis_store = str(mis_row.get('Store', '')).strip()
            mis_locs = normalize_location_set(mis_store if mis_store else 'All Locations')
            mis_start = str(mis_row.get('Start date', '')).strip()
            mis_end = str(mis_row.get('End date', '')).strip()
            
            section = get_section_from_weekday(mis_weekday)
            
            # Build result entry
            result_entry = {
                'mis_id': mis_id,
                'brand': mis_brand,
                'weekday': mis_weekday,
                'discount': mis_discount,
                'vendor_pct': mis_vendor,
                'locations': mis_store if mis_store else 'All Locations',
                'start_date': mis_start,
                'end_date': mis_end,
                'section': section
            }
            
            # Method 1: Full Field Match
            found_full_match = False
            partial_match_details = []
            
            for entry in sheet_entries:
                # Check brand (strict match)
                brand_match = entry['brand'] == mis_brand.lower().strip()
                
                if not brand_match:
                    continue
                
                # Found brand match - check other fields
                weekday_match = True
                if section == 'weekly':
                    # For weekly, compare weekdays
                    mis_weekday_lower = mis_weekday.lower()
                    entry_weekday_lower = entry['weekday'].lower()
                    # Normalize weekday comparison
                    mis_days = set(d.strip()[:3] for d in mis_weekday_lower.replace(',', ' ').split() if d.strip())
                    entry_days = set(d.strip()[:3] for d in entry_weekday_lower.replace(',', ' ').split() if d.strip())
                    weekday_match = mis_days == entry_days or not mis_days or not entry_days
                
                discount_match = abs(entry['discount'] - mis_discount) < 0.01
                vendor_match = abs(entry['vendor_pct'] - mis_vendor) < 0.01
                loc_match = entry['locations'] == mis_locs or 'all' in entry['locations'] or 'all' in mis_locs
                
                if weekday_match and discount_match and vendor_match and loc_match:
                    found_full_match = True
                    break
                else:
                    # Partial match - collect details
                    diffs = []
                    if not weekday_match:
                        diffs.append('Weekday')
                    if not discount_match:
                        diffs.append('Discount')
                    if not vendor_match:
                        diffs.append('Vendor%')
                    if not loc_match:
                        diffs.append('Locations')
                    if diffs:
                        partial_match_details.append(', '.join(diffs))
            
            if not found_full_match:
                result_entry_full = result_entry.copy()
                if partial_match_details:
                    result_entry_full['status'] = 'PARTIAL_MATCH'
                    result_entry_full['partial_match_details'] = 'Diff: ' + partial_match_details[0]
                else:
                    result_entry_full['status'] = 'NOT_IN_SHEET'
                full_match_issues.append(result_entry_full)
            
            # Method 2: MIS ID Only
            if mis_id not in all_sheet_mis_ids:
                result_entry_id = result_entry.copy()
                result_entry_id['status'] = 'ID_NOT_TRACKED'
                id_only_issues.append(result_entry_id)
        
        return jsonify({
            'success': True,
            'results': {
                'fullMatch': full_match_issues,
                'idOnly': id_only_issues
            }
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/mis/audit', methods=['POST'])
def api_mis_audit():
    """Run audit comparison."""
    try:
        tab_name = request.form.get('tab')
        csv_file = request.files.get('csv')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab'})
        
        # --- NEW: Check both uploaded file AND pulled CSV ---
        mis_df = None
        
        if csv_file:
            # User uploaded a CSV file
            print("[AUDIT] Using uploaded CSV file")
            mis_df = pd.read_csv(csv_file)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            # Use the pulled CSV from disk
            pulled_csv_path = GLOBAL_DATA['mis']['mis_csv_filepath']
            print(f"[AUDIT] Using pulled CSV: {GLOBAL_DATA['mis'].get('mis_csv_filename')}")
            
            if Path(pulled_csv_path).exists():
                mis_df = pd.read_csv(pulled_csv_path)
            else:
                return jsonify({'success': False, 'error': f'Pulled CSV not found: {pulled_csv_path}'})
        else:
            return jsonify({'success': False, 'error': 'No CSV available. Please pull CSV or upload manually.'})
        
        GLOBAL_DATA['mis']['mis_df'] = mis_df
        
        # Fetch Google Sheet data (Returns Dictionary)
        sections_data = fetch_google_sheet_data(tab_name)
        
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found'})
        
        # Run audit per section
        all_results = {}
        for section in ['weekly', 'monthly', 'sale']:
            df = sections_data.get(section, pd.DataFrame())
            if not df.empty:
                # PASS section_type HERE
                results = audit_google_vs_mis(df, mis_df, section_type=section)
                all_results[section] = results
            else:
                all_results[section] = []
                all_results[section] = []
        
        return jsonify({'success': True, 'results': all_results})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

# ============================================
# v12.25.0: Comprehensive Audit State Management
# ============================================

@app.route('/api/audit/save-state', methods=['POST'])
def api_audit_save_state():
    """Save comprehensive audit state to file."""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data provided'})
        
        audit_id = data.get('audit_id', 'audit_unknown')
        tab_name = data.get('tab_name', 'Unknown')
        
        # Create filename based on tab name
        safe_tab_name = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in tab_name).strip()
        filename = f"audit_state_{safe_tab_name}.json"
        filepath = AUDIT_REPORTS_DIR / filename
        
        # Save state
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=2)
        
        print(f"[AUDIT] Saved state to {filepath}")
        return jsonify({'success': True, 'filepath': str(filepath)})
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/audit/load-state', methods=['GET'])
def api_audit_load_state():
    """Load comprehensive audit state from file."""
    try:
        tab_name = request.args.get('tab', '')
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab name provided'})
        
        # Find state file
        safe_tab_name = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in tab_name).strip()
        filename = f"audit_state_{safe_tab_name}.json"
        filepath = AUDIT_REPORTS_DIR / filename
        
        if not filepath.exists():
            return jsonify({'success': False, 'error': 'No saved state found'})
        
        with open(filepath, 'r') as f:
            state = json.load(f)
        
        print(f"[AUDIT] Loaded state from {filepath}")
        return jsonify({'success': True, 'state': state})
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/audit/export', methods=['POST'])
def api_audit_export():
    """Export audit report as CSV."""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data provided'})
        
        tab_name = data.get('tab_name', 'Unknown')
        results = data.get('results', [])
        
        # Create filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        safe_tab_name = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in tab_name).strip()
        filename = f"Audit_{safe_tab_name}_{timestamp}.csv"
        filepath = AUDIT_REPORTS_DIR / filename
        
        # Build CSV
        import csv
        with open(filepath, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['Row Number', 'Section', 'Brand(s)', 'Linked Brand', 'Weekday', 
                           'MIS ID(s)', 'Audit Status', 'Issues Found', 'Audited Date', 'Notes'])
            
            for r in results:
                writer.writerow([
                    r.get('row_number', ''),
                    r.get('section', ''),
                    r.get('brand', ''),
                    r.get('linked_brand', ''),
                    r.get('weekday', ''),
                    r.get('mis_id', ''),
                    r.get('status', 'pending'),
                    r.get('issues', ''),
                    r.get('audited_at', ''),
                    r.get('notes', '')
                ])
        
        print(f"[AUDIT] Exported report to {filepath}")
        return jsonify({'success': True, 'filepath': str(filepath), 'filename': filename})
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/review-discrepancy', methods=['POST'])
def api_mis_review_discrepancy():
    try:
        data = request.get_json()
        mis_id = data.get('mis_id', '').replace(' (Estimated)', '').strip()
        
        # Strip any tag prefixes (Part 1:, GAP:, Patch:, etc.)
        mis_id = strip_mis_id_tag(mis_id)
        
        true_row = int(data.get('google_row', 0))
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        mis_status = "MIS ID skipped"
        if mis_id and mis_id != '-':
            # INTELLIGENT MIS SESSION CHECK
            try:
                creds = load_credentials_config()
                mis_user = creds.get('mis_username', '')
                mis_pass = creds.get('mis_password', '')
                ensure_mis_ready(driver, mis_user, mis_pass)
                
                if filter_and_open_mis_id(driver, mis_id):
                    mis_status = f"Opened MIS ID {mis_id}"
                else:
                    mis_status = f"Failed to open MIS ID {mis_id}"
            except Exception as e:
                mis_status = f"MIS error: {str(e)}"
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        sheet_name = GLOBAL_DATA['mis']['current_sheet']
        sheet_status = "Sheet not configured"
        if spreadsheet_id and sheet_name:
            if open_google_sheet_in_browser(spreadsheet_id, sheet_name, true_row):
                sheet_status = f"Opened Sheet Row {true_row}"
            else:
                sheet_status = "Failed to open Sheet"
        return jsonify({'success': True, 'message': f'{sheet_status} | {mis_status}'})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/open-sheet-row', methods=['POST'])
def api_mis_open_sheet_row():
    try:
        data = request.get_json()
        row_number = int(data.get('row', 0))
        if not row_number:
            return jsonify({'success': False, 'error': 'No row specified'})
        spreadsheet_id = GLOBAL_DATA['mis'].get('spreadsheet_id')
        sheet_name = GLOBAL_DATA['mis'].get('current_sheet')
        if not spreadsheet_id or not sheet_name:
            return jsonify({'success': False, 'error': 'Sheet not configured'})
        if open_google_sheet_in_browser(spreadsheet_id, sheet_name, row_number):
            return jsonify({'success': True, 'message': f'Opened row {row_number}'})
        return jsonify({'success': False, 'error': 'Failed to open'})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/lookup-mis-id', methods=['POST'])
def api_mis_lookup_mis_id():
    try:
        # Set automation flag
        GLOBAL_DATA['automation_in_progress'] = True
        
        data = request.get_json()
        mis_id = str(data.get('mis_id', '')).strip()
        row_data = data.get('row_data', None)  # NEW: Get row data for validation
        
        if not mis_id:
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': False, 'error': 'No ID'})
        
        # Strip any tag prefixes (Part 1:, Part 2:, GAP:, Patch:, etc.)
        mis_id = strip_mis_id_tag(mis_id)
        
        if not mis_id or not mis_id.isdigit():
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': False, 'error': f'Invalid MIS ID format: {data.get("mis_id")}'})
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        # INTELLIGENT MIS SESSION CHECK - ensures tab exists and is logged in
        try:
            creds = load_credentials_config()
            mis_user = creds.get('mis_username', '')
            mis_pass = creds.get('mis_password', '')
            ensure_mis_ready(driver, mis_user, mis_pass)
        except Exception as e:
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': False, 'error': str(e)})
        
        print(f"\n{'='*60}")
        print(f"[MIS LOOKUP] Looking up MIS ID: {mis_id}")
        print(f"[MIS LOOKUP] Row data provided: {row_data is not None}")
        
        # v12.12.5: AGGRESSIVE DEBUG
        google_df = GLOBAL_DATA.get('google_df')
        if google_df is not None:
            print(f"[MIS LOOKUP] [EMOJI] Google Sheet IS LOADED [EMOJI]")
            print(f"[MIS LOOKUP] DataFrame shape: {google_df.shape}")
            print(f"[MIS LOOKUP] DataFrame columns: {list(google_df.columns)[:5]}...")
        else:
            print(f"[MIS LOOKUP] [EMOJI] GOOGLE SHEET IS NONE [EMOJI]")
            print(f"[MIS LOOKUP] GLOBAL_DATA keys: {list(GLOBAL_DATA.keys())}")
        
        print(f"{'='*60}")
        
        # SMART FALLBACK: If no row data provided, try to fetch from Google Sheet
        if not row_data:
            print(f"[MIS LOOKUP] No row data provided, searching Google Sheet...")
            try:
                # Try to get Google Sheet data from GLOBAL_DATA
                google_df = GLOBAL_DATA.get('google_df')
                if google_df is not None and not google_df.empty:
                    # Search for matching MIS ID in Google Sheet
                    # Check both 'ID' and 'MIS ID' columns
                    id_col = None
                    for col in ['MIS ID', 'ID', 'Mis Id', 'MIS_ID', 'mis_id']:
                        if col in google_df.columns:
                            id_col = col
                            break
                    
                    if id_col:
                        # Search for the MIS ID - collect ALL matching rows for multi-day detection
                        matching_rows = []
                        
                        for idx, row in google_df.iterrows():
                            sheet_mis_id = str(row.get(id_col, '')).strip()
                            # Handle multi-part IDs (W1: 123, W2: 456)
                            if mis_id in sheet_mis_id or sheet_mis_id == mis_id:
                                matching_rows.append(row)
                        
                        if matching_rows:
                            print(f"[MIS LOOKUP] [EMOJI] Found {len(matching_rows)} matching row(s) for MIS ID {mis_id}")
                            
                            # Use first row as base, but combine weekdays from all rows
                            base_row = matching_rows[0]
                            
                            # MULTI-DAY HANDLING: Combine weekdays from all matching rows
                            all_weekdays = []
                            for match_row in matching_rows:
                                weekday = str(match_row.get('Weekday', '')).strip()
                                if weekday and weekday not in all_weekdays:
                                    all_weekdays.append(weekday)
                            
                            combined_weekday = ', '.join(all_weekdays) if len(all_weekdays) > 1 else all_weekdays[0] if all_weekdays else ''
                            
                            # DEBUG: Print column names
                            print(f"[MIS LOOKUP] [EMOJI] Available columns: {list(google_df.columns)}")
                            
                            # ENHANCED COLUMN DETECTION: Search for columns CONTAINING keywords
                            # This handles newlines, extra spaces, and variations
                            
                            # Find Discount column (handles "Deal Discount Value/Type", "Discount %", etc.)
                            # IMPORTANT: Exclude "After Wholesale Discount" by requiring value/rate/% keywords
                            discount_value = ''
                            discount_col_found = None
                            for col in google_df.columns:
                                col_lower = col.lower()
                                # Look for columns with "discount" AND ("value" OR "rate" OR "%")
                                # Exclude columns with "wholesale" or "type"
                                if ('discount' in col_lower and 
                                    ('value' in col_lower or 'rate' in col_lower or '%' in col_lower) and
                                    'wholesale' not in col_lower and 
                                    'type' not in col_lower):
                                    discount_value = str(base_row.get(col, '')).strip()
                                    if discount_value:
                                        discount_col_found = col
                                        print(f"[MIS LOOKUP] [EMOJI] Found Discount in column '{col}': '{discount_value}'")
                                        break
                            
                            if not discount_col_found:
                                print(f"[MIS LOOKUP] [EMOJI] Could not find Discount column")
                            
                            # Find Vendor % column (handles "Brand Contribution % (Credit)", "Vendor %", etc.)
                            vendor_value = ''
                            vendor_col_found = None
                            for col in google_df.columns:
                                col_lower = col.lower()
                                # Look for columns containing "contribution" OR "vendor"
                                if 'contribution' in col_lower or 'vendor' in col_lower:
                                    vendor_value = str(base_row.get(col, '')).strip()
                                    if vendor_value:
                                        vendor_col_found = col
                                        print(f"[MIS LOOKUP] [EMOJI] Found Vendor % in column '{col}': '{vendor_value}'")
                                        break
                            
                            if not vendor_col_found:
                                print(f"[MIS LOOKUP] [EMOJI] Could not find Vendor % column")
                            
                            # Extract locations with "All Locations Except" handling
                            locations_raw = str(base_row.get('Locations', 'All Locations')).strip()
                            
                            # MULTI-BRAND HANDLING: Parse MIS ID position and use correct brand
                            brand_value = str(base_row.get('Brand', '')).strip()
                            
                            # Check if this is a multi-brand deal (MIS ID contains W1/W2 format)
                            sheet_mis_id = str(base_row.get(id_col, '')).strip()
                            if ',' in sheet_mis_id and ':' in sheet_mis_id:
                                # Multi-brand deal: "W1: 771, W2: 772"
                                print(f"[MIS LOOKUP] [EMOJI] Multi-brand deal detected in MIS ID: {sheet_mis_id}")
                                
                                # Parse to find which position our MIS ID is in
                                parts = [p.strip() for p in sheet_mis_id.split(',')]
                                mis_position = None
                                
                                for idx, part in enumerate(parts):
                                    # Extract just the number from "W1: 771" or "771"
                                    if ':' in part:
                                        num = part.split(':')[1].strip()
                                    else:
                                        num = part.strip()
                                    
                                    if mis_id == num or mis_id in num:
                                        mis_position = idx
                                        print(f"[MIS LOOKUP] Found MIS ID {mis_id} at position {idx} (part: '{part}')")
                                        break
                                
                                # If we found the position, use the corresponding brand
                                if mis_position is not None and brand_value:
                                    brands = [b.strip() for b in brand_value.split(',')]
                                    if mis_position < len(brands):
                                        brand_value = brands[mis_position]
                                        print(f"[MIS LOOKUP] Using brand at position {mis_position}: '{brand_value}'")
                                    else:
                                        print(f"[MIS LOOKUP] [EMOJI] Position {mis_position} out of range for brands: {brands}")
                            
                            # Find After Wholesale Discount column
                            after_wholesale_value = False
                            after_ws_col_found = None
                            for col in google_df.columns:
                                col_lower = col.lower()
                                # Look for columns containing both "wholesale" and "discount"
                                if 'wholesale' in col_lower and 'discount' in col_lower:
                                    cell_value = str(base_row.get(col, '')).strip()
                                    after_ws_col_found = col
                                    # Check for TRUE/checked/yes/1
                                    after_wholesale_value = cell_value.lower() in ['yes', 'true', '1', 'checked', 'x', 'TRUE']
                                    print(f"[MIS LOOKUP] Found After Wholesale in column '{col}': '{cell_value}' [EMOJI] {after_wholesale_value}")
                                    break
                            
                            if not after_ws_col_found:
                                print(f"[MIS LOOKUP] [EMOJI] Could not find After Wholesale Discount column")
                            
                            # Found it! Extract row data
                            row_data = {
                                'brand': brand_value,
                                'linked_brand': str(base_row.get('Linked Brand', '')).strip(),
                                'weekday': combined_weekday,
                                'categories': str(base_row.get('Categories', '')).strip(),
                                'discount': discount_value,
                                'vendor_contrib': vendor_value,
                                'locations': locations_raw,
                                'rebate_type': str(base_row.get('Rebate Type', '')).strip(),
                                'after_wholesale': after_wholesale_value
                            }
                            
                            print(f"[MIS LOOKUP] [EMOJI] Found row data in Google Sheet!")
                            print(f"[MIS LOOKUP] Brand: {row_data['brand']}, Weekday: {row_data['weekday']}")
                            print(f"[MIS LOOKUP] Discount: '{row_data['discount']}', Vendor %: '{row_data['vendor_contrib']}'")
                            print(f"[MIS LOOKUP] Locations: {row_data['locations']}")
                            
                            if len(matching_rows) > 1:
                                print(f"[MIS LOOKUP] [EMOJI] Multi-day deal detected! Combined {len(matching_rows)} weekdays: {combined_weekday}")
                            
                    else:
                        print(f"[MIS LOOKUP] [EMOJI] Could not find MIS ID column in Google Sheet")
                else:
                    print(f"[MIS LOOKUP] [EMOJI] No Google Sheet data available")
            except Exception as e:
                print(f"[MIS LOOKUP] [EMOJI] Error searching Google Sheet: {e}")
        else:
            print(f"[MIS LOOKUP] Row data provided by frontend")
        
        # Open the entry modal
        if filter_and_open_mis_id(driver, mis_id):
            time.sleep(1)  # V2: Wait for modal to open before injecting
            # v12.22.5: If row data provided, inject checklist banner (same as Compare to Google Sheet)
            if row_data:
                try:
                    # Format row data for validation (similar to create_deal)
                    expected_data = {
                        'brand': row_data.get('brand', ''),
                        'linked_brand': row_data.get('linked_brand', ''),
                        'weekday': row_data.get('weekday', ''),
                        'categories': row_data.get('categories', ''),
                        'discount': row_data.get('discount', ''),
                        'vendor_contrib': row_data.get('vendor_contrib', ''),
                        'locations': row_data.get('locations', 'All Locations'),
                        'rebate_type': row_data.get('rebate_type', ''),
                        'after_wholesale': row_data.get('after_wholesale', False)
                    }
                    
                    print(f"[MIS LOOKUP] Injecting checklist banner with row data")
                    print(f"[MIS LOOKUP] Expected: Brand={expected_data['brand']}, Weekday={expected_data['weekday']}")
                    print(f"[MIS LOOKUP] After Wholesale: {expected_data['after_wholesale']}")
                    
                    # v12.22.5: Inject checklist banner for visual checklist panel
                    inject_checklist_banner(driver, expected_data, mode='compare')
                    print(f"[MIS LOOKUP] ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ Checklist banner injected for MIS ID {mis_id}")
                    
                    # v12.22.6: ALSO send message to existing validator to switch to automation mode
                    # The V2 validator may already be running (persistent from previous entry)
                    # This will send it the expected_data so it validates properly
                    inject_mis_validation(driver, expected_data=expected_data)
                    print(f"[MIS LOOKUP] ÃƒÆ’Ã‚Â¢Ãƒâ€¦Ã¢â‚¬Å“ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¦ Validator switched to automation mode")
                    
                except Exception as e:
                    print(f"[MIS LOOKUP] ÃƒÆ’Ã‚Â¢Ãƒâ€šÃ‚ÂÃƒâ€¦Ã¢â‚¬â„¢ Could not inject checklist: {e}")
                    # Fallback to basic validation
                    inject_mis_validation(driver, expected_data=None)
            else:
                # No row data - basic validation only (Rebate Type + Weekday must be filled)
                inject_mis_validation(driver, expected_data=None)
                print(f"[MIS LOOKUP] No row data - manual mode validation")
            
            # Clear automation flag
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': True, 'message': f'Lookup successful for ID {mis_id}'})
        
        GLOBAL_DATA['automation_in_progress'] = False
        return jsonify({'success': False, 'error': f'Failed to lookup ID {mis_id}'})
        
    except Exception as e:
        GLOBAL_DATA['automation_in_progress'] = False
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/validate-lookup', methods=['POST'])
def api_mis_validate_lookup():
    """
    V2: Handle MIS Browser datatable clicks.
    Check Google Sheet for MIS ID, send automation or manual message.
    """
    try:
        data = request.get_json()
        mis_id = str(data.get('mis_id', '')).strip()
        
        if not mis_id:
            return jsonify({'success': False, 'error': 'No MIS ID provided'})
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        
        print(f"\n{'='*60}")
        print(f"[V2-LOOKUP] MIS Browser click detected: MIS ID {mis_id}")
        print(f"{'='*60}")
        
        # Check if Google Sheet data available
        google_df = GLOBAL_DATA.get('google_df')
        
        if google_df is not None and not google_df.empty:
            print(f"[V2-LOOKUP] [EMOJI] Searching Google Sheet for MIS ID {mis_id}")
            
            # Search for MIS ID in sheet
            found_data = None
            for idx, row in google_df.iterrows():
                # Check multiple possible ID columns
                for id_col in ['MIS ID', 'ID', 'Mis Id', 'MIS_ID', 'mis_id']:
                    if id_col in google_df.columns:
                        sheet_mis_id = str(row.get(id_col, '')).strip()
                        if mis_id in sheet_mis_id or sheet_mis_id == mis_id:
                            # Found it!
                            found_data = {
                                'brand': str(row.get('Brand', '')).strip(),
                                'linked_brand': str(row.get('Linked Brand', '')).strip(),
                                'weekday': str(row.get('Weekday', '')).strip(),
                                'categories': str(row.get('Categories', '')).strip(),
                                'discount': str(row.get('Discount', '')).strip(),
                                'vendor_contrib': str(row.get('Vendor %', '')).strip(),
                                'locations': str(row.get('Locations', 'All Locations')).strip(),
                                'rebate_type': str(row.get('Rebate Type', '')).strip(),
                                'after_wholesale': str(row.get('After Wholesale', '')).strip().lower() in ['yes', 'true', '1']
                            }
                            print(f"[V2-LOOKUP] [EMOJI] Found in Google Sheet!")
                            print(f"[V2-LOOKUP] Brand: {found_data['brand']}, Weekday: {found_data['weekday']}")
                            break
                if found_data:
                    break
            
            if found_data:
                # Send automation message
                send_validation_message(driver, action='automation', mis_id=mis_id, expected_data=found_data)
                return jsonify({
                    'success': True,
                    'mode': 'automation',
                    'message': f'MIS ID {mis_id} found in Google Sheet - automation mode activated'
                })
            else:
                print(f"[V2-LOOKUP] [EMOJI] MIS ID {mis_id} not found in Google Sheet")
                # Send manual message
                send_validation_message(driver, action='manual')
                return jsonify({
                    'success': True,
                    'mode': 'manual',
                    'message': f'MIS ID {mis_id} not in Google Sheet - manual mode'
                })
        else:
            print(f"[V2-LOOKUP] [EMOJI] No Google Sheet data available")
            # Send manual message
            send_validation_message(driver, action='manual')
            return jsonify({
                'success': True,
                'mode': 'manual',
                'message': 'No Google Sheet loaded - manual mode'
            })
    
    except Exception as e:
        print(f"[V2-LOOKUP] [EMOJI] Error: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


def get_brand_for_mis_id(mis_id: str, mis_id_column_value: str, brands_column_value: str) -> str:
    """
    v12.18: Given an MIS ID, find which brand it corresponds to in a multi-brand row.
    
    Multi-brand rows in Google Sheet have format:
        MIS ID column: "S1: 966, S2: 967, S3: 968, S4: 969, S5: 970"
        Brands column: "Kiva, Camino, Lost Farm, Terra, Petra"
    
    S1 = first brand, S2 = second brand, etc.
    Also supports W1/W2 (Weekly) and M1/M2 (Monthly) prefixes.
    
    Args:
        mis_id: The MIS ID to look up (e.g., "966")
        mis_id_column_value: The full MIS ID column value (e.g., "S1: 966, S2: 967, ...")
        brands_column_value: The brands column value (e.g., "Kiva, Camino, Lost Farm, ...")
    
    Returns:
        The brand name at the matching position, or None if not found
    """
    import re
    
    if not mis_id or not mis_id_column_value or not brands_column_value:
        return None
    
    # Parse brands list
    brands = [b.strip() for b in brands_column_value.split(',') if b.strip()]
    
    if not brands:
        return None
    
    # If only one brand, return it directly
    if len(brands) == 1:
        return brands[0]
    
    # Find position of our MIS ID using pattern like "S1: 966", "W2: 815", "M3: 500"
    # Pattern matches: letter + number + colon + optional space + our MIS ID
    pattern = r'[SWM](\d+):\s*' + re.escape(str(mis_id).strip())
    match = re.search(pattern, mis_id_column_value, re.IGNORECASE)
    
    if match:
        position = int(match.group(1)) - 1  # Convert to 0-indexed
        if 0 <= position < len(brands):
            print(f"[MULTI-BRAND] MIS ID {mis_id} found at position {position + 1}, brand: {brands[position]}")
            return brands[position]
    
    # Fallback: Try simple position matching by splitting and finding index
    # Handle formats like "S1: 966, S2: 967" by extracting just the IDs
    try:
        # Remove prefixes and get just the IDs
        ids_raw = re.sub(r'[SWM]\d+:\s*', '', mis_id_column_value)
        ids = [i.strip() for i in ids_raw.split(',') if i.strip()]
        
        for idx, id_val in enumerate(ids):
            if str(mis_id).strip() == id_val.strip() and idx < len(brands):
                print(f"[MULTI-BRAND] MIS ID {mis_id} matched at index {idx}, brand: {brands[idx]}")
                return brands[idx]
    except Exception as e:
        print(f"[MULTI-BRAND] Fallback parsing failed: {e}")
    
    print(f"[MULTI-BRAND] Could not determine brand for MIS ID {mis_id} in '{mis_id_column_value}'")
    return None


def find_locations_value(row, columns):
    """
    v12.17: Find locations value from row - uses resolve_location_columns for consistency.
    """
    import pandas as pd
    
    # v12.17: Use the same logic as the main matching system
    try:
        loc_raw, exc_raw = resolve_location_columns(row)
        result = format_location_display(loc_raw, exc_raw)
        if result and result.lower() not in ['', '-', 'nan', 'none']:
            print(f"[COMPARE-TO-SHEET] Locations via resolve_location_columns: '{result}'")
            return result
    except Exception as e:
        print(f"[COMPARE-TO-SHEET] resolve_location_columns failed: {e}, falling back")
    
    # Fallback: Priority order for column names
    location_col_names = [
        "Locations (Discount Applies at)",
        "Locations",
        "Location", 
        "Store Locations",
        "Stores"
    ]
    
    def clean_value(val):
        """Clean cell value, handling NaN, None, etc."""
        if val is None:
            return ""
        if pd.isna(val):
            return ""
        s = str(val).strip()
        if s.lower() in ['nan', 'none', 'null', '-']:
            return ""
        return s
    
    # Try exact matches first
    for col_name in location_col_names:
        if col_name in columns:
            val = clean_value(row.get(col_name, ""))
            if val:
                print(f"[COMPARE-TO-SHEET] Found Locations in column '{col_name}': '{val}'")
                return val
    
    # Try case-insensitive partial matches
    for col in columns:
        col_lower = col.lower()
        if "location" in col_lower or "store" in col_lower:
            if "marketing" not in col_lower:  # Skip marketing columns
                val = clean_value(row.get(col, ""))
                if val:
                    print(f"[COMPARE-TO-SHEET] Found Locations in column '{col}': '{val}'")
                    return val
    
    # Log what columns were available for debugging
    location_cols = [c for c in columns if 'location' in c.lower() or 'store' in c.lower()]
    print(f"[COMPARE-TO-SHEET] WARNING: No locations value found!")
    print(f"[COMPARE-TO-SHEET] Available location-like columns: {location_cols}")
    print(f"[COMPARE-TO-SHEET] Defaulting to 'All Locations'")
    return "All Locations"

def find_weekday_column_value(row, columns, section_type):
    """
    v12.12.12: Section-aware weekday/date column detection.
    - Weekly: Uses "Weekday" column
    - Monthly: Uses "Weekday/Day of Month" or column containing "day of month"
    - Sale: Uses column containing "Sale Runs:" 
    
    Returns: (column_value, column_name)
    """
    import pandas as pd
    
    def clean_value(val):
        if val is None or pd.isna(val):
            return ""
        s = str(val).strip()
        if s.lower() in ['nan', 'none', 'null', '-']:
            return ""
        return s
    
    if section_type == 'monthly':
        # Look for "Day of Month" column
        priority_cols = [
            'Weekday/\nDay of Month',
            'Weekday/Day of Month', 
            'Day of Month',
            'Monthly Date'
        ]
        
        # Try exact matches
        for col_name in priority_cols:
            if col_name in columns:
                val = clean_value(row.get(col_name, ""))
                if val:
                    print(f"[COMPARE-TO-SHEET] Monthly: Found in column '{col_name}': '{val}'")
                    return (val, col_name)
        
        # Try partial match for "day of month"
        for col in columns:
            col_lower = col.lower().replace('\n', ' ')
            if 'day of month' in col_lower or 'monthly' in col_lower:
                val = clean_value(row.get(col, ""))
                if val:
                    print(f"[COMPARE-TO-SHEET] Monthly: Found in column '{col}': '{val}'")
                    return (val, col)
        
        print(f"[COMPARE-TO-SHEET] WARNING: No 'Day of Month' column found for monthly deal")
        return ("", None)
    
    elif section_type == 'sale':
        # Look for "Sale Runs:" column
        for col in columns:
            col_lower = col.lower().replace('\n', ' ')
            if 'sale runs' in col_lower or 'sale date' in col_lower:
                val = clean_value(row.get(col, ""))
                if val:
                    print(f"[COMPARE-TO-SHEET] Sale: Found in column '{col}': '{val}'")
                    return (val, col)
        
        print(f"[COMPARE-TO-SHEET] WARNING: No 'Sale Runs' column found for sale deal")
        return ("", None)
    
    else:
        # Weekly - use standard Weekday column
        weekday_cols = ['Weekday', 'Day', 'Days']
        for col_name in weekday_cols:
            if col_name in columns:
                val = clean_value(row.get(col_name, ""))
                if val:
                    return (val, col_name)
        
        # Fallback
        val = clean_value(row.get('Weekday', ""))
        return (val, 'Weekday')

def parse_monthly_ordinals(day_str: str) -> list:
    """
    v12.12.12: Parse monthly ordinal strings like "1st", "10th", "1st, 15th"
    Returns list of day numbers: [1, 15]
    """
    import re
    
    if not day_str:
        return []
    
    # Find all ordinal patterns: 1st, 2nd, 3rd, 4th, 5th, etc.
    ordinal_pattern = r'(\d+)(?:st|nd|rd|th)'
    matches = re.findall(ordinal_pattern, day_str.lower())
    
    days = [int(m) for m in matches if 1 <= int(m) <= 31]
    print(f"[COMPARE-TO-SHEET] Parsed monthly ordinals: '{day_str}' -> days {days}")
    return days

def parse_sale_dates_for_validation(sale_str: str) -> list:
    """
    v12.12.12: Parse sale date strings like "01/16/26 - Friday" or "01/16/26 - Friday, 01/17/26 - Saturday"
    Returns list of dicts: [{'date': '01/16/26', 'weekday': 'Friday', 'date_obj': date}, ...]
    
    NOTE: This is separate from parse_sale_dates() at line ~3325 which takes 3 args and returns List[date]
    for the Split Audit date expansion. This function is for validation comparison only.
    """
    import re
    from datetime import datetime
    
    if not sale_str:
        return []
    
    results = []
    
    # Pattern: MM/DD/YY - Weekday
    pattern = r'(\d{1,2}/\d{1,2}/\d{2,4})\s*-\s*(\w+)'
    matches = re.findall(pattern, sale_str)
    
    for date_str, weekday in matches:
        try:
            # Parse date (handle 2-digit and 4-digit years)
            if len(date_str.split('/')[-1]) == 2:
                date_obj = datetime.strptime(date_str, '%m/%d/%y').date()
            else:
                date_obj = datetime.strptime(date_str, '%m/%d/%Y').date()
            
            results.append({
                'date': date_str,
                'weekday': weekday.strip().title(),
                'date_obj': date_obj
            })
        except ValueError as e:
            print(f"[COMPARE-TO-SHEET] Warning: Could not parse sale date '{date_str}': {e}")
    
    print(f"[COMPARE-TO-SHEET] Parsed sale dates: '{sale_str}' -> {len(results)} dates")
    return results

def calculate_expected_dates(section_type: str, date_value: str, tab_name: str) -> dict:
    """
    v12.12.12: Calculate expected dates/weekdays based on section type.
    
    Returns dict with:
    - 'all_entries': List of all expected entries from Google Sheet
    - 'weekday': Weekday string for MIS (for weekly deals, direct; for monthly/sale, calculated)
    """
    from datetime import date, timedelta
    import calendar
    
    result = {
        'all_entries': [],
        'weekday': '',
        'section_type': section_type,
        'raw_value': date_value
    }
    
    if section_type == 'weekly':
        # Weekly deals: weekday is used directly
        result['weekday'] = date_value
        result['all_entries'] = [{'weekday': date_value, 'type': 'weekly'}]
        return result
    
    # Get month/year from tab name
    tab_month, tab_year = parse_tab_month_year(tab_name)
    print(f"[COMPARE-TO-SHEET] Tab '{tab_name}' -> Month: {tab_month}, Year: {tab_year}")
    
    if section_type == 'monthly':
        # Parse ordinal days
        days = parse_monthly_ordinals(date_value)
        
        for day in days:
            try:
                # Create date for this day in the target month
                entry_date = date(tab_year, tab_month, day)
                weekday_name = calendar.day_name[entry_date.weekday()]
                
                result['all_entries'].append({
                    'day': day,
                    'ordinal': f"{day}{'st' if day == 1 else 'nd' if day == 2 else 'rd' if day == 3 else 'th'}",
                    'date': entry_date.strftime('%m/%d/%Y'),
                    'date_short': entry_date.strftime('%m/%d/%y'),
                    'weekday': weekday_name,
                    'type': 'monthly'
                })
            except ValueError as e:
                print(f"[COMPARE-TO-SHEET] Warning: Invalid date - day {day} in {tab_month}/{tab_year}: {e}")
        
        # Set weekday to comma-separated list of all expected weekdays
        all_weekdays = [e['weekday'] for e in result['all_entries']]
        result['weekday'] = ', '.join(all_weekdays) if all_weekdays else ''
        
    elif section_type == 'sale':
        # Parse sale date strings
        sale_dates = parse_sale_dates_for_validation(date_value)
        
        for sd in sale_dates:
            result['all_entries'].append({
                'date': sd['date'],
                'date_obj': sd['date_obj'],
                'weekday': sd['weekday'],
                'type': 'sale'
            })
        
        # Set weekday to comma-separated list of all expected weekdays
        all_weekdays = list(set([e['weekday'] for e in result['all_entries']]))
        result['weekday'] = ', '.join(sorted(all_weekdays)) if all_weekdays else ''
    
    print(f"[COMPARE-TO-SHEET] Calculated {len(result['all_entries'])} expected entries for {section_type}")
    return result

@app.route('/api/mis/compare-to-sheet', methods=['POST'])
def api_mis_compare_to_sheet():
    """
    V2: Manual "Compare to Google Sheet" button handler.
    User clicks button in validation banner to search Google Sheet for current MIS ID.
    """
    try:
        data = request.get_json()
        mis_id = str(data.get('mis_id', '')).strip()
        
        if not mis_id:
            return jsonify({'success': False, 'error': 'No MIS ID provided'})
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        
        print(f"\n{'='*60}")
        print(f"[COMPARE-TO-SHEET] [EMOJI] Manual comparison requested for MIS ID: {mis_id}")
        print(f"{'='*60}")
        
        # Check if Google Sheet data available
        google_df = GLOBAL_DATA.get('google_df')
        
        if google_df is None or google_df.empty:
            print(f"[COMPARE-TO-SHEET] [EMOJI] No Google Sheet data loaded")
            return jsonify({
                'success': False, 
                'error': 'No Google Sheet loaded. Please run Audit first.'
            })
        
        print(f"[COMPARE-TO-SHEET] Google Sheet loaded with {len(google_df)} rows")
        
        # Search for MIS ID (reuse same logic as lookup)
        found_data = None
        
        # Find ID column
        id_col = None
        for col in ['MIS ID', 'ID', 'Mis Id', 'MIS_ID', 'mis_id']:
            if col in google_df.columns:
                id_col = col
                break
        
        if not id_col:
            return jsonify({
                'success': False,
                'error': 'Could not find MIS ID column in Google Sheet'
            })
        
        # Search for matching rows (same logic as api_mis_lookup_mis_id)
        matching_rows = []
        for idx, row in google_df.iterrows():
            sheet_mis_id = str(row.get(id_col, '')).strip()
            if mis_id in sheet_mis_id or sheet_mis_id == mis_id:
                matching_rows.append(row)
        
        if not matching_rows:
            print(f"[COMPARE-TO-SHEET] [EMOJI] MIS ID {mis_id} not found in Google Sheet")
            # Switch to manual mode
            inject_mis_validation(driver, expected_data=None)
            return jsonify({
                'success': True,
                'mode': 'manual',
                'message': f'MIS ID {mis_id} not in Google Sheet - staying in manual mode'
            })
        
        # Found it! Extract data (same logic as lookup)
        print(f"[COMPARE-TO-SHEET] [EMOJI] Found {len(matching_rows)} matching row(s)")
        
        base_row = matching_rows[0]
        
        # v12.12.12: Detect section type from _section column
        section_type = str(base_row.get('_section', 'weekly')).strip().lower()
        if section_type not in ['weekly', 'monthly', 'sale']:
            section_type = 'weekly'
        print(f"[COMPARE-TO-SHEET] Section type: {section_type}")
        
        # v12.12.12: Get tab name for date calculations
        tab_name = GLOBAL_DATA.get('mis', {}).get('current_sheet', '')
        print(f"[COMPARE-TO-SHEET] Current tab: '{tab_name}'")
        
        # v12.12.12: Section-aware weekday/date extraction
        date_value, date_col = find_weekday_column_value(base_row, google_df.columns, section_type)
        print(f"[COMPARE-TO-SHEET] Date/Weekday value from '{date_col}': '{date_value}'")
        
        # Calculate expected dates/weekdays based on section type
        date_info = calculate_expected_dates(section_type, date_value, tab_name)
        combined_weekday = date_info['weekday']
        all_expected_entries = date_info['all_entries']
        
        print(f"[COMPARE-TO-SHEET] Calculated weekday(s): '{combined_weekday}'")
        print(f"[COMPARE-TO-SHEET] All expected entries: {len(all_expected_entries)}")
        
        # Find Discount column (v12.12.7 - enhanced detection)
        # Priority order: exact "Discount", then variations with value/rate/%
        discount_value = ''
        discount_col_candidates = []
        for col in google_df.columns:
            col_lower = col.lower().strip()
            col_clean = col_lower.replace('\n', ' ').replace('\r', ' ')
            
            # Skip columns that are clearly NOT the discount value
            if 'wholesale' in col_lower or 'blaze' in col_lower:
                continue
            
            # Exact match for "Discount" column (highest priority)
            if col_clean == 'discount':
                discount_col_candidates.insert(0, col)
            # "Deal Discount Value/Type" or similar with line breaks
            elif 'deal discount' in col_clean or 'discount value' in col_clean:
                discount_col_candidates.insert(0, col)
            # Generic discount columns
            elif 'discount' in col_lower and 'type' not in col_lower:
                discount_col_candidates.append(col)
        
        # Try candidates in priority order
        for col in discount_col_candidates:
            val = str(base_row.get(col, '')).strip()
            if val:
                discount_value = val
                print(f"[COMPARE-TO-SHEET] Found Discount in column '{col}': '{discount_value}'")
                break
        
        if not discount_value:
            print(f"[COMPARE-TO-SHEET] [EMOJI] No discount value found. Columns searched: {discount_col_candidates}")
        
        # Find Vendor % column
        vendor_value = ''
        for col in google_df.columns:
            if 'contribution' in col.lower() or 'vendor' in col.lower():
                vendor_value = str(base_row.get(col, '')).strip()
                if vendor_value:
                    print(f"[COMPARE-TO-SHEET] Found Vendor % in column '{col}': '{vendor_value}'")
                    break
        
        # Find After Wholesale Discount column (v12.12.10 - enhanced detection)
        after_wholesale_value = False
        after_wholesale_col = None
        
        # Priority order for column names
        priority_cols = [
            'After Wholesale Discount',  # Exact match (user's column)
            'After Wholesale',
            'Rebate After Wholesale Discount?',
            'Wholesale Discount'
        ]
        
        # Try priority matches first
        for priority_name in priority_cols:
            if priority_name in google_df.columns:
                after_wholesale_col = priority_name
                break
        
        # Fallback: search for any column with wholesale + discount
        if not after_wholesale_col:
            for col in google_df.columns:
                col_lower = col.lower()
                if 'wholesale' in col_lower and ('discount' in col_lower or 'after' in col_lower):
                    after_wholesale_col = col
                    break
        
        if after_wholesale_col:
            cell_value = base_row.get(after_wholesale_col, '')
            
            # Handle Google Sheets checkbox (returns actual boolean)
            if isinstance(cell_value, bool):
                after_wholesale_value = cell_value
                print(f"[COMPARE-TO-SHEET] After Wholesale column '{after_wholesale_col}': {cell_value} (boolean) -> {after_wholesale_value}")
            else:
                # Handle string values
                cell_str = str(cell_value).strip().lower()
                after_wholesale_value = cell_str in ['yes', 'true', '1', 'checked', 'x']
                print(f"[COMPARE-TO-SHEET] After Wholesale column '{after_wholesale_col}': '{cell_value}' (string) -> {after_wholesale_value}")
        else:
            print(f"[COMPARE-TO-SHEET] WARNING: No After Wholesale column found. Available columns with 'wholesale': {[c for c in google_df.columns if 'wholesale' in c.lower()]}")
        
        # v12.18: Enhanced multi-brand handling using get_brand_for_mis_id()
        brand_value = str(base_row.get('Brand', '')).strip()
        sheet_mis_id = str(base_row.get(id_col, '')).strip()
        
        # Check if this is a multi-brand row (has commas in MIS ID column)
        if ',' in sheet_mis_id or ':' in sheet_mis_id:
            print(f"[COMPARE-TO-SHEET] Multi-brand row detected. MIS ID column: '{sheet_mis_id}'")
            print(f"[COMPARE-TO-SHEET] Brands column: '{brand_value}'")
            
            # Use the helper function to get the specific brand for this MIS ID
            specific_brand = get_brand_for_mis_id(mis_id, sheet_mis_id, brand_value)
            if specific_brand:
                brand_value = specific_brand
                print(f"[COMPARE-TO-SHEET] v12.18 Multi-brand: Resolved to brand '{brand_value}' for MIS ID {mis_id}")
            else:
                print(f"[COMPARE-TO-SHEET] v12.18 Multi-brand: Could not resolve brand, using first")
                # Fallback to first brand if we can't determine position
                if ',' in brand_value:
                    brand_value = brand_value.split(',')[0].strip()
        
        # Build expected data
        # v12.12.12: Serialize all_expected_entries for JSON (convert date objects)
        serialized_entries = []
        for entry in all_expected_entries:
            ser_entry = entry.copy()
            if 'date_obj' in ser_entry:
                ser_entry['date_obj'] = ser_entry['date_obj'].isoformat() if ser_entry['date_obj'] else None
            serialized_entries.append(ser_entry)
        
        expected_data = {
            'brand': brand_value,
            # v12.17: Try row first, then fall back to Settings tab brand_settings
            'linked_brand': str(base_row.get('Linked Brand', '')).strip() or GLOBAL_DATA.get('brand_settings', {}).get(brand_value.lower(), ''),
            'weekday': combined_weekday,
            'categories': str(base_row.get('Categories', '')).strip(),
            'discount': discount_value,
            'vendor_contrib': vendor_value,
            'locations': find_locations_value(base_row, google_df.columns),
            'rebate_type': str(base_row.get('Rebate Type', '')).strip(),
            'after_wholesale': after_wholesale_value,
            # v12.12.12: Section-specific data
            'section_type': section_type,
            'all_expected_entries': serialized_entries,
            'raw_date_value': date_value,
            'tab_name': tab_name
        }
        
        print(f"[COMPARE-TO-SHEET] Brand: {expected_data['brand']}, Weekday: {expected_data['weekday']}")
        print(f"[COMPARE-TO-SHEET] Discount: '{expected_data['discount']}', Vendor %: '{expected_data['vendor_contrib']}'")
        print(f"[COMPARE-TO-SHEET] Rebate Type: '{expected_data['rebate_type']}'")
        print(f"[COMPARE-TO-SHEET] Locations: '{expected_data['locations']}'")
        print(f"[COMPARE-TO-SHEET] Section: {section_type}, Expected entries: {len(serialized_entries)}")
        # v12.19: INJECT CHECKLIST BANNER IN COMPARE MODE
        # Instead of just returning JSON, inject the banner directly
        print(f"[COMPARE-TO-SHEET] [EMOJI] Injecting checklist banner in 'compare' mode")
        inject_checklist_banner(driver, expected_data, mode='compare')
        
        # v12.21: CRITICAL FIX - Return expected_data and mode='automation' so frontend activates
        return jsonify({
            'success': True,
            'mode': 'automation',  # Frontend checks for this!
            'expected_data': expected_data,  # Frontend needs this!
            'message': f'Found MIS ID {mis_id} in Google Sheet - checklist active'
        })
    
    except Exception as e:
        print(f"[COMPARE-TO-SHEET] [EMOJI] Error: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/search-brand', methods=['POST'])
def api_mis_search_brand():
    try:
        data = request.get_json()
        brand = data.get('brand', '').strip()
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        # INTELLIGENT MIS SESSION CHECK
        try:
            creds = load_credentials_config()
            mis_user = creds.get('mis_username', '')
            mis_pass = creds.get('mis_password', '')
            ensure_mis_ready(driver, mis_user, mis_pass)
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)})
        
        try:
            close_buttons = driver.find_elements(By.CSS_SELECTOR, "button.close[data-dismiss='modal']")
            for btn in close_buttons:
                if btn.is_displayed():
                    btn.click()
                    time.sleep(0.3)
                    break
        except:
            pass
        
        try:
            search_input = WebDriverWait(driver, 3).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
            )
            search_input.click()
            search_input.send_keys(Keys.CONTROL + "a")
            search_input.send_keys(Keys.DELETE)
            search_input.send_keys(brand)
            search_input.send_keys(Keys.RETURN)
            return jsonify({'success': True})
        except Exception as e:
            return jsonify({'success': False, 'error': f"Search failed: {str(e)}"})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# ============================================
# UPDATE MIS END DATE (v12.2 - Expand & Attack Fix)
# ============================================
@app.route('/api/mis/update-end-date', methods=['POST'])
def api_mis_update_end_date():
    """
    Update the end date of a MIS entry using EXPAND & ATTACK strategy.
    
    The MIS DataTable uses Responsive Mode where the Edit button is hidden
    in a child row. We must EXPAND the row first to access the button.
    
    Workflow:
    1. Filter: Enter MIS ID into search bar
    2. Expand: Click first cell (td:first-child) to expand child row
    3. Click: Wait for expansion, find Edit button (a.btn-table-dialog), click it
    4. Update: Fill in new date and save
    """
    try:
        data = request.get_json()
        mis_id = str(data.get('mis_id', '')).strip()
        new_date = str(data.get('new_date', '')).strip()
        
        if not mis_id:
            return jsonify({'success': False, 'error': 'No MIS ID provided'})
        if not new_date:
            return jsonify({'success': False, 'error': 'No new date provided'})
        
        # Strip any tag prefixes
        mis_id = strip_mis_id_tag(mis_id)
        
        if not mis_id or not mis_id.isdigit():
            return jsonify({'success': False, 'error': f'Invalid MIS ID format: {data.get("mis_id")}'})
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        # INTELLIGENT MIS SESSION CHECK - ensures tab exists and is logged in
        try:
            creds = load_credentials_config()
            mis_user = creds.get('mis_username', '')
            mis_pass = creds.get('mis_password', '')
            ensure_mis_ready(driver, mis_user, mis_pass)
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)})
        
        print(f"[MIS UPDATE END DATE] Starting Expand & Attack for MIS ID: {mis_id}")
        
        # Close any open modals first
        try:
            close_buttons = driver.find_elements(By.CSS_SELECTOR, "button.close[data-dismiss='modal'], .modal button.close, .btn-close")
            for btn in close_buttons:
                if btn.is_displayed():
                    btn.click()
                    time.sleep(0.3)
                    break
        except:
            pass
        
        # ========================================
        # STEP 1: FILTER - Enter MIS ID in search
        # ========================================
        try:
            search_input = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
            )
            search_input.click()
            search_input.send_keys(Keys.CONTROL + "a")
            search_input.send_keys(Keys.DELETE)
            search_input.send_keys(mis_id)
            print(f"[MIS UPDATE END DATE] Step 1: Filtered by MIS ID: {mis_id}")
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not find search input: {e}'})
        
        # Wait for table to filter
        time.sleep(1.5)
        
        # ========================================
        # STEP 2: EXPAND - Click first cell to show child row
        # ========================================
        try:
            # Wait for filtered results
            WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "#daily-discount tbody tr"))
            )
            time.sleep(0.5)
            
            # Find the row containing our MIS ID
            table_rows = driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.child)")
            target_row = None
            
            print(f"[MIS UPDATE END DATE] Found {len(table_rows)} parent rows in table")
            
            for row in table_rows:
                try:
                    row_text = row.text
                    if mis_id in row_text:
                        target_row = row
                        print(f"[MIS UPDATE END DATE] Found target row containing MIS ID {mis_id}")
                        break
                except:
                    continue
            
            if not target_row:
                return jsonify({'success': False, 'error': f'Could not find row with MIS ID {mis_id} in table'})
            
            # Click the FIRST CELL to trigger DataTable expansion
            first_cell = target_row.find_element(By.CSS_SELECTOR, "td:first-child")
            print(f"[MIS UPDATE END DATE] Step 2: Clicking first cell to expand row...")
            
            # Use ActionChains for reliable click
            actions = ActionChains(driver)
            actions.move_to_element(first_cell)
            actions.click()
            actions.perform()
            
            print(f"[MIS UPDATE END DATE] Clicked first cell, waiting for expansion...")
            time.sleep(1)  # Wait for expansion animation
            
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not expand row: {e}'})
        
        # ========================================
        # STEP 3: CLICK - Find and click Edit button in child row
        # ========================================
        try:
            # The Edit button should now be visible in the expanded child row
            # It uses class "btn-table-dialog" (anchor tag)
            print(f"[MIS UPDATE END DATE] Step 3: Looking for Edit button...")
            
            edit_button = None
            
            # Method A: Look for Edit button in child row
            try:
                edit_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, "tr.child a.btn-table-dialog"))
                )
                print(f"[MIS UPDATE END DATE] Found Edit button in child row")
            except:
                pass
            
            # Method B: Look for any visible Edit button with btn-table-dialog class
            if not edit_button:
                try:
                    buttons = driver.find_elements(By.CSS_SELECTOR, "a.btn-table-dialog")
                    for btn in buttons:
                        if btn.is_displayed():
                            edit_button = btn
                            print(f"[MIS UPDATE END DATE] Found visible Edit button")
                            break
                except:
                    pass
            
            # Method C: Look for button with "Edit" text or edit icon
            if not edit_button:
                try:
                    buttons = driver.find_elements(By.XPATH, "//a[contains(@class, 'btn') and (contains(text(), 'Edit') or contains(@class, 'edit'))]")
                    for btn in buttons:
                        if btn.is_displayed():
                            edit_button = btn
                            print(f"[MIS UPDATE END DATE] Found Edit button via XPath")
                            break
                except:
                    pass
            
            if not edit_button:
                return jsonify({'success': False, 'error': 'Could not find Edit button after expanding row'})
            
            # Click the Edit button
            print(f"[MIS UPDATE END DATE] Clicking Edit button...")
            actions = ActionChains(driver)
            actions.move_to_element(edit_button)
            actions.click()
            actions.perform()
            
            print(f"[MIS UPDATE END DATE] Edit button clicked, waiting for modal...")
            
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not click Edit button: {e}'})
        
        # ========================================
        # STEP 4: UPDATE - Wait for modal and update date
        # ========================================
        # Wait for edit modal to open
        time.sleep(2)
        
        # Find and update the date_end field
        try:
            date_end_input = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "input#date_end, input[name='date_end']"))
            )
            
            original_value = date_end_input.get_attribute('value')
            print(f"[MIS UPDATE END DATE] Step 4: Found date_end field, current value: {original_value}")
            
            # Clear and enter new date
            date_end_input.click()
            time.sleep(0.3)
            
            # Select all and delete
            date_end_input.send_keys(Keys.CONTROL + "a")
            time.sleep(0.1)
            date_end_input.send_keys(Keys.DELETE)
            time.sleep(0.3)
            
            # Type new date
            date_end_input.send_keys(new_date)
            time.sleep(0.5)
            
            # Click elsewhere to trigger any change events (blur the field)
            try:
                form_element = driver.find_element(By.CSS_SELECTOR, "form, .modal-body, body")
                form_element.click()
            except:
                pass
            time.sleep(0.3)
            
            # Verify the date was entered correctly
            updated_value = date_end_input.get_attribute('value')
            print(f"[MIS UPDATE END DATE] After update, value is: {updated_value}")
            
            # Check if the date matches (handle different formats)
            date_matches = False
            # Normalize both dates for comparison
            new_date_parts = new_date.split('/')
            updated_parts = updated_value.split('/')
            
            if len(new_date_parts) == 3 and len(updated_parts) == 3:
                # Compare month and day directly
                if new_date_parts[0] == updated_parts[0] and new_date_parts[1] == updated_parts[1]:
                    # Compare year (handle 2-digit vs 4-digit)
                    new_year = new_date_parts[2]
                    updated_year = updated_parts[2]
                    if len(new_year) == 2:
                        new_year = '20' + new_year
                    if len(updated_year) == 2:
                        updated_year = '20' + updated_year
                    date_matches = (new_year == updated_year)
            
            if not date_matches:
                # Try direct comparison
                date_matches = (new_date == updated_value) or (new_date.replace('/20', '/') == updated_value)
            
            if not date_matches:
                return jsonify({
                    'success': False, 
                    'error': f'Date verification failed. Expected: {new_date}, Got: {updated_value}'
                })
            
            print(f"[MIS UPDATE END DATE] Date verified successfully: {updated_value}")
            
            # Now click the Save button
            try:
                # Look for save button - common patterns
                save_button = None
                save_selectors = [
                    "button[type='submit']",
                    "button.btn-primary:contains('Save')",
                    "button.btn-success",
                    "input[type='submit']",
                    ".modal-footer button.btn-primary",
                    "button.save-btn",
                    "#save-btn",
                    "button:contains('Save')",
                    "button:contains('Update')"
                ]
                
                for selector in save_selectors:
                    try:
                        if ':contains' in selector:
                            # Use XPath for text matching
                            text = selector.split("'")[1]
                            buttons = driver.find_elements(By.XPATH, f"//button[contains(text(), '{text}')]")
                            for btn in buttons:
                                if btn.is_displayed() and btn.is_enabled():
                                    save_button = btn
                                    break
                        else:
                            buttons = driver.find_elements(By.CSS_SELECTOR, selector)
                            for btn in buttons:
                                if btn.is_displayed() and btn.is_enabled():
                                    btn_text = btn.text.lower()
                                    # Make sure it's a save-type button, not cancel
                                    if 'save' in btn_text or 'update' in btn_text or 'submit' in btn_text or btn_text == '':
                                        save_button = btn
                                        break
                        if save_button:
                            break
                    except:
                        continue
                
                if save_button:
                    print(f"[MIS UPDATE END DATE] Found save button: {save_button.text or 'No text'}")
                    save_button.click()
                    time.sleep(2)
                    print("[MIS UPDATE END DATE] Save button clicked!")
                    
                    return jsonify({
                        'success': True, 
                        'message': f'End date updated to {new_date} and saved!',
                        'mis_id': mis_id,
                        'new_date': new_date,
                        'saved': True
                    })
                else:
                    print("[MIS UPDATE END DATE] Could not find save button")
                    return jsonify({
                        'success': True, 
                        'message': f'End date updated to {new_date}. Could not find Save button - please save manually.',
                        'mis_id': mis_id,
                        'new_date': new_date,
                        'saved': False
                    })
                    
            except Exception as save_err:
                print(f"[MIS UPDATE END DATE] Save button error: {save_err}")
                return jsonify({
                    'success': True, 
                    'message': f'End date updated to {new_date}. Save button click failed - please save manually.',
                    'mis_id': mis_id,
                    'new_date': new_date,
                    'saved': False
                })
            
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not find/update date_end field: {e}'})
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# ============================================
# VALIDATION V2 - Message Passing Helper
# ============================================
def send_validation_message(driver, action='manual', mis_id=None, expected_data=None):
    """
    V2: Send message to persistent validator instead of re-injecting.
    
    Args:
        driver: Selenium WebDriver
        action: 'manual' | 'automation' | 'lookup'
        mis_id: MIS ID (optional)
        expected_data: Expected data dict (optional)
    """
    import json
    
    message = {
        'action': action,
        'mis_id': mis_id,
        'expected_data': expected_data
    }
    message_json = json.dumps(message)
    
    print(f"[V2] [EMOJI] Sending message: action={action}, has_data={expected_data is not None}")
    
    try:
        driver.execute_script(f"""
            if (window.receiveValidationMessage) {{
                window.receiveValidationMessage({message_json});
            }} else {{
                console.error('[V2] ERROR: Validator not initialized! Call inject_mis_validation first.');
            }}
        """)
        print(f"[V2] [EMOJI] Message sent successfully")
    except Exception as e:
        print(f"[V2] [EMOJI] Failed to send message: {e}")


def inject_mis_browser_click_listeners(driver):
    """
    V2: Inject click listeners for MIS Browser datatable.
    Detects when user clicks Edit/MIS ID and sends lookup message.
    """
    print("[V2] Injecting MIS Browser click listeners...")
    
    listener_js = """
    (function() {
        if (window.MIS_BROWSER_LISTENERS_ACTIVE) {
            console.log('[V2] MIS Browser listeners already active');
            return;
        }
        window.MIS_BROWSER_LISTENERS_ACTIVE = true;
        
        console.log('[V2] [EMOJI] Setting up MIS Browser click detection');
        
        // Function to send lookup request to backend
        window.sendMISLookupRequest = async function(misId) {
            console.log('[V2] [EMOJI] Sending lookup request for MIS ID:', misId);
            
            try {
                const response = await fetch('/api/mis/validate-lookup', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ mis_id: misId })
                });
                
                const result = await response.json();
                console.log('[V2] Lookup response:', result);
            } catch (e) {
                console.error('[V2] Lookup request failed:', e);
            }
        };
        
        // Attach click listener to datatable
        function attachListeners() {
            const table = document.querySelector('#mis-datatable, .datatable, table');
            if (!table) {
                console.log('[V2] MIS datatable not found, will retry');
                return false;
            }
            
            console.log('[V2] [EMOJI] Found MIS datatable, attaching listeners');
            
            table.addEventListener('click', function(e) {
                // Check if clicked element is in a row
                const row = e.target.closest('tr');
                if (!row) return;
                
                // Check if clicked on Edit button or MIS ID cell
                const isEditBtn = e.target.closest('.btn-edit, .edit-button, button');
                const isMISID = e.target.closest('.mis-id, [data-mis-id]');
                
                if (isEditBtn || isMISID) {
                    // Try to extract MIS ID from row
                    let misId = null;
                    
                    // Method 1: Look for data attribute
                    if (row.dataset.misId) {
                        misId = row.dataset.misId;
                    }
                    // Method 2: Look for MIS ID in cells
                    else {
                        const cells = row.querySelectorAll('td');
                        for (const cell of cells) {
                            const text = cell.textContent.trim();
                            // MIS IDs are typically numeric
                            if (/^\\d{3,}$/.test(text)) {
                                misId = text;
                                break;
                            }
                        }
                    }
                    
                    if (misId) {
                        console.log('[V2] [EMOJI] Detected MIS Browser click, MIS ID:', misId);
                        window.sendMISLookupRequest(misId);
                    }
                }
            });
            
            return true;
        }
        
        // Try to attach now, retry if needed
        if (!attachListeners()) {
            // Retry after 2 seconds if table not found
            setTimeout(() => {
                if (!attachListeners()) {
                    console.log('[V2] [EMOJI] Could not find MIS datatable after retry');
                }
            }, 2000);
        }
        
    })();
    """
    
    try:
        driver.execute_script(listener_js)
        print("[V2] [EMOJI] MIS Browser listeners injected")
    except Exception as e:
        print(f"[V2] [EMOJI] Failed to inject listeners: {e}")


# ============================================
# CREATE DEAL IN MIS (v12.3)
# ============================================
def inject_mis_validation(driver, expected_data=None):
    """
    v12.11 - Comprehensive Banner: Inject MIS validation JavaScript.
    
    Phase 1 (CRITICAL - RED):
    - Rebate Type must not be "- Select -"
    - Blocks Save button until fixed
    
    Phase 2 (ADVISORY - ORANGE):
    - Compares all fields to expected_data (Google Sheet)
    - Shows ORANGE boxes for mismatches
    - Does NOT block Save button
    
    v12.9 Enhancements:
    - Persistent banner (always visible until Save clicked)
    - Save button detection (stops validation)
    - Cancel button detection (switches to manual mode)
    - Manual vs Automation mode tracking
    - Category and Linked Brand validation
    
    Args:
        driver: Selenium WebDriver instance
        expected_data: Dict of expected values from Google Sheet
            {
                'brand': str,
                'linked_brand': str,
                'categories': str,  # Comma-separated
                'weekday': str,
                'discount': str/float,
                'vendor_contrib': str/float,
                'locations': str,
                'rebate_type': str,
                'after_wholesale': bool
            }
    """
    # Prepare expected data as JSON for JavaScript
    import json
    expected_json = json.dumps(expected_data) if expected_data else 'null'
    
    # V2 ARCHITECTURE: Check if validator already active, just send message instead of re-injecting
    try:
        is_active = driver.execute_script("return window.VALIDATOR_V2_ACTIVE === true;")
        if is_active and expected_data is not None:
            print("[V2] [EMOJI] Validator already active, sending message instead of re-injecting")
            message = {
                'action': 'automation' if expected_data else 'manual',
                'expected_data': expected_data
            }
            message_json = json.dumps(message)
            driver.execute_script(f"""
                if (window.receiveValidationMessage) {{
                    window.receiveValidationMessage({message_json});
                }} else {{
                    console.error('[V2] ERROR: receiveValidationMessage not found!');
                }}
            """)
            return
    except Exception as e:
        print(f"[V2] Could not check validator status: {e}")
        # Continue with injection if check fails
    
    validation_js = f"""
    (function() {{
        // V2: Persistent validator flag
        if (window.VALIDATOR_V2_ACTIVE) {{
            console.log('[V2] Validator already active, updating data only');
            if (window.receiveValidationMessage) {{
                window.receiveValidationMessage({{
                    action: {expected_json} ? 'automation' : 'manual',
                    expected_data: {expected_json}
                }});
            }}
            return;
        }}
        window.VALIDATOR_V2_ACTIVE = true;
        
        console.log('[MIS-VALIDATION] v12.12.6 (V2) - Persistent Validator Starting...');
        console.log('[V2] Message-passing architecture active');
        console.log('[V2] Supports 3 modes: manual, automation, lookup');
        
        // ============================================
        // V2 MESSAGE RECEIVER
        // ============================================
        window.receiveValidationMessage = function(message) {{
            console.log('[V2] [EMOJI] Received message:', message);
            
            if (message.action === 'manual') {{
                VALIDATION_MODE = 'manual';
                EXPECTED_DATA = null;
                console.log('[V2] [EMOJI] Switched to MANUAL mode');
            }}
            else if (message.action === 'automation') {{
                VALIDATION_MODE = 'automation';
                EXPECTED_DATA = message.expected_data;
                console.log('[V2] [EMOJI] Switched to AUTOMATION mode');
                console.log('[V2] Expected data:', message.expected_data);
            }}
            else if (message.action === 'lookup') {{
                console.log('[V2] [EMOJI] LOOKUP mode - backend will send automation or manual');
            }}
            
            // Clear existing banner and warnings
            if (validationState.summaryBanner) {{
                validationState.summaryBanner.remove();
                validationState.summaryBanner = null;
            }}
            validationState.fieldWarnings = {{}};
        }};
        
        // Note: Re-injection check now handled in Python for better control
        if (window.MIS_VALIDATOR_ACTIVE) {{
            console.log('[MIS-VALIDATION] Re-initializing validator...');
        }}
        window.MIS_VALIDATOR_ACTIVE = true;
        
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {{
            checkInterval: 500,
            modalSelector: '.modal-content',
            modalTitleText: 'Add New Daily Discount',
            saveButtonSelector: '.btn-submit',
            cancelButtonSelector: 'button.btn-default, button:contains("Close")',
            
            // Field IDs
            brandId: 'brand_id',
            brandContainerId: 'select2-brand_id-container',
            linkedBrandId: 'linked_brand_id',
            linkedBrandContainerId: 'select2-linked_brand_id-container',
            weekdayId: 'weekday_ids',
            categoryId: 'category_ids',
            storeId: 'store_ids',
            discountId: 'discount_rate',
            rebateTypeId: 'daily_discount_type_id',
            rebateTypeContainerId: 'select2-daily_discount_type_id-container',
            vendorContribId: 'rebate_percent',
            afterWholesaleId: 'rebate_wholesale_discount',
            // v12.12.12: Date fields for Monthly/Sale validation
            startDateId: 'date_start',
            endDateId: 'date_end'
        }};
        
        // Expected data from Google Sheet (Phase 2) - CAN BE CLEARED
        let EXPECTED_DATA = {expected_json};
        
        // Validation mode: 'automation' or 'manual'
        let VALIDATION_MODE = EXPECTED_DATA ? 'automation' : 'manual';
        
        // ============================================
        // STATE
        // ============================================
        let validationState = {{
            modalOpen: false,
            rebateTypeValid: false,
            weekdayValid: false,  // NEW: Track weekday validity (CRITICAL)
            fieldWarnings: {{}},
            saveButtonHidden: false,
            originalSaveButton: null,
            errorBox: null,
            forceButton: null,
            compareButton: null,  // V2: Compare to Google Sheet button
            summaryBanner: null,
            saveButtonListener: null,
            cancelButtonListener: null
        }};
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function log(message, level) {{
            level = level || 'INFO';  // Default to 'INFO' if not provided
            console.log(`[MIS-VALIDATION] [${{level}}] ${{message}}`);
        }}
        
        function isModalOpen() {{
            const modal = document.querySelector(CONFIG.modalSelector);
            if (!modal) return false;
            
            const modalTitle = modal.querySelector('.modal-title');
            if (!modalTitle) return false;
            
            // v12.12.5: Check for BOTH "Add New" and "Edit" modals
            const titleText = modalTitle.textContent || '';
            return titleText.includes('Daily Discount') || titleText.includes('Discount');
        }}
        
        // ============================================
        // BUTTON DETECTION
        // ============================================
        function attachSaveButtonListener() {{
            const saveBtn = document.querySelector(CONFIG.saveButtonSelector);
            if (!saveBtn || validationState.saveButtonListener) return;
            
            validationState.saveButtonListener = function() {{
                log('Save button clicked - Stopping validation', 'INFO');
                handleSaveClick();
            }};
            
            saveBtn.addEventListener('click', validationState.saveButtonListener);
            log('Save button listener attached', 'DEBUG');
        }}
        
        function attachCancelButtonListener() {{
            const modal = document.querySelector(CONFIG.modalSelector);
            if (!modal) {{
                log('Modal not found for cancel detection', 'WARN');
                return;
            }}
            
            // Skip if already attached
            if (validationState.cancelButtonListener) return;
            
            // Method 1: Find all buttons with data-dismiss="modal" attribute
            // This catches: <button data-dismiss="modal">Close</button>
            //           and: <button data-dismiss="modal">[EMOJI]</button>
            const dismissButtons = modal.querySelectorAll('[data-dismiss="modal"]');
            
            // Method 2: Find by specific class names
            // This catches: <button class="btn-modal-close">...</button>
            //           and: <button class="close">[EMOJI]</button>
            const closeButtons = modal.querySelectorAll('.btn-modal-close, .close');
            
            // Combine both sets (use Set to avoid duplicates)
            const allCancelButtons = new Set([...dismissButtons, ...closeButtons]);
            
            if (allCancelButtons.size === 0) {{
                log('No cancel buttons found (Close/X)', 'WARN');
                return;
            }}
            
            // Create the handler function once
            validationState.cancelButtonListener = function() {{
                log('Close/X button clicked - Switching to manual mode', 'WARN');
                handleCancelClick();
            }};
            
            // Attach listener to all cancel buttons
            let attachedCount = 0;
            allCancelButtons.forEach(btn => {{
                // Skip if already has listener (prevent double-attach)
                if (btn.dataset.cancelListenerAttached) return;
                
                btn.addEventListener('click', validationState.cancelButtonListener);
                btn.dataset.cancelListenerAttached = 'true';
                attachedCount++;
            }});
            
            log(`Cancel listeners attached to ${{attachedCount}} button(s) (Close/X)`, 'DEBUG');
        }}
        
        function handleSaveClick() {{
            // Stop validation - user is saving
            log('Cleaning up for Save...', 'INFO');
            removeSummaryBanner();
            removeForceButton();
            // Don't set modalOpen = false, let natural modal close handle it
        }}
        
        function handleCancelClick() {{
            // User clicked Close/X button - switch to manual mode immediately
            log('Handling cancel - clearing automation data', 'INFO');
            
            // Clear expected data and switch to manual mode
            EXPECTED_DATA = null;
            VALIDATION_MODE = 'manual';
            validationState.criticalErrors = {{}};
            validationState.fieldWarnings = {{}};
            
            // Clear all validation state
            validationState.fieldWarnings = {{}};
            validationState.criticalErrors = {{}};
            validationState.rebateTypeValid = false;
            validationState.weekdayValid = false;
            
            // Remove all visual indicators immediately (clean slate)
            removeAllRedBoxes();
            removeAllOrangeBoxes();
            removeSummaryBanner();
            
            log('Switched to MANUAL mode (Rebate Type + Weekday only)', 'SUCCESS');
            log('Expected data cleared - next entry will be manual', 'INFO');
            log('All validation boxes cleared - clean slate', 'DEBUG');
        }}
        
        // ============================================
        // FIELD VALUE GETTERS (FIXED MULTI-SELECT)
        // ============================================
        function getRebateTypeValue() {{
            const container = document.getElementById(CONFIG.rebateTypeContainerId);
            if (!container) return null;
            return container.getAttribute('title');
        }}
        
        function getBrandValue() {{
            const container = document.getElementById(CONFIG.brandContainerId);
            if (!container) return null;
            return container.getAttribute('title');
        }}
        
        function getLinkedBrandValue() {{
            const container = document.getElementById(CONFIG.linkedBrandContainerId);
            if (!container) return null;
            return container.getAttribute('title');
        }}
        
        function getWeekdayValues() {{
            const select = document.getElementById(CONFIG.weekdayId);
            if (!select) {{
                log('Weekday select not found', 'WARN');
                return [];
            }}
            
            const selected = [];
            // Use proper iteration for HTMLOptionsCollection
            for (let i = 0; i < select.options.length; i++) {{
                const option = select.options[i];
                if (option.selected) {{
                    selected.push(option.text.trim());
                }}
            }}
            
            log(`Weekday values: [${{selected.join(', ')}}] (count: ${{selected.length}})`, 'DEBUG');
            return selected;
        }}
        
        function getCategoryValues() {{
            const select = document.getElementById(CONFIG.categoryId);
            if (!select) {{
                log('Category select not found', 'WARN');
                return [];
            }}
            
            const selected = [];
            for (let i = 0; i < select.options.length; i++) {{
                const option = select.options[i];
                if (option.selected) {{
                    selected.push(option.text.trim());
                }}
            }}
            
            log(`Category values: [${{selected.join(', ')}}] (count: ${{selected.length}})`, 'DEBUG');
            return selected;
        }}
        
        function getStoreValues() {{
            const select = document.getElementById(CONFIG.storeId);
            if (!select) {{
                log('Store select not found', 'WARN');
                return [];
            }}
            
            const selected = [];
            for (let i = 0; i < select.options.length; i++) {{
                const option = select.options[i];
                if (option.selected) {{
                    selected.push(option.text.trim());
                }}
            }}
            
            log(`Store values: [${{selected.join(', ')}}] (count: ${{selected.length}})`, 'DEBUG');
            return selected;
        }}
        
        function getDiscountValue() {{
            const input = document.getElementById(CONFIG.discountId);
            if (!input) return null;
            return input.value.trim();
        }}
        
        function getVendorContribValue() {{
            const input = document.getElementById(CONFIG.vendorContribId);
            if (!input) return null;
            return input.value.trim();
        }}
        
        function getAfterWholesaleValue() {{
            const checkbox = document.getElementById(CONFIG.afterWholesaleId);
            if (!checkbox) return false;
            return checkbox.checked;
        }}
        
        // v12.12.12: Date field getters for Monthly/Sale validation
        function getStartDateValue() {{
            const input = document.getElementById(CONFIG.startDateId);
            if (!input) return null;
            return input.value.trim();
        }}
        
        function getEndDateValue() {{
            const input = document.getElementById(CONFIG.endDateId);
            if (!input) return null;
            return input.value.trim();
        }}
        
        // v12.12.12: Calculate weekday from date string
        function getWeekdayFromDate(dateStr) {{
            if (!dateStr) return null;
            
            // Handle MM/DD/YYYY or MM/DD/YY format
            let dateParts;
            if (dateStr.includes('/')) {{
                dateParts = dateStr.split('/');
            }} else if (dateStr.includes('-')) {{
                // Handle YYYY-MM-DD format
                const parts = dateStr.split('-');
                dateParts = [parts[1], parts[2], parts[0]];
            }} else {{
                return null;
            }}
            
            if (dateParts.length < 3) return null;
            
            let month = parseInt(dateParts[0], 10) - 1;
            let day = parseInt(dateParts[1], 10);
            let year = parseInt(dateParts[2], 10);
            
            // Handle 2-digit year
            if (year < 100) {{
                year = year + 2000;
            }}
            
            const date = new Date(year, month, day);
            const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return weekdays[date.getDay()];
        }}
        
        // v12.12.12: Find which expected entry matches the current MIS dates
        function findMatchingEntry(allEntries, startDate, endDate) {{
            if (!allEntries || allEntries.length === 0) return null;
            
            for (const entry of allEntries) {{
                if (entry.type === 'monthly') {{
                    // For monthly, start and end date should be the same and match the entry date
                    if (entry.date && startDate === endDate) {{
                        // Compare dates (handle format differences)
                        const entryDateStr = entry.date_short || entry.date;
                        if (startDate === entryDateStr || startDate.includes(entry.date.split('/')[1])) {{
                            return entry;
                        }}
                        // Also try matching by day of month
                        const startDay = parseInt(startDate.split('/')[1], 10);
                        if (startDay === entry.day) {{
                            return entry;
                        }}
                    }}
                }} else if (entry.type === 'sale') {{
                    // For sale, check if the date falls within range
                    const entryDate = entry.date;
                    if (startDate <= entryDate && endDate >= entryDate) {{
                        return entry;
                    }}
                }}
            }}
            return null;
        }}
        
        // v12.12.12: Get other entries that are NOT covered by current MIS entry
        function getOtherExpectedEntries(allEntries, startDate, endDate, selectedWeekdays) {{
            if (!allEntries || allEntries.length <= 1) return [];
            
            const others = [];
            const selectedWeekdaysLower = (selectedWeekdays || []).map(w => w.toLowerCase());
            
            for (const entry of allEntries) {{
                let isCovered = false;
                
                if (entry.type === 'monthly') {{
                    // Check if this day is covered by current MIS entry
                    const startDay = parseInt(startDate.split('/')[1], 10);
                    if (startDate === endDate && startDay === entry.day) {{
                        isCovered = true;
                    }}
                }} else if (entry.type === 'sale') {{
                    // Check if this date is in range AND weekday is selected
                    if (entry.date_obj) {{
                        const entryDateParts = entry.date.split('/');
                        const entryDateStr = entry.date;
                        // Date in range check
                        if (startDate <= entryDateStr && endDate >= entryDateStr) {{
                            // Weekday selected check
                            if (selectedWeekdaysLower.includes(entry.weekday.toLowerCase())) {{
                                isCovered = true;
                            }}
                        }}
                    }}
                }} else if (entry.type === 'weekly') {{
                    // For weekly, check if weekday is in selected weekdays
                    if (selectedWeekdaysLower.includes(entry.weekday.toLowerCase())) {{
                        isCovered = true;
                    }}
                }}
                
                if (!isCovered) {{
                    others.push(entry);
                }}
            }}
            
            return others;
        }}
        
        // ============================================
        // CRITICAL VALIDATION (RED - BLOCKS SAVE)
        // ============================================
        function isRebateTypeValid() {{
            const value = getRebateTypeValue();
            return value && value !== '- Select -';
        }}
        
        function isWeekdayValid() {{
            // Weekday MUST have at least one day selected
            const selected = getWeekdayValues();
            const valid = selected.length > 0;
            log(`Weekday validation: ${{valid ? 'VALID' : 'INVALID'}} (${{selected.length}} days selected)`, valid ? 'SUCCESS' : 'ERROR');
            return valid;
        }}
        
        function validateAllFields() {{
            if (!EXPECTED_DATA || VALIDATION_MODE === 'manual') {{
                log('Manual mode - skipping Phase 2 validation', 'DEBUG');
                return {{}};
            }}
            
            const warnings = {{}};
            
            // Brand
            if (EXPECTED_DATA.brand) {{
                const actual = getBrandValue();
                if (actual && actual !== '- Select -' && actual !== EXPECTED_DATA.brand) {{
                    warnings.brand = {{
                        expected: EXPECTED_DATA.brand,
                        actual: actual,
                        message: `Brand mismatch: Expected "${{EXPECTED_DATA.brand}}", found "${{actual}}"`
                    }};
                }}
            }}
            
            // Linked Brand
            if (EXPECTED_DATA.linked_brand) {{
                const actual = getLinkedBrandValue();
                if (actual && actual !== '- Select -' && actual !== EXPECTED_DATA.linked_brand) {{
                    warnings.linked_brand = {{
                        expected: EXPECTED_DATA.linked_brand,
                        actual: actual,
                        message: `Linked Brand mismatch: Expected "${{EXPECTED_DATA.linked_brand}}", found "${{actual}}"`
                    }};
                }}
            }}
            
            // Rebate Type VALUE comparison (Phase 2 ADVISORY)
            if (EXPECTED_DATA.rebate_type) {{
                const rebateSelect = document.getElementById('daily_discount_type_id');
                if (rebateSelect && rebateSelect.value) {{
                    const actual = rebateSelect.options[rebateSelect.selectedIndex]?.text || rebateSelect.value;
                    const expected = EXPECTED_DATA.rebate_type;
                    if (actual && actual !== expected) {{
                        warnings.rebate_type = {{
                            expected: expected,
                            actual: actual,
                            message: `Rebate Type: Expected "${{expected}}", found "${{actual}}"`
                        }};
                    }}
                }}
            }}
            
            // Weekday (ENHANCED with Extra/Missing detection)
            if (EXPECTED_DATA.weekday) {{
                const actual = getWeekdayValues();
                const expectedStr = EXPECTED_DATA.weekday;
                const expected = expectedStr.split(',').map(d => d.trim()).filter(d => d);
                
                const actualLower = actual.map(d => d.toLowerCase());
                const expectedLower = expected.map(d => d.toLowerCase());
                
                // Find extra and missing days
                const extraDays = actual.filter(day => !expectedLower.includes(day.toLowerCase()));
                const missingDays = expected.filter(day => !actualLower.includes(day.toLowerCase()));
                
                if (extraDays.length > 0 || missingDays.length > 0) {{
                    let msg = `Weekday: Expected "${{expected.join(', ')}}", found "${{actual.join(', ')}}"`;
                    const notes = [];
                    if (extraDays.length > 0) notes.push('Extra: ' + extraDays.join(', '));
                    if (missingDays.length > 0) notes.push('Missing: ' + missingDays.join(', '));
                    if (notes.length > 0) msg += ' (' + notes.join(', ') + ')';
                    
                    warnings.weekday = {{
                        expected: expected.join(', '),
                        actual: actual.join(', '),
                        message: msg
                    }};
                }}
            }}
            
            // Categories (ENHANCED LOGIC - similar to Stores)
            if (EXPECTED_DATA.categories) {{
                const actual = getCategoryValues();
                const expectedText = EXPECTED_DATA.categories.trim();
                const expectedLower = expectedText.toLowerCase();
                
                // Case 1: "All Categories" or "All" - blank actual is correct
                if (expectedLower === 'all categories' || expectedLower === 'all') {{
                    if (actual.length > 0) {{
                        warnings.categories = {{
                            expected: 'All Categories (blank)',
                            actual: actual.join(', '),
                            message: `Category mismatch: Expected "All Categories" (blank), found "${{actual.join(', ')}}"`
                        }};
                    }}
                    // If actual is blank, that's correct - no warning
                }}
                // Case 2: "All Categories (Except: X, Y)" - ignore "*" exceptions
                else if (expectedText.toLowerCase().includes('except')) {{
                    const exceptMatch = expectedText.match(/except[:\\s]*(.+?)(?:\\)|$)/i);
                    if (exceptMatch) {{
                        const exceptionsText = exceptMatch[1];
                        const rawExceptions = exceptionsText.split(',').map(s => s.trim());
                        
                        // Filter out "*" (filler exception) and empty strings
                        const exceptions = rawExceptions.filter(exc => 
                            exc && exc !== '*' && exc.toLowerCase() !== 'none'
                        ).map(s => s.toLowerCase());
                        
                        // If no real exceptions (only "*"), treat as "All Categories"
                        if (exceptions.length === 0) {{
                            if (actual.length > 0) {{
                                warnings.categories = {{
                                    expected: 'All Categories (blank)',
                                    actual: actual.join(', '),
                                    message: `Category mismatch: Expected "All Categories" (blank), found "${{actual.join(', ')}}"`
                                }};
                            }}
                        }} else {{
                            // Has real exceptions - validate properly
                            // For categories, we don't have a master list, so just check if expected text makes sense
                            log(`Categories with real exceptions: ${{exceptions.join(', ')}}`, 'DEBUG');
                            // For now, if blank actual with real exceptions, that might be wrong
                            // But we can't fully validate without master category list
                        }}
                    }}
                }}
                // Case 3: Specific categories
                else {{
                    const expected = expectedText.split(',').map(s => s.trim());
                    const expectedLower = expected.map(s => s.toLowerCase());
                    const actualLower = actual.map(s => s.toLowerCase());
                    
                    const missing = expected.filter(e => !actualLower.includes(e.toLowerCase()));
                    const extra = actual.filter(a => !expectedLower.includes(a.toLowerCase()));
                    
                    if (missing.length > 0 || extra.length > 0) {{
                        warnings.categories = {{
                            expected: expected.join(', '),
                            actual: actual.join(', ') || '(blank)',
                            message: `Category mismatch: Expected "${{expected.join(', ')}}", found "${{actual.join(', ') || '(blank)'}}"`
                        }};
                    }}
                }}
            }}
            
            // Discount
            if (EXPECTED_DATA.discount != null) {{
                const actual = getDiscountValue();
                let expected = String(EXPECTED_DATA.discount);
                
                // Normalize: Strip "%" from both and convert to numbers for comparison
                expected = expected.replace('%', '').trim();
                const actualClean = actual ? actual.replace('%', '').trim() : '';
                
                // Convert to numbers to handle "30.00" vs "30"
                const expectedNum = parseFloat(expected);
                const actualNum = parseFloat(actualClean);
                
                if (!isNaN(expectedNum) && !isNaN(actualNum) && expectedNum !== actualNum) {{
                    warnings.discount = {{
                        expected: expected + '%',
                        actual: actualClean + '%',
                        message: `Discount mismatch: Expected "${{expected}}%", found "${{actualClean}}%"`
                    }};
                }}
            }}
            
            // Vendor Contribution
            if (EXPECTED_DATA.vendor_contrib != null) {{
                const actual = getVendorContribValue();
                let expected = String(EXPECTED_DATA.vendor_contrib);
                
                // Normalize: Strip "%" from both and convert to numbers for comparison
                expected = expected.replace('%', '').trim();
                const actualClean = actual ? actual.replace('%', '').trim() : '';
                
                // Convert to numbers to handle "30.00" vs "30"
                const expectedNum = parseFloat(expected);
                const actualNum = parseFloat(actualClean);
                
                if (!isNaN(expectedNum) && !isNaN(actualNum) && expectedNum !== actualNum) {{
                    warnings.vendor_contrib = {{
                        expected: expected + '%',
                        actual: actualClean + '%',
                        message: `Vendor Contribution mismatch: Expected "${{expected}}%", found "${{actualClean}}%"`
                    }};
                }}
            }}
            
            // After Wholesale toggle
            if (EXPECTED_DATA.after_wholesale != null) {{
                const actual = getAfterWholesaleValue();
                const expected = EXPECTED_DATA.after_wholesale;
                if (actual !== expected) {{
                    warnings.after_wholesale = {{
                        expected: expected ? 'ON' : 'OFF',
                        actual: actual ? 'ON' : 'OFF',
                        message: `After Wholesale toggle mismatch: Expected "${{expected ? 'ON' : 'OFF'}}", found "${{actual ? 'ON' : 'OFF'}}"`
                    }};
                }}
            }}
            
            // Stores (v12.12.7 - ENHANCED LOGIC with store mapping)
            // Handle: "All Locations", "All Locations Except: X, Y", specific stores, blank
            if (EXPECTED_DATA.locations !== undefined) {{
                const actual = getStoreValues();
                const expectedText = (EXPECTED_DATA.locations || '').trim();
                const expectedLower = expectedText.toLowerCase();
                
                // Store name mapping: Google Sheet name -> MIS display name
                const STORE_MAP = {{
                    'beverly hills': 'beverly',
                    'beverly': 'beverly',
                    'davis': 'davis',
                    'dixon': 'dixon',
                    'el sobrante': 'el sobrante',
                    'fresno (palm)': 'fresno',
                    'fresno': 'fresno',
                    'fresno shaw': 'fresno shaw',
                    'fresno (shaw)': 'fresno shaw',
                    'hawthorne': 'hawthorne',
                    'koreatown': 'koreatown',
                    'laguna woods': 'laguna woods',
                    'oxnard': 'oxnard',
                    'riverside': 'riverside',
                    'west hollywood': 'west hollywood'
                }};
                
                // Master list of MIS store names
                const MASTER_STORES_MIS = [
                    'Beverly', 'Davis', 'Dixon', 'El Sobrante', 'Fresno', 'Fresno Shaw',
                    'Hawthorne', 'Koreatown', 'Laguna Woods', 'Oxnard', 'Riverside', 'West Hollywood'
                ];
                
                // Helper: Normalize store name from Google Sheet to MIS format
                function normalizeStoreName(name) {{
                    const lower = name.toLowerCase().trim();
                    return STORE_MAP[lower] || lower;
                }}
                
                // Helper: Check if two store names match (case-insensitive, with mapping)
                function storesMatch(actual, expected) {{
                    const actualNorm = normalizeStoreName(actual);
                    const expectedNorm = normalizeStoreName(expected);
                    return actualNorm === expectedNorm;
                }}
                
                // Get actual store count
                const actualCount = actual.length;
                const allStoresCount = MASTER_STORES_MIS.length; // 12
                
                log(`Store validation: actual=${{actual.join(', ')}} (count: ${{actualCount}}), expected="${{expectedText}}"`, 'DEBUG');
                
                // Case 1: "All Locations" OR blank/empty = expects blank OR all 12 stores
                if (expectedLower === 'all locations' || expectedLower === 'all' || expectedLower === '') {{
                    // Valid states: blank (0 stores) OR all 12 stores selected
                    if (actualCount === 0 || actualCount === allStoresCount) {{
                        // CORRECT - no warning needed
                        log(`Store validation: All Locations - CORRECT (actual: ${{actualCount}} stores)`, 'DEBUG');
                    }} else {{
                        warnings.stores = {{
                            expected: 'All Locations (blank or all 12 stores)',
                            actual: actual.join(', ') || '(blank)',
                            message: `Store mismatch: Expected "All Locations" (blank or all 12), found ${{actualCount}} stores: "${{actual.join(', ')}}"`
                        }};
                    }}
                }}
                // Case 2: "All Locations Except: X, Y"
                else if (expectedLower.includes('except')) {{
                    // Parse exceptions - handle various formats
                    const exceptMatch = expectedText.match(/except[:\\s,]*(.+?)(?:\\)|$)/i);
                    if (exceptMatch) {{
                        const exceptionsText = exceptMatch[1];
                        // Split by comma, filter empty strings
                        const rawExceptions = exceptionsText.split(',')
                            .map(s => s.trim())
                            .filter(s => s && s !== '');
                        
                        // Normalize exception names to MIS format
                        const exceptionsNorm = rawExceptions.map(e => normalizeStoreName(e));
                        
                        log(`Store exceptions (raw): ${{rawExceptions.join(', ')}}`, 'DEBUG');
                        log(`Store exceptions (normalized): ${{exceptionsNorm.join(', ')}}`, 'DEBUG');
                        
                        // Build expected stores list: all stores EXCEPT the exceptions
                        const expectedStores = MASTER_STORES_MIS.filter(store => {{
                            const storeNorm = store.toLowerCase();
                            // Check if this store is in the exception list
                            const isException = exceptionsNorm.some(exc => 
                                storeNorm === exc || 
                                storeNorm.includes(exc) || 
                                exc.includes(storeNorm)
                            );
                            return !isException;
                        }});
                        
                        log(`Expected stores after exclusions: ${{expectedStores.join(', ')}}`, 'DEBUG');
                        
                        // Compare actual vs expected
                        const actualNorm = actual.map(s => s.toLowerCase());
                        const expectedNorm = expectedStores.map(s => s.toLowerCase());
                        
                        const missing = expectedStores.filter(s => !actualNorm.includes(s.toLowerCase()));
                        const extra = actual.filter(s => !expectedNorm.includes(s.toLowerCase()));
                        
                        if (missing.length > 0 || extra.length > 0) {{
                            let msg = `Store mismatch:`;
                            if (missing.length > 0) msg += ` Missing: ${{missing.join(', ')}}.`;
                            if (extra.length > 0) msg += ` Extra: ${{extra.join(', ')}}.`;
                            
                            warnings.stores = {{
                                expected: expectedStores.join(', '),
                                actual: actual.join(', ') || '(blank)',
                                message: msg
                            }};
                        }} else {{
                            log(`Store validation: All Locations Except - CORRECT`, 'DEBUG');
                        }}
                    }}
                }}
                // Case 3: Specific stores listed
                else {{
                    // Parse expected stores from comma-separated list
                    const expectedStores = expectedText.split(',')
                        .map(s => s.trim())
                        .filter(s => s && s !== '');
                    
                    // Normalize expected store names to MIS format for comparison
                    const expectedStoresNorm = expectedStores.map(s => normalizeStoreName(s));
                    const actualNorm = actual.map(s => s.toLowerCase());
                    
                    log(`Specific stores expected (raw): ${{expectedStores.join(', ')}}`, 'DEBUG');
                    log(`Specific stores expected (normalized): ${{expectedStoresNorm.join(', ')}}`, 'DEBUG');
                    
                    // Find missing and extra stores
                    const missing = expectedStores.filter((s, i) => !actualNorm.includes(expectedStoresNorm[i]));
                    const extra = actual.filter(s => !expectedStoresNorm.includes(s.toLowerCase()));
                    
                    if (missing.length > 0 || extra.length > 0) {{
                        let msg = `Store mismatch:`;
                        if (missing.length > 0) msg += ` Missing: ${{missing.join(', ')}}.`;
                        if (extra.length > 0) msg += ` Extra: ${{extra.join(', ')}}.`;
                        
                        warnings.stores = {{
                            expected: expectedStores.join(', '),
                            actual: actual.join(', ') || '(blank)',
                            message: msg
                        }};
                    }} else {{
                        log(`Store validation: Specific stores - CORRECT`, 'DEBUG');
                    }}
                }}
            }}
            
            // v12.12.12: Section-specific date validation for Monthly and Sale deals
            const sectionType = EXPECTED_DATA.section_type || 'weekly';
            const allExpectedEntries = EXPECTED_DATA.all_expected_entries || [];
            
            if (sectionType === 'monthly' && allExpectedEntries.length > 0) {{
                log(`Monthly deal validation - ${{allExpectedEntries.length}} expected entries`, 'DEBUG');
                
                const startDate = getStartDateValue();
                const endDate = getEndDateValue();
                const selectedWeekdays = getWeekdayValues();
                
                log(`MIS Dates: Start=${{startDate}}, End=${{endDate}}, Weekdays=${{selectedWeekdays.join(', ')}}`, 'DEBUG');
                
                // Monthly deals: start and end date should be the same (single day)
                if (startDate && endDate && startDate !== endDate) {{
                    warnings.date_range = {{
                        expected: 'Same date (single day)',
                        actual: `${{startDate}} to ${{endDate}}`,
                        message: `Monthly deals should have same start/end date (single day). Found range: ${{startDate}} - ${{endDate}}`
                    }};
                }}
                
                // Verify weekday matches the date
                if (startDate && selectedWeekdays.length > 0) {{
                    const calculatedWeekday = getWeekdayFromDate(startDate);
                    if (calculatedWeekday) {{
                        const selectedWeekdayLower = selectedWeekdays[0].toLowerCase();
                        const calculatedLower = calculatedWeekday.toLowerCase();
                        
                        if (selectedWeekdayLower !== calculatedLower) {{
                            warnings.weekday_date_mismatch = {{
                                expected: calculatedWeekday,
                                actual: selectedWeekdays[0],
                                message: `Weekday/Date mismatch: ${{startDate}} is a ${{calculatedWeekday}}, but "${{selectedWeekdays[0]}}" is selected`
                            }};
                        }} else {{
                            log(`Monthly weekday validation: CORRECT (${{startDate}} is ${{calculatedWeekday}})`, 'DEBUG');
                        }}
                    }}
                }}
                
                // Find other expected entries (for multi-day monthly deals like "1st, 10th")
                if (startDate) {{
                    const startDay = parseInt(startDate.split('/')[1], 10);
                    const otherEntries = allExpectedEntries.filter(e => e.day !== startDay);
                    
                    if (otherEntries.length > 0) {{
                        warnings._otherEntriesExpected = otherEntries;
                        log(`Other entries expected: ${{otherEntries.length}} more`, 'DEBUG');
                    }}
                }}
            }}
            
            if (sectionType === 'sale' && allExpectedEntries.length > 0) {{
                log(`Sale deal validation - ${{allExpectedEntries.length}} expected entries`, 'DEBUG');
                
                const startDate = getStartDateValue();
                const endDate = getEndDateValue();
                const selectedWeekdays = getWeekdayValues();
                
                log(`MIS Dates: Start=${{startDate}}, End=${{endDate}}, Weekdays=${{selectedWeekdays.join(', ')}}`, 'DEBUG');
                
                // Check if all expected sale dates are within the MIS date range
                // and their weekdays are selected
                const coveredEntries = [];
                const uncoveredEntries = [];
                
                for (const entry of allExpectedEntries) {{
                    const entryDateStr = entry.date;
                    const entryWeekday = entry.weekday;
                    
                    // Simple date comparison (MM/DD/YY format)
                    // Check if entryDate is within startDate to endDate
                    let isInRange = false;
                    let weekdaySelected = false;
                    
                    if (startDate && endDate) {{
                        // Compare dates
                        isInRange = (entryDateStr >= startDate && entryDateStr <= endDate);
                    }}
                    
                    if (selectedWeekdays.length > 0) {{
                        weekdaySelected = selectedWeekdays.some(w => w.toLowerCase() === entryWeekday.toLowerCase());
                    }}
                    
                    if (isInRange && weekdaySelected) {{
                        coveredEntries.push(entry);
                    }} else {{
                        uncoveredEntries.push(entry);
                    }}
                }}
                
                log(`Sale validation: ${{coveredEntries.length}} covered, ${{uncoveredEntries.length}} uncovered`, 'DEBUG');
                
                // If some entries are not covered, add to warnings
                if (uncoveredEntries.length > 0) {{
                    warnings._otherEntriesExpected = uncoveredEntries;
                }}
                
                // Check if end date extends beyond the last sale date (advisory warning)
                if (endDate && allExpectedEntries.length > 0) {{
                    const lastSaleDate = allExpectedEntries[allExpectedEntries.length - 1].date;
                    if (endDate > lastSaleDate) {{
                        warnings.end_date_extended = {{
                            expected: lastSaleDate,
                            actual: endDate,
                            message: `End date (${{endDate}}) extends beyond last sale date (${{lastSaleDate}}) - may not cause issues but should be ${{lastSaleDate}} for cleanliness`
                        }};
                    }}
                }}
            }}
            
            return warnings;
        }}
        
        // ============================================
        // VISUAL INDICATORS - RED (CRITICAL)
        // ============================================
        function addRedBox(fieldId, containerId, tooltip) {{
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            const container = field.nextElementSibling;
            if (container && container.classList.contains('select2')) {{
                container.style.border = '3px solid #dc3545';
                container.style.borderRadius = '4px';
                container.style.boxShadow = '0 0 10px rgba(220, 53, 69, 0.5)';
                container.setAttribute('title', tooltip);
            }}
            
            log(`Added RED box to ${{fieldId}}`, 'WARN');
        }}
        
        function removeRedBox(fieldId, containerId) {{
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            const container = field.nextElementSibling;
            if (container && container.classList.contains('select2')) {{
                container.style.border = '';
                container.style.borderRadius = '';
                container.style.boxShadow = '';
                container.removeAttribute('title');
            }}
            
            log(`Removed RED box from ${{fieldId}}`, 'SUCCESS');
        }}
        
        function removeAllRedBoxes() {{
            // Remove RED boxes from all critical fields
            removeRedBox(CONFIG.rebateTypeId, CONFIG.rebateTypeContainerId);
            removeRedBox(CONFIG.weekdayId, null);
            log('Removed all RED boxes', 'DEBUG');
        }}
        
        // ============================================
        // VISUAL INDICATORS - ORANGE (ADVISORY)
        // ============================================
        function addOrangeBox(fieldId, isSelect2, tooltip) {{
            const field = document.getElementById(fieldId);
            if (!field) {{
                log(`Field not found: ${{fieldId}}`, 'WARN');
                return;
            }}
            
            if (isSelect2) {{
                const container = field.nextElementSibling;
                if (container && container.classList.contains('select2')) {{
                    container.style.border = '3px solid #ff9800';
                    container.style.borderRadius = '4px';
                    container.style.boxShadow = '0 0 10px rgba(255, 152, 0, 0.5)';
                    container.setAttribute('title', tooltip);
                    log(`Added ORANGE box to ${{fieldId}} (Select2)`, 'WARN');
                }} else {{
                    log(`Select2 container not found for ${{fieldId}}`, 'WARN');
                }}
            }} else if (fieldId === CONFIG.afterWholesaleId) {{
                const row = field.closest('.input-row');
                if (row) {{
                    row.style.border = '3px solid #ff9800';
                    row.style.borderRadius = '4px';
                    row.style.boxShadow = '0 0 10px rgba(255, 152, 0, 0.5)';
                    row.style.padding = '5px';
                    row.setAttribute('title', tooltip);
                    log(`Added ORANGE box to After Wholesale (toggle row)`, 'WARN');
                }} else {{
                    log(`Toggle row not found for ${{fieldId}}`, 'WARN');
                }}
            }} else {{
                field.style.border = '3px solid #ff9800';
                field.style.borderRadius = '4px';
                field.style.boxShadow = '0 0 10px rgba(255, 152, 0, 0.5)';
                field.setAttribute('title', tooltip);
                log(`Added ORANGE box to ${{fieldId}} (input)`, 'WARN');
            }}
        }}
        
        function removeOrangeBox(fieldId, isSelect2) {{
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            if (isSelect2) {{
                const container = field.nextElementSibling;
                if (container && container.classList.contains('select2')) {{
                    container.style.border = '';
                    container.style.borderRadius = '';
                    container.style.boxShadow = '';
                    container.removeAttribute('title');
                }}
            }} else if (fieldId === CONFIG.afterWholesaleId) {{
                const row = field.closest('.input-row');
                if (row) {{
                    row.style.border = '';
                    row.style.borderRadius = '';
                    row.style.boxShadow = '';
                    row.style.padding = '';
                    row.removeAttribute('title');
                }}
            }} else {{
                field.style.border = '';
                field.style.borderRadius = '';
                field.style.boxShadow = '';
                field.removeAttribute('title');
            }}
        }}
        
        function removeAllOrangeBoxes() {{
            // Remove ORANGE boxes from all advisory fields
            removeOrangeBox(CONFIG.brandId, true);
            removeOrangeBox(CONFIG.linkedBrandId, true);
            removeOrangeBox(CONFIG.weekdayId, true);
            removeOrangeBox(CONFIG.categoryId, true);
            removeOrangeBox(CONFIG.storeId, true);
            removeOrangeBox(CONFIG.discountId, false);
            removeOrangeBox(CONFIG.vendorContribId, false);
            removeOrangeBox(CONFIG.afterWholesaleId, false);
            log('Removed all ORANGE boxes', 'DEBUG');
        }}
        
        function updateFieldWarnings(warnings) {{
            // Remove all orange boxes first
            removeOrangeBox(CONFIG.brandId, true);
            removeOrangeBox(CONFIG.linkedBrandId, true);
            removeOrangeBox(CONFIG.weekdayId, true);
            removeOrangeBox(CONFIG.categoryId, true);
            removeOrangeBox(CONFIG.storeId, true);
            removeOrangeBox(CONFIG.discountId, false);
            removeOrangeBox(CONFIG.vendorContribId, false);
            removeOrangeBox(CONFIG.afterWholesaleId, false);
            
            // Add orange boxes for warnings
            if (warnings.brand) {{
                addOrangeBox(CONFIG.brandId, true, `[EMOJI] ${{warnings.brand.message}}`);
            }}
            if (warnings.linked_brand) {{
                addOrangeBox(CONFIG.linkedBrandId, true, `[EMOJI] ${{warnings.linked_brand.message}}`);
            }}
            if (warnings.weekday) {{
                addOrangeBox(CONFIG.weekdayId, true, `[EMOJI] ${{warnings.weekday.message}}`);
            }}
            if (warnings.categories) {{
                addOrangeBox(CONFIG.categoryId, true, `[EMOJI] ${{warnings.categories.message}}`);
            }}
            if (warnings.stores) {{
                addOrangeBox(CONFIG.storeId, true, `[EMOJI] ${{warnings.stores.message}}`);
            }}
            if (warnings.discount) {{
                addOrangeBox(CONFIG.discountId, false, `[EMOJI] ${{warnings.discount.message}}`);
            }}
            if (warnings.vendor_contrib) {{
                addOrangeBox(CONFIG.vendorContribId, false, `[EMOJI] ${{warnings.vendor_contrib.message}}`);
            }}
            if (warnings.after_wholesale) {{
                addOrangeBox(CONFIG.afterWholesaleId, false, `[EMOJI] ${{warnings.after_wholesale.message}}`);
            }}
        }}
        
        // ============================================
        // v12.12.12: OTHER ENTRIES EXPECTED SECTION BUILDER
        // ============================================
        function buildOtherEntriesSection(otherEntries) {{
            if (!otherEntries || otherEntries.length === 0) return '';
            
            let entriesHtml = '';
            for (const entry of otherEntries) {{
                if (entry.type === 'monthly') {{
                    entriesHtml += `
                        <div style="margin: 4px 0; font-size: 0.85em;">
                            <strong>${{entry.ordinal}}</strong>: 
                            Start/End: ${{entry.date_short || entry.date}}, 
                            Weekday: ${{entry.weekday}}
                        </div>
                    `;
                }} else if (entry.type === 'sale') {{
                    entriesHtml += `
                        <div style="margin: 4px 0; font-size: 0.85em;">
                            <strong>${{entry.date}}</strong> (${{entry.weekday}})
                        </div>
                    `;
                }}
            }}
            
            return `
                <div style="
                    border: 2px solid rgba(255,255,255,0.6);
                    border-radius: 6px;
                    padding: 10px;
                    margin-left: 15px;
                    min-width: 200px;
                    max-width: 300px;
                    background: rgba(255,255,255,0.1);
                ">
                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 0.95em; border-bottom: 1px solid rgba(255,255,255,0.3); padding-bottom: 5px;">
                        [EMOJI] [EMOJI] Other Entries Expected
                    </div>
                    <div style="font-weight: normal; font-size: 0.85em; margin-bottom: 8px;">
                        ${{otherEntries.length}} more MIS ${{otherEntries.length === 1 ? 'entry' : 'entries'}} needed:
                    </div>
                    ${{entriesHtml}}
                </div>
            `;
        }}
        
        // ============================================
        // PERSISTENT SUMMARY BANNER
        // ============================================
        function createSummaryBanner(warnings, criticalErrors) {{
            // Remove existing banner
            if (validationState.summaryBanner) {{
                validationState.summaryBanner.remove();
                validationState.summaryBanner = null;
            }}
            
            // v12.12.12: Extract _otherEntriesExpected from warnings (not a real warning)
            const otherEntriesExpected = warnings ? warnings._otherEntriesExpected : null;
            const displayWarnings = {{}};
            for (const [key, value] of Object.entries(warnings || {{}})) {{
                if (key !== '_otherEntriesExpected') {{
                    displayWarnings[key] = value;
                }}
            }}
            
            const criticalCount = Object.keys(criticalErrors || {{}}).length;
            const warningCount = Object.keys(displayWarnings || {{}}).length;
            const totalIssues = criticalCount + warningCount;
            
            const banner = document.createElement('div');
            banner.id = 'mis-validation-summary';
            
            // Determine banner color: RED for critical, ORANGE for advisory only, GREEN for all correct
            if (totalIssues === 0) {{
                // ALL CORRECT - Green banner
                banner.style.cssText = `
                    background: #28a745;
                    color: white;
                    padding: 12px 15px;
                    margin-bottom: 15px;
                    border-radius: 4px;
                    font-weight: bold;
                    text-align: center;
                    display: flex;
                    justify-content: space-between;
                    align-items: flex-start;
                `;
                
                let mainContent = '';
                if (VALIDATION_MODE === 'automation') {{
                    mainContent = `
                        <div style="flex: 1;">
                            <div style="font-size: 1.1em;">
                                [EMOJI] All Fields Correct - Ready to Save!
                            </div>
                            <div style="font-weight: normal; font-size: 0.85em; margin-top: 5px;">
                                Automation mode: Validating against Google Sheet
                            </div>
                        </div>
                    `;
                }} else {{
                    mainContent = `
                        <div style="flex: 1;">
                            <div style="font-size: 1.1em;">
                                [EMOJI] Critical Fields Filled - Ready to Save!
                            </div>
                            <div style="font-weight: normal; font-size: 0.85em; margin-top: 5px;">
                                Manual mode: Validating Rebate Type + Weekday only
                            </div>
                        </div>
                    `;
                }}
                
                // v12.12.12: Add "Other Entries Expected" section if needed
                let otherEntriesSection = '';
                if (otherEntriesExpected && otherEntriesExpected.length > 0) {{
                    otherEntriesSection = buildOtherEntriesSection(otherEntriesExpected);
                }}
                
                banner.innerHTML = mainContent + otherEntriesSection;
            }} else {{
                // HAS ISSUES - RED for critical, ORANGE for advisory only
                const hasCritical = criticalCount > 0;
                const bgColor = hasCritical ? '#dc3545' : '#ff9800';  // RED or ORANGE
                
                banner.style.cssText = `
                    background: ${{bgColor}};
                    color: white;
                    padding: 12px 15px;
                    margin-bottom: 15px;
                    border-radius: 4px;
                    font-weight: bold;
                    text-align: left;
                    display: flex;
                    justify-content: space-between;
                    align-items: flex-start;
                `;
                
                // v12.19: SIMPLIFIED BANNER - No detailed error list (checklist shows that)
                // Just show high-level status and key metadata
                
                // Build header text
                const plural = totalIssues > 1 ? 's' : '';
                let headerText = '';
                let subtitleText = '';
                
                if (hasCritical) {{
                    // RED banner - has critical errors
                    const blockingText = criticalCount === 1 ? '1 error blocking' : `${{criticalCount}} errors blocking`;
                    headerText = `[EMOJI] ${{totalIssues}} Issue${{plural}} Found (${{blockingText}} save)`;
                    subtitleText = 'Check the Deal Entry Checklist panel for details [EMOJI]';
                }} else {{
                    // ORANGE banner - advisory only
                    headerText = `[EMOJI] ${{totalIssues}} Field${{plural}} May Need Review`;
                    subtitleText = 'See Deal Entry Checklist panel for details [EMOJI]';
                }}
                
                // v12.19: Extract deal metadata from EXPECTED_DATA if available
                let dealMetadata = '';
                if (typeof EXPECTED_DATA !== 'undefined' && EXPECTED_DATA) {{
                    const dealType = EXPECTED_DATA.section_type || 'Unknown';
                    const brandName = EXPECTED_DATA.brand || 'Unknown Brand';
                    const duration = (EXPECTED_DATA.all_expected_entries && EXPECTED_DATA.all_expected_entries.length > 1) 
                        ? 'Multi-Day' 
                        : 'Single-Day';
                    
                    dealMetadata = `
                        <div style="font-size: 0.85em; margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.3); text-align: center;">
                            [EMOJI] ${{dealType.toUpperCase()}} | ${{duration}} | ${{brandName}}
                        </div>
                    `;
                }}
                
                // v12.12.12: Add "Other Entries Expected" section if needed
                let otherEntriesSection = '';
                if (otherEntriesExpected && otherEntriesExpected.length > 0) {{
                    otherEntriesSection = buildOtherEntriesSection(otherEntriesExpected);
                }}
                
                banner.innerHTML = `
                    <div style="flex: 1;">
                        <div style="text-align: center; margin-bottom: 8px; font-size: 1.1em;">
                            ${{headerText}}
                        </div>
                        <div style="font-weight: normal; text-align: center; font-size: 0.85em;">
                            ${{subtitleText}}
                        </div>
                        ${{dealMetadata}}
                    </div>
                    ${{otherEntriesSection}}
                `;
            }}
            
            // Insert at top of modal body
            const modalBody = document.querySelector('.modal-body');
            if (modalBody) {{
                modalBody.insertBefore(banner, modalBody.firstChild);
                validationState.summaryBanner = banner;
                
                if (totalIssues === 0) {{
                    log(`Persistent banner created: ALL CORRECT`, 'INFO');
                }} else {{
                    log(`Persistent banner created: ${{criticalCount}} critical, ${{warningCount}} advisory`, 'INFO');
                }}
            }}
        }}
        
        function removeSummaryBanner() {{
            if (validationState.summaryBanner) {{
                validationState.summaryBanner.remove();
                validationState.summaryBanner = null;
            }}
        }}
        
        // ============================================
        // SAVE BUTTON CONTROL
        // ============================================
        function hideSaveButton() {{
            if (validationState.saveButtonHidden) return;
            
            const saveBtn = document.querySelector(CONFIG.saveButtonSelector);
            if (!saveBtn) {{
                log('Save button not found', 'ERROR');
                return;
            }}
            
            validationState.originalSaveButton = saveBtn;
            saveBtn.style.display = 'none';
            
            const errorBox = document.createElement('div');
            errorBox.id = 'mis-validation-error-box';
            errorBox.style.cssText = `
                background: #dc3545;
                color: white;
                padding: 10px 15px;
                border-radius: 4px;
                margin-bottom: 10px;
                font-weight: bold;
                text-align: center;
            `;
            errorBox.innerHTML = `
                [EMOJI] CRITICAL ERROR - Cannot Save<br>
                <small style="font-weight: normal;">[EMOJI] Rebate Type must be selected (Wholesale or Retail)</small>
            `;
            
            saveBtn.parentNode.insertBefore(errorBox, saveBtn);
            validationState.errorBox = errorBox;
            validationState.saveButtonHidden = true;
            log('Save button hidden - Rebate Type validation failed', 'WARN');
        }}
        
        function showSaveButton() {{
            if (!validationState.saveButtonHidden) return;
            
            if (validationState.errorBox) {{
                validationState.errorBox.remove();
                validationState.errorBox = null;
            }}
            
            if (validationState.originalSaveButton) {{
                validationState.originalSaveButton.style.display = '';
                log('Save button restored - Validation passed', 'SUCCESS');
            }}
            
            validationState.saveButtonHidden = false;
        }}
        
        // ============================================
        // FORCE SHOW SAVE BUTTON (SAFETY OVERRIDE)
        // ============================================
        function createForceButton() {{
            if (validationState.forceButton) return;
            
            const forceBtn = document.createElement('button');
            forceBtn.id = 'force-show-save-btn';
            forceBtn.textContent = 'Force Show Save';
            forceBtn.style.cssText = `
                position: fixed;
                top: 10px;
                left: 10px;
                z-index: 99999;
                background: #ffc107;
                color: #000;
                border: 2px solid #ff9800;
                padding: 8px 12px;
                border-radius: 4px;
                font-weight: bold;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            `;
            forceBtn.onclick = function() {{
                log('FORCE OVERRIDE: User clicked Force Show Save', 'WARN');
                showSaveButton();
                log('Force button remains active (persistent during validation)', 'INFO');
            }};
            
            document.body.appendChild(forceBtn);
            validationState.forceButton = forceBtn;
            log('Force Show Save button created (persistent safety override)', 'INFO');
        }}
        
        function removeForceButton() {{
            if (validationState.forceButton) {{
                validationState.forceButton.remove();
                validationState.forceButton = null;
                log('Force Show Save button removed (modal closed)', 'INFO');
            }}
        }}
        
        // ============================================
        // COMPARE TO GOOGLE SHEET BUTTON (V2.1 - Listening Mode)
        // ============================================
        let listeningMode = false;
        let notFoundMode = false;  // v12.12.8: Track if MIS ID was not found
        let datatableClickHandler = null;
        const FLASK_BACKEND = 'http://127.0.0.1:5100';
        
        function createCompareButton() {{
            if (validationState.compareButton) return;
            
            const compareBtn = document.createElement('button');
            compareBtn.id = 'compare-to-sheet-btn';
            compareBtn.textContent = 'Compare to Google Sheet';
            compareBtn.style.cssText = `
                position: fixed;
                top: 10px;
                left: 160px;
                z-index: 99999;
                background: #17a2b8;
                color: #fff;
                border: 2px solid #138496;
                padding: 8px 12px;
                border-radius: 4px;
                font-weight: bold;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                transition: all 0.3s ease;
            `;
            compareBtn.title = 'Click to enter listening mode, then click a row in the datatable';
            
            compareBtn.onclick = function() {{
                if (!listeningMode) {{
                    enterListeningMode(compareBtn);
                }} else {{
                    exitListeningMode(compareBtn);
                }}
            }};
            
            document.body.appendChild(compareBtn);
            validationState.compareButton = compareBtn;
            log('Compare to Google Sheet button created', 'INFO');
        }}
        
        function enterListeningMode(btn) {{
            listeningMode = true;
            notFoundMode = false;  // v12.12.8: Reset not-found flag when entering listening mode
            log('[EMOJI] Entering LISTENING MODE - Click a row in the datatable', 'INFO');
            
            // Update button appearance
            btn.textContent = '[EMOJI] Click a Row...';
            btn.style.background = '#ffc107';
            btn.style.color = '#000';
            btn.style.border = '2px solid #e0a800';
            btn.style.animation = 'pulse 1.5s infinite';
            btn.title = 'Click a MIS ID or Edit button in the datatable (or click here to cancel)';
            
            // Add pulse animation if not exists
            if (!document.getElementById('compare-btn-pulse-style')) {{
                const style = document.createElement('style');
                style.id = 'compare-btn-pulse-style';
                style.textContent = `
                    @keyframes pulse {{
                        0% {{ box-shadow: 0 0 0 0 rgba(255, 193, 7, 0.7); }}
                        70% {{ box-shadow: 0 0 0 10px rgba(255, 193, 7, 0); }}
                        100% {{ box-shadow: 0 0 0 0 rgba(255, 193, 7, 0); }}
                    }}
                `;
                document.head.appendChild(style);
            }}
            
            // Attach click listener to datatable
            attachDatatableListener();
        }}
        
        function exitListeningMode(btn) {{
            listeningMode = false;
            log('Exiting listening mode', 'INFO');
            
            // v12.12.8: Don't reset button if in "Not Found" mode - keep RED
            if (notFoundMode) {{
                log('Preserving NOT FOUND button state (RED)', 'DEBUG');
                // Just remove the listener, don't reset button appearance
                removeDatatableListener();
                return;
            }}
            
            // Restore button appearance (only if NOT in notFoundMode)
            btn.textContent = 'Compare to Google Sheet';
            btn.style.background = '#17a2b8';
            btn.style.color = '#fff';
            btn.style.border = '2px solid #138496';
            btn.style.animation = 'none';
            btn.title = 'Click to enter listening mode, then click a row in the datatable';
            
            // Remove datatable listener
            removeDatatableListener();
        }}
        
        function attachDatatableListener() {{
            // Find the datatable - try multiple selectors
            const datatable = document.querySelector('#daily-discount-table, .dataTable, table.table, #DataTables_Table_0');
            
            if (!datatable) {{
                log('[EMOJI] Could not find datatable to attach listener', 'WARN');
                alert('Could not find datatable. Make sure you are on the Daily Discount page.');
                return;
            }}
            
            log('[EMOJI] Attaching click listener to datatable', 'DEBUG');
            
            datatableClickHandler = async function(event) {{
                // Check if we clicked on a MIS ID link or Edit button
                const target = event.target;
                const row = target.closest('tr');
                
                if (!row) return;
                
                let misId = null;
                
                // Method 1: Clicked directly on a link/cell containing the MIS ID
                // MIS IDs are typically 3-7 digit numbers
                if (target.tagName === 'A' || target.tagName === 'TD' || target.tagName === 'SPAN') {{
                    const text = target.textContent.trim();
                    const match = text.match(/^(\\d{{3,7}})$/);
                    if (match) {{
                        misId = match[1];
                        log(`Clicked MIS ID directly: ${{misId}}`, 'INFO');
                    }}
                }}
                
                // Method 2: Clicked Edit button - find MIS ID from the row
                if (!misId && (target.classList.contains('edit') || 
                              target.classList.contains('btn-edit') ||
                              target.classList.contains('fa-edit') ||
                              target.classList.contains('fa-pencil') ||
                              target.textContent.toLowerCase().includes('edit') ||
                              target.closest('button')?.textContent.toLowerCase().includes('edit') ||
                              target.closest('a')?.classList.contains('edit'))) {{
                    // Search the row for a cell containing just a number (MIS ID)
                    const cells = row.querySelectorAll('td');
                    for (const cell of cells) {{
                        const text = cell.textContent.trim();
                        const match = text.match(/^(\\d{{3,7}})$/);
                        if (match) {{
                            misId = match[1];
                            log(`Found MIS ID from row (edit click): ${{misId}}`, 'INFO');
                            break;
                        }}
                    }}
                    
                    // Also check for links within the row
                    if (!misId) {{
                        const links = row.querySelectorAll('a');
                        for (const link of links) {{
                            const text = link.textContent.trim();
                            const match = text.match(/^(\\d{{3,7}})$/);
                            if (match) {{
                                misId = match[1];
                                log(`Found MIS ID from row link: ${{misId}}`, 'INFO');
                                break;
                            }}
                        }}
                    }}
                }}
                
                // Method 3: Check first cell which often contains ID
                if (!misId) {{
                    const firstCell = row.querySelector('td:first-child');
                    if (firstCell) {{
                        const text = firstCell.textContent.trim();
                        const match = text.match(/^(\\d{{3,7}})$/);
                        if (match) {{
                            misId = match[1];
                            log(`Found MIS ID from first cell: ${{misId}}`, 'INFO');
                        }}
                    }}
                }}
                
                // Method 4: Check if any cell in the row has data-id or similar attribute
                if (!misId) {{
                    const cellWithId = row.querySelector('[data-id], [data-mis-id], [data-discount-id]');
                    if (cellWithId) {{
                        misId = cellWithId.dataset.id || cellWithId.dataset.misId || cellWithId.dataset.discountId;
                        if (misId) {{
                            log(`Found MIS ID from data attribute: ${{misId}}`, 'INFO');
                        }}
                    }}
                }}
                
                // Method 5: Row itself might have data-id
                if (!misId && row.dataset.id) {{
                    misId = row.dataset.id;
                    log(`Found MIS ID from row data-id: ${{misId}}`, 'INFO');
                }}
                
                if (misId) {{
                    log(`[EMOJI] Captured MIS ID: ${{misId}} - calling backend`, 'INFO');
                    await compareToGoogleSheet(misId);
                    exitListeningMode(validationState.compareButton);
                }}
            }};
            
            datatable.addEventListener('click', datatableClickHandler);
            log('[EMOJI] Datatable click listener attached', 'DEBUG');
        }}
        
        function removeDatatableListener() {{
            if (datatableClickHandler) {{
                const datatable = document.querySelector('#daily-discount-table, .dataTable, table.table, #DataTables_Table_0');
                if (datatable) {{
                    datatable.removeEventListener('click', datatableClickHandler);
                    log('Datatable click listener removed', 'DEBUG');
                }}
                datatableClickHandler = null;
            }}
        }}
        
        async function compareToGoogleSheet(misId) {{
            log(`[EMOJI] Comparing MIS ID ${{misId}} to Google Sheet...`, 'INFO');
            
            const btn = validationState.compareButton;
            if (btn) {{
                btn.textContent = 'Searching...';
                btn.disabled = true;
            }}
            
            try {{
                const response = await fetch(`${{FLASK_BACKEND}}/api/mis/compare-to-sheet`, {{
                    method: 'POST',
                    headers: {{ 'Content-Type': 'application/json' }},
                    body: JSON.stringify({{ mis_id: misId }})
                }});
                
                const result = await response.json();
                
                if (result.success) {{
                    log(`[EMOJI] ${{result.message}}`, 'SUCCESS');
                    
                    if (result.mode === 'automation' && result.expected_data) {{
                        // v12.12.6: DIRECTLY UPDATE validation mode and expected data
                        VALIDATION_MODE = 'automation';
                        EXPECTED_DATA = result.expected_data;
                        
                        log('[EMOJI] DIRECTLY SET AUTOMATION MODE', 'INFO');
                        log(`Expected Data: Brand=${{EXPECTED_DATA.brand}}, Weekday=${{EXPECTED_DATA.weekday}}`, 'DEBUG');
                        log(`Expected Data: Discount=${{EXPECTED_DATA.discount}}, Vendor=${{EXPECTED_DATA.vendor_contrib}}`, 'DEBUG');
                        log(`Expected Data: Rebate Type=${{EXPECTED_DATA.rebate_type}}`, 'DEBUG');
                        
                        // Clear existing validation state to force re-validation with new data
                        validationState.fieldWarnings = {{}};
                        if (validationState.summaryBanner) {{
                            validationState.summaryBanner.remove();
                            validationState.summaryBanner = null;
                        }}
                        
                        log('Validation state cleared - will re-validate with Google Sheet data', 'INFO');
                        notFoundMode = false;  // Clear the flag on successful find
                        
                        // v12.21.3: ENHANCED - Better checklist visibility handling
                        setTimeout(() => {{
                            const checklistBanner = document.getElementById('checklist-banner-v18');
                            if (checklistBanner) {{
                                log('[EMOJI] Checklist banner FOUND in DOM', 'SUCCESS');
                                log(`Banner display: ${{checklistBanner.style.display}}, opacity: ${{checklistBanner.style.opacity}}`, 'DEBUG');
                                
                                // Force visibility with multiple styles
                                checklistBanner.style.display = 'block';
                                checklistBanner.style.visibility = 'visible';
                                checklistBanner.style.opacity = '1';
                                checklistBanner.style.zIndex = '100000';
                                checklistBanner.style.pointerEvents = 'auto';
                                
                                log('Checklist styles updated for visibility', 'INFO');
                                
                                // Scroll banner into view if needed
                                checklistBanner.scrollIntoView({{ behavior: 'smooth', block: 'nearest' }});
                                
                                log('[EMOJI] Checklist should now be VISIBLE in top-right corner', 'SUCCESS');
                            }} else {{
                                log('[EMOJI] WARNING: Checklist banner NOT FOUND in DOM', 'WARN');
                                log('Searching all elements with id containing "checklist"...', 'DEBUG');
                                const allChecklistElements = document.querySelectorAll('[id*="checklist"]');
                                log(`Found ${{allChecklistElements.length}} elements with "checklist" in ID`, 'DEBUG');
                                allChecklistElements.forEach(el => {{
                                    log(`  - ${{el.id}} (${{el.tagName}})`, 'DEBUG');
                                }});
                            }}
                            
                            // Force validation update to reflect new expected data
                            if (typeof runValidation === 'function') {{
                                log('Triggering validation update with new expected data', 'DEBUG');
                                runValidation();
                            }} else {{
                                log('WARNING: runValidation function not found', 'WARN');
                            }}
                        }}, 800);  // Increased delay to 800ms for backend Selenium injection
                    }} else {{
                        // v12.12.8: MIS ID NOT FOUND - Show RED button notification
                        log('MIS ID not found in Google Sheet - staying in manual mode', 'WARN');
                        VALIDATION_MODE = 'manual';
                        EXPECTED_DATA = null;
                        notFoundMode = true;  // Set flag to preserve RED button in exitListeningMode
                        
                        // Change button to RED to alert user
                        if (btn) {{
                            btn.textContent = '[EMOJI] Not Found - Manual Mode';
                            btn.style.background = '#dc3545';  // RED
                            btn.style.color = '#000';  // BLACK text
                            btn.style.border = '2px solid #c82333';
                            btn.style.animation = 'none';
                            btn.title = 'MIS ID was not found in Google Sheet. Using manual validation mode.';
                            
                            // Reset button after 5 seconds
                            setTimeout(() => {{
                                if (btn && btn.textContent.includes('Not Found')) {{
                                    btn.textContent = 'Compare to Google Sheet';
                                    btn.style.background = '#17a2b8';
                                    btn.style.color = '#fff';
                                    btn.style.border = '2px solid #138496';
                                    btn.title = 'Click to enter listening mode, then click a row in the datatable';
                                    notFoundMode = false;  // Clear the flag when button resets
                                }}
                            }}, 5000);
                        }}
                    }}
                }} else {{
                    log(`[EMOJI] ${{result.error}}`, 'ERROR');
                    alert(result.error || 'Failed to compare with Google Sheet');
                }}
            }} catch (error) {{
                log(`[EMOJI] Compare request failed: ${{error}}`, 'ERROR');
                alert('Failed to connect to backend. Is the Flask server running?');
            }} finally {{
                if (btn) {{
                    btn.disabled = false;
                }}
            }}
        }}
        
        function removeCompareButton() {{
            if (validationState.compareButton) {{
                validationState.compareButton.remove();
                validationState.compareButton = null;
                log('Compare to Google Sheet button removed (modal closed)', 'INFO');
            }}
        }}
        
        // Extract MIS ID from the current form
        function extractMisIdFromForm() {{
            // Try multiple possible locations for MIS ID
            
            // Method 1: Direct input field (if exists)
            const misIdField = document.querySelector('#mis_id, #daily_discount_id, [name="mis_id"], [name="id"]');
            if (misIdField && misIdField.value) {{
                return misIdField.value.trim();
            }}
            
            // Method 2: Look in modal title or header
            const modal = document.querySelector('.modal-content');
            if (modal) {{
                const title = modal.querySelector('.modal-title, h4, h3');
                if (title) {{
                    // Extract numbers from title like "Edit Daily Discount #771"
                    const match = title.textContent.match(/#?(\\d+)/);
                    if (match) {{
                        return match[1];
                    }}
                }}
            }}
            
            // Method 3: Look for any visible element with MIS ID
            const labels = document.querySelectorAll('label, span, div');
            for (const label of labels) {{
                if (label.textContent.toLowerCase().includes('mis id') || 
                    label.textContent.toLowerCase().includes('discount id')) {{
                    const next = label.nextElementSibling || label.parentElement;
                    if (next) {{
                        const match = next.textContent.match(/(\\d+)/);
                        if (match) {{
                            return match[1];
                        }}
                    }}
                }}
            }}
            
            return null;
        }}
        
        // ============================================
        // VALIDATION LOOP
        // ============================================
        function runValidation() {{
            const modalOpen = isModalOpen();
            
            if (modalOpen !== validationState.modalOpen) {{
                validationState.modalOpen = modalOpen;
                
                if (modalOpen) {{
                    log('Modal detected - Starting validation', 'INFO');
                    log(`Validation mode: ${{VALIDATION_MODE}}`, 'INFO');
                    createForceButton();
                    createCompareButton();  // V2: Add Compare to Google Sheet button
                    attachSaveButtonListener();
                    attachCancelButtonListener();
                }} else {{
                    log('Modal closed - Cleaning up', 'INFO');
                    removeForceButton();
                    removeCompareButton();  // V2: Remove Compare button
                    removeSummaryBanner();
                    validationState.saveButtonHidden = false;
                    validationState.rebateTypeValid = false;
                    validationState.weekdayValid = false;
                    validationState.fieldWarnings = {{}};
                }}
            }}
            
            if (!modalOpen) return;
            
            // Phase 1: CRITICAL - Rebate Type AND Weekday
            const rebateValid = isRebateTypeValid();
            const weekdayValid = isWeekdayValid();
            
            // Check if validation state changed
            const rebateChanged = rebateValid !== validationState.rebateTypeValid;
            const weekdayChanged = weekdayValid !== validationState.weekdayValid;
            
            if (rebateChanged) {{
                validationState.rebateTypeValid = rebateValid;
                
                if (rebateValid) {{
                    log('Rebate Type is valid', 'SUCCESS');
                    removeRedBox(CONFIG.rebateTypeId, CONFIG.rebateTypeContainerId);
                }} else {{
                    log('Rebate Type is INVALID', 'ERROR');
                    addRedBox(CONFIG.rebateTypeId, CONFIG.rebateTypeContainerId, 
                        '[EMOJI] Rebate Type is required! Must be Wholesale or Retail');
                }}
            }}
            
            if (weekdayChanged) {{
                validationState.weekdayValid = weekdayValid;
                
                if (weekdayValid) {{
                    log('Weekday is valid', 'SUCCESS');
                    removeRedBox(CONFIG.weekdayId, null);
                }} else {{
                    log('Weekday is INVALID', 'ERROR');
                    addRedBox(CONFIG.weekdayId, null,
                        '[EMOJI] Weekday is required! Must select at least one day');
                }}
            }}
            
            // Update Save button based on BOTH critical fields
            const bothValid = rebateValid && weekdayValid;
            const eitherInvalid = !rebateValid || !weekdayValid;
            
            if (rebateChanged || weekdayChanged) {{
                if (bothValid) {{
                    showSaveButton();
                }} else {{
                    hideSaveButton(!rebateValid, !weekdayValid);
                }}
            }}
            
            // Build critical errors object
            const criticalErrors = {{}};
            if (!rebateValid) {{
                criticalErrors.rebateType = {{
                    message: 'Must be selected'
                }};
            }}
            if (!weekdayValid) {{
                criticalErrors.weekday = {{
                    message: 'Must have at least one day'
                }};
            }}
            
            // Phase 2: ADVISORY - All other fields (only in automation mode)
            const warnings = validateAllFields();
            
            // Deep compare: Check if ANY warning changed (not just count)
            const currentWarningsJson = JSON.stringify(warnings);
            const oldWarningsJson = JSON.stringify(validationState.fieldWarnings);
            const warningsChanged = currentWarningsJson !== oldWarningsJson;
            
            // Check if critical validation changed
            const currentCriticalJson = JSON.stringify(criticalErrors);
            const oldCriticalJson = JSON.stringify(validationState.criticalErrors || {{}});
            const criticalChanged = currentCriticalJson !== oldCriticalJson;
            
            // ALWAYS create banner if it doesn't exist (first run after modal opens)
            const bannerMissing = !validationState.summaryBanner;
            
            // Update banner when ANYTHING changes (critical OR advisory OR missing)
            if (criticalChanged || warningsChanged || bannerMissing) {{
                validationState.fieldWarnings = warnings;
                validationState.criticalErrors = criticalErrors;
                updateFieldWarnings(warnings);
                
                // ALWAYS update banner - pass BOTH critical and advisory
                removeSummaryBanner();
                createSummaryBanner(warnings, criticalErrors);
                
                const warningCount = Object.keys(warnings).length;
                const criticalCount = Object.keys(criticalErrors).length;
                
                if (criticalCount > 0) {{
                    log(`Phase 1: ${{criticalCount}} CRITICAL error(s) found`, 'ERROR');
                }}
                if (warningCount > 0) {{
                    log(`Phase 2: ${{warningCount}} advisory warning(s) found`, 'WARN');
                }}
                if (criticalCount === 0 && warningCount === 0) {{
                    log('All validation passed - all fields correct', 'SUCCESS');
                }}
                
                if (bannerMissing) {{
                    log('Initial banner created (first validation run)', 'INFO');
                }}
            }}
        }}
        
        // ============================================
        // START MONITORING
        // ============================================
        log('Starting validation monitor (500ms interval)');
        log('Phase 1: Rebate Type + Weekday (CRITICAL - blocks save)');
        log('Phase 2: All fields (ADVISORY - warnings only)');
        log('Features: Persistent banner, Save/Cancel detection');
        setInterval(runValidation, CONFIG.checkInterval);
        
        runValidation();
        
        log('v12.11 validation system active!');
    }})();
    """
    
    try:
        # DIAGNOSTIC: Pre-execution checks
        print("[VALIDATION-INJECT] Starting injection...")
        print(f"[VALIDATION-INJECT] Driver type: {type(driver)}")
        print(f"[VALIDATION-INJECT] Expected data: {expected_data is not None}")
        print(f"[VALIDATION-INJECT] JavaScript length: {len(validation_js)} characters")
        
        # DIAGNOSTIC: Save JavaScript to file for inspection
        import datetime
        debug_file = f"reports/validation_debug_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.js"
        try:
            with open(debug_file, 'w', encoding='utf-8') as f:
                f.write(validation_js)
            print(f"[VALIDATION-INJECT] [EMOJI] Saved JavaScript to: {debug_file}")
        except Exception as e:
            print(f"[VALIDATION-INJECT] [EMOJI] Could not save debug file: {e}")
        
        driver.execute_script(validation_js)
        print("[MIS-VALIDATION] v12.10 JavaScript injected successfully")
        print("[VALIDATION-INJECT] [EMOJI] Injection completed successfully")
        
    except Exception as e:
        # ENHANCED ERROR LOGGING
        import traceback
        error_details = traceback.format_exc()
        print(f"[VALIDATION-INJECT] [EMOJI] JavaScript execution FAILED!")
        print(f"[VALIDATION-INJECT] Error type: {type(e).__name__}")
        print(f"[VALIDATION-INJECT] Error message: {str(e)}")
        print(f"[VALIDATION-INJECT] Full traceback:\n{error_details}")
        print(f"[MIS-VALIDATION] Error injecting JavaScript: {e}")
        raise


@app.route('/api/mis/create-deal', methods=['POST'])
def api_mis_create_deal():
    """
    Create a new deal in MIS based on Google Sheet data.
    
    Steps:
    1. Navigate to MIS daily-discount page
    2. Click "Add New" button
    3. Fill out form fields from Google Sheet data
    4. (Does NOT click Save - user reviews first)
    """
    try:
        # Set automation flag (prevents background validation monitor from interfering)
        GLOBAL_DATA['automation_in_progress'] = True
        
        data = request.get_json()
        start_date = data.get('start_date', '')
        end_date = data.get('end_date', '')
        sheet_data = data.get('sheet_data', {})
        
        if not start_date or not end_date:
            return jsonify({'success': False, 'error': 'Start and end dates are required'})
        
        warnings = []
        
        # Extract sheet data
        brand = sheet_data.get('brand', '')
        linked_brand = sheet_data.get('linked_brand', '')
        weekday = sheet_data.get('weekday', '')
        discount = sheet_data.get('discount', '')
        vendor_contrib = sheet_data.get('vendor_contrib', '')
        locations = sheet_data.get('locations', '')
        categories = sheet_data.get('categories', '')
        raw_row_data = sheet_data.get('raw_row_data', {})
        
        print(f"[MIS CREATE DEAL] Starting deal creation for brand: {brand}")
        print(f"[MIS CREATE DEAL] Weekday: {weekday}, Discount: {discount}%, Vendor: {vendor_contrib}%")
        print(f"[MIS CREATE DEAL] Dates: {start_date} to {end_date}")
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        # INTELLIGENT MIS SESSION CHECK - ensures tab exists and is logged in
        try:
            # Load credentials from config for auto-login if needed
            creds = load_credentials_config()
            mis_user = creds.get('mis_username', '')
            mis_pass = creds.get('mis_password', '')
            ensure_mis_ready(driver, mis_user, mis_pass)
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)})
        
        # ensure_mis_ready guarantees we're on MIS tab and logged in
        
        # Click "Add New" button
        try:
            add_btn = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.btn-add-dialog"))
            )
            add_btn.click()
            print("[MIS CREATE DEAL] Clicked 'Add New' button")
            time.sleep(2)
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not find Add New button: {e}'})
        
        # Wait for modal to open
        try:
            WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.ID, "discount_rate"))
            )
            print("[MIS CREATE DEAL] Modal opened successfully")
        except:
            return jsonify({'success': False, 'error': 'Deal creation modal did not open'})
        
        # ============================================
        # ATOMIC TRANSACTIONS FORM FILLING
        # ============================================
        # Strategy: Find -> Click -> Action -> Backdrop Click -> Verify
        # Each field is an isolated mission - no TAB navigation
        
        # Master store list for parsing "All Locations Except" logic
        # NOTE: "Green Easy (Old)" exists in dropdown but should NEVER be selected
        MASTER_STORE_LIST = [
            'Beverly', 'Davis', 'Dixon', 'El Sobrante', 'Fresno', 'Fresno Shaw',
            'Hawthorne', 'Koreatown', 'Laguna Woods', 'Oxnard', 'Riverside', 'West Hollywood'
        ]
        
        def log(message, level="INFO"):
            """Debug logging with timestamp."""
            timestamp = time.strftime("%H:%M:%S")
            print(f"[{timestamp}] [{level}] {message}")
        
        def click_backdrop():
            """Click neutral element to force-close any Select2 dropdown and reset focus."""
            try:
                # Try clicking the modal title (always visible, neutral)
                backdrop = driver.find_element(By.CSS_SELECTOR, "h4.modal-title, .modal-header, .modal-body h5")
                backdrop.click()
                log("Clicked backdrop to reset focus", "DEBUG")
                time.sleep(0.1)  # Reduced from 0.3
            except:
                try:
                    # Fallback: press ESCAPE
                    ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                    time.sleep(0.08)  # Reduced from 0.2
                except:
                    pass
        
        def build_xpath_contains(text):
            """Build XPath contains() that handles apostrophes correctly."""
            if "'" in text:
                # Use concat() to handle apostrophes
                parts = text.split("'")
                concat_parts = []
                for i, part in enumerate(parts):
                    if part:
                        concat_parts.append(f"'{part}'")
                    if i < len(parts) - 1:
                        concat_parts.append('"\'"')
                return f"concat({', '.join(concat_parts)})"
            else:
                return f"'{text}'"
        
        def fast_type_or_paste(element, text, field_name="field"):
            """
            Fast input: Try JavaScript injection first, fall back to send_keys.
            Optimized for speed with minimal delays.
            """
            text = str(text)
            
            # Method 1: JavaScript injection (fastest)
            try:
                # Set value via JS and trigger input/change events for Select2
                driver.execute_script("""
                    var element = arguments[0];
                    var text = arguments[1];
                    element.value = text;
                    element.dispatchEvent(new Event('input', { bubbles: true }));
                    element.dispatchEvent(new Event('keyup', { bubbles: true }));
                """, element, text)
                log(f"  [{field_name}] Fast-typed '{text}' via JS", "DEBUG")
                time.sleep(0.15)  # Reduced from 0.3 - Give Select2 time to filter
                return True
            except Exception as e:
                log(f"  [{field_name}] JS injection failed: {e}", "DEBUG")
            
            # Method 2: Direct send_keys (still fast, sends all at once)
            try:
                element.send_keys(text)
                log(f"  [{field_name}] Typed '{text}' via send_keys", "DEBUG")
                time.sleep(0.15)  # Reduced from 0.3
                return True
            except Exception as e:
                log(f"  [{field_name}] send_keys failed: {e}", "DEBUG")
            
            # Method 3: Character by character (slowest, most reliable)
            try:
                for char in text:
                    element.send_keys(char)
                    time.sleep(0.015)  # Reduced from 0.02
                log(f"  [{field_name}] Typed '{text}' char-by-char", "DEBUG")
                time.sleep(0.15)  # Reduced from 0.3
                return True
            except Exception as e:
                log(f"  [{field_name}] Char-by-char failed: {e}", "ERROR")
                return False
        
        def atomic_single_select(label_text, value, field_name):
            """
            Fill a single-select dropdown using SIMULATED MOUSE CLICKS.
            Handles BOTH searchable and non-searchable dropdowns (like Rebate Type).
            """
            if not value:
                log(f"Skipping {field_name} (no value)", "SKIP")
                return True
            
            log(f"ATOMIC SINGLE-SELECT: {field_name} = {value}", "INFO")
            
            # Map field names to their Select2 select element IDs
            FIELD_SELECT_MAP = {
                'Brand': 'brand_id',
                'Linked Brand': 'linked_brand_id',
                'Rebate Type': 'daily_discount_type_id'
            }
            
            select_id = FIELD_SELECT_MAP.get(field_name, field_name.lower().replace(' ', '_'))
            
            try:
                # Step 1: Close any open dropdown
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.1)
                click_backdrop()
                time.sleep(0.15)
                
                # Step 2: Find the Select2 container
                container = None
                
                # Method A: Find by select ID
                try:
                    container_css = f"select#{select_id} + .select2-container, " \
                                   f".select2-container[aria-labelledby*='{select_id}']"
                    container = driver.find_element(By.CSS_SELECTOR, container_css)
                    log(f"  [{field_name}] Found container via select ID", "DEBUG")
                except:
                    pass
                
                # Method B: Find by label
                if not container:
                    try:
                        xpath_value = build_xpath_contains(label_text)
                        container_xpath = f"//label[contains(text(), {xpath_value})]/following::span[contains(@class, 'select2-container')][1]"
                        container = driver.find_element(By.XPATH, container_xpath)
                        log(f"  [{field_name}] Found container via label", "DEBUG")
                    except:
                        pass
                
                # Method C: Known IDs fallback
                if not container:
                    try:
                        id_map = {
                            'Brand': 'select2-brand_id-container',
                            'Linked Brand': 'select2-linked_brand_id-container',
                            'Rebate Type': 'select2-daily_discount_type_id-container'
                        }
                        if field_name in id_map:
                            container = driver.find_element(By.ID, id_map[field_name])
                            log(f"  [{field_name}] Found container via known ID", "DEBUG")
                    except:
                        pass
                
                if not container:
                    log(f"  [{field_name}] Could not find Select2 container!", "ERROR")
                    return False
                
                # Step 3: SIMULATE MOUSE CLICK to open dropdown
                log(f"  [{field_name}] Simulating mouse click on container...", "DEBUG")
                actions = ActionChains(driver)
                actions.move_to_element(container)
                actions.click()
                actions.perform()
                time.sleep(0.25)
                
                # Step 4: Check if search input exists and is VISIBLE
                search_input = None
                search_is_visible = False
                
                try:
                    # Look for search input that is NOT hidden
                    search_elements = driver.find_elements(By.CSS_SELECTOR, 
                        ".select2-dropdown .select2-search__field")
                    for elem in search_elements:
                        if elem.is_displayed():
                            search_input = elem
                            search_is_visible = True
                            break
                    
                    if search_is_visible:
                        log(f"  [{field_name}] Search input is VISIBLE - will type to filter", "DEBUG")
                    else:
                        log(f"  [{field_name}] Search input is HIDDEN - will click option directly", "DEBUG")
                except:
                    log(f"  [{field_name}] No search input found - will click option directly", "DEBUG")
                
                # Step 5: If search is visible, type to filter; otherwise skip
                if search_is_visible and search_input:
                    actions = ActionChains(driver)
                    actions.move_to_element(search_input)
                    actions.click()
                    actions.perform()
                    time.sleep(0.1)
                    
                    # Fast type the value
                    fast_type_or_paste(search_input, str(value), field_name)
                
                # Step 6: Find and click the matching option directly
                try:
                    # Build XPath for exact or contains match
                    option_xpath_value = build_xpath_contains(str(value))
                    
                    # Try exact text match first, then contains
                    option = None
                    
                    # Method A: Exact text match
                    try:
                        exact_xpath = f"//li[contains(@class, 'select2-results__option') and normalize-space(text())={option_xpath_value}]"
                        option = WebDriverWait(driver, 1).until(
                            EC.element_to_be_clickable((By.XPATH, exact_xpath))
                        )
                        log(f"  [{field_name}] Found option via exact match", "DEBUG")
                    except:
                        pass
                    
                    # Method B: Contains text match
                    if not option:
                        try:
                            contains_xpath = f"//li[contains(@class, 'select2-results__option') and contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 1.5).until(
                                EC.element_to_be_clickable((By.XPATH, contains_xpath))
                            )
                            log(f"  [{field_name}] Found option via contains match", "DEBUG")
                        except:
                            pass
                    
                    # Method C: Find by results list ID (for Rebate Type specifically)
                    if not option and field_name == 'Rebate Type':
                        try:
                            # Rebate Type options have specific IDs
                            results_xpath = f"//ul[@id='select2-daily_discount_type_id-results']//li[contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 1).until(
                                EC.element_to_be_clickable((By.XPATH, results_xpath))
                            )
                            log(f"  [{field_name}] Found option via results list ID", "DEBUG")
                        except:
                            pass
                    
                    if option:
                        # Simulate click on option
                        actions = ActionChains(driver)
                        actions.move_to_element(option)
                        actions.click()
                        actions.perform()
                        log(f"  [{field_name}] [EMOJI] Selected '{value}'", "SUCCESS")
                    else:
                        raise Exception(f"Could not find option '{value}'")
                        
                except Exception as e:
                    # Last resort: try keyboard navigation
                    log(f"  [{field_name}] Click failed, trying ENTER: {e}", "WARN")
                    if search_input and search_is_visible:
                        search_input.send_keys(Keys.ENTER)
                    else:
                        # Press down arrow to move to first real option, then ENTER
                        ActionChains(driver).send_keys(Keys.ARROW_DOWN).perform()
                        time.sleep(0.1)
                        ActionChains(driver).send_keys(Keys.ENTER).perform()
                    log(f"  [{field_name}] [EMOJI] Selected '{value}' via keyboard", "SUCCESS")
                
                time.sleep(0.1)
                
                # Step 7: Cleanup
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.08)
                click_backdrop()
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_single_select for {field_name}: {e}", "ERROR")
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                click_backdrop()
                return False
        
        def atomic_multi_select(label_text, values, field_name):
            """
            Fill a multi-select dropdown by CLICKING OPTIONS DIRECTLY.
            
            Speed optimization: Instead of typing to filter, we:
            1. Open dropdown once
            2. Find each option by text and click it
            3. Dropdown stays open for multi-select
            4. Repeat until all values selected
            """
            if not values or len(values) == 0:
                log(f"Skipping {field_name} (no values)", "SKIP")
                return True
            
            log(f"ATOMIC MULTI-SELECT: {field_name} = {values} ({len(values)} items)", "INFO")
            
            # Map field names to their results list IDs
            FIELD_RESULTS_MAP = {
                'Weekday': 'select2-weekday_ids-results',
                'Store': 'select2-store_ids-results', 
                'Category': 'select2-category_ids-results'
            }
            
            # Map field names to their Select2 container IDs
            FIELD_SELECT_MAP = {
                'Weekday': 'weekday_ids',
                'Store': 'store_ids', 
                'Category': 'category_ids'
            }
            
            select_id = FIELD_SELECT_MAP.get(field_name, field_name.lower())
            results_id = FIELD_RESULTS_MAP.get(field_name, f"select2-{select_id}-results")
            
            try:
                # Step 1: Close any previously open dropdown
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.08)
                click_backdrop()
                time.sleep(0.1)
                
                # Step 2: Find and open THIS field's dropdown ONCE
                container = None
                
                # Method A: Find by select element ID
                try:
                    container_css = f"select#{select_id} + .select2-container, " \
                                   f"select[name='{select_id}'] + .select2-container, " \
                                   f".select2-container[aria-labelledby*='{select_id}']"
                    container = driver.find_element(By.CSS_SELECTOR, container_css)
                    log(f"  [{field_name}] Found container via select ID", "DEBUG")
                except:
                    pass
                
                # Method B: Find by label text
                if not container:
                    try:
                        xpath_label = build_xpath_contains(label_text)
                        container_xpath = f"//label[contains(text(), {xpath_label})]/following::span[contains(@class, 'select2-container')][1]"
                        container = driver.find_element(By.XPATH, container_xpath)
                        log(f"  [{field_name}] Found container via label", "DEBUG")
                    except:
                        pass
                
                if not container:
                    log(f"  [{field_name}] Could not find Select2 container!", "ERROR")
                    return False
                
                # Step 3: Click to open the dropdown
                log(f"  [{field_name}] Opening dropdown...", "DEBUG")
                actions = ActionChains(driver)
                actions.move_to_element(container)
                actions.click()
                actions.perform()
                time.sleep(0.2)
                
                # Verify dropdown opened
                try:
                    WebDriverWait(driver, 2).until(
                        lambda d: 'select2-container--open' in container.get_attribute('class')
                    )
                    log(f"  [{field_name}] Dropdown opened", "DEBUG")
                except:
                    log(f"  [{field_name}] Dropdown may not have opened", "WARN")
                
                # Step 4: Select each value by CLICKING DIRECTLY (no typing!)
                selected_count = 0
                for i, value in enumerate(values):
                    value = value.strip()
                    if not value:
                        continue
                    
                    log(f"  [{field_name}] ({i+1}/{len(values)}) Selecting '{value}'...", "DEBUG")
                    
                    # Find the option directly in the results list
                    option = None
                    option_xpath_value = build_xpath_contains(value)
                    
                    # Method A: Find by results list ID (most reliable)
                    try:
                        results_xpath = f"//ul[@id='{results_id}']//li[normalize-space(text())={option_xpath_value}]"
                        option = WebDriverWait(driver, 1).until(
                            EC.element_to_be_clickable((By.XPATH, results_xpath))
                        )
                        log(f"  [{field_name}] Found '{value}' via results list", "DEBUG")
                    except:
                        pass
                    
                    # Method B: Find by contains text in any visible option
                    if not option:
                        try:
                            contains_xpath = f"//li[contains(@class, 'select2-results__option') and contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 0.5).until(
                                EC.element_to_be_clickable((By.XPATH, contains_xpath))
                            )
                            log(f"  [{field_name}] Found '{value}' via contains", "DEBUG")
                        except:
                            pass
                    
                    # Method C: If dropdown closed, reopen and try again
                    if not option:
                        log(f"  [{field_name}] Option not found, reopening dropdown...", "WARN")
                        actions = ActionChains(driver)
                        actions.move_to_element(container)
                        actions.click()
                        actions.perform()
                        time.sleep(0.15)
                        
                        try:
                            results_xpath = f"//ul[@id='{results_id}']//li[contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 1).until(
                                EC.element_to_be_clickable((By.XPATH, results_xpath))
                            )
                        except:
                            log(f"  [{field_name}] Could not find option '{value}'!", "ERROR")
                            continue
                    
                    if option:
                        # Click the option using ActionChains
                        actions = ActionChains(driver)
                        actions.move_to_element(option)
                        actions.click()
                        actions.perform()
                        selected_count += 1
                        log(f"  [{field_name}] [EMOJI] Selected '{value}'", "SUCCESS")
                        time.sleep(0.08)  # Very short pause between selections
                
                # Step 5: Close the dropdown after ALL selections
                log(f"  [{field_name}] Selected {selected_count}/{len(values)} items, closing dropdown", "DEBUG")
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.08)
                click_backdrop()
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_multi_select for {field_name}: {e}", "ERROR")
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                click_backdrop()
                return False
        
        def atomic_text_input(input_id, value, field_name):
            """
            Fill a text input using direct ID lookup.
            """
            if value is None or value == '':
                log(f"Skipping {field_name} (no value)", "SKIP")
                return True
            
            log(f"ATOMIC TEXT INPUT: {field_name} = {value}", "INFO")
            
            try:
                # Step 1: Click backdrop first
                click_backdrop()
                time.sleep(0.2)
                
                # Step 2: Find input by ID
                input_el = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.ID, input_id))
                )
                
                # Step 3: Click to focus
                input_el.click()
                time.sleep(0.1)
                
                # Step 4: Clear and type
                input_el.send_keys(Keys.CONTROL + "a")
                input_el.send_keys(Keys.DELETE)
                time.sleep(0.1)
                
                value_str = str(value).replace('%', '').strip()
                input_el.send_keys(value_str)
                log(f"Typed '{value_str}' into {field_name}", "SUCCESS")
                
                # Step 5: Click backdrop
                click_backdrop()
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_text_input for {field_name}: {e}", "ERROR")
                click_backdrop()
                return False
        
        def atomic_toggle(label_for_id, should_enable, field_name):
            """
            Toggle a checkbox/switch by clicking its label.
            """
            if not should_enable:
                log(f"Skipping {field_name} (not enabled)", "SKIP")
                return True
            
            log(f"ATOMIC TOGGLE: {field_name} = ON", "INFO")
            
            try:
                # Click backdrop first
                click_backdrop()
                time.sleep(0.2)
                
                # Find and click the label
                label = driver.find_element(By.XPATH, f"//label[@for='{label_for_id}']")
                label.click()
                log(f"Toggled {field_name} ON", "SUCCESS")
                time.sleep(0.2)
                
                click_backdrop()
                return True
                
            except Exception as e:
                log(f"Error in atomic_toggle for {field_name}: {e}", "ERROR")
                return False
        
        def resolve_store_selection(locations_text):
            """
            Parse store selection text and return list of stores to select.
            Handles: "All Locations", "All Locations Except: X, Y", or specific stores.
            """
            if not locations_text:
                return []
            
            text = locations_text.strip()
            text_lower = text.lower()
            
            # Case 1: All Locations (leave blank - default)
            if text_lower == 'all locations' or text_lower == 'all':
                log("Store logic: All Locations (leaving blank)", "DEBUG")
                return []
            
            # Case 2: All Locations Except
            if 'except' in text_lower:
                # Extract exceptions
                # Handle formats like "All Locations (Except: X, Y)" or "All Locations Except: X, Y"
                import re
                match = re.search(r'except[:\s]*(.+?)(?:\)|$)', text_lower, re.IGNORECASE)
                if match:
                    exceptions_text = match.group(1)
                    exceptions = [e.strip() for e in exceptions_text.split(',') if e.strip()]
                    
                    # v12.21.3: Apply STORE_MAPPING to exceptions
                    mapped_exceptions = [STORE_MAPPING.get(exc, exc) for exc in exceptions]
                    
                    # Return master list minus exceptions
                    result = []
                    for store in MASTER_STORE_LIST:
                        store_lower = store.lower()
                        is_exception = any(exc.lower() in store_lower or store_lower in exc.lower() for exc in mapped_exceptions)
                        if not is_exception:
                            result.append(store)
                    
                    log(f"Store logic: All except {mapped_exceptions} = {result}", "DEBUG")
                    return result
            
            # Case 3: Specific stores
            stores = [s.strip() for s in text.split(',') if s.strip()]
            
            # v12.21.3: Apply STORE_MAPPING to convert Settings tab names to MIS names
            # Example: "Fresno (Palm)" ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ "Fresno"
            mapped_stores = []
            for store in stores:
                mapped = STORE_MAPPING.get(store, store)  # Try mapping, else use original
                if mapped:
                    mapped_stores.append(mapped)
                    if mapped != store:
                        log(f"  Store mapping: '{store}' ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬ÃƒÂ¢Ã¢â‚¬Å¾Ã‚Â¢ '{mapped}'", "DEBUG")
            
            log(f"Store logic: Specific stores = {mapped_stores}", "DEBUG")
            return mapped_stores
        
        # ============================================
        # PARSE INPUT DATA
        # ============================================
        log("=" * 60, "INFO")
        log("PREPARING FORM DATA", "INFO")
        log("=" * 60, "INFO")
        
        # Parse weekdays
        weekdays_to_select = []
        if weekday:
            weekday_lower = weekday.lower().strip()
            if weekday_lower == 'all week' or weekday_lower == 'everyday':
                weekdays_to_select = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
            else:
                day_map = {
                    'mon': 'Monday', 'monday': 'Monday',
                    'tue': 'Tuesday', 'tuesday': 'Tuesday', 'tues': 'Tuesday',
                    'wed': 'Wednesday', 'wednesday': 'Wednesday',
                    'thu': 'Thursday', 'thursday': 'Thursday', 'thur': 'Thursday', 'thurs': 'Thursday',
                    'fri': 'Friday', 'friday': 'Friday',
                    'sat': 'Saturday', 'saturday': 'Saturday',
                    'sun': 'Sunday', 'sunday': 'Sunday'
                }
                import re
                parts = re.split(r'[,\s]+', weekday_lower)
                for part in parts:
                    part = part.strip()
                    if part in day_map:
                        weekdays_to_select.append(day_map[part])
        log(f"Weekdays: {weekdays_to_select}", "DATA")
        
        # Parse stores using resolver
        stores_to_select = resolve_store_selection(locations)
        log(f"Stores: {stores_to_select}", "DATA")
        
        # Parse brand
        primary_brand = ''
        if brand:
            brands = parse_multi_brand(brand)
            primary_brand = brands[0] if brands else brand
        log(f"Brand: {primary_brand}", "DATA")
        log(f"Linked Brand: {linked_brand}", "DATA")
        
        # Parse categories
        categories_to_select = []
        if categories:
            cat_lower = categories.lower().strip()
            if cat_lower not in ['all', 'all categories', '']:
                categories_to_select = [c.strip() for c in categories.split(',') if c.strip()]
        log(f"Categories: {categories_to_select}", "DATA")
        
        # Parse rebate type
        wholesale_checked = False
        retail_checked = False
        wholesale_col_found = False
        retail_col_found = False
        
        # Debug: Log all keys AND values in raw_row_data to help diagnose
        log(f"raw_row_data keys: {list(raw_row_data.keys())}", "DEBUG")
        log(f"raw_row_data full content:", "DEBUG")
        for k, v in raw_row_data.items():
            log(f"  '{k}' = '{v}'", "DEBUG")
        
        for key, val in raw_row_data.items():
            key_lower = key.lower()
            # Check for various column name formats
            if 'wholesale' in key_lower:
                wholesale_col_found = True
                val_str = str(val).strip().upper()
                log(f"Found wholesale column: '{key}' = '{val}' (normalized: '{val_str}')", "DEBUG")
                # Google Sheets checkboxes return TRUE/FALSE as strings
                if val_str in ['TRUE', 'YES', '1', 'X', '[EMOJI]', 'CHECKED']:
                    wholesale_checked = True
                elif val_str in ['FALSE', 'NO', '0', '', 'UNCHECKED']:
                    wholesale_checked = False
            if 'retail' in key_lower:
                retail_col_found = True
                val_str = str(val).strip().upper()
                log(f"Found retail column: '{key}' = '{val}' (normalized: '{val_str}')", "DEBUG")
                if val_str in ['TRUE', 'YES', '1', 'X', '[EMOJI]', 'CHECKED']:
                    retail_checked = True
                elif val_str in ['FALSE', 'NO', '0', '', 'UNCHECKED']:
                    retail_checked = False
        
        # Log if columns weren't found at all
        if not wholesale_col_found:
            log("WARNING: No 'Wholesale' column found in raw_row_data!", "WARN")
        if not retail_col_found:
            log("WARNING: No 'Retail' column found in raw_row_data!", "WARN")
        
        log(f"Wholesale checked: {wholesale_checked}, Retail checked: {retail_checked}", "DEBUG")
        
        rebate_type = None
        rebate_type_error = False
        
        if wholesale_checked and retail_checked:
            warnings.append('[EMOJI] REBATE TYPE ERROR: Both Wholesale AND Retail are TRUE - only one can be selected!')
            log("REBATE TYPE ERROR: Both checked!", "WARN")
            rebate_type_error = True
            # Highlight the Rebate Type field with red border
            try:
                driver.execute_script("""
                    var container = document.querySelector('#select2-daily_discount_type_id-container');
                    if (container) {
                        container.parentElement.style.border = '3px solid red';
                        container.parentElement.style.borderRadius = '4px';
                    }
                """)
                log("Added red highlight to Rebate Type field", "DEBUG")
            except:
                pass
                
        elif not wholesale_checked and not retail_checked:
            warnings.append('[EMOJI] REBATE TYPE ERROR: Neither Wholesale nor Retail is TRUE - one must be selected!')
            log("REBATE TYPE ERROR: Neither checked!", "WARN")
            rebate_type_error = True
            # Highlight the Rebate Type field with red border
            try:
                driver.execute_script("""
                    var container = document.querySelector('#select2-daily_discount_type_id-container');
                    if (container) {
                        container.parentElement.style.border = '3px solid red';
                        container.parentElement.style.borderRadius = '4px';
                    }
                """)
                log("Added red highlight to Rebate Type field", "DEBUG")
            except:
                pass
                
        elif wholesale_checked:
            rebate_type = 'Wholesale'
        elif retail_checked:
            rebate_type = 'Retail'
        log(f"Rebate Type: {rebate_type}", "DATA")
        log(f"Discount: {discount}", "DATA")
        log(f"Vendor Contrib: {vendor_contrib}", "DATA")
        
        # Parse toggles
        after_wholesale = False
        for key, val in raw_row_data.items():
            if 'after wholesale' in key.lower():
                after_wholesale = str(val).upper() == 'TRUE'
                break
        log(f"After Wholesale: {after_wholesale}", "DATA")
        
        # Parse weight info
        weight_info = parse_weight_exception(raw_row_data)
        min_weight = weight_info.get('min_weight') if weight_info else None
        max_weight = weight_info.get('max_weight') if weight_info else None
        log(f"Min Weight: {min_weight}, Max Weight: {max_weight}", "DATA")
        log(f"Start Date: {start_date}, End Date: {end_date}", "DATA")
        
        # ============================================
        # FILL FORM USING ATOMIC TRANSACTIONS
        # ============================================
        log("=" * 60, "INFO")
        log("STARTING ATOMIC FORM FILL", "INFO")
        log("=" * 60, "INFO")
        
        # Initial backdrop click to ensure clean state
        click_backdrop()
        time.sleep(0.5)
        
        # 1. WEEKDAY (multi-select)
        if weekdays_to_select:
            if not atomic_multi_select("Weekday", weekdays_to_select, "Weekday"):
                warnings.append('[EMOJI] Could not fill Weekday')
        
        # 2. STORE (multi-select) - only if specific stores needed
        if stores_to_select:
            if not atomic_multi_select("Store", stores_to_select, "Store"):
                warnings.append('[EMOJI] Could not fill Store')
        
        # 3. BRAND (single-select)
        if primary_brand:
            if not atomic_single_select("Brand", primary_brand, "Brand"):
                warnings.append('[EMOJI] Could not fill Brand')
        
        # 4. LINKED BRAND (single-select)
        if linked_brand:
            if not atomic_single_select("Linked Brand", linked_brand, "Linked Brand"):
                warnings.append('[EMOJI] Could not fill Linked Brand')
        
        # 5. CATEGORY (multi-select)
        if categories_to_select:
            if not atomic_multi_select("Category", categories_to_select, "Category"):
                warnings.append('[EMOJI] Could not fill Category')
        
        # 6. DISCOUNT RATE (text input)
        if discount is not None and str(discount).strip() != '':
            if not atomic_text_input("discount_rate", discount, "Discount Rate"):
                warnings.append('[EMOJI] Could not fill Discount Rate')
        
        # 7. REBATE TYPE (single-select)
        if rebate_type:
            if not atomic_single_select("Rebate Type", rebate_type, "Rebate Type"):
                warnings.append('[EMOJI] Could not fill Rebate Type')
        
        # 8. VENDOR REBATE % (text input)
        if vendor_contrib is not None and str(vendor_contrib).strip() != '':
            if not atomic_text_input("rebate_percent", vendor_contrib, "Vendor Rebate"):
                warnings.append('[EMOJI] Could not fill Vendor Rebate')
        
        # 9. TOGGLE: After Wholesale
        if after_wholesale:
            if not atomic_toggle("rebate_wholesale_discount", True, "After Wholesale"):
                warnings.append('[EMOJI] Could not toggle After Wholesale')
        
        # 10. START DATE (text input)
        if start_date:
            if not atomic_text_input("date_start", start_date, "Start Date"):
                warnings.append('[EMOJI] Could not fill Start Date')
        
        # 11. END DATE (text input)
        if end_date:
            if not atomic_text_input("date_end", end_date, "End Date"):
                warnings.append('[EMOJI] Could not fill End Date')
        
        # 12. MIN WEIGHT (text input)
        if min_weight is not None:
            if not atomic_text_input("min_weight", min_weight, "Min Weight"):
                warnings.append('[EMOJI] Could not fill Min Weight')
        
        # 13. MAX WEIGHT (text input)
        if max_weight is not None:
            if not atomic_text_input("max_weight", max_weight, "Max Weight"):
                warnings.append('[EMOJI] Could not fill Max Weight')
        
        # ============================================
        # FORM FILL COMPLETE
        # ============================================
        log("=" * 60, "INFO")
        log("FORM FILL COMPLETE", "SUCCESS")
        log("=" * 60, "INFO")
        
        # v12.8 Phase 2: Inject validation system after form fill with expected data
        try:
            # Prepare expected data for validation
            expected_data = {
                'brand': primary_brand,  # Use primary_brand, not just brand
                'linked_brand': linked_brand,
                'weekday': weekday,
                'categories': ','.join(categories_to_select) if categories_to_select else '',
                'discount': discount,
                'vendor_contrib': vendor_contrib,
                'locations': locations,
                'rebate_type': rebate_type,
                'after_wholesale': after_wholesale
            }
            
            # DIAGNOSTIC: Log validation injection attempt
            print("[VALIDATION-DIAGNOSTIC] Attempting to inject validation system...")
            print(f"[VALIDATION-DIAGNOSTIC] Driver available: {driver is not None}")
            print(f"[VALIDATION-DIAGNOSTIC] Expected data keys: {list(expected_data.keys())}")
            
            inject_mis_validation(driver, expected_data)
            log("Validation system injected with Phase 2 field comparison", "SUCCESS")
            print("[VALIDATION-DIAGNOSTIC] [EMOJI] Validation injection successful!")
            
        except Exception as e:
            # ENHANCED ERROR LOGGING
            import traceback
            error_details = traceback.format_exc()
            print(f"[VALIDATION-DIAGNOSTIC] [EMOJI] Validation injection FAILED!")
            print(f"[VALIDATION-DIAGNOSTIC] Error type: {type(e).__name__}")
            print(f"[VALIDATION-DIAGNOSTIC] Error message: {str(e)}")
            print(f"[VALIDATION-DIAGNOSTIC] Full traceback:\n{error_details}")
            
            log(f"Warning: Could not inject validation: {e}", "WARN")
            warnings.append(f'[EMOJI] Validation system not loaded: {type(e).__name__}')
        
        # Clear automation flag
        GLOBAL_DATA['automation_in_progress'] = False
        
        return jsonify({
            'success': True,
            'message': 'Deal form filled. Please review and click Save.',
            'warnings': warnings
        })
        
    except Exception as e:
        # Clear automation flag on error
        GLOBAL_DATA['automation_in_progress'] = False
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


def parse_weight_exception(raw_row_data):
    """
    Parse weight exceptions from Category Except or Special Notes columns.
    
    Patterns:
    - "Except 3.5g" -> max_weight = 3.0 (0.5 below stated)
    - "Only 3.5g" -> min_weight = 3.4 (0.1 below), max_weight = 3.5
    
    Weight conversions:
    - quarter = 7g
    - half/half ounce/half oz = 14g
    - ounce/full ounce/oz/1oz = 28g
    """
    import re
    
    # Weight word to grams mapping
    weight_map = {
        'quarter': 7,
        'half': 14, 'half ounce': 14, 'half oz': 14,
        'ounce': 28, 'full ounce': 28, 'oz': 28, '1oz': 28
    }
    
    def extract_weight(text):
        """Extract weight value from text."""
        text = text.lower()
        
        # Check for word-based weights first
        for word, grams in weight_map.items():
            if word in text:
                return grams
        
        # Look for numeric weight (e.g., "3.5g", "3.5 g", "3.5")
        match = re.search(r'(\d+\.?\d*)\s*g?', text)
        if match:
            return float(match.group(1))
        
        return None
    
    result = {}
    
    # Search in relevant columns
    search_columns = ['category except', 'special notes', 'notes', 'exceptions']
    
    for key, value in raw_row_data.items():
        key_lower = key.lower()
        if any(col in key_lower for col in search_columns):
            if not value or str(value).strip().lower() in ['', 'nan', 'none']:
                continue
            
            value_str = str(value).lower()
            weight = extract_weight(value_str)
            
            if weight:
                if 'except' in value_str:
                    # "Except X" -> max_weight = X - 0.5
                    result['max_weight'] = weight - 0.5
                    print(f"[WEIGHT PARSE] Found 'Except {weight}g' -> max_weight = {result['max_weight']}")
                elif 'only' in value_str:
                    # "Only X" -> min_weight = X - 0.1, max_weight = X
                    result['min_weight'] = weight - 0.1
                    result['max_weight'] = weight
                    print(f"[WEIGHT PARSE] Found 'Only {weight}g' -> min={result['min_weight']}, max={result['max_weight']}")
    
    return result if result else None


# v12.8: Standalone endpoint to inject validation (for manual entry monitoring)
@app.route('/api/mis/inject-validation', methods=['POST'])
def api_mis_inject_validation():
    """
    Inject MIS validation system into the current page.
    Can be called independently to enable validation for manual entries.
    """
    try:
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        
        # Switch to MIS tab
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if "mymis.net" in driver.current_url or "mis" in driver.current_url.lower():
                break
        
        inject_mis_validation(driver, expected_data=None)
        
        return jsonify({
            'success': True,
            'message': 'Validation system injected. Modal monitoring active.'
        })
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# ============================================
# GOOGLE SHEET CONFLICT AUDIT (Pre-Flight Check)
# ============================================
@app.route('/api/mis/gsheet-conflict-audit', methods=['POST'])
def api_gsheet_conflict_audit():
    """
    DATE-AWARE Pre-flight check: Scans the Google Sheet for cross-section brand conflicts.
    Returns TWO sets of conflicts:
    1. Date Conflicts: Same Brand + Same Date overlap.
    2. Brand Conflicts: Same Brand in multiple sections (regardless of date).
    """
    try:
        data = request.get_json() or {}
        tab_name = data.get('tab', '')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab specified. Please select a Google Sheet tab in Setup.'})

        # 1. Parse tab name to get month/year context
        target_month, target_year = parse_tab_month_year(tab_name)
        print(f"[GSHEET AUDIT] Tab: {tab_name} -> Month: {target_month}, Year: {target_year}")

        # 2. Fetch data from Google Sheet (splits into sections)
        sections_data = fetch_google_sheet_data(tab_name)
        
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found in the selected sheet tab.'})

        # 3. Process each section
        # We need two maps: one for date-specific checking, one for general brand checking
        brand_date_map = {}     # Key: (brand, date) -> list of rows
        brand_general_map = {}  # Key: brand -> list of rows (all sections)
        
        section_counts = {'weekly': 0, 'monthly': 0, 'sale': 0}
        unique_brands = set()

        for section_key in ['weekly', 'monthly', 'sale']:
            section_df = sections_data.get(section_key, pd.DataFrame())
            if section_df.empty:
                continue
                
            # Apply multi-day grouping FIRST (for Weekly deals)
            multi_day_groups, row_to_group = detect_multi_day_groups(section_df, section_key)
            processed_groups = set()

            for idx, row in section_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand: continue
                
                unique_brands.add(brand)
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                group_id = row_to_group.get(true_row)
                
                # --- EXTRACT DATA ---
                # v12.22.4: Weekly uses Column A ('Weekday'), Monthly/Sale use Column K ('Weekday/ Day of Month')
                if section_key == 'weekly':
                    weekday_raw = str(get_col(row, ['Weekday', 'Day of Week'], '-')).strip()
                else:
                    weekday_raw = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '-')).strip()
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                mis_id = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                special_notes = str(row.get('SPECIAL NOTES', '')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)

                # --- DATE EXPANSION LOGIC ---
                expanded_dates = []
                is_multi_day_parent = False
                
                if section_key == 'weekly':
                    if group_id and group_id in multi_day_groups:
                        if group_id in processed_groups: 
                            continue 
                        processed_groups.add(group_id)
                        is_multi_day_parent = True
                        expanded_dates = get_all_weekdays_for_multiday_group(
                            multi_day_groups[group_id], section_df, section_key, target_month, target_year
                        )
                        weekday_raw = ', '.join(multi_day_groups[group_id].get('weekdays', []))
                    else:
                        expanded_dates = expand_weekday_to_dates(weekday_raw, target_month, target_year)
                
                elif section_key == 'monthly':
                    expanded_dates = parse_monthly_dates(weekday_raw, target_month, target_year)
                    
                elif section_key == 'sale':
                    expanded_dates = parse_sale_dates(weekday_raw, target_month, target_year)

                section_counts[section_key] += 1

                # Prepare Base Row Detail
                row_detail = {
                    'section': section_key,
                    'row_num': true_row,
                    'weekday_raw': weekday_raw if weekday_raw and weekday_raw != '[!] [EMOJI][EMOJI]  MISSING' else '-',
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'notes': special_notes,
                    'mis_id': mis_id,
                    'brand_display': brand, # Store original casing
                    'conflict_date': None 
                }

                # A) POPULATE DATE MAP (For specific date conflicts)
                for d in expanded_dates:
                    key = (brand.lower(), d)
                    if key not in brand_date_map:
                        brand_date_map[key] = []
                    
                    date_specific_detail = row_detail.copy()
                    date_specific_detail['conflict_date'] = d.strftime('%Y-%m-%d')
                    brand_date_map[key].append(date_specific_detail)

                # B) POPULATE GENERAL MAP (For broad brand conflicts)
                # If it's a multi-day parent, we add it once. If single, we add it once.
                # We do NOT add per expanded date here, just per logical deal row.
                if brand.lower() not in brand_general_map:
                    brand_general_map[brand.lower()] = []
                brand_general_map[brand.lower()].append(row_detail)


        # 4. Detect Conflicts (Type A: DATE BASED)
        date_conflicts_grouped = {} 

        for (brand_lower, date_obj), entries in brand_date_map.items():
            sections_present = set(e['section'] for e in entries)
            
            if len(sections_present) > 1:
                # DATE CONFLICT FOUND
                date_str = date_obj.strftime('%Y-%m-%d')
                brand_display = entries[0].get('brand_display', brand_lower.title()) 
                
                # Restore casing
                for b in unique_brands:
                    if b.lower() == brand_lower:
                        brand_display = b
                        break
                
                if brand_display not in date_conflicts_grouped:
                    date_conflicts_grouped[brand_display] = {
                        'brand': brand_display,
                        'sections': set(),
                        'conflicting_dates': set(),
                        'rows': []
                    }
                
                date_conflicts_grouped[brand_display]['sections'].update(sections_present)
                date_conflicts_grouped[brand_display]['conflicting_dates'].add(date_str)
                
                existing_rows = {r['row_num'] for r in date_conflicts_grouped[brand_display]['rows']}
                for e in entries:
                    if e['row_num'] not in existing_rows:
                        date_conflicts_grouped[brand_display]['rows'].append(e)
                        existing_rows.add(e['row_num'])

        # 5. Detect Conflicts (Type B: BRAND BASED)
        brand_conflicts_grouped = {}
        
        for brand_lower, entries in brand_general_map.items():
            sections_present = set(e['section'] for e in entries)
            
            if len(sections_present) > 1:
                # BRAND CONFLICT FOUND (Appears in >1 section types)
                brand_display = entries[0].get('brand_display', brand_lower.title())
                for b in unique_brands:
                    if b.lower() == brand_lower:
                        brand_display = b
                        break
                
                brand_conflicts_grouped[brand_display] = {
                    'brand': brand_display,
                    'sections': list(sections_present),
                    'rows': sorted(entries, key=lambda x: x['row_num'])
                }

        # Format Outputs
        final_date_conflicts = []
        for brand, data in date_conflicts_grouped.items():
            final_date_conflicts.append({
                'brand': brand,
                'sections': list(data['sections']),
                'total_conflict_dates': len(data['conflicting_dates']),
                'conflicting_dates': [{'date': d} for d in sorted(list(data['conflicting_dates']))],
                'rows': sorted(data['rows'], key=lambda x: x['row_num'])
            })
            
        final_brand_conflicts = []
        for brand, data in brand_conflicts_grouped.items():
            final_brand_conflicts.append({
                'brand': brand,
                'sections': data['sections'],
                'rows': data['rows']
            })

        return jsonify({
            'success': True, 
            'date_conflicts': final_date_conflicts,
            'brand_conflicts': final_brand_conflicts,
            'summary': {
                'weekly_count': section_counts['weekly'],
                'monthly_count': section_counts['monthly'],
                'sale_count': section_counts['sale'],
                'unique_brands': len(unique_brands)
            },
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}"
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================================
# SPLIT AUDIT API ROUTES (V29)
# ============================================================================
def simulate_calendar_hierarchy(weekly_deals: List[Dict], tier1_deals: List[Dict], target_month: int, target_year: int) -> Dict:
    """
    Build a virtual calendar for the target month with deal dominance.
    Tier 1 (Sale/Monthly) locks dates. Tier 2 (Weekly) fills remaining dates.
    Returns: {date_str: {'dominant': deal_info, 'conflicts': [...]}}
    """
    import calendar
    from datetime import date
    
    num_days = calendar.monthrange(target_year, target_month)[1]
    calendar_map = {}
    
    # Initialize calendar
    for day in range(1, num_days + 1):
        d = date(target_year, target_month, day)
        date_str = d.strftime('%Y-%m-%d')
        calendar_map[date_str] = {
            'date': d,
            'tier1_deals': [],  # Sale/Monthly - highest priority
            'tier2_deals': [],  # Weekly - lower priority
            'dominant': None
        }
    
    # Populate Tier 1 (Sale/Monthly) deals
    for deal in tier1_deals:
        for d in deal.get('expanded_dates', []):
            date_str = d.strftime('%Y-%m-%d')
            if date_str in calendar_map:
                calendar_map[date_str]['tier1_deals'].append(deal)
    
    # Populate Tier 2 (Weekly) deals
    for deal in weekly_deals:
        for d in deal.get('expanded_dates', []):
            date_str = d.strftime('%Y-%m-%d')
            if date_str in calendar_map:
                calendar_map[date_str]['tier2_deals'].append(deal)
    
    # Determine dominance for each date
    for date_str, day_data in calendar_map.items():
        if day_data['tier1_deals']:
            # Tier 1 dominates
            day_data['dominant'] = day_data['tier1_deals'][0]
            day_data['dominant']['tier'] = 1
        elif day_data['tier2_deals']:
            # Tier 2 fills in
            day_data['dominant'] = day_data['tier2_deals'][0]
            day_data['dominant']['tier'] = 2
    
    return calendar_map


def detect_split_requirements(weekly_deals: List[Dict], tier1_deals: List[Dict], target_month: int, target_year: int) -> Tuple[List[Dict], List[Dict]]:
    """
    Identify Weekly deals that conflict with Tier 1 deals and require splitting.
    Returns: (splits_required, no_conflict)
    """
    from datetime import date
    import calendar
    
    splits_required = []
    no_conflict = []
    
    # Build Tier 1 date map: {(brand_lower, date): deal_info}
    tier1_date_map = {}
    for deal in tier1_deals:
        brand_lower = deal.get('brand', '').lower()
        for d in deal.get('expanded_dates', []):
            key = (brand_lower, d)
            if key not in tier1_date_map:
                tier1_date_map[key] = []
            tier1_date_map[key].append(deal)
    
    print(f"[DEBUG-CONFLICT] Built tier1_date_map with {len(tier1_date_map)} keys")
    print(f"[DEBUG-CONFLICT] Sample keys: {list(tier1_date_map.keys())[:5]}")
    
    # Check each Weekly deal for conflicts
    for weekly in weekly_deals:
        brand_lower = weekly.get('brand', '').lower()
        weekly_dates = weekly.get('expanded_dates', [])
        
        print(f"[DEBUG-CONFLICT] Checking Weekly: {weekly.get('brand')} with {len(weekly_dates)} dates")
        
        conflict_dates = []
        interrupting_deals = []
        
        for d in weekly_dates:
            key = (brand_lower, d)
            if key in tier1_date_map:
                print(f"[DEBUG-CONFLICT] MATCH FOUND: {key}")
                conflict_dates.append(d)
                interrupting_deals.extend(tier1_date_map[key])
        
        if conflict_dates:
            # v94: Location-aware conflict detection
            has_conflict, conflict_stores, non_conflict_stores, conflict_type = calculate_location_conflict(
                weekly.get('locations', ''),
                interrupting_deals[0].get('locations', '') if interrupting_deals else ''
            )
            
            # If no actual location overlap, skip this (shouldn't happen but safety check)
            if not has_conflict or conflict_type == 'NONE':
                no_conflict.append({
                    'brand': weekly.get('brand'),
                    'weekday': weekly.get('weekday'),
                    'section': 'Weekly',
                    'discount': weekly.get('discount'),
                    'vendor_contrib': weekly.get('vendor_contrib'),
                    'locations': weekly.get('locations'),
                    'google_row': weekly.get('google_row'),
                    'mis_id': weekly.get('mis_id'),
                    'deal_info': weekly.get('deal_info', ''),
                    'special_notes': weekly.get('special_notes', ''),
                    'categories': weekly.get('categories', '')
                })
                continue
            
            overlap_locations = list(conflict_stores)
            
            # Generate split plan with location awareness
            conflict_dates_sorted = sorted(set(conflict_dates))
            plan = generate_split_plan(weekly, conflict_dates_sorted, target_month, target_year, conflict_type, non_conflict_stores)
            
            # Attribute comparison
            attr_comparison = {
                'weekly': {
                    'discount': weekly.get('discount'),
                    'vendor_contrib': weekly.get('vendor_contrib'),
                    'locations': weekly.get('locations')
                },
                'tier1': {
                    'discount': interrupting_deals[0].get('discount') if interrupting_deals else None,
                    'vendor_contrib': interrupting_deals[0].get('vendor_contrib') if interrupting_deals else None,
                    'locations': interrupting_deals[0].get('locations') if interrupting_deals else None
                }
            }
            
            splits_required.append({
                'brand': weekly.get('brand'),
                'weekday': weekly.get('weekday'),
                'section': 'weekly',  # v10.8: Section being split (weekly, monthly, sale)
                'original_mis_id': weekly.get('mis_id'),
                # v10.8: Parse MIS ID cell with section-based format (W1, W2, WP, etc.)
                'parsed_mis_ids': parse_mis_id_cell(weekly.get('mis_id', '')),
                # v88: Additional fields for enhanced display
                'discount': weekly.get('discount'),
                'vendor_contrib': weekly.get('vendor_contrib'),
                'locations': weekly.get('locations'),
                'google_row': weekly.get('google_row'),
                'deal_info': weekly.get('deal_info', ''),
                'special_notes': weekly.get('special_notes', ''),
                'categories': weekly.get('categories', ''),
                # v12.22.2: Add rebate type fields for Continue row Create automation
                'linked_brand': weekly.get('linked_brand', ''),
                'retail': weekly.get('retail', ''),
                'wholesale': weekly.get('wholesale', ''),
                'after_wholesale': weekly.get('after_wholesale', ''),
                'conflict_type': conflict_type,
                'conflict_dates': [d.strftime('%m/%d') for d in conflict_dates_sorted],
                'interrupting_deal_type': interrupting_deals[0].get('section', 'monthly').lower() if interrupting_deals else 'monthly',
                'interrupting_deal': {
                    'brand': interrupting_deals[0].get('brand') if interrupting_deals else '',
                    'discount': interrupting_deals[0].get('discount') if interrupting_deals else '',
                    'vendor_contrib': interrupting_deals[0].get('vendor_contrib') if interrupting_deals else '',
                    'locations': format_location_set(conflict_stores) if conflict_stores else (interrupting_deals[0].get('locations') if interrupting_deals else ''),  # v94: Only conflicting stores
                    'google_row': interrupting_deals[0].get('google_row') if interrupting_deals else None,
                    'mis_id': interrupting_deals[0].get('mis_id') if interrupting_deals else '',
                    'deal_info': interrupting_deals[0].get('deal_info') if interrupting_deals else '',
                    'special_notes': interrupting_deals[0].get('special_notes') if interrupting_deals else '',
                    'categories': interrupting_deals[0].get('categories') if interrupting_deals else '',
                    # v12.18: Added missing fields for Create automation
                    'weekday': interrupting_deals[0].get('weekday') if interrupting_deals else '',
                    'linked_brand': interrupting_deals[0].get('linked_brand') if interrupting_deals else '',
                    'retail': interrupting_deals[0].get('retail') if interrupting_deals else '',
                    'wholesale': interrupting_deals[0].get('wholesale') if interrupting_deals else '',
                    'after_wholesale': interrupting_deals[0].get('after_wholesale') if interrupting_deals else ''
                },
                'overlap_locations': overlap_locations,
                'plan': plan,
                'attribute_comparison': attr_comparison
            })
        else:
            no_conflict.append({
                'brand': weekly.get('brand'),
                'weekday': weekly.get('weekday'),
                'section': 'Weekly',
                # v88: Additional fields for enhanced display
                'discount': weekly.get('discount'),
                'vendor_contrib': weekly.get('vendor_contrib'),
                'locations': weekly.get('locations'),
                'google_row': weekly.get('google_row'),
                'mis_id': weekly.get('mis_id'),
                'deal_info': weekly.get('deal_info', ''),
                'special_notes': weekly.get('special_notes', ''),
                'categories': weekly.get('categories', '')
            })
    
    return splits_required, no_conflict


def generate_split_plan(weekly: Dict, conflict_dates: List, target_month: int, target_year: int, conflict_type: str = 'FULL', non_conflict_stores: set = None) -> List[Dict]:
    """
    Generate the MIS entry plan for splitting a Weekly deal around conflict dates.
    v94: Now includes PATCH entries for partial location conflicts.
    """
    import calendar
    from datetime import date, timedelta
    
    plan = []
    weekly_dates = sorted(weekly.get('expanded_dates', []))
    
    if not weekly_dates or not conflict_dates:
        return plan
    
    # Find continuous segments before, during, and after conflicts
    conflict_set = set(conflict_dates)
    
    # Part 1: Dates before first conflict
    part1_dates = [d for d in weekly_dates if d < min(conflict_dates)]
    if part1_dates:
        plan.append({
            'action': 'CREATE_PART1',
            'dates': f"{part1_dates[0].strftime('%m/%d')} - {part1_dates[-1].strftime('%m/%d')}",
            'notes': f"End date: {(min(conflict_dates) - timedelta(days=1)).strftime('%m/%d')}"
        })
    
    # GAP: The conflict dates (Tier 1 deal runs here)
    plan.append({
        'action': 'GAP',
        'dates': ', '.join([d.strftime('%m/%d') for d in sorted(conflict_dates)]),
        'notes': 'Tier 1 deal active - Weekly pauses at conflicting locations'
    })
    
    # PATCH: If partial conflict, Weekly continues at non-conflicting locations
    if conflict_type == 'PARTIAL' and non_conflict_stores:
        patch_locations = format_location_set(non_conflict_stores, weekly.get('locations', ''))
        plan.append({
            'action': 'PATCH',
            'dates': ', '.join([d.strftime('%m/%d') for d in sorted(conflict_dates)]),
            'notes': f"Weekly continues at: {patch_locations}",
            'locations': patch_locations,
            'discount': weekly.get('discount'),
            'vendor_contrib': weekly.get('vendor_contrib')
        })
    
    # Part 2: Dates after last conflict
    part2_dates = [d for d in weekly_dates if d > max(conflict_dates)]
    if part2_dates:
        plan.append({
            'action': 'CREATE_PART2',
            'dates': f"{part2_dates[0].strftime('%m/%d')} - {part2_dates[-1].strftime('%m/%d')}",
            'notes': f"Start date: {(max(conflict_dates) + timedelta(days=1)).strftime('%m/%d')} (New MIS ID required)"
        })
    
    return plan


@app.route('/api/mis/split-audit/planning', methods=['POST'])
def api_split_audit_planning():
    """
    Phase 1: Planning - Analyze Google Sheet for split requirements.
    Returns a To-Do list of MIS entries needed.
    """
    try:
        data = request.get_json() or {}
        tab_name = data.get('tab', '')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab specified.'})
        
        # Parse month/year context
        target_month, target_year = parse_tab_month_year(tab_name)
        print(f"[SPLIT AUDIT] Planning for {tab_name} -> {target_month}/{target_year}")
        
        # Fetch Google Sheet data
        sections_data = fetch_google_sheet_data(tab_name)
        
        # DIAGNOSTIC: Check what sections_data contains
        print(f"[DIAGNOSTIC] sections_data keys: {sections_data.keys()}")
        print(f"[DIAGNOSTIC] weekly rows: {len(sections_data.get('weekly', pd.DataFrame()))}")
        print(f"[DIAGNOSTIC] monthly rows: {len(sections_data.get('monthly', pd.DataFrame()))}")
        print(f"[DIAGNOSTIC] sale rows: {len(sections_data.get('sale', pd.DataFrame()))}")
        
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found in sheet.'})
        
        # Process Weekly deals (Tier 2)
        weekly_deals = []
        weekly_df = sections_data.get('weekly', pd.DataFrame())
        
        if not weekly_df.empty:
            multi_day_groups, row_to_group = detect_multi_day_groups(weekly_df, 'weekly')
            processed_groups = set()
            
            for idx, row in weekly_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand:
                    continue
                
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                group_id = row_to_group.get(true_row)
                
                # v12.22.4: Weekly uses Column A ('Weekday')
                weekday_raw = str(get_col(row, ['Weekday', 'Day of Week'], '-')).strip()
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                mis_id = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)
                
                # Expand dates
                if group_id and group_id in multi_day_groups:
                    if group_id in processed_groups:
                        continue
                    processed_groups.add(group_id)
                    expanded_dates = get_all_weekdays_for_multiday_group(
                        multi_day_groups[group_id], weekly_df, 'weekly', target_month, target_year
                    )
                    weekday_raw = ', '.join(multi_day_groups[group_id].get('weekdays', []))
                else:
                    expanded_dates = expand_weekday_to_dates(weekday_raw, target_month, target_year)
                
                # v88: Get additional fields for enhanced display
                deal_info = str(get_col(row, ['Deal info', 'Deal Info', 'Deal'], '')).strip()
                special_notes = str(get_col(row, ['Special Notes', 'Notes'], '')).strip()
                categories = str(get_col(row, ['Category', 'Categories'], '')).strip()
                
                # v12.18.2: Get Rebate Type checkboxes (Column R = Wholesale, Column T = Retail)
                # v12.18.3: Debug logging for checkbox detection
                if idx == 0:  # Only log column names for first row
                    print(f"[CHECKBOX DEBUG] Weekly row columns: {list(row.index)}")
                    for col in row.index:
                        col_lower = str(col).lower()
                        if 'wholesale' in col_lower or 'retail' in col_lower or 'after' in col_lower or 'rebate' in col_lower:
                            print(f"[CHECKBOX DEBUG] Column '{col}' = '{row.get(col, 'N/A')}'")
                
                wholesale_val = get_col(row, ['Wholesale', 'Wholesale?'], '')
                retail_val = get_col(row, ['Retail', 'Retail?'], '')
                after_wholesale_val = get_col(row, ['Rebate After Wholesale Discount?', 'After Wholesale', 'After Wholesale?'], '')
                
                # v12.18.3: Debug logging for actual values found
                if brand:  # Log for each row with a brand
                    print(f"[CHECKBOX DEBUG] Row {true_row} ({brand}): wholesale='{wholesale_val}', retail='{retail_val}', after_wholesale='{after_wholesale_val}'")
                
                # Convert checkbox values to boolean strings
                is_wholesale = str(wholesale_val).upper() in ['TRUE', 'YES', '1', 'X', '[EMOJI]', 'CHECKED']
                is_retail = str(retail_val).upper() in ['TRUE', 'YES', '1', 'X', '[EMOJI]', 'CHECKED']
                is_after_wholesale = str(after_wholesale_val).upper() in ['TRUE', 'YES', '1', 'X', '[EMOJI]', 'CHECKED']
                
                weekly_deals.append({
                    'brand': brand,
                    'weekday': weekday_raw,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'mis_id': mis_id,
                    'expanded_dates': expanded_dates,
                    'section': 'weekly',
                    # v88: Additional fields
                    'google_row': true_row,
                    'deal_info': deal_info,
                    'special_notes': special_notes,
                    'categories': categories,
                    # v12.18.2: Rebate Type fields
                    'retail': 'TRUE' if is_retail else 'FALSE',
                    'wholesale': 'TRUE' if is_wholesale else 'FALSE',
                    'after_wholesale': 'TRUE' if is_after_wholesale else 'FALSE'
                })
        
        # Process Tier 1 deals (Monthly + Sale)
        tier1_deals = []
        
        for section_key in ['monthly', 'sale']:
            print(f"[DIAGNOSTIC] Loop iteration for: {section_key}")
            section_df = sections_data.get(section_key, pd.DataFrame())
            print(f"[DIAGNOSTIC] {section_key} DataFrame shape: {section_df.shape}")
            if section_df.empty:
                print(f"[DIAGNOSTIC] {section_key} is EMPTY, skipping")
                continue
            
            print(f"[DEBUG] Processing {section_key} section: {len(section_df)} rows")
            
            for idx, row in section_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand:
                    continue
                
                # v88: Get google_row for interrupting deal Row button
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                
                # v12.13: Section-aware column detection for dates
                if section_key == 'monthly':
                    # Monthly: Read from Column K (ordinals like "1st, 10th")
                    date_raw = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '-')).strip()
                else:  # sale
                    # Sale: Read from Column C (dates like "01/16/26, 01/23/26")
                    date_raw = str(get_col(row, ['Contracted Duration (MM/DD/YY - MM/DD/YY)', 'Contracted Duration', 'Sale Runs:'], '-')).strip()
                
                print(f"[DEBUG] {section_key.upper()} - Brand: {brand}, Date Raw: {date_raw}")
                
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)
                
                # Expand dates based on section type
                if section_key == 'monthly':
                    expanded_dates = parse_monthly_dates(date_raw, target_month, target_year)
                else:  # sale
                    expanded_dates = parse_sale_dates(date_raw, target_month, target_year)
                
                print(f"[DEBUG] {section_key.upper()} - Expanded Dates: {expanded_dates}")
                
                mis_id = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                deal_info = str(get_col(row, ['Deal info', 'Deal Info', 'Deal'], '')).strip()
                special_notes = str(get_col(row, ['Special Notes', 'Notes'], '')).strip()
                categories = str(get_col(row, ['Category', 'Categories'], '')).strip()
                
                # v12.18.2: Get weekday for Sale (Column A) or calculate for Monthly
                if section_key == 'sale':
                    # Sale deals: weekday is in Column A (same as Weekly)
                    weekday_val = str(get_col(row, ['Weekday', 'Day', 'Day of Week'], '')).strip()
                else:
                    # Monthly deals: weekday needs to be calculated from dates
                    # For now store the day-of-month info, frontend will calculate actual weekday
                    weekday_val = ''  # Will be calculated in frontend based on start/end dates
                
                # v12.18.2: Get Rebate Type checkboxes (Column R = Wholesale, Column T = Retail)
                wholesale_val = get_col(row, ['Wholesale', 'Wholesale?'], '')
                retail_val = get_col(row, ['Retail', 'Retail?'], '')
                after_wholesale_val = get_col(row, ['Rebate After Wholesale Discount?', 'After Wholesale', 'After Wholesale?'], '')
                
                # Convert checkbox values to boolean strings
                is_wholesale = str(wholesale_val).upper() in ['TRUE', 'YES', '1', 'X', '[EMOJI]', 'CHECKED']
                is_retail = str(retail_val).upper() in ['TRUE', 'YES', '1', 'X', '[EMOJI]', 'CHECKED']
                is_after_wholesale = str(after_wholesale_val).upper() in ['TRUE', 'YES', '1', 'X', '[EMOJI]', 'CHECKED']
                
                print(f"[DEBUG] {section_key.upper()} - Weekday: '{weekday_val}', Wholesale: {is_wholesale}, Retail: {is_retail}")
                
                tier1_deals.append({
                    'brand': brand,
                    'date_raw': date_raw,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'mis_id': mis_id,
                    'expanded_dates': expanded_dates,
                    'section': section_key,
                    'google_row': true_row,
                    'deal_info': deal_info,
                    'special_notes': special_notes,
                    'categories': categories,
                    # v12.18.2: Additional fields for Create automation
                    'weekday': weekday_val,
                    'retail': 'TRUE' if is_retail else 'FALSE',
                    'wholesale': 'TRUE' if is_wholesale else 'FALSE',
                    'after_wholesale': 'TRUE' if is_after_wholesale else 'FALSE'
                })
        
        print(f"[DEBUG] Total tier1_deals: {len(tier1_deals)}")
        print(f"[DEBUG] Sale deals in tier1: {len([d for d in tier1_deals if d['section'] == 'sale'])}")
        
        # Detect split requirements
        splits_required, no_conflict = detect_split_requirements(
            weekly_deals, tier1_deals, target_month, target_year
        )
        
        # v12.18.3: Load Settings tab for Brand/Category dropdowns in Pre-Flight Popup
        brand_list = []
        category_list = []
        brand_linked_map = {}
        try:
            spreadsheet_id = GLOBAL_DATA.get('mis', {}).get('spreadsheet_id')
            if spreadsheet_id:
                settings_data = load_settings_dropdown_data(spreadsheet_id)
                brand_list = list(settings_data.get('brand_linked_map', {}).keys())
                # Capitalize brand names for display
                brand_list = [b.title() for b in brand_list]
                brand_list.sort()
                category_list = settings_data.get('categories', [])
                brand_linked_map = settings_data.get('brand_linked_map', {})
                print(f"[SPLIT AUDIT] Loaded {len(brand_list)} brands, {len(category_list)} categories for Pre-Flight dropdowns")
        except Exception as e:
            print(f"[SPLIT AUDIT] Warning: Could not load Settings data: {e}")
        
        return jsonify({
            'success': True,
            'splits_required': splits_required,
            'no_conflict': no_conflict,
            'summary': {
                'weekly_count': len(weekly_deals),
                'monthly_count': len([d for d in tier1_deals if d['section'] == 'monthly']),
                'sale_count': len([d for d in tier1_deals if d['section'] == 'sale'])
            },
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}",
            'brand_list': brand_list,
            'category_list': category_list,
            'brand_linked_map': brand_linked_map
        })
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500
def check_mis_weekday_active(target_date: date, mis_weekday_str: str) -> bool:
    """
    Checks if a specific date's day-of-week is present in the MIS Weekday column.
    Example: target_date=Dec 25 (Thursday). mis_str="Mon, Wed, Fri". Returns False.
    """
    if not mis_weekday_str or str(mis_weekday_str).lower() in ['nan', 'none', '', '-']:
        return False # No weekdays listed = Not active? Or assume all? Usually specific.
        
    # Get day name from date (e.g., 'Thursday')
    target_day_full = target_date.strftime('%A').lower() # thursday
    target_day_abbr = target_date.strftime('%a').lower() # thu
    
    # MIS formats usually: "Monday", "Mon", "Mon, Wed", "Monday, Wednesday"
    mis_clean = str(mis_weekday_str).lower()
    
    # Simple check: is 'thu' or 'thursday' in the string?
    # We map standard days to ensure we don't partial match 'mon' inside 'month' (unlikely but safe)
    day_map = {
        'monday': ['mon', 'monday'],
        'tuesday': ['tue', 'tues', 'tuesday'],
        'wednesday': ['wed', 'wednesday'],
        'thursday': ['thu', 'thur', 'thurs', 'thursday'],
        'friday': ['fri', 'friday'],
        'saturday': ['sat', 'saturday'],
        'sunday': ['sun', 'sunday']
    }
    
    valid_tokens = day_map.get(target_day_full, [])
    
    for token in valid_tokens:
        if token in mis_clean:
            return True
            
    return False

@app.route('/api/mis/split-audit/gap-check', methods=['POST'])
def api_split_audit_gap_check():
    """
    Phase 2: Gap Check - Verifies that MIS CSV has gaps on conflict dates.
    Input: Google Sheet (Plan) + MIS CSV (Actual).
    """
    try:
        # 1. LOAD INPUTS
        tab_name = request.form.get('tab')
        if not tab_name: return jsonify({'success': False, 'error': 'No tab specified.'})

        mis_df = None
        if request.files.get('csv'):
            mis_df = pd.read_csv(request.files['csv'])
        elif request.form.get('local_csv_path'):
            path = request.form.get('local_csv_path')
            if os.path.exists(path):
                mis_df = pd.read_csv(path)
        
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'MIS CSV data missing.'})

        # 2. GENERATE PLAN (Re-run Phase 1 Logic)
        target_month, target_year = parse_tab_month_year(tab_name)
        sections_data = fetch_google_sheet_data(tab_name)
        
        # Prepare Tier 1 Deals
        tier1_deals = []
        for sec in ['sale', 'monthly']:
            df = sections_data.get(sec, pd.DataFrame())
            if not df.empty:
                for idx, row in df.iterrows():
                    brand = str(row.get('Brand', '')).strip()
                    if not brand: continue
                    # v12.13: Section-aware column detection
                    if sec == 'sale':
                        # Sale: Read dates from Column C
                        d_str = str(get_col(row, ['Contracted Duration (MM/DD/YY - MM/DD/YY)', 'Contracted Duration', 'Sale Runs:'], '')).strip()
                        dates = parse_sale_dates(d_str, target_month, target_year)
                    else:  # monthly
                        # Monthly: Read ordinals from Column K
                        d_str = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                        dates = parse_monthly_dates(d_str, target_month, target_year)
                    if dates:
                        tier1_deals.append({'brand': brand, 'section': sec, 'expanded_dates': dates, 'locations': format_location_display(*resolve_location_columns(row))})

        # Prepare Weekly Deals
        weekly_deals = []
        weekly_df = sections_data.get('weekly', pd.DataFrame())
        if not weekly_df.empty:
            multi_day_groups, row_to_group = detect_multi_day_groups(weekly_df, 'weekly')
            processed_groups = set()
            for idx, row in weekly_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand: continue
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                group_id = row_to_group.get(true_row)
                
                if group_id and group_id in multi_day_groups:
                    if group_id in processed_groups: continue
                    processed_groups.add(group_id)
                    dates = get_all_weekdays_for_multiday_group(multi_day_groups[group_id], weekly_df, 'weekly', target_month, target_year)
                    wk_str = ', '.join(multi_day_groups[group_id].get('weekdays', []))
                else:
                    # v12.22.4: Weekly uses Column A ('Weekday')
                    wk_str = str(get_col(row, ['Weekday', 'Day of Week'], '')).strip()
                    dates = expand_weekday_to_dates(wk_str, target_month, target_year)
                
                if dates:
                    weekly_deals.append({
                        'brand': brand, 'weekday': wk_str, 'expanded_dates': dates,
                        'locations': format_location_display(*resolve_location_columns(row)),
                        'mis_id': str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                    })

        # 3. IDENTIFY REQUIRED GAPS
        splits_required, _ = detect_split_requirements(weekly_deals, tier1_deals, target_month, target_year)
        
        missing_gaps = []
        verified_gaps = []

        # 4. CHECK MIS DATA
        mis_df['Start_DT'] = pd.to_datetime(mis_df['Start date'], errors='coerce')
        mis_df['End_DT'] = pd.to_datetime(mis_df['End date'], errors='coerce')

        for req in splits_required:
            brand = req['brand']
            conflict_dates_str = req['conflict_dates'] 
            
            # Fuzzy match Brand
            relevant_mis = mis_df[mis_df['Brand'].astype(str).apply(lambda x: fuzz.token_set_ratio(x.lower(), brand.lower()) > 85)]
            
            if relevant_mis.empty: continue 
            
            for d_str in conflict_dates_str:
                try:
                    parts = d_str.split('/')
                    check_date = datetime(target_year, int(parts[0]), int(parts[1]))
                    # Convert to pandas Timestamp for date comparison
                    ts_check_date = pd.Timestamp(check_date)
                    
                    # --- NEW LOGIC: Check Date Range AND Weekday Column ---
                    active_on_conflict = relevant_mis[
                        (relevant_mis['Start_DT'] <= ts_check_date) & 
                        (relevant_mis['End_DT'] >= ts_check_date)
                    ]
                    
                    # Filter further: Is the deal actually running on this specific weekday?
                    actually_active = []
                    for _, m_row in active_on_conflict.iterrows():
                        mis_weekdays = str(m_row.get('Weekday', ''))
                        # Only count as active if the Weekday column confirms it
                        if check_mis_weekday_active(check_date, mis_weekdays):
                            actually_active.append(m_row)
                    
                    if len(actually_active) > 0:
                        # FAILURE: Deal is running on a conflict date!
                        row = actually_active[0]
                        missing_gaps.append({
                            'brand': brand,
                            'weekday': req['weekday'],
                            'mis_id': str(row.get('ID', 'Unknown')),
                            'mis_end_date': str(row.get('End date', '')),
                            'expected_gap_dates': [d_str] 
                        })
                    else:
                        # SUCCESS: No deal found active on this date + weekday
                        verified_gaps.append({'brand': brand, 'gap_date': d_str})

                except Exception as e:
                    print(f"Gap check error for {brand} on {d_str}: {e}")
                    continue

        return jsonify({
            'success': True,
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}",
            'summary': {'weekly_checked': len(weekly_deals), 'tier1_conflicts': len(splits_required)},
            'missing_gaps': missing_gaps,
            'verified_gaps': verified_gaps
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/mis/split-audit/final', methods=['POST'])
def api_split_audit_final():
    """
    Phase 3: Final Audit - Ensures exactly 1 dominant deal exists on conflict dates.
    Input: MIS CSV only (but uses Sheet to find conflict dates).
    """
    try:
        # 1. LOAD INPUTS
        tab_name = request.form.get('tab')
        if not tab_name: return jsonify({'success': False, 'error': 'No tab specified.'})

        mis_df = None
        if request.files.get('csv'):
            mis_df = pd.read_csv(request.files['csv'])
        elif request.form.get('local_csv_path'):
            path = request.form.get('local_csv_path')
            if os.path.exists(path):
                mis_df = pd.read_csv(path)
        
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'MIS CSV data missing.'})

        # 2. IDENTIFY ALL CONFLICT DATES (From Sheet)
        target_month, target_year = parse_tab_month_year(tab_name)
        sections_data = fetch_google_sheet_data(tab_name)
        
        tier1_map = {} # {date_obj: [deal_info]}
        for sec in ['sale', 'monthly']:
            df = sections_data.get(sec, pd.DataFrame())
            if df.empty: continue
            for _, row in df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand: continue
                if sec == 'sale':
                    d_str = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                    dates = parse_sale_dates(d_str, target_month, target_year)
                else:
                    d_str = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                    dates = parse_monthly_dates(d_str, target_month, target_year)
                for d in dates:
                    if d not in tier1_map: tier1_map[d] = []
                    tier1_map[d].append({'brand': brand, 'type': sec})

        # 3. VALIDATE MIS CSV
        mis_df['Start_DT'] = pd.to_datetime(mis_df['Start date'], errors='coerce')
        mis_df['End_DT'] = pd.to_datetime(mis_df['End date'], errors='coerce')
        
        double_dips = []
        empty_gaps = []
        valid_dates = []
        
        processed_dates = sorted(tier1_map.keys())
        
        for check_date in processed_dates:
            expected_deals = tier1_map[check_date]
            ts_check_date = pd.Timestamp(check_date) # Conversion for comparison

            for expected in expected_deals:
                brand = expected['brand']
                
                # Broad Filter: Brand + Date Range
                potential_deals = mis_df[
                    (mis_df['Brand'].astype(str).apply(lambda x: fuzz.token_set_ratio(x.lower(), brand.lower()) > 85)) &
                    (mis_df['Start_DT'] <= ts_check_date) &
                    (mis_df['End_DT'] >= ts_check_date)
                ]
                
                # Strict Filter: Check Weekday Column
                active_deals = []
                for _, row in potential_deals.iterrows():
                    mis_weekdays = str(row.get('Weekday', ''))
                    # NEW: Verify this specific date matches the weekday string
                    if check_mis_weekday_active(check_date, mis_weekdays):
                        active_deals.append(row)
                
                date_str = check_date.strftime('%Y-%m-%d')
                
                if len(active_deals) == 0:
                    empty_gaps.append({
                        'date': date_str, 'brand': brand, 
                        'expected_source': expected['type'].title()
                    })
                elif len(active_deals) > 1:
                    # DOUBLE DIP!
                    deals_info = []
                    for row in active_deals:
                        deals_info.append({
                            'mis_id': str(row.get('ID', '')),
                            'deal_type': 'Active Deal',
                            'discount': str(row.get('Daily Deal Discount', ''))
                        })
                    double_dips.append({'date': date_str, 'brand': brand, 'deals': deals_info})
                else:
                    # Perfect
                    row = active_deals[0]
                    valid_dates.append({
                        'date': date_str, 'brand': brand,
                        'active_deal_type': expected['type'].title(),
                        'mis_id': str(row.get('ID', ''))
                    })

        return jsonify({
            'success': True,
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}",
            'summary': {'conflict_dates_checked': len(processed_dates)},
            'double_dips': double_dips, 'empty_gaps': empty_gaps, 'valid_dates': valid_dates
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# END SPLIT AUDIT API ROUTES (Phase 1 & Legacy Gap Check)

# ============================================================================
# PHASE 2: FINAL VERIFICATION - Helper Functions
# ============================================================================

def parse_mis_id_cell(cell_value: str, section: str = None) -> Dict[str, any]:
    """
    Parse a Google Sheet MIS ID cell that may contain tagged IDs.
    
    v10.8.1: Uses regex for robust parsing regardless of line break format.
    
    v10.8 NEW FORMAT (newline-separated with section-based tags):
        W1: 12345     (Weekly Original)
        WP: 67890     (Weekly Patch)
        W2: 54321     (Weekly Continuation)
        M1: 99999     (Monthly Original)
        MP: 88888     (Monthly Patch)
        M2: 77777     (Monthly Continuation)
        S1: 66666     (Sale Original)
        SP: 55555     (Sale Patch)
        S2: 44444     (Sale Continuation)
    
    Tag format: {Section Letter}{Number or P}: {MIS ID}
        W = Weekly, M = Monthly, S = Sale
        1, 2, 3... = Parts (Original, Continuation 1, Continuation 2...)
        P = Patch
    
    Args:
        cell_value: The MIS ID cell content
        section: Optional - 'weekly', 'monthly', or 'sale' to filter results
    
    Returns dict with:
        'weekly': {'parts': [W1, W2, ...], 'patch': WP or None}
        'monthly': {'parts': [M1, M2, ...], 'patch': MP or None}
        'sale': {'parts': [S1, S2, ...], 'patch': SP or None}
        'parts': All parts combined (for backward compat)
        'patches': All patches combined (for backward compat)
        'raw': Original cell value
        'is_tagged': True if new tagged format detected
    """
    import re
    
    result = {
        'weekly': {'parts': [], 'patch': None},
        'monthly': {'parts': [], 'patch': None},
        'sale': {'parts': [], 'patch': None},
        'parts': [],      # Combined parts for backward compat
        'patches': [],    # Combined patches for backward compat
        'gaps': [],       # Legacy GAP support
        'raw': str(cell_value).strip() if cell_value else '',
        'is_tagged': False,
        'all_tagged': []  # v12.1: All (tag, id) pairs in order, including duplicates for multi-brand
    }
    
    if not cell_value or str(cell_value).strip() in ['', 'nan', 'None', '-']:
        print(f"[PARSE] Empty or invalid cell value: '{cell_value}'")
        return result
    
    raw = str(cell_value).strip()
    print(f"[PARSE] Raw input: '{raw}'")
    
    # v12.1: Universal pattern to capture ALL tagged IDs in order (for multi-brand support)
    # This captures W1, W2, WP, M1, M2, MP, S1, S2, SP and the ID
    universal_pattern = r'([WwMmSs])([1-9Pp])\s*:\s*(\d+)'
    for match in re.finditer(universal_pattern, raw):
        section_letter = match.group(1).upper()
        part_indicator = match.group(2).upper()
        mis_id = match.group(3)
        tag = f"{section_letter}{part_indicator}"
        result['all_tagged'].append((tag, mis_id))
    
    # v10.8.1: Use regex to find all tagged IDs regardless of separator format
    # Pattern matches: W1: 12345, W2: 67890, WP: 99999, M1: 11111, etc.
    # Works with newlines, literal \n, commas, or any separator
    
    # Weekly parts (W1, W2, W3, etc.)
    weekly_parts_pattern = r'[Ww](\d+)\s*:\s*(\d+)'
    for match in re.finditer(weekly_parts_pattern, raw):
        part_num = int(match.group(1))
        mis_id = match.group(2)
        print(f"[PARSE] Found W{part_num}: {mis_id}")
        # Ensure parts list is long enough and insert at correct position
        while len(result['weekly']['parts']) < part_num:
            result['weekly']['parts'].append(None)
        result['weekly']['parts'][part_num - 1] = mis_id
        if mis_id not in result['parts']:
            result['parts'].append(mis_id)
        result['is_tagged'] = True
    
    # Weekly patch (WP)
    weekly_patch_pattern = r'[Ww][Pp]\s*:\s*(\d+)'
    match = re.search(weekly_patch_pattern, raw)
    if match:
        mis_id = match.group(1)
        print(f"[PARSE] Found WP: {mis_id}")
        result['weekly']['patch'] = mis_id
        result['patches'].append(mis_id)
        result['is_tagged'] = True
    
    # Monthly parts (M1, M2, M3, etc.)
    monthly_parts_pattern = r'[Mm](\d+)\s*:\s*(\d+)'
    for match in re.finditer(monthly_parts_pattern, raw):
        part_num = int(match.group(1))
        mis_id = match.group(2)
        print(f"[PARSE] Found M{part_num}: {mis_id}")
        while len(result['monthly']['parts']) < part_num:
            result['monthly']['parts'].append(None)
        result['monthly']['parts'][part_num - 1] = mis_id
        if mis_id not in result['parts']:
            result['parts'].append(mis_id)
        result['is_tagged'] = True
    
    # Monthly patch (MP)
    monthly_patch_pattern = r'[Mm][Pp]\s*:\s*(\d+)'
    match = re.search(monthly_patch_pattern, raw)
    if match:
        mis_id = match.group(1)
        print(f"[PARSE] Found MP: {mis_id}")
        result['monthly']['patch'] = mis_id
        result['patches'].append(mis_id)
        result['is_tagged'] = True
    
    # Sale parts (S1, S2, S3, etc.)
    sale_parts_pattern = r'[Ss](\d+)\s*:\s*(\d+)'
    for match in re.finditer(sale_parts_pattern, raw):
        part_num = int(match.group(1))
        mis_id = match.group(2)
        print(f"[PARSE] Found S{part_num}: {mis_id}")
        while len(result['sale']['parts']) < part_num:
            result['sale']['parts'].append(None)
        result['sale']['parts'][part_num - 1] = mis_id
        if mis_id not in result['parts']:
            result['parts'].append(mis_id)
        result['is_tagged'] = True
    
    # Sale patch (SP)
    sale_patch_pattern = r'[Ss][Pp]\s*:\s*(\d+)'
    match = re.search(sale_patch_pattern, raw)
    if match:
        mis_id = match.group(1)
        print(f"[PARSE] Found SP: {mis_id}")
        result['sale']['patch'] = mis_id
        result['patches'].append(mis_id)
        result['is_tagged'] = True
    
    # LEGACY: Part 1, Part 2, etc.
    legacy_part_pattern = r'[Pp]art\s*(\d+)\s*:\s*(\d+)'
    for match in re.finditer(legacy_part_pattern, raw):
        part_num = int(match.group(1))
        mis_id = match.group(2)
        print(f"[PARSE] Found legacy Part {part_num}: {mis_id}")
        while len(result['weekly']['parts']) < part_num:
            result['weekly']['parts'].append(None)
        if result['weekly']['parts'][part_num - 1] is None:
            result['weekly']['parts'][part_num - 1] = mis_id
        if mis_id not in result['parts']:
            result['parts'].append(mis_id)
        result['is_tagged'] = True
    
    # LEGACY: GAP
    gap_pattern = r'[Gg][Aa][Pp]\s*:\s*(\d+)'
    for match in re.finditer(gap_pattern, raw):
        mis_id = match.group(1)
        print(f"[PARSE] Found legacy GAP: {mis_id}")
        result['gaps'].append(mis_id)
        result['is_tagged'] = True
    
    # LEGACY: Patch (without section prefix)
    legacy_patch_pattern = r'[Pp]atch\s*:\s*(\d+)'
    match = re.search(legacy_patch_pattern, raw)
    if match:
        mis_id = match.group(1)
        print(f"[PARSE] Found legacy Patch: {mis_id}")
        if result['weekly']['patch'] is None:
            result['weekly']['patch'] = mis_id
        if mis_id not in result['patches']:
            result['patches'].append(mis_id)
        result['is_tagged'] = True
    
    # If no tags found, try plain number (untagged single ID)
    if not result['is_tagged']:
        # Check for plain numeric ID
        plain_id_pattern = r'^(\d{5,7})$'
        match = re.match(plain_id_pattern, raw)
        if match:
            mis_id = match.group(1)
            print(f"[PARSE] Found plain ID: {mis_id}")
            result['weekly']['parts'].append(mis_id)
            result['parts'].append(mis_id)
    
    # Remove None values from parts lists
    result['weekly']['parts'] = [p for p in result['weekly']['parts'] if p is not None]
    result['monthly']['parts'] = [p for p in result['monthly']['parts'] if p is not None]
    result['sale']['parts'] = [p for p in result['sale']['parts'] if p is not None]
    
    # Add part1 for backward compatibility
    result['part1'] = result['parts'][0] if result['parts'] else None
    
    print(f"[PARSE] Result: weekly={result['weekly']}, monthly={result['monthly']}, sale={result['sale']}")
    
    return result


# ============================================================================
# MULTI-BRAND SUPPORT FUNCTIONS (v12.1)
# ============================================================================

def parse_multi_brand(brand_str: str) -> List[str]:
    """
    Parse a brand string that may contain multiple brands.
    
    v12.1: Multi-brand support - handles comma-separated brands from dropdown multi-select.
    v12.2: Preserve brands that legitimately contain "&" (Papa & Barkley, Hash & Flowers)
    
    Examples:
        "Stiiizy" -> ["Stiiizy"]
        "Stiiizy, Shryne" -> ["Stiiizy", "Shryne"]
        "Brand A / Brand B" -> ["Brand A", "Brand B"]
        "Papa & Barkley" -> ["Papa & Barkley"]  # Preserved!
        "Hash & Flowers" -> ["Hash & Flowers"]  # Preserved!
    
    Returns: List of individual brand names
    """
    if not brand_str or str(brand_str).strip() in ['', 'nan', 'None', '-']:
        return []
    
    brand_str = str(brand_str).strip()
    
    # v12.2: Known brands that contain "&" - these should NOT be split
    # Use placeholders to preserve them during normalization
    AMPERSAND_BRANDS = [
        'Papa & Barkley',
        'Hash & Flowers',
    ]
    
    # Replace known ampersand brands with placeholders
    preserved = {}
    for i, ab in enumerate(AMPERSAND_BRANDS):
        placeholder = f"__AMPERSAND_BRAND_{i}__"
        # Case-insensitive replacement
        import re
        pattern = re.compile(re.escape(ab), re.IGNORECASE)
        if pattern.search(brand_str):
            # Get the actual matched text to preserve original case
            match = pattern.search(brand_str)
            preserved[placeholder] = match.group(0)
            brand_str = pattern.sub(placeholder, brand_str)
    
    # Normalize separators: / becomes , (but NOT & anymore since we've preserved known brands)
    # Only treat standalone & as separator if it's surrounded by spaces
    import re
    # Replace " / " with comma
    normalized = re.sub(r'\s*/\s*', ', ', brand_str)
    # Replace " & " with comma ONLY if it's not a preserved placeholder
    # Don't replace & at all now - only commas and slashes are separators
    
    # Split on comma and clean up
    brands = [b.strip() for b in normalized.split(',') if b.strip()]
    
    # Restore preserved brands
    result = []
    for b in brands:
        for placeholder, original in preserved.items():
            b = b.replace(placeholder, original)
        result.append(b)
    
    return result


def is_multi_brand(brand_str: str) -> bool:
    """Check if a brand string contains multiple brands."""
    return len(parse_multi_brand(brand_str)) > 1


def get_brand_from_mis_id(mis_id: str, mis_df) -> Optional[str]:
    """
    Look up a MIS ID in the CSV and return the brand name.
    Used to determine which brand a MIS ID belongs to in multi-brand deals.
    """
    if not mis_id or mis_df is None or mis_df.empty:
        return None
    
    mis_id = str(mis_id).strip()
    if mis_id.endswith('.0'):
        mis_id = mis_id[:-2]
    
    # Find ID column
    id_col = None
    for col in ['ID', 'id', 'MIS ID', 'Mis Id']:
        if col in mis_df.columns:
            id_col = col
            break
    
    if not id_col:
        return None
    
    # Search for the ID
    matches = mis_df[mis_df[id_col].astype(str).str.strip() == mis_id]
    
    if matches.empty:
        return None
    
    return str(matches.iloc[0].get('Brand', '')).strip()


def match_mis_ids_to_brands(mis_id_cell: str, brands: List[str], mis_df) -> Dict[str, List]:
    """
    Given a MIS ID cell with multiple IDs and a list of brands,
    match each MIS ID to its corresponding brand by looking up in CSV.
    
    v12.2: Uses strict matching to avoid confusing similar brands
           (e.g., "Stiiizy" vs "Stiiizy Accessories")
    
    Args:
        mis_id_cell: The MIS ID cell content (e.g., "W1: 12345\\nW1: 67890\\nW2: 11111\\nW2: 22222")
        brands: List of brand names (e.g., ["Stiiizy", "Stiiizy Accessories"])
        mis_df: The MIS CSV DataFrame
    
    Returns:
        Dict mapping brand name to list of (tag, id) tuples
        e.g., {"Stiiizy": [("W1", "919")], 
               "Stiiizy Accessories": [("W1", "920")]}
    """
    parsed = parse_mis_id_cell(mis_id_cell)
    all_tagged = parsed.get('all_tagged', [])
    
    result = {brand: [] for brand in brands}
    unmatched = []
    
    for tag, mis_id in all_tagged:
        csv_brand = get_brand_from_mis_id(mis_id, mis_df)
        
        if csv_brand:
            csv_brand_lower = csv_brand.lower().strip()
            matched = False
            
            # v12.2: STRICT MATCHING - prioritize exact matches first
            # This prevents "Stiiizy" from matching "Stiiizy Accessories"
            
            # Pass 1: Exact match (case-insensitive)
            for brand in brands:
                if csv_brand_lower == brand.lower().strip():
                    result[brand].append((tag, mis_id))
                    matched = True
                    break
            
            # Pass 2: If no exact match, check for partial containment carefully
            # Only match if csv_brand contains the sheet brand AND they're "close enough"
            # But NOT if one is a substring of the other with extra words
            if not matched:
                for brand in brands:
                    brand_lower = brand.lower().strip()
                    
                    # Skip if one contains the other but they're not equal
                    # This prevents "Stiiizy" matching "Stiiizy Accessories"
                    if brand_lower in csv_brand_lower and brand_lower != csv_brand_lower:
                        continue
                    if csv_brand_lower in brand_lower and brand_lower != csv_brand_lower:
                        continue
                    
                    # Fuzzy match only for completely different spellings
                    # (e.g., typos, slight variations)
                    ratio = fuzz.token_set_ratio(csv_brand_lower, brand_lower)
                    if ratio >= 95:  # Very high threshold for non-exact matches
                        result[brand].append((tag, mis_id))
                        matched = True
                        break
            
            if not matched:
                unmatched.append((tag, mis_id, csv_brand))
        else:
            unmatched.append((tag, mis_id, None))
    
    # Add unmatched to a special key
    if unmatched:
        result['_unmatched'] = unmatched
    
    return result


def format_brand_mis_ids(tagged_ids: List[tuple]) -> str:
    """
    Format a list of (tag, id) tuples back into a cell string.
    e.g., [("W1", "12345"), ("W2", "67890")] -> "W1: 12345, W2: 67890"
    """
    if not tagged_ids:
        return ''
    return ', '.join([f"{tag}: {mid}" for tag, mid in tagged_ids])


def format_tagged_mis_cell(section: str, parts: List[str] = None, patch: str = None, 
                           existing_content: str = None) -> str:
    """
    Format MIS IDs into the new tagged newline-separated format.
    
    v10.8: Section-based tags (W1/W2/WP, M1/M2/MP, S1/S2/SP)
    
    Args:
        section: 'weekly', 'monthly', or 'sale'
        parts: List of part IDs [Original, Continuation1, Continuation2, ...]
        patch: Patch ID (if any)
        existing_content: Existing cell content to preserve other section's IDs
    
    Returns formatted string like:
        W1: 12345
        WP: 67890
        W2: 54321
    """
    # Determine section prefix
    section_lower = section.lower() if section else 'weekly'
    if section_lower.startswith('week') or section_lower == 'w':
        prefix = 'W'
    elif section_lower.startswith('month') or section_lower == 'm':
        prefix = 'M'
    elif section_lower.startswith('sale') or section_lower == 's':
        prefix = 'S'
    else:
        prefix = 'W'  # Default to Weekly
    
    # Parse existing content to preserve other sections
    existing = parse_mis_id_cell(existing_content) if existing_content else None
    
    lines = []
    
    # If we have existing content, preserve other sections first
    if existing and existing['raw']:
        raw_lines = existing['raw'].replace('\r\n', '\n').split('\n')
        for line in raw_lines:
            line = line.strip()
            if not line:
                continue
            line_lower = line.lower()
            # Keep lines that don't start with our section prefix
            if line_lower and line_lower[0] != prefix.lower():
                lines.append(line)
    
    # Add parts for this section (W1, W2, W3... or M1, M2, M3... or S1, S2, S3...)
    if parts:
        for i, part_id in enumerate(parts, 1):
            if part_id:
                lines.append(f"{prefix}{i}: {part_id}")
    
    # Add patch for this section (WP, MP, or SP)
    if patch:
        lines.append(f"{prefix}P: {patch}")
    
    return '\n'.join(lines)


def update_tagged_mis_cell(existing_content: str, tag: str, new_id: str, append_mode: bool = False) -> str:
    """
    Update a specific tag in a MIS ID cell, preserving other content.
    
    v10.8: Section-based tags
    tag: 'w1', 'w2', 'wp', 'm1', 'm2', 'mp', 's1', 's2', 'sp'
         (also accepts legacy: 'part1', 'part2', 'gap', 'patch')
    new_id: The MIS ID to set
    append_mode: v12.1 - If True, always append new line even if tag exists (for multi-brand)
    
    If tag already exists and append_mode=False, updates it. Otherwise, appends it.
    """
    if not new_id or not new_id.strip():
        return existing_content
    
    new_id = str(new_id).strip()
    tag_lower = tag.lower().strip()
    
    # Strip any existing tag from the MIS ID (in case it was passed with a tag)
    new_id = strip_mis_id_tag(new_id)
    
    # Parse existing content
    existing_lines = []
    if existing_content:
        existing_lines = [l.strip() for l in existing_content.replace('\r\n', '\n').split('\n') if l.strip()]
    
    # Determine the tag prefix to look for and the line to add
    # v10.8: New format (W1, W2, WP, M1, M2, MP, S1, S2, SP)
    new_line = ''
    tag_prefix = ''
    
    if tag_lower in ['w1', 'weekly1', 'weekly_1']:
        new_line = f"W1: {new_id}"
        tag_prefix = 'w1'
    elif tag_lower in ['w2', 'weekly2', 'weekly_2']:
        new_line = f"W2: {new_id}"
        tag_prefix = 'w2'
    elif tag_lower in ['w3', 'weekly3', 'weekly_3']:
        new_line = f"W3: {new_id}"
        tag_prefix = 'w3'
    elif tag_lower in ['wp', 'weekly_patch', 'weeklypatch']:
        new_line = f"WP: {new_id}"
        tag_prefix = 'wp'
    elif tag_lower in ['m1', 'monthly1', 'monthly_1']:
        new_line = f"M1: {new_id}"
        tag_prefix = 'm1'
    elif tag_lower in ['m2', 'monthly2', 'monthly_2']:
        new_line = f"M2: {new_id}"
        tag_prefix = 'm2'
    elif tag_lower in ['m3', 'monthly3', 'monthly_3']:
        new_line = f"M3: {new_id}"
        tag_prefix = 'm3'
    elif tag_lower in ['mp', 'monthly_patch', 'monthlypatch']:
        new_line = f"MP: {new_id}"
        tag_prefix = 'mp'
    elif tag_lower in ['s1', 'sale1', 'sale_1']:
        new_line = f"S1: {new_id}"
        tag_prefix = 's1'
    elif tag_lower in ['s2', 'sale2', 'sale_2']:
        new_line = f"S2: {new_id}"
        tag_prefix = 's2'
    elif tag_lower in ['s3', 'sale3', 'sale_3']:
        new_line = f"S3: {new_id}"
        tag_prefix = 's3'
    elif tag_lower in ['sp', 'sale_patch', 'salepatch']:
        new_line = f"SP: {new_id}"
        tag_prefix = 'sp'
    # Legacy support
    elif tag_lower in ['part1', 'part_1', 'part 1']:
        new_line = f"W1: {new_id}"
        tag_prefix = 'w1'
    elif tag_lower in ['part2', 'part_2', 'part 2']:
        new_line = f"W2: {new_id}"
        tag_prefix = 'w2'
    elif tag_lower in ['gap']:
        # GAP is deprecated but convert to appropriate section if known
        new_line = f"M1: {new_id}"  # Assume monthly for legacy GAP
        tag_prefix = 'm1'
    elif tag_lower in ['patch']:
        new_line = f"WP: {new_id}"  # Assume weekly patch for legacy
        tag_prefix = 'wp'
    else:
        # Unknown tag - just add as W1
        new_line = f"W1: {new_id}"
        tag_prefix = 'w1'
    
    # Look for existing line with same tag and replace (unless append_mode), or append
    found = False
    result_lines = []
    
    for line in existing_lines:
        line_lower = line.lower()
        # Check if this line has the same tag prefix
        if line_lower.startswith(tag_prefix + ':') or line_lower.startswith(tag_prefix + ' :'):
            if append_mode:
                # v12.1: In append mode, keep existing line AND add new one later
                result_lines.append(line)
            else:
                # Replace mode: replace existing line with new one
                result_lines.append(new_line)
                found = True
        else:
            result_lines.append(line)
    
    if not found or append_mode:
        result_lines.append(new_line)
    
    return '\n'.join(result_lines)


def strip_mis_id_tag(tagged_id: str) -> str:
    """
    Strip any tag prefix from a MIS ID for display or lookup.
    
    v10.8 examples:
    'W1: 12345' -> '12345'
    'WP: 67890' -> '67890'
    'M1: 99999' -> '99999'
    'S2: 88888' -> '88888'
    
    Legacy examples:
    'Part 1: 12345' -> '12345'
    'GAP: 67890' -> '67890'
    '12345' -> '12345'
    """
    if not tagged_id:
        return ''
    
    tagged_id = str(tagged_id).strip()
    
    if ':' in tagged_id:
        return tagged_id.split(':', 1)[1].strip()
    
    return tagged_id


def find_mis_entry_by_id(mis_df: pd.DataFrame, mis_id: str) -> Optional[Dict]:
    """
    Find a deal in the MIS CSV by its ID.
    Returns a dict with deal attributes or None if not found.
    v10.7: More robust ID column detection and debug output
    """
    if not mis_id or mis_df is None or mis_df.empty:
        print(f"[FIND-MIS] Skipping - mis_id={mis_id}, df_empty={mis_df is None or mis_df.empty if mis_df is not None else True}")
        return None
    
    # Clean the ID - strip tags if present
    mis_id = str(mis_id).strip()
    mis_id = strip_mis_id_tag(mis_id)  # Remove "Part 1:", "GAP:", etc.
    
    if not mis_id or not mis_id.isdigit():
        print(f"[FIND-MIS] Invalid MIS ID after cleaning: '{mis_id}'")
        return None
    
    # v10.7: Try multiple possible ID column names
    id_columns = ['ID', 'id', 'MIS ID', 'Mis Id', 'MIS_ID', 'mis_id']
    id_col = None
    
    for col in id_columns:
        if col in mis_df.columns:
            id_col = col
            break
    
    if not id_col:
        print(f"[FIND-MIS] ERROR: No ID column found. Available columns: {list(mis_df.columns)}")
        return None
    
    # Search in the ID column
    matches = mis_df[mis_df[id_col].astype(str).str.strip() == mis_id]
    
    if matches.empty:
        print(f"[FIND-MIS] No match for ID '{mis_id}' in column '{id_col}'")
        return None
    
    row = matches.iloc[0]
    print(f"[FIND-MIS] [OK] Found MIS ID {mis_id}: Brand='{row.get('Brand', 'N/A')}'")
    
    return {
        'mis_id': str(row.get(id_col, '')),
        'brand': str(row.get('Brand', '')).strip(),
        'discount': str(row.get('Daily Deal Discount', '')).strip(),
        'vendor_pct': str(row.get('Discount paid by vendor', '')).strip(),
        'start_date': str(row.get('Start date', '')).strip(),
        'end_date': str(row.get('End date', '')).strip(),
        'locations': str(row.get('Store', '')).strip(),
        'weekday': str(row.get('Weekday', '')).strip(),
        'category': str(row.get('Category', '')).strip()
    }


def compare_deal_attributes(expected: Dict, actual: Dict) -> Tuple[bool, List[str]]:
    """
    Compare expected deal attributes against actual MIS entry.
    Returns: (all_match, list_of_issues)
    """
    issues = []
    
    if not actual:
        return False, ['MIS entry not found']
    
    def normalize_numeric_value(val):
        """
        Normalize numeric values for comparison.
        Handles: '50%' -> 50.0, '50' -> 50.0, 50 -> 50.0, '0.50' -> 0.50
        Also handles: '50% off', '$20', '20.5%', etc.
        """
        if val is None:
            return None
        
        # Convert to string and clean
        val_str = str(val).strip().lower()
        if not val_str or val_str in ['', '-', 'nan', 'none', 'n/a']:
            return None
        
        # Remove common suffixes and prefixes
        val_str = val_str.replace('off', '').replace('discount', '').strip()
        
        # Extract numeric portion: remove %, $, and other non-numeric chars except decimal and minus
        cleaned = ''
        found_decimal = False
        for c in val_str:
            if c.isdigit():
                cleaned += c
            elif c == '.' and not found_decimal:
                cleaned += c
                found_decimal = True
            elif c == '-' and cleaned == '':
                cleaned += c
        
        if not cleaned or cleaned == '-':
            return val_str  # Return original if no numbers found
        
        try:
            num = float(cleaned)
            # Handle decimal percentages (0.50 -> 50 if expected is likely a percentage)
            # Only do this if the number is between 0 and 1 and original had no % sign
            if 0 < num < 1 and '%' not in str(val):
                num = num * 100
            return num
        except:
            return val_str
    
    def values_match(exp_val, act_val, tolerance=0.5):
        """Compare two normalized values with tolerance."""
        if exp_val is None or act_val is None:
            return True  # Skip comparison if either is missing
        
        if isinstance(exp_val, float) and isinstance(act_val, float):
            # Allow tolerance for floating point comparison
            return abs(exp_val - act_val) <= tolerance
        
        # String comparison as fallback
        return str(exp_val).lower() == str(act_val).lower()
    
    # Compare discount
    exp_discount = normalize_numeric_value(expected.get('discount', ''))
    act_discount = normalize_numeric_value(actual.get('discount', ''))
    
    if not values_match(exp_discount, act_discount):
        issues.append(f"Discount: expected '{expected.get('discount')}', got '{actual.get('discount')}'")
    
    # Compare vendor percentage
    exp_vendor = normalize_numeric_value(expected.get('vendor_pct', ''))
    act_vendor = normalize_numeric_value(actual.get('vendor_pct', ''))
    
    if not values_match(exp_vendor, act_vendor):
        issues.append(f"Vendor%: expected '{expected.get('vendor_pct')}', got '{actual.get('vendor_pct')}'")
    
    # Compare dates (if provided in expected)
    if expected.get('start_date'):
        exp_start = expected.get('start_date', '').strip()
        act_start = actual.get('start_date', '').strip()
        if exp_start and act_start and exp_start != act_start:
            issues.append(f"Start date: expected '{exp_start}', got '{act_start}'")
    
    if expected.get('end_date'):
        exp_end = expected.get('end_date', '').strip()
        act_end = actual.get('end_date', '').strip()
        if exp_end and act_end and exp_end != act_end:
            issues.append(f"End date: expected '{exp_end}', got '{act_end}'")
    
    # Compare locations (if provided)
    if expected.get('locations'):
        exp_loc = expected.get('locations', '').strip().lower()
        act_loc = actual.get('locations', '').strip().lower()
        
        # Treat NaN/empty/blank as "All Locations"
        if not act_loc or act_loc in ['nan', 'none', '', '-', 'n/a']:
            act_loc = 'all locations'
        if not exp_loc or exp_loc in ['nan', 'none', '', '-', 'n/a']:
            exp_loc = 'all locations'
        
        # Fuzzy location comparison (they might be formatted differently)
        if exp_loc and act_loc:
            # "All Locations" matches anything or empty
            if exp_loc == 'all locations' or act_loc == 'all locations':
                pass  # No issue - All Locations matches everything
            elif fuzz.token_set_ratio(exp_loc, act_loc) < 80:
                issues.append(f"Locations: expected '{expected.get('locations')}', got '{actual.get('locations')}'")
    
    return len(issues) == 0, issues


def generate_fuzzy_suggestions(expected_deal: Dict, mis_df: pd.DataFrame, max_results: int = 3) -> List[Dict]:
    """
    Find similar deals in MIS CSV when exact MIS ID is missing.
    Scores by: brand (40pts), discount (20pts), vendor% (10pts), dates (20pts), locations (10pts)
    """
    if mis_df is None or mis_df.empty:
        return []
    
    suggestions = []
    exp_brand = str(expected_deal.get('brand', '')).lower()
    exp_discount = str(expected_deal.get('discount', '')).lower()
    exp_vendor = str(expected_deal.get('vendor_pct', '')).lower()
    exp_locations = str(expected_deal.get('locations', '')).lower()
    
    for _, row in mis_df.iterrows():
        score = 0
        
        # Brand match (40 pts max)
        act_brand = str(row.get('Brand', '')).lower()
        brand_score = fuzz.token_set_ratio(exp_brand, act_brand)
        if brand_score >= 85:
            score += 40
        elif brand_score >= 70:
            score += 25
        elif brand_score >= 50:
            score += 10
        
        # Discount match (20 pts max)
        act_discount = str(row.get('Daily Deal Discount', '')).lower()
        if exp_discount and act_discount and exp_discount == act_discount:
            score += 20
        elif exp_discount and act_discount and fuzz.ratio(exp_discount, act_discount) > 80:
            score += 10
        
        # Vendor % match (10 pts max)
        act_vendor = str(row.get('Discount paid by vendor', '')).lower()
        if exp_vendor and act_vendor and exp_vendor == act_vendor:
            score += 10
        
        # Location match (10 pts max)
        act_locations = str(row.get('Store', '')).lower()
        if exp_locations and act_locations:
            loc_score = fuzz.token_set_ratio(exp_locations, act_locations)
            if loc_score >= 80:
                score += 10
            elif loc_score >= 60:
                score += 5
        
        # Only include if score is meaningful
        if score >= 30:
            suggestions.append({
                'mis_id': str(row.get('ID', '')),
                'score': score,
                'brand': str(row.get('Brand', '')),
                'discount': str(row.get('Daily Deal Discount', '')),
                'vendor_pct': str(row.get('Discount paid by vendor', '')),
                'locations': str(row.get('Store', '')),
                'start_date': str(row.get('Start date', '')),
                'end_date': str(row.get('End date', '')),
                'weekday': str(row.get('Weekday', ''))
            })
    
    # Sort by score descending and return top results
    suggestions.sort(key=lambda x: x['score'], reverse=True)
    return suggestions[:max_results]


@app.route('/api/mis/split-audit/final-check', methods=['POST'])
def api_split_audit_final_check():
    """
    Phase 2: Final Verification - Compares expected plan against actual MIS CSV.
    
    1. Regenerates expected plan (same as Phase 1)
    2. Parses MIS IDs from Google Sheet (with prefix handling)
    3. Matches each entry in CSV and verifies attributes
    4. Returns color-coded verification results
    """
    try:
        # 1. LOAD INPUTS
        tab_name = request.form.get('tab')
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab specified.'})
        
        # Load MIS CSV - check multiple sources in priority order
        mis_df = None
        csv_source = None
        
        # Priority 1: Uploaded file in request
        if request.files.get('csv'):
            mis_df = pd.read_csv(request.files['csv'])
            csv_source = "uploaded file"
        
        # Priority 2: local_csv_path from form data (sent by frontend)
        elif request.form.get('local_csv_path'):
            path = request.form.get('local_csv_path')
            if Path(path).exists():
                mis_df = pd.read_csv(path)
                csv_source = f"local path: {path}"
        
        # Priority 3: Global path stored from previous pull
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            path = GLOBAL_DATA['mis']['mis_csv_filepath']
            if Path(path).exists():
                mis_df = pd.read_csv(path)
                csv_source = f"global CSV: {GLOBAL_DATA['mis'].get('mis_csv_filename')}"
        
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'No MIS CSV available. Please pull or upload a CSV in Setup tab.'})
        
        print(f"[FINAL-CHECK] Using {csv_source}")
        
        # Store for later use
        GLOBAL_DATA['mis']['mis_df'] = mis_df
        
        # 2. REGENERATE EXPECTED PLAN (Same as Phase 1)
        target_month, target_year = parse_tab_month_year(tab_name)
        print(f"[FINAL-CHECK] Verifying {tab_name} -> {target_month}/{target_year}")
        
        sections_data = fetch_google_sheet_data(tab_name)
        
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found in sheet.'})
        
        # Process Weekly deals (Tier 2)
        weekly_deals = []
        weekly_df = sections_data.get('weekly', pd.DataFrame())
        
        if not weekly_df.empty:
            multi_day_groups, row_to_group = detect_multi_day_groups(weekly_df, 'weekly')
            processed_groups = set()
            
            for idx, row in weekly_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand:
                    continue
                
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                group_id = row_to_group.get(true_row)
                
                # v12.22.4: Weekly uses Column A ('Weekday')
                weekday_raw = str(get_col(row, ['Weekday', 'Day of Week'], '-')).strip()
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                mis_id_raw = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)
                
                deal_info = str(get_col(row, ['Deal info', 'Deal Info', 'Deal'], '')).strip()
                special_notes = str(get_col(row, ['Special Notes', 'Notes'], '')).strip()
                categories = str(get_col(row, ['Category', 'Categories'], '')).strip()
                
                # Handle multi-day groups
                if group_id and group_id in multi_day_groups:
                    if group_id in processed_groups:
                        continue
                    processed_groups.add(group_id)
                    expanded_dates = get_all_weekdays_for_multiday_group(
                        multi_day_groups[group_id], weekly_df, 'weekly', target_month, target_year
                    )
                    weekday_raw = ', '.join(multi_day_groups[group_id].get('weekdays', []))
                else:
                    expanded_dates = expand_weekday_to_dates(weekday_raw, target_month, target_year)
                
                if expanded_dates:
                    weekly_deals.append({
                        'brand': brand,
                        'weekday': weekday_raw,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'mis_id': mis_id_raw,
                        'expanded_dates': expanded_dates,
                        'google_row': true_row,
                        'deal_info': deal_info,
                        'special_notes': special_notes,
                        'categories': categories
                    })
        
        # Process Tier 1 deals (Sale/Monthly)
        tier1_deals = []
        for section_key in ['sale', 'monthly']:
            section_df = sections_data.get(section_key, pd.DataFrame())
            if section_df.empty:
                continue
            
            for idx, row in section_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand:
                    continue
                
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                
                # v12.13: Section-aware column detection for dates
                if section_key == 'monthly':
                    # Monthly: Read from Column K (ordinals like "1st, 10th")
                    date_raw = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '-')).strip()
                else:  # sale
                    # Sale: Read from Column C (dates like "01/16/26, 01/23/26")
                    date_raw = str(get_col(row, ['Contracted Duration (MM/DD/YY - MM/DD/YY)', 'Contracted Duration', 'Sale Runs:'], '-')).strip()
                
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)
                
                mis_id = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                
                if section_key == 'monthly':
                    expanded_dates = parse_monthly_dates(date_raw, target_month, target_year)
                else:  # sale
                    expanded_dates = parse_sale_dates(date_raw, target_month, target_year)
                
                tier1_deals.append({
                    'brand': brand,
                    'date_raw': date_raw,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'mis_id': mis_id,
                    'expanded_dates': expanded_dates,
                    'section': section_key,
                    'google_row': true_row
                })
        
        # 3. DETECT SPLIT REQUIREMENTS (Reuse Phase 1 logic)
        splits_required, no_conflict = detect_split_requirements(
            weekly_deals, tier1_deals, target_month, target_year
        )
        
        # 4. VERIFY EACH SPLIT
        verification_results = []
        summary = {
            'total_splits': len(splits_required),
            'fully_correct': 0,
            'partial_errors': 0,
            'missing_ids': 0,
            'no_conflict_count': len(no_conflict)
        }
        
        for split in splits_required:
            brand = split.get('brand')
            google_row = split.get('google_row')
            mis_id_raw = split.get('original_mis_id', '')
            plan = split.get('plan', [])
            section = split.get('section', 'weekly').lower()  # v10.8: Get section being split
            int_section = split.get('interrupting_deal_type', 'monthly').lower()  # v10.8: Interrupting section
            
            # v10.8: Parse MIS IDs from Google Sheet cell with section awareness
            parsed_ids = parse_mis_id_cell(mis_id_raw)
            section_ids = parsed_ids.get(section, {}) or {'parts': [], 'patch': None}
            
            # v10.8: Debug output with new format
            print(f"[PHASE2] Brand: {brand}, Row: {google_row}, Section: {section}")
            print(f"[PHASE2]   Raw MIS ID cell: '{mis_id_raw}'")
            print(f"[PHASE2]   {section.upper()} IDs: parts={section_ids.get('parts', [])}, patch={section_ids.get('patch')}")
            
            # Track indices for multiple parts
            part_idx = 0  # 0 = Original, 1 = Cont1, etc.
            
            # Build verification entry for each plan action
            entry_verifications = []
            has_error = False
            has_missing = False
            
            for plan_item in plan:
                action = plan_item.get('action', '')
                entry_result = {
                    'action': action,
                    'expected_dates': plan_item.get('dates', ''),
                    'expected_notes': plan_item.get('notes', ''),
                    'status': 'PENDING',
                    'issues': [],
                    'actual': None,
                    'mis_id': None,
                    'suggestions': []
                }
                
                # v10.8: Determine which MIS ID to use based on action and section
                if action == 'CREATE_PART1':
                    # Original: First in section's parts list (W1, M1, S1)
                    parts = section_ids.get('parts', [])
                    entry_result['mis_id'] = parts[0] if parts else None
                    part_idx = 1  # Next part will be Continuation
                    expected_attrs = {
                        'discount': split.get('discount'),
                        'vendor_pct': split.get('vendor_contrib'),
                        'locations': split.get('locations')
                    }
                    
                elif action == 'GAP':
                    # v10.8: Interrupting deal's MIS ID comes from its own row
                    int_deal = split.get('interrupting_deal', {})
                    tier1_mis_id = int_deal.get('mis_id', '')
                    if tier1_mis_id:
                        # Parse the interrupting deal's MIS ID cell
                        tier1_parsed = parse_mis_id_cell(tier1_mis_id)
                        # Get the interrupting section's IDs (M1, S1, etc.)
                        int_section_ids = tier1_parsed.get(int_section, {}) or {'parts': [], 'patch': None}
                        int_parts = int_section_ids.get('parts', [])
                        if int_parts:
                            entry_result['mis_id'] = int_parts[0]
                        elif tier1_parsed.get('parts'):
                            # Fallback to legacy parts list
                            entry_result['mis_id'] = tier1_parsed['parts'][0]
                        else:
                            # Use raw value if no tags found
                            entry_result['mis_id'] = strip_mis_id_tag(tier1_mis_id)
                    
                    # GAP uses Tier 1 deal attributes
                    expected_attrs = {
                        'discount': int_deal.get('discount'),
                        'vendor_pct': int_deal.get('vendor_contrib'),
                        'locations': int_deal.get('locations')
                    }
                    
                elif action == 'PATCH':
                    # v10.8: Patch ID from section (WP, MP, SP)
                    entry_result['mis_id'] = section_ids.get('patch')
                    
                    expected_attrs = {
                        'discount': plan_item.get('discount', split.get('discount')),
                        'vendor_pct': plan_item.get('vendor_contrib', split.get('vendor_contrib')),
                        'locations': plan_item.get('locations', '')
                    }
                    
                elif action.startswith('CREATE_PART'):
                    # v10.8: Continuation (W2, W3, M2, M3, S2, S3)
                    parts = section_ids.get('parts', [])
                    if part_idx < len(parts):
                        entry_result['mis_id'] = parts[part_idx]
                    part_idx += 1
                    
                    expected_attrs = {
                        'discount': split.get('discount'),
                        'vendor_pct': split.get('vendor_contrib'),
                        'locations': split.get('locations')
                    }
                else:
                    expected_attrs = {}
                
                entry_result['expected'] = expected_attrs
                
                # Verify the entry
                if entry_result['mis_id']:
                    actual = find_mis_entry_by_id(mis_df, entry_result['mis_id'])
                    entry_result['actual'] = actual
                    
                    if actual:
                        all_match, issues = compare_deal_attributes(expected_attrs, actual)
                        if all_match:
                            entry_result['status'] = 'CORRECT'
                        else:
                            entry_result['status'] = 'ERROR'
                            entry_result['issues'] = issues
                            has_error = True
                    else:
                        entry_result['status'] = 'NOT_FOUND'
                        entry_result['issues'] = [f"MIS ID {entry_result['mis_id']} not found in CSV"]
                        has_error = True
                else:
                    # No MIS ID - generate suggestions
                    entry_result['status'] = 'MISSING_ID'
                    has_missing = True
                    
                    # Generate fuzzy suggestions
                    suggestions = generate_fuzzy_suggestions(expected_attrs, mis_df)
                    entry_result['suggestions'] = suggestions
                
                entry_verifications.append(entry_result)
            
            # Determine overall status
            if has_missing:
                overall_status = 'MISSING_ID'
                summary['missing_ids'] += 1
            elif has_error:
                overall_status = 'PARTIAL_ERROR'
                summary['partial_errors'] += 1
            else:
                overall_status = 'CORRECT'
                summary['fully_correct'] += 1
            
            verification_results.append({
                'brand': brand,
                'weekday': split.get('weekday'),
                'google_row': google_row,
                'conflict_type': split.get('conflict_type'),
                'conflict_dates': split.get('conflict_dates', []),
                'interrupting_deal': split.get('interrupting_deal', {}),
                'overall_status': overall_status,
                'parsed_ids': parsed_ids,
                'details': entry_verifications
            })
        
        # 5. RETURN RESULTS
        return jsonify({
            'success': True,
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}",
            'verification_results': verification_results,
            'no_conflict': no_conflict,
            'summary': summary
        })
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/mis/split-audit/fuzzy-suggestions', methods=['POST'])
def api_split_audit_fuzzy_suggestions():
    """
    Get fuzzy match suggestions for a missing MIS ID.
    Called when user needs help finding the correct MIS entry.
    """
    try:
        data = request.get_json() or {}
        expected = data.get('expected', {})
        
        # Use global MIS CSV
        mis_df = GLOBAL_DATA['mis'].get('mis_df')
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'No MIS CSV loaded.'})
        
        suggestions = generate_fuzzy_suggestions(expected, mis_df, max_results=5)
        
        return jsonify({
            'success': True,
            'suggestions': suggestions
        })
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/mis/conflict-audit', methods=['POST'])
def api_mis_conflict_audit():
    """
    Scans the MIS CSV for internal conflicts (Active deals with matching parameters).
    Criteria: Start Date <= Today <= End Date AND Exact Match on (Brand, Weekday).
    Ignores Location.
    """
    try:
        # 1. Load Data (Prefer pulled CSV, fallback to upload)
        csv_file = request.files.get('csv')
        df = None
        
        if csv_file:
            df = pd.read_csv(csv_file)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            path = GLOBAL_DATA['mis']['mis_csv_filepath']
            if Path(path).exists():
                df = pd.read_csv(path)
        
        if df is None or df.empty:
            return jsonify({'success': False, 'error': 'No MIS CSV loaded. Please pull or upload a CSV in Setup.'})

        # 2. Filter for ACTIVE deals
        # Logic: Start Date <= Today AND (End Date >= Today OR End Date is Empty)
        today = datetime.now()
        today = today.replace(hour=0, minute=0, second=0, microsecond=0)
        
        active_rows = []
        
        for idx, row in df.iterrows():
            # Parse Dates
            start_str = str(row.get('Start date', '')).strip()
            end_str = str(row.get('End date', '')).strip()
            
            try:
                # Helper to parse flexible date formats
                def parse_dt(d_str):
                    if not d_str or d_str.lower() == 'nan': return None
                    for fmt in ('%Y-%m-%d', '%m/%d/%Y', '%m-%d-%Y'):
                        try:
                            return datetime.strptime(d_str, fmt)
                        except: continue
                    return None

                s_date = parse_dt(start_str)
                e_date = parse_dt(end_str)
                
                # Active Logic
                is_started = s_date is None or s_date <= today
                is_not_ended = e_date is None or e_date >= today
                
                if is_started and is_not_ended:
                    active_rows.append(row)
                    
            except Exception:
                # If date parse fails, assume active to be safe (or skip)
                continue

        if not active_rows:
            return jsonify({'success': True, 'conflicts': [], 'message': 'No active deals found.'})

        # 3. Group by Fingerprint
        # Fingerprint: Brand + Weekday (Ignores Discount/Category to find conflicting OFFERS)
        grouped = {}
        
        for row in active_rows:
            brand = str(row.get('Brand', 'N/A')).strip()
            cat = str(row.get('Category', 'N/A')).strip()
            disc = str(row.get('Daily Deal Discount', '0')).strip()
            weekday = str(row.get('Weekday', 'All')).strip()
            
            # UPDATED: Relaxed fingerprint to find DIFFERENT deals for the SAME brand
            # We group purely by Brand + Weekday.
            fingerprint = f"{brand}|{weekday}".lower()
            
            if fingerprint not in grouped:
                grouped[fingerprint] = []
            
            # Store the row data needed for display
            grouped[fingerprint].append({
                'mis_id': str(row.get('ID', '')),
                'brand': brand,
                'category': cat,
                'discount': disc,
                'weekday': weekday,
                'locations': str(row.get('Store', 'All Locations')),
                'start': str(row.get('Start date', '')),
                'end': str(row.get('End date', ''))
            })

        # 4. Filter for Conflicts (Groups with > 1 item)
        conflicts = []
        for key, rows in grouped.items():
            if len(rows) > 1:
                # Add metadata for the group header
                first = rows[0]
                
                # Create a summary of the conflicting discounts (e.g. "20% vs BOGO")
                discounts_found = list(set([r['discount'] for r in rows]))
                disc_summary = " vs ".join(discounts_found)
                if len(disc_summary) > 50: disc_summary = disc_summary[:47] + "..."
                
                conflicts.append({
                    'fingerprint': key,
                    # Updated Title to show the conflict type
                    'title': f"{first['brand']} ({first['weekday']}) - [{disc_summary}]",
                    'count': len(rows),
                    'rows': rows
                })
        
        # Sort by count (most conflicting first)
        conflicts.sort(key=lambda x: x['count'], reverse=True)
        
        # --- THIS WAS MISSING ---
        return jsonify({
            'success': True, 
            'conflicts': conflicts, 
            'total_active': len(active_rows),
            'conflict_groups': len(conflicts)
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/blaze/refresh')
def api_blaze_refresh():
    data, error = scrape_blaze_data_from_browser()
    if error:
        return jsonify(success=False, message=error)
    GLOBAL_DATA['blaze']['df_raw'] = pd.DataFrame(data)
    groups = load_groups()
    return jsonify(success=True, data=data, groups=groups)

@app.route('/api/blaze/poll-update')
def api_blaze_poll_update():
    try:
        # Frontend sends its last known timestamp
        client_ts = float(request.args.get('ts', 0))
        server_ts = GLOBAL_DATA['blaze'].get('last_update_ts', 0)
        
        # If server has newer data than client, signal an update
        if server_ts > client_ts:
            return jsonify({'update': True, 'ts': server_ts})
            
        return jsonify({'update': False})
    except Exception as e:
        return jsonify({'update': False, 'error': str(e)})

@app.route('/api/blaze/get-cache')
def api_blaze_get_cache():
    try:
        # Get data from memory
        df = GLOBAL_DATA['blaze'].get('df_raw')
        if df is None or df.empty:
            return jsonify(success=False, message="No data")
        
        # Convert to dictionary for JSON
        # Replace NaN with None to avoid invalid JSON errors
        data = df.where(pd.notnull(df), None).to_dict('records')
        
        # Get current timestamp to keep client in sync
        server_ts = GLOBAL_DATA['blaze'].get('last_update_ts', 0)
        
        return jsonify(success=True, data=data, ts=server_ts)
    except Exception as e:
        return jsonify(success=False, message=str(e))

@app.route('/api/blaze/export-csv')
def api_blaze_export_csv():
    try:
        # Check if data exists
        if 'blaze' not in GLOBAL_DATA or 'df_raw' not in GLOBAL_DATA['blaze'] or GLOBAL_DATA['blaze']['df_raw'].empty:
            return "No Blaze data found. Please click 'Refresh / Sync Data' first.", 400
            
        # Get the dataframe - USE DEEP COPY to protect live dashboard
        df = GLOBAL_DATA['blaze']['df_raw'].copy(deep=True)
        
        # Helper to flatten the group dictionaries into comma-separated strings for CSV
        def flatten_groups(val):
            if isinstance(val, list):
                # Extract 'name' from each group dict
                return ", ".join([str(g.get('name', '')) for g in val])
            return str(val)

        # Apply flattening to the group columns
        if 'buy_groups' in df.columns:
            df['buy_groups'] = df['buy_groups'].apply(flatten_groups)
        if 'get_groups' in df.columns:
            df['get_groups'] = df['get_groups'].apply(flatten_groups)
            
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"blaze_full_report_{timestamp}.csv"
        filepath = BASE_DIR / filename
        
        # Save and send
        df.to_csv(filepath, index=False)
        return send_file(filepath, as_attachment=True, download_name=filename)

    except Exception as e:
        traceback.print_exc()
        return str(e), 500


@app.route('/api/blaze/export-filtered-csv', methods=['POST'])
def api_blaze_export_filtered_csv():
    """Export only the filtered/visible rows as CSV."""
    try:
        data = request.get_json()
        ids = data.get('ids', [])
        
        if not ids:
            return "No IDs provided", 400
            
        # Check if data exists
        if 'blaze' not in GLOBAL_DATA or 'df_raw' not in GLOBAL_DATA['blaze'] or GLOBAL_DATA['blaze']['df_raw'].empty:
            return "No Blaze data found. Please click 'Refresh / Sync Data' first.", 400
            
        # Get the dataframe - USE DEEP COPY
        df = GLOBAL_DATA['blaze']['df_raw'].copy(deep=True)
        
        # Filter to only requested IDs
        df_filtered = df[df['ID'].astype(str).isin([str(i) for i in ids])]
        
        if df_filtered.empty:
            return "No matching rows found", 404
        
        # Helper to flatten groups
        def flatten_groups(val):
            if isinstance(val, list):
                return ", ".join([str(g.get('name', '')) for g in val])
            return str(val)

        if 'buy_groups' in df_filtered.columns:
            df_filtered['buy_groups'] = df_filtered['buy_groups'].apply(flatten_groups)
        if 'get_groups' in df_filtered.columns:
            df_filtered['get_groups'] = df_filtered['get_groups'].apply(flatten_groups)
            
        # Generate CSV in memory
        import io
        output = io.StringIO()
        df_filtered.to_csv(output, index=False)
        output.seek(0)
        
        # Create response
        from flask import Response
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"blaze_filtered_report_{timestamp}.csv"
        
        return Response(
            output.getvalue(),
            mimetype='text/csv',
            headers={'Content-Disposition': f'attachment; filename={filename}'}
        )

    except Exception as e:
        traceback.print_exc()
        return str(e), 500


@app.route('/api/blaze/zombie-disable', methods=['POST'])
def api_blaze_zombie_disable():
    """
    Disable a single zombie promotion via browser automation.
    Steps:
    1. Navigate to promo page and click Setup tab
    2. Find and click the Status toggle to disable
    3. Click dropdown to reveal Save button
    4. Click Save
    5. Wait for popup to close (indicates success)
    """
    try:
        data = request.get_json()
        promo_id = data.get('promo_id')
        
        if not promo_id:
            return jsonify({'success': False, 'error': 'No promo_id provided'})
        
        driver = GLOBAL_DATA.get('browser_instance')
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not ready'})
        
        print(f"[ZOMBIE] Starting disable for promo ID: {promo_id}")
        
        # Step 1: Switch to Blaze tab
        for h in driver.window_handles:
            driver.switch_to.window(h)
            if "blaze.me" in driver.current_url:
                break
        
        # Step 2: Navigate to the promotion Setup page
        target_url = f'https://retail.blaze.me/company-promotions/promotions/{promo_id}#setup'
        driver.get(target_url)
        print(f"[ZOMBIE] Navigated to: {target_url}")
        
        # Step 3: Click Setup tab (with retry logic from existing navBlaze)
        max_attempts = 5
        setup_clicked = False
        
        for attempt in range(1, max_attempts + 1):
            try:
                # Check if we're already on Setup (Name input visible)
                try:
                    name_input = driver.find_element(By.ID, "name")
                    if name_input.is_displayed():
                        print(f"[ZOMBIE] Setup tab already active (attempt {attempt})")
                        setup_clicked = True
                        break
                except:
                    pass
                
                # Click Setup tab
                setup_container = WebDriverWait(driver, 2).until(
                    EC.presence_of_element_located((By.XPATH, "//p[text()='Setup']/parent::div/parent::div"))
                )
                
                if setup_container.is_displayed():
                    driver.execute_script("arguments[0].click();", setup_container)
                    print(f"[ZOMBIE] Clicked Setup tab (attempt {attempt})")
                
                time.sleep(0.7)
                
            except Exception as e:
                print(f"[ZOMBIE] Setup tab attempt {attempt} waiting... ({e})")
                time.sleep(0.7)
        
        # Step 4: Wait for Status toggle to appear and click it
        print("[ZOMBIE] Looking for Status toggle...")
        
        try:
            # Wait for the Status toggle container
            # Using the specific MUI switch structure
            status_toggle = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((
                    By.XPATH, 
                    "//label[contains(text(),'Status')]/ancestor::div[contains(@class,'inlineContainer')]//input[@type='checkbox']"
                ))
            )
            
            # Check if already disabled
            is_checked = status_toggle.get_attribute('checked')
            print(f"[ZOMBIE] Status toggle found. Currently checked: {is_checked}")
            
            if is_checked:
                # Click to disable
                # Use JavaScript click since MUI switches can be tricky
                parent_switch = status_toggle.find_element(By.XPATH, "./ancestor::span[contains(@class,'MuiSwitch-root')]")
                driver.execute_script("arguments[0].click();", parent_switch)
                print("[ZOMBIE] [OK] Clicked Status toggle to disable")
                time.sleep(0.5)
                
                # Verify it's now unchecked
                is_checked_after = status_toggle.get_attribute('checked')
                if is_checked_after:
                    print("[ZOMBIE] [!] [EMOJI][EMOJI] Toggle may not have changed - trying direct input click")
                    driver.execute_script("arguments[0].click();", status_toggle)
                    time.sleep(0.5)
            else:
                print("[ZOMBIE] Already disabled, proceeding to save...")
        
        except TimeoutException:
            return jsonify({'success': False, 'error': 'Could not find Status toggle within timeout'})
        except Exception as e:
            print(f"[ZOMBIE] Error with Status toggle: {e}")
            return jsonify({'success': False, 'error': f'Status toggle error: {str(e)}'})
        
        # Step 5: Click the Schedule tab to navigate to that section
        print("[ZOMBIE] Clicking Schedule tab...")
        
        # Import ActionChains for human-like interactions
        # ActionChains already imported globally
        
        try:
            # Find the Schedule tab - it's a <p> element with text "Schedule"
            schedule_tab = WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((
                    By.XPATH,
                    "//p[text()='Schedule']"
                ))
            )
            
            # Scroll into view
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", schedule_tab)
            time.sleep(0.3)
            
            # Click the Schedule tab
            ActionChains(driver).move_to_element(schedule_tab).pause(0.2).click().perform()
            print("[ZOMBIE] [OK] Clicked Schedule tab")
            time.sleep(0.5)
            
        except TimeoutException:
            print("[ZOMBIE] ERROR: Could not find Schedule tab")
            return jsonify({'success': False, 'error': 'Could not find Schedule tab'})
        except Exception as e:
            print(f"[ZOMBIE] ERROR: Schedule tab error: {e}")
            return jsonify({'success': False, 'error': f'Schedule tab error: {str(e)}'})
        
        # Step 6: Click the Save button (direct button, not dropdown menu)
        print("[ZOMBIE] Looking for Save button...")
        
        try:
            # Wait for the Save button to appear - it's a submit button with text "Save"
            save_btn = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((
                    By.XPATH,
                    "//button[@type='submit' and contains(text(),'Save')]"
                ))
            )
            
            # Click Save using ActionChains
            ActionChains(driver).move_to_element(save_btn).pause(0.2).click().perform()
            print("[ZOMBIE] [OK] Clicked Save button")
            
        except TimeoutException:
            # Try alternate selector
            print("[ZOMBIE] Primary Save selector failed, trying alternate...")
            try:
                save_btn = driver.find_element(By.XPATH, "//button[contains(@class,'MuiButton-contained') and contains(text(),'Save')]")
                driver.execute_script("arguments[0].click();", save_btn)
                print("[ZOMBIE] [OK] Clicked Save (alternate selector)")
            except:
                return jsonify({'success': False, 'error': 'Could not find Save button'})
        except Exception as e:
            print(f"[ZOMBIE] ERROR: Save button error: {e}")
            return jsonify({'success': False, 'error': f'Save button error: {str(e)}'})
        
        # Step 7: Wait for save to complete
        print("[ZOMBIE] Waiting for save to complete...")
        
        try:
            # Wait for save operation - look for loading state to appear and disappear
            # or wait for a success indicator
            time.sleep(1)  # Brief pause for save to initiate
            
            # Try to detect if page is processing (button becomes disabled or shows loading)
            try:
                # Wait for any loading spinner to disappear (if present)
                WebDriverWait(driver, 10).until_not(
                    EC.presence_of_element_located((
                        By.XPATH,
                        "//span[contains(@class,'spinner')]"
                    ))
                )
            except:
                pass  # No spinner found, that's fine
            
            # Additional wait to ensure save completed
            time.sleep(1)
            print("[ZOMBIE] [OK] Save completed")
            
        except Exception as e:
            print(f"[ZOMBIE] [!] [EMOJI][EMOJI] Save wait issue: {e}, but proceeding...")
        
        # Small delay before next operation
        time.sleep(1)
        
        print(f"[ZOMBIE] [OK] Successfully disabled promo ID: {promo_id}")
        return jsonify({'success': True, 'message': f'Disabled promo {promo_id}'})
        
    except Exception as e:
        print(f"[ZOMBIE] Error: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/blaze/navigate', methods=['POST'])
def api_blaze_navigate():
    try:
        data = request.get_json()
        target_url = data.get('url')
        if not target_url: return jsonify({'success': False})
            
        driver = GLOBAL_DATA['browser_instance']
        if not driver: return jsonify({'success': False, 'error': 'Browser not ready'})
            
        # Switch tab logic
        for h in driver.window_handles:
            driver.switch_to.window(h)
            if "blaze.me" in driver.current_url: break
        
        driver.get(target_url)
        
        # --- ROBUST SETUP CLICKER (Restored) ---
        max_attempts = 5
        click_success = False
        
        print(f"[BLAZE] Navigating... Starting Setup Tab search (Max {max_attempts} attempts)")
        
        for attempt in range(1, max_attempts + 1):
            try:
                # 1. Check if we succeeded (Is the Title/Name input visible?)
                try:
                    name_input = driver.find_element(By.ID, "name")
                    if name_input.is_displayed():
                        print(f"[BLAZE] Success! Detected Promotion Title element on attempt {attempt}.")
                        click_success = True
                        break 
                except:
                    pass

                # 2. If not found, Click the Setup Tab
                # Matches the container <div> that holds the "Setup" text
                setup_container = WebDriverWait(driver, 2).until(
                    EC.presence_of_element_located((By.XPATH, "//p[text()='Setup']/parent::div/parent::div"))
                )
                
                if setup_container.is_displayed():
                    driver.execute_script("arguments[0].click();", setup_container)
                    print(f"[BLAZE] Clicked 'Setup' (Attempt {attempt})")
                
                time.sleep(0.7)
                
            except Exception as e:
                print(f"[BLAZE] Attempt {attempt} waiting for page load...")
                time.sleep(0.7)

        if not click_success:
            print("[BLAZE] WARN: Reached max attempts. Setup tab might not be active.")
        
        # START WATCHER THREAD (For Single Row Sync)
        promo_id = None
        if "/promotions/" in target_url:
            parts = target_url.split("/promotions/")
            if len(parts) > 1:
                promo_id = parts[1].split("#")[0].split("?")[0]

        if promo_id:
            # Assumes monitor_browser_return function exists in your script (it should be there from previous edits)
            thread = threading.Thread(target=monitor_browser_return, args=(promo_id,), daemon=True)
            thread.start()
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# v12.7: Create Blaze Discount Automation Endpoint
@app.route('/api/blaze/create-discount', methods=['POST'])
def api_blaze_create_discount():
    """
    Automates creation of a new discount in Blaze.
    Expects: {'title': str, 'type': str, 'description': str}
    
    Steps:
    1. Switch to/open Blaze browser tab
    2. Login if needed
    3. Navigate directly to creation URL (bypasses button detection)
    4. Wait for discount type options to appear (validates page loaded)
    5. Select discount type from dropdown
    6. Fill in title field
    7. PAUSE for manual completion (future: auto-fill remaining fields)
    """
    try:
        data = request.get_json()
        title = data.get('title', '').strip()
        discount_type = data.get('type', '').strip()
        description = data.get('description', '').strip()
        
        if not title or not discount_type:
            return jsonify({'success': False, 'error': 'Title and discount type required'})
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        
        print(f"[CREATE-BLAZE] Starting automation for: {title} ({discount_type})")
        
        # Step 1: Switch to Blaze tab or open new one
        blaze_found = False
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if "blaze.me" in driver.current_url:
                blaze_found = True
                print("[CREATE-BLAZE] Switched to existing Blaze tab")
                break
        
        if not blaze_found:
            print("[CREATE-BLAZE] Opening new Blaze tab...")
            driver.execute_script("window.open('https://retail.blaze.me/', '_blank');")
            time.sleep(1)
            driver.switch_to.window(driver.window_handles[-1])
        
        # Step 2: Check if logged in (look for login fields)
        try:
            username_field = driver.find_element(By.NAME, "username")
            # Login page detected - need to login
            print("[CREATE-BLAZE] Login page detected, logging in...")
            
            # Get credentials from config
            creds = load_credentials()
            if not creds or 'blaze_username' not in creds:
                return jsonify({'success': False, 'error': 'Blaze credentials not configured'})
            
            username_field.send_keys(creds['blaze_username'])
            password_field = driver.find_element(By.NAME, "password")
            password_field.send_keys(creds['blaze_password'])
            password_field.send_keys(Keys.RETURN)
            
            time.sleep(3)  # Wait for login
            print("[CREATE-BLAZE] Login completed")
        except:
            print("[CREATE-BLAZE] Already logged in")
        
        # Step 3: Navigate directly to creation URL (bypasses button detection)
        # v12.7.3: Direct navigation is more reliable than finding/clicking button
        creation_url = "https://retail.blaze.me/company-promotions/promotions/add#promotion-type"
        print(f"[CREATE-BLAZE] Navigating to creation URL: {creation_url}")
        driver.get(creation_url)
        time.sleep(2)  # Allow page to load
        
        # Step 4: Wait for discount type options to be present (validates page loaded)
        print("[CREATE-BLAZE] Waiting for discount type options to appear...")
        try:
            # Wait for any of the discount type buttons to be present
            # This confirms the creation interface loaded successfully
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//div[@role='button']//p[text()='BOGO' or text()='Bundle' or text()='Global Product Discount' or text()='Collection Discount']"))
            )
            print("[CREATE-BLAZE] Creation interface loaded successfully")
        except Exception as e:
            return jsonify({'success': False, 'error': f'Creation interface did not load properly: {str(e)}'})
        
        # Step 5: Select discount type from dropdown
        type_mapping = {
            'Bundle': "//div[@role='button'][@tabindex='3']//p[text()='Bundle']",
            'BOGO': "//div[@role='button'][@tabindex='0']//p[text()='BOGO']",
            'Global Product Discount': "//div[@role='button'][@tabindex='2']//p[text()='Global Product Discount']",
            'Collection Discount': "//div[@role='button'][@tabindex='1']//p[text()='Collection Discount']"
        }
        
        type_xpath = type_mapping.get(discount_type)
        if not type_xpath:
            return jsonify({'success': False, 'error': f'Unknown discount type: {discount_type}'})
        
        try:
            type_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, type_xpath))
            )
            driver.execute_script("arguments[0].click();", type_button)
            print(f"[CREATE-BLAZE] Selected discount type: {discount_type}")
            time.sleep(1)
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not select discount type: {str(e)}'})
        
        # Step 6: Fill in title field
        try:
            title_input = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "name"))
            )
            title_input.clear()
            title_input.send_keys(title)
            print(f"[CREATE-BLAZE] Filled title: {title}")
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not fill title field: {str(e)}'})
        
        # Step 7: PAUSE - Future automation will fill remaining fields
        # TODO (Future Enhancement): Auto-fill dates, products, locations, etc.
        #   - Fill Start/End dates from Google Sheet data
        #   - Select products/collections based on category
        #   - Select locations from Google Sheet locations column
        #   - Fill description field
        #   - Set discount value/type
        #   - Configure advanced settings
        
        print("[CREATE-BLAZE] Automation PAUSED - Manual completion required")
        print("[CREATE-BLAZE] Title filled successfully. Please complete remaining fields manually.")
        
        return jsonify({
            'success': True,
            'message': 'Discount creation started. Title filled. Please complete remaining fields manually.',
            'title': title,
            'type': discount_type
        })
        
    except Exception as e:
        print(f"[CREATE-BLAZE] ERROR: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/tax-rates')
def api_get_tax_rates():
    """
    Fetch tax rates (defaults + local overrides from tax_config.json).
    Returns: {'success': True, 'rates': {...}} or {'success': False, 'error': '...'}
    """
    try:
        rates = fetch_tax_rates()
        if rates:
            return jsonify({'success': True, 'rates': rates})
        else:
            return jsonify({'success': False, 'error': 'No tax rates available.'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/save-tax-rates', methods=['POST'])
def api_save_tax_rates():
    """
    Save user-edited tax rates to tax_config.json.
    Expects JSON: {'rates': {'Store Name': 1.0975, ...}}
    Returns: {'success': True} or {'success': False, 'error': '...'}
    """
    try:
        data = request.get_json()
        rates = data.get('rates', {})
        
        if not rates:
            return jsonify({'success': False, 'error': 'No rates provided'})
        
        # Validate rates are numbers
        for store, rate in rates.items():
            try:
                float(rate)
            except (ValueError, TypeError):
                return jsonify({'success': False, 'error': f'Invalid rate for {store}: {rate}'})
        
        # Save to tax_config.json
        with open(TAX_CONFIG_FILE, 'w') as f:
            json.dump(rates, f, indent=2)
        
        print(f"[TAX] Saved {len(rates)} tax rates to {TAX_CONFIG_FILE}")
        return jsonify({'success': True, 'message': f'Saved {len(rates)} tax rates'})
        
    except Exception as e:
        print(f"[ERROR] Failed to save tax rates: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/debug/analyze-collections', methods=['GET'])
def api_debug_analyze_collections():
    """
    DIAGNOSTIC: Navigate to Collections page and analyze network traffic.
    Access: http://127.0.0.1:5100/api/debug/analyze-collections
    """
    try:
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'error': 'Browser not initialized'})
        
        # Navigate to Smart Collections
        for h in driver.window_handles:
            driver.switch_to.window(h)
            if "blaze.me" in driver.current_url:
                break
        
        print("[DIAG] Navigating to Smart Collections page...")
        driver.get("https://retail.blaze.me/company-promotions/smart-collections")
        time.sleep(5)  # Wait for page to fully load
        
        # Analyze traffic
        analyze_blaze_network_traffic()
        
        return jsonify({
            'success': True,
            'message': 'Check CMD console for network traffic analysis'
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'error': str(e)})

# ============================================================================
# BLAZE TAG UPDATER INTEGRATION (Tier Promotions)
# ============================================================================
def run_tier_promotion_update_logic(driver):
    """
    Adapted from blaze_tag_updater.py v3.8.
    Executes the Tag Update sequence using the existing browser session.
    """
    # ActionChains already imported globally
    
    # --- CONFIGURATION ---
    DISCOUNTS_TO_UPDATE = ["T1 BAG DAY", "T2 BAG DAY", "T3 BAG DAY"]
    EXCLUDED_STORES = ["Davis", "Dixon"]
    
    # --- SELECTORS ---
# Updated to target the specific promotion search bar using data-cy
    SEL_SEARCH_BAR = "input[data-cy='testSearch']"
    SEL_EDIT_BTN = "//button[contains(., 'Edit')]"
    SEL_SAVE_BTN = "//button[contains(@class, 'btn-success') and contains(text(), 'Save')]"
    SEL_CLEAR_FILTERS = "//button[contains(text(), 'Clear')]"
    SEL_ACTIVE_CHIP_DEL = "//div[contains(@class, 'MuiChip')]//span[text()='Active']/following-sibling::*[name()='svg']"

    # --- HELPERS ---
    def btu_force_click(element):
        driver.execute_script("arguments[0].click();", element)

    def btu_open_dropdown():
        try:
            dropdown = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "span[data-cy='lbl-shop-name']"))
            )
            btu_force_click(dropdown)
            WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.CSS_SELECTOR, "li.shopElement")))
            return True
        except TimeoutException: 
            return False

    def btu_switch_store(store_name):
        print(f"[TAG-UPDATER] Switching to: {store_name}...")
        if not btu_open_dropdown(): 
            print("[TAG-UPDATER] Failed to open store dropdown.")
            return False
        
        try:
            options = driver.find_elements(By.CSS_SELECTOR, "li.shopElement span")
            for opt in options:
                if store_name in opt.text:
                    driver.execute_script("arguments[0].scrollIntoView(true);", opt)
                    time.sleep(0.5)
                    btu_force_click(opt)
                    time.sleep(5) 
                    return True
            ActionChains(driver).send_keys(Keys.ESCAPE).perform()
            return False
        except Exception as e:
            print(f"[TAG-UPDATER] Error switching store: {e}")
            ActionChains(driver).send_keys(Keys.ESCAPE).perform()
            return False

    def btu_clear_active_filter():
        try:
            clear_btns = driver.find_elements(By.XPATH, SEL_CLEAR_FILTERS)
            for btn in clear_btns:
                if btn.is_displayed():
                    btu_force_click(btn)
                    time.sleep(1)
                    return
        except: pass
        try:
            active_chip_x = driver.find_elements(By.XPATH, SEL_ACTIVE_CHIP_DEL)
            for x in active_chip_x:
                if x.is_displayed():
                    btu_force_click(x)
                    time.sleep(1)
        except: pass

    def btu_perform_react_search(text):
        try:
            search_input = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, SEL_SEARCH_BAR))
            )
            search_input.click()
            search_input.send_keys(Keys.CONTROL + "a")
            search_input.send_keys(Keys.BACKSPACE)
            time.sleep(0.2)
            search_input.send_keys(text)
            search_input.send_keys(Keys.RETURN)
            
            print(f"[TAG-UPDATER] Search sent: '{text}'. Waiting 3s...")
            time.sleep(3) 
            return True
        except Exception as e:
            print(f"[TAG-UPDATER] Search Failed: {e}")
            return False

    def btu_find_and_click_promo_row(promo_name):
        lower_name = promo_name.lower()
        xpath_by_title = f"//div[@role='gridcell'][contains(translate(@title, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '{lower_name}')]"
        xpath_by_text = f"//div[@role='gridcell'][contains(translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '{lower_name}')]"
        xpath_by_link = f"//a[contains(@class, 'virtualized_row_link')][.//div[contains(translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '{lower_name}')]]"

        for attempt in range(1, 4):
            try:
                try:
                    target = driver.find_element(By.XPATH, xpath_by_title)
                    btu_force_click(target)
                    return True
                except NoSuchElementException: pass

                try:
                    target = driver.find_element(By.XPATH, xpath_by_text)
                    btu_force_click(target)
                    return True
                except NoSuchElementException: pass

                target = driver.find_element(By.XPATH, xpath_by_link)
                btu_force_click(target)
                return True

            except (Exception):
                time.sleep(1.5)
                
        return False

    def btu_update_product_tags():
        print("[TAG-UPDATER] Scrolling to BOTTOM...")
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(1.5) 
        
        # 1. FIND ARROW
        arrow_xpath = "//b[contains(text(), 'Product Tags')]/ancestor::div[1]//span[contains(@class, 'Select-arrow-zone')]"
        
        try:
            arrow_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, arrow_xpath))
            )
            print("[TAG-UPDATER] Clicking Dropdown Arrow...")
            ActionChains(driver).move_to_element(arrow_btn).click().perform()
        except TimeoutException:
            print("[TAG-UPDATER] Arrow click failed. Using fallback...")
            box_xpath = "//b[contains(text(), 'Product Tags')]/ancestor::div[1]//div[contains(@class, 'Select-control')]"
            box = driver.find_element(By.XPATH, box_xpath)
            ActionChains(driver).move_to_element(box).click().perform()

        time.sleep(1) 
        
        actions = ActionChains(driver)
        
        # 2. CLEAR
        print("[TAG-UPDATER] Clearing tags (Backspace x5)...")
        for _ in range(5):
            actions.send_keys(Keys.BACKSPACE).perform()
            time.sleep(0.1) 
            
        # 3. TYPE
        print("[TAG-UPDATER] Typing new tags...")
        
        actions.send_keys("Promo").perform()
        time.sleep(0.5)
        actions.send_keys(Keys.RETURN).perform()
        time.sleep(0.5)
        
        actions.send_keys("promo").perform()
        time.sleep(0.5)
        actions.send_keys(Keys.RETURN).perform()
        time.sleep(0.5)

    def btu_process_discount(discount_name):
        print(f"[TAG-UPDATER] Processing: {discount_name}")
        
        driver.get("https://retail.blaze.me/promotions")
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, SEL_SEARCH_BAR)))
        
        btu_clear_active_filter()
        
        if not btu_perform_react_search(discount_name): return False
        if not btu_find_and_click_promo_row(discount_name): return False
        
        time.sleep(4) 

        try:
            # Edit
            edit_btn = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, SEL_EDIT_BTN)))
            btu_force_click(edit_btn)
            print("[TAG-UPDATER] Edit mode enabled. Waiting 2s...")
            time.sleep(2) 
            
            # Update Tags
            btu_update_product_tags()
            
            # SAVE LOGIC
            print("[TAG-UPDATER] Clicking Save...")
            save_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, SEL_SAVE_BTN))
            )
            
            # Ensure visible
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", save_btn)
            time.sleep(0.5)
            btu_force_click(save_btn)
            
            # BLIND WAIT (Fire & Forget)
            print("[TAG-UPDATER] Save clicked. Blind wait (2s)...")
            time.sleep(2) 

            return True

        except Exception as e:
            print(f"[TAG-UPDATER] Failed during edit/save: {e}")
            return False
        finally:
            print("[TAG-UPDATER] Returning to list...")
            driver.get("https://retail.blaze.me/promotions")
            time.sleep(3)

    # --- EXECUTION ---
    try:
        # 1. Go to Promotions to get Store List
        print("[TAG-UPDATER] Initializing Sequence...")
        driver.get("https://retail.blaze.me/promotions")
        time.sleep(3)

        # 2. Get Stores
        print("[TAG-UPDATER] Fetching store list...")
        btu_open_dropdown()
        time.sleep(1)
        options = driver.find_elements(By.CSS_SELECTOR, "li.shopElement span")
        all_shops = [o.text.strip() for o in options if o.text.strip()]
        ActionChains(driver).send_keys(Keys.ESCAPE).perform() 
        
        target_shops = [s for s in all_shops if not any(ex in s for ex in EXCLUDED_STORES)]
        target_shops.sort()
        print(f"[TAG-UPDATER] Target Stores: {target_shops}")
        
        # 3. Execute Loop
        for shop in target_shops:
            if btu_switch_store(shop):
                for promo_name in DISCOUNTS_TO_UPDATE:
                    btu_process_discount(promo_name)
        
        return "Sequence Complete!"

    except Exception as e:
        print(f"[TAG-UPDATER] Fatal Error: {e}")
        return f"Error: {str(e)}"

@app.route('/api/blaze/update-tags', methods=['POST'])
def api_blaze_update_tags():
    """Trigger the Tier Promotion Tag Update sequence in background."""
    # Get credentials for safety check (passed to background executor)
    data = request.get_json() or {}
    gui_username = data.get('mis_username', '').strip()
    gui_password = data.get('mis_password', '').strip()
    
    print("[API] Received request to Update Tier Promotions...")
    
    # Use execute_in_background to handle tab switching/creation
    result = execute_in_background('blaze', run_tier_promotion_update_logic, gui_username=gui_username, gui_password=gui_password)
    
    if result['success']:
        return jsonify({'success': True, 'message': 'Tier Promotion Update Started (Check Console)'})
    else:
        return jsonify({'success': False, 'error': result['error']})


# ============================================================================
# v12.24.1: BLAZE ECOM SYNC TO TYMBER (Mission Control API)
# ============================================================================
@app.route('/api/blaze/ecom-sync', methods=['POST'])
def api_blaze_ecom_sync() -> dict:
    """
    v12.24.1: Sync inventory to Tymber menu via Blaze Ecom Mission Control API.
    
    Request Body:
        {"store": "DAVIS", "email": "...", "password": "..."}
        (email/password optional if already in GLOBAL_DATA)
    
    Response:
        {"success": true/false, "message": "...", "error": "..."}
    
    Requires: secrets/sync_keys.json with store UUIDs.
    
    Flow:
        1. Get Blaze credentials (from request or GLOBAL_DATA)
        2. Authenticate with Ecom API ÃƒÂ¢Ã¢â‚¬Â Ã¢â‚¬â„¢ get JWT token
        3. Load store UUID from sync_keys.json
        4. POST sync request with token + UUID
    """
    try:
        data = request.get_json() or {}
        store_name: str = data.get('store', '').strip()
        
        # Validate store name
        if not store_name:
            print("[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ No store name provided")
            return jsonify({
                'success': False,
                'error': 'No store name provided. Please select a store.'
            })
        
        print(f"[ECOM-SYNC] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
        print(f"[ECOM-SYNC] Starting sync for store: {store_name}")
        
        # Step 1: Get Blaze credentials
        email = data.get('email', '').strip()
        password = data.get('password', '').strip()
        
        # Fallback to GLOBAL_DATA if not in request
        if not email or not password:
            blaze_creds = GLOBAL_DATA.get('blaze', {}).get('credentials', {})
            email = email or blaze_creds.get('email', '')
            password = password or blaze_creds.get('password', '')
        
        if not email or not password:
            print("[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ No Blaze credentials available")
            return jsonify({
                'success': False,
                'error': 'Blaze credentials required. Please enter email/password in Blaze Config.'
            })
        
        # Step 2: Load store UUID
        store_data = load_sync_keys(store_name)
        if store_data is None:
            error_msg = f'No UUID found for {store_name}. Add it to secrets/sync_keys.json'
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ {error_msg}")
            return jsonify({
                'success': False,
                'error': error_msg
            })
        
        store_uuid: str = store_data['store_uuid']
        print(f"[ECOM-SYNC] Store UUID: {store_uuid[:8]}...{store_uuid[-4:]}")
        
        # Step 3: Authenticate with Ecom API
        print(f"[ECOM-SYNC] Authenticating with Ecom API...")
        token, auth_error = get_ecom_token(email, password)
        
        if token is None:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Authentication failed: {auth_error}")
            return jsonify({
                'success': False,
                'error': f'Authentication failed: {auth_error}'
            })
        
        # Step 4: Trigger the sync
        print(f"[ECOM-SYNC] Triggering sync request...")
        success, message = trigger_ecom_sync(store_uuid, token)
        
        if success:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã…â€œÃ¢â‚¬Â¦ Sync complete for {store_name}")
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
            return jsonify({
                'success': True,
                'message': f'{store_name} sync triggered successfully'
            })
        else:
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Sync failed: {message}")
            print(f"[ECOM-SYNC] ÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚ÂÃƒÂ¢Ã¢â‚¬Â¢Ã‚Â")
            return jsonify({
                'success': False,
                'error': message
            })
    
    except Exception as e:
        print(f"[ECOM-SYNC] ÃƒÂ¢Ã‚ÂÃ…â€™ Unexpected error: {e}")
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': f'Unexpected error: {str(e)}'
        })


# ============================================================================
# INVENTORY API ROUTES
# ============================================================================
@app.route('/api/blaze/inventory/start', methods=['POST'])
def api_blaze_inventory_start():
    """Start inventory report generation in background thread."""
    target_store = request.json.get('target_store', 'ALL')
    
    if GLOBAL_DATA['blaze']['inventory_running']:
        return jsonify({'error': 'Report already running'}), 409

    def run_in_thread():
        reporter = BlazeInventoryReporter()
        reporter.run_report(target_store)
    
    thread = threading.Thread(target=run_in_thread, daemon=True)
    thread.start()
    
    return jsonify({'success': True})

@app.route('/api/blaze/inventory/status')
def api_blaze_inventory_status():
    return jsonify({
        'running': GLOBAL_DATA['blaze']['inventory_running'],
        'logs': GLOBAL_DATA['blaze']['inventory_logs']
    })

@app.route('/api/blaze/inventory/data')
def api_blaze_inventory_data():
    """Return current inventory data for UI display."""
    df = GLOBAL_DATA['blaze'].get('inventory_data')
    
    if df is None or df.empty:
        return jsonify({'success': False, 'error': 'No data available'})
    
    # Convert DataFrame to list of dicts
    data = df.to_dict('records')
    
    return jsonify({'success': True, 'data': data})

@app.route('/api/blaze/inventory/download')
def api_blaze_inventory_download():
    """Redirect to inventory folder (Windows Explorer or Finder)."""
    import subprocess
    import platform
    
    if platform.system() == 'Windows':
        subprocess.Popen(f'explorer "{INVENTORY_DIR}"')
    elif platform.system() == 'Darwin':  # macOS
        subprocess.Popen(['open', str(INVENTORY_DIR)])
    else:  # Linux
        subprocess.Popen(['xdg-open', str(INVENTORY_DIR)])
    
    return jsonify({'success': True})

@app.route('/api/blaze/inventory/fetch', methods=['POST'])
def api_blaze_inventory_fetch():
    """
    Fetch inventory data and cache it per store.
    Payload: { "store": "store_name", "fresh": true/false, "force_reset": true/false }
    Returns: Success status (data loaded via separate endpoint)
    """
    try:
        payload = request.json
        store = payload.get('store', '')
        use_fresh = payload.get('fresh', False)
        force_reset = payload.get('force_reset', False)
        
        if not store:
            return jsonify({'success': False, 'error': 'Store parameter required'}), 400
        
        # --- CRITICAL FIX START: UNLOCK IF REQUESTED ---
        if force_reset:
            GLOBAL_DATA['blaze']['inventory_running'] = False
            GLOBAL_DATA['blaze']['inventory_start_time'] = None
            print("[WARN] Force reset requested - clearing stuck state")
        # --- CRITICAL FIX END ---

        # Check for stuck operations (Timeout after 5 mins)
        if GLOBAL_DATA['blaze']['inventory_running']:
            start_time = GLOBAL_DATA['blaze'].get('inventory_start_time')
            if start_time:
                elapsed = datetime.now() - start_time
                if elapsed > timedelta(minutes=5):
                    GLOBAL_DATA['blaze']['inventory_running'] = False
                    print(f"[WARN] Auto-reset stuck inventory operation (timeout: {elapsed})")
        
        # Now check again - if still running and NO force reset, then error
        if GLOBAL_DATA['blaze']['inventory_running']:
            return jsonify({
                'success': False, 
                'error': 'Another inventory operation is running. Use force_reset=true to override.'
            }), 409
        
        # Run fetch operation
        reporter = BlazeInventoryReporter()
        success = reporter.run_report(store)
        
        if success and GLOBAL_DATA['blaze'].get('inventory_data') is not None:
            df = GLOBAL_DATA['blaze']['inventory_data']
            
            # Filter by store
            if store != 'ALL':
                df = df[df['Store'] == store]
            
            # NEW: Cache the data for this store
            GLOBAL_DATA['blaze']['inventory_cache'][store] = {
                'data': df,
                'timestamp': datetime.now()
            }
            
            print(f"[CACHE] Stored inventory data for '{store}' ({len(df)} rows)")
            
            # Return success WITHOUT data (frontend will fetch via get-tab-data)
            return jsonify({
                'success': True, 
                'message': f'Inventory data cached successfully',
                'row_count': len(df)
            })
        else:
            return jsonify({'success': False, 'error': 'Failed to fetch inventory data'}), 500
            
    except Exception as e:
        # Always reset on error
        GLOBAL_DATA['blaze']['inventory_running'] = False
        GLOBAL_DATA['blaze']['inventory_start_time'] = None
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/blaze/inventory/get-tab-data', methods=['POST'])
def api_get_inventory_tab_data():
    """
    Retrieve cached inventory data for a specific store (lazy loading).
    Payload: { "store": "store_name" }
    Returns: { "success": true, "data": [...rows...], "timestamp": "..." }
    """
    try:
        payload = request.json
        store = payload.get('store', '')
        
        if not store:
            return jsonify({'success': False, 'error': 'Store parameter required'}), 400
        
        # Check cache
        cache_entry = GLOBAL_DATA['blaze']['inventory_cache'].get(store)
        
        if cache_entry is None:
            return jsonify({
                'success': False, 
                'error': f'No cached data found for store: {store}. Please fetch first.'
            }), 404
        
        # Convert DataFrame to JSON
        df = cache_entry['data']
        data = df.to_dict('records')
        timestamp = cache_entry['timestamp'].strftime('%Y-%m-%d %H:%M:%S')
        
        print(f"[CACHE] Retrieved {len(data)} rows for '{store}' (cached at {timestamp})")
        
        return jsonify({
            'success': True,
            'data': data,
            'timestamp': timestamp,
            'row_count': len(data)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/blaze/inventory/export', methods=['POST'])
def api_blaze_inventory_export():
    """
    Generate CSV/Excel export based on modal selections.
    Payload: {
        "mode": "full" or "filtered",
        "stores": ["store1", "store2"] or ["ALL"],
        "fresh": true/false,
        "filtered_data": [...] (only if mode="filtered")
    }
    Returns: CSV file download
    """
    try:
        payload = request.json
        mode = payload.get('mode', 'full')
        stores = payload.get('stores', [])
        use_fresh = payload.get('fresh', False)
        filtered_data = payload.get('filtered_data', None)
        
        if not stores:
            return jsonify({'error': 'No stores selected'}), 400
        
        # Mode: filtered - Use provided filtered_data
        if mode == 'filtered' and filtered_data:
            df = pd.DataFrame(filtered_data)
        else:
            # Mode: full - Fetch all data for selected stores
            if use_fresh or GLOBAL_DATA['blaze'].get('inventory_data') is None:
                # Run fresh fetch
                if GLOBAL_DATA['blaze']['inventory_running']:
                    return jsonify({'error': 'Another operation is running'}), 409
                
                reporter = BlazeInventoryReporter()
                if 'ALL' in stores:
                    reporter.run_report('ALL')
                else:
                    # Run for each store and combine
                    for store in stores:
                        reporter.run_report(store)
            
            # Get data from GLOBAL_DATA
            df = GLOBAL_DATA['blaze'].get('inventory_data')
            if df is None or df.empty:
                return jsonify({'error': 'No data available'}), 404
            
            # Filter by stores if not ALL
            if 'ALL' not in stores:
                df = df[df['Store'].isin(stores)]
        
        # Generate CSV in memory
        from io import StringIO
        output = StringIO()
        df.to_csv(output, index=False)
        output.seek(0)
        
        # Create response with CSV download
        from flask import make_response
        response = make_response(output.getvalue())
        response.headers['Content-Type'] = 'text/csv'
        response.headers['Content-Disposition'] = f'attachment; filename=Inventory_Export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        
        return response
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/blaze/inventory/list-reports')
def api_blaze_inventory_list_reports():
    """
    List all available inventory CSV files in the INVENTORY directory.
    Returns: { "success": true, "reports": ["filename1.csv", "filename2.csv", ...] }
    """
    try:
        if not INVENTORY_DIR.exists():
            return jsonify({'success': True, 'reports': []})
        
        # Get all CSV files
        csv_files = [f.name for f in INVENTORY_DIR.glob('*.csv')]
        csv_files.sort(reverse=True)  # Most recent first
        
        return jsonify({'success': True, 'reports': csv_files})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/blaze/inventory/load-report', methods=['POST'])
def api_blaze_inventory_load_report():
    """
    Load a saved inventory report from file.
    Payload: { "filename": "filename.csv" }
    Returns: { "success": true, "data": [...rows...] }
    """
    try:
        payload = request.json
        filename = payload.get('filename', '')
        
        if not filename:
            return jsonify({'success': False, 'error': 'Filename required'}), 400
        
        filepath = INVENTORY_DIR / filename
        
        if not filepath.exists():
            return jsonify({'success': False, 'error': 'File not found'}), 404
        
        # Load CSV file
        df = pd.read_csv(filepath)
        data = df.to_dict('records')
        
        return jsonify({'success': True, 'data': data})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/blaze/inventory/export-tabs', methods=['POST'])
def api_blaze_inventory_export_tabs():
    """
    Export selected tabs as CSV (single tab) or XLSX (multiple tabs).
    Payload: { "tabs": { "Store1": [...data...], "Store2": [...data...], ... } }
    Returns: CSV or XLSX file download
    """
    try:
        payload = request.json
        tabs = payload.get('tabs', {})
        
        if not tabs:
            return jsonify({'error': 'No tabs provided'}), 400
        
        from flask import make_response
        
        if len(tabs) == 1:
            # Single tab: Export as CSV
            store_name = list(tabs.keys())[0]
            df = pd.DataFrame(tabs[store_name])
            
            from io import StringIO
            output = StringIO()
            df.to_csv(output, index=False)
            output.seek(0)
            
            response = make_response(output.getvalue())
            response.headers['Content-Type'] = 'text/csv'
            safe_name = store_name.replace(" ", "_").replace("/", "-")
            response.headers['Content-Disposition'] = f'attachment; filename={safe_name}_Inventory_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
            
        else:
            # Multiple tabs: Export as XLSX
            from io import BytesIO
            output = BytesIO()
            
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                for store_name, data in tabs.items():
                    df = pd.DataFrame(data)
                    # Excel sheet names have 31 char limit
                    safe_name = store_name[:30].replace("/", "-")
                    df.to_excel(writer, sheet_name=safe_name, index=False)
            
            output.seek(0)
            
            response = make_response(output.getvalue())
            response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            response.headers['Content-Disposition'] = f'attachment; filename=Multi_Store_Inventory_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
        
        return response
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/blaze/inventory/navigate-to-product', methods=['POST'])
def navigate_to_product():
    """
    Navigate Blaze browser to specific product page.
    Steps:
    1. Navigate to inventory URL
    2. Check/change store location
    3. Navigate to product page
    4. Bring tab to front
    """
    try:
        data = request.json
        store_name = data.get('store_name')
        blaze_id = data.get('blaze_id')
        
        if not store_name or not blaze_id:
            return jsonify({'success': False, 'error': 'Missing store_name or blaze_id'}), 400
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'}), 500
        
        with BROWSER_LOCK:
            # STEP 0: Find or create Blaze tab (don't hijack active tab)
            print(f"[NAVIGATE] Finding or creating Blaze tab...")
            blaze_handle = None
            original_handle = driver.current_window_handle
            
            # Look for existing retail.blaze.me tab
            for handle in driver.window_handles:
                driver.switch_to.window(handle)
                if 'retail.blaze.me' in driver.current_url:
                    print(f"[NAVIGATE] [OK] Found existing Blaze tab")
                    blaze_handle = handle
                    break
            
            # If no Blaze tab found, create a new one
            if not blaze_handle:
                print(f"[NAVIGATE] Creating new Blaze tab...")
                driver.execute_script("window.open('https://retail.blaze.me/inventory', '_blank');")
                time.sleep(2)  # Wait for new tab to open
                # Switch to the newly created tab (last one)
                driver.switch_to.window(driver.window_handles[-1])
                blaze_handle = driver.current_window_handle
                print(f"[NAVIGATE] [OK] Created new Blaze tab")
            else:
                # Already on Blaze tab from the search above
                print(f"[NAVIGATE] Using existing Blaze tab")
            
            # STEP 1: Navigate to inventory page (in Blaze tab)
            print(f"[NAVIGATE] Navigating to inventory page...")
            driver.get('https://retail.blaze.me/inventory')
            time.sleep(2)  # Wait for page load
            
            # STEP 2: Check and change store if needed
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                print(f"[NAVIGATE] Attempt {attempt}/{max_attempts} - Checking store location...")
                
                # Check current store
                try:
                    current_store_elem = driver.find_element(By.CSS_SELECTOR, 'span[data-cy="lbl-shop-name"]')
                    current_store = current_store_elem.text.strip()
                    print(f"[NAVIGATE] Current store: {current_store}")
                    print(f"[NAVIGATE] Target store: {store_name}")
                    
                    if current_store == store_name:
                        print(f"[NAVIGATE] [OK] Already on correct store!")
                        break
                    else:
                        print(f"[NAVIGATE] Need to change store...")
                        
                        # Click dropdown to open menu
                        dropdown_button = driver.find_element(By.CSS_SELECTOR, 'div.shopDropdown')
                        dropdown_button.click()
                        time.sleep(1)
                        
                        # Extract location part from store name (text after " - ")
                        # "The Artist Tree - Koreatown" ->[EMOJI] "Koreatown"
                        if ' - ' in store_name:
                            location_part = store_name.split(' - ')[-1].strip()
                        else:
                            location_part = store_name.strip()
                        
                        print(f"[NAVIGATE] Searching for store with location: '{location_part}'")
                        
                        # Find and click target store in dropdown using partial text match
                        # This handles variations like:
                        # - "The Artist Tree - Koreatown"
                        # - "Davisville Business Enterprises, Inc. - Davis"
                        # - "The Artist Tree - Fresno (Shaw Ave)"
                        try:
                            # Use XPath to find span that contains the location text
                            # The xpath looks for: <span data-cy="...">Text containing location</span>
                            xpath = f"//li[@class='shopElement']//span[contains(text(), '{location_part}')]"
                            target_store_elem = driver.find_element(By.XPATH, xpath)
                            
                            # Log what we found
                            found_text = target_store_elem.text.strip()
                            print(f"[NAVIGATE] [OK] Found store: '{found_text}'")
                            
                            target_store_elem.click()
                            print(f"[NAVIGATE] [OK] Clicked target store")
                            
                            # Wait for page refresh
                            time.sleep(3)
                            
                            # Verify store changed (check if location part is in current store name)
                            current_store_elem = driver.find_element(By.CSS_SELECTOR, 'span[data-cy="lbl-shop-name"]')
                            current_store = current_store_elem.text.strip()
                            
                            # Success if location part is in the current store name
                            if location_part in current_store:
                                print(f"[NAVIGATE] [OK] Store changed successfully to: '{current_store}'")
                                break
                            else:
                                print(f"[NAVIGATE] [OK][EMOJI][EMOJI] Store change failed, retrying...")
                                
                        except NoSuchElementException:
                            return jsonify({
                                'success': False, 
                                'error': f'Store with location "{location_part}" not found in dropdown menu'
                            }), 404
                
                except NoSuchElementException as e:
                    print(f"[NAVIGATE] Error finding store elements: {e}")
                    if attempt == max_attempts:
                        return jsonify({
                            'success': False,
                            'error': 'Could not find store dropdown elements'
                        }), 500
                    time.sleep(2)
            else:
                # Max attempts reached without success
                return jsonify({
                    'success': False,
                    'error': f'Failed to change to store "{store_name}" after {max_attempts} attempts'
                }), 500
            
            # STEP 3: Navigate to product page
            product_url = f'https://retail.blaze.me/inventory/product/{blaze_id}'
            print(f"[NAVIGATE] Navigating to product: {product_url}")
            driver.get(product_url)
            time.sleep(2)
            
            # STEP 4: Ensure Blaze tab is in front (we already have the handle)
            try:
                driver.switch_to.window(blaze_handle)
                print(f"[NAVIGATE] [OK] Blaze tab is in focus")
            except Exception as e:
                print(f"[NAVIGATE] Warning: Could not ensure tab focus: {e}")
            
            return jsonify({
                'success': True,
                'message': f'Navigated to product {blaze_id} in store {store_name}',
                'url': product_url
            })
        
    except Exception as e:
        print(f"[NAVIGATE] Error: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


def convert_store_name_to_data_cy(store_name):
    """
    Convert store display name to data-cy format.
    Example: "The Artist Tree - Koreatown" ->[EMOJI] "lbl-TheArtistTree-Koreatown"
    """
    # Remove spaces and hyphens between words
    # "The Artist Tree - Koreatown" ->[EMOJI] "TheArtistTree-Koreatown"
    parts = store_name.split(' - ')
    if len(parts) == 2:
        company_part = parts[0].replace(' ', '')  # "TheArtistTree"
        location_part = parts[1].replace(' ', '')  # "Koreatown"
        result = f"lbl-{company_part}-{location_part}"
    else:
        # Fallback for different formats
        result = f"lbl-{store_name.replace(' ', '').replace('-', '')}"
    
    return result


# ============================================================================
# STARTUP
# ============================================================================
# ============================================================================
# STARTUP
# ============================================================================
def background_validation_monitor():
    """
    Background thread that ensures validation system is always active on MIS daily-discount page.
    Runs every 10 seconds, non-blocking, skips if automation is in progress.
    """
    print("[VALIDATION-MONITOR] Background validation monitor starting...")
    time.sleep(5)  # Wait for browser to initialize
    
    while True:
        try:
            time.sleep(10)  # Check every 10 seconds
            
            # SAFETY: Skip if automation is running
            if GLOBAL_DATA.get('automation_in_progress', False):
                continue
            
            # SAFETY: Skip if browser not initialized
            driver = GLOBAL_DATA.get('browser_instance')
            if not driver:
                continue
            
            # Check if we're on the daily-discount page
            try:
                current_url = driver.current_url
                if "daily-discount" not in current_url:
                    continue
                
                # Quick check if validation already active
                is_active = driver.execute_script(
                    "return window.MIS_VALIDATOR_ACTIVE || false;"
                )
                
                if not is_active:
                    # Inject validation in manual mode (no expected data)
                    inject_mis_validation(driver, expected_data=None)
                    print("[VALIDATION-MONITOR] [EMOJI] Injected manual validation (was missing)")
                    
            except Exception:
                # Silently skip on any error (don't crash the monitor)
                pass
                
        except Exception as e:
            # Log but don't crash
            print(f"[VALIDATION-MONITOR] [EMOJI] Error: {e}")
            time.sleep(30)  # Wait longer on error

def open_browser_to_dashboard():
    time.sleep(2)
    print("[STARTUP] Initializing unified browser...")
    driver = init_browser()
    if driver:
        print("[STARTUP] Navigating to dashboard...")
        # FIX: Explicitly switch to the existing window [0]
        try:
            if len(driver.window_handles) > 0:
                driver.switch_to.window(driver.window_handles[0])
        except:
            pass
        driver.get("http://127.0.0.1:5100")
        print("[OK] Dashboard loaded")
    else:
        print("[ERROR] Browser init failed")

def main():
    print("="*70)
    print("BLAZE MIS Audit Pro - Project 2 v12")
    print("="*70)
    print(f"[PROFILE] Active: {ACTIVE_PROFILE['handle']}")
    print("[INFO] MULTI-DAY DEAL DETECTION ENABLED")
    print("[INFO] DATE-AWARE CONFLICT AUDIT ENABLED")
    print("[INFO] UP-DOWN PLANNING - Logic Gap & Split Management")
    print("[INFO] 3 Main Tabs: Setup | Audit | BLAZE")
    print(f"[INFO] Reports: {REPORTS_DIR}")
    print("="*70)

    GLOBAL_DATA['blaze']['inventory_running'] = False # Force clear lock on startup
    
    browser_thread = threading.Thread(target=open_browser_to_dashboard, daemon=True)
    browser_thread.start()
    
    # Start background validation monitor
    validation_monitor_thread = threading.Thread(target=background_validation_monitor, daemon=True)
    validation_monitor_thread.start()
    
    print("[START] Starting Flask server on http://127.0.0.1:5100")
    
    # Run Flask without reloader to prevent duplicate threads
    app.run(port=5100, debug=False, use_reloader=False)

# ============================================================================
#  FINAL ROBUST AUTOMATION (Human-Speed & Crash Proof)
# ============================================================================

@app.route('/api/mis/automate-end-date', methods=['POST'])
def api_mis_automate_end_date():
    """
    v12.15: Automates adjusting the End Date with comprehensive debugging.
    Fixes 500 Error: Cleans MIS ID tags and handles errors gracefully.
    """
    try:
        data = request.get_json()
        print(f"\n{'='*60}")
        print("[AUTOMATION] END DATE - Starting Sequence")
        print(f"{'='*60}")
        print(f"[DEBUG] Raw payload: {json.dumps(data, indent=2)}")
        
        raw_id = str(data.get('mis_id', '')).strip()
        new_date = str(data.get('new_end_date', '')).strip()

        print(f"[DEBUG] Extracted: raw_id='{raw_id}', new_date='{new_date}'")

        if not raw_id or not new_date:
            print("[ERROR] Missing required fields")
            return jsonify({'success': False, 'error': 'Missing MIS ID or Date'})

        # CRITICAL FIX: Strip tags like "W1:", "Gap:", "Part 2:" to get just the number
        if ':' in raw_id:
            mis_id = raw_id.split(':')[-1].strip()
            print(f"[DEBUG] Stripped tag prefix: '{raw_id}' -> '{mis_id}'")
        else:
            mis_id = raw_id

        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            print("[ERROR] Browser not initialized")
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        
        print("[STEP 1] Ensuring MIS is ready...")
        ensure_mis_ready(driver)

        # 1. Search for ID using existing helper (Robust)
        print(f"[STEP 2] Searching table for clean ID: {mis_id}")
        found = filter_and_open_mis_id(driver, mis_id)
        
        if not found:
            print(f"[ERROR] Could not find Deal {mis_id} in MIS table")
            return jsonify({'success': False, 'error': f'Could not find Deal {mis_id} in MIS table.'})

        # 2. Wait for Modal (increased from 1.0s to 2.0s)
        print("[STEP 3] Waiting for modal animation (2.0s)...")
        time.sleep(2.0)
        
        print("[STEP 4] Waiting for end date field to be visible...")
        try:
            WebDriverWait(driver, 10).until(EC.visibility_of_element_located((By.NAME, "date_end")))
            print("[SUCCESS] End date field visible")
        except Exception as wait_err:
            print(f"[ERROR] End date field not found: {wait_err}")
            return jsonify({'success': False, 'error': 'End date field not visible in modal'})
        
        # 3. Verify field is clickable
        print("[STEP 5] Waiting for end date field to be clickable...")
        try:
            end_date_input = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.NAME, "date_end"))
            )
            print("[SUCCESS] End date field is clickable")
        except Exception as click_err:
            print(f"[ERROR] End date field not clickable: {click_err}")
            return jsonify({'success': False, 'error': 'End date field not clickable'})
        
        # 4. Log current value before change
        current_value = end_date_input.get_attribute('value')
        print(f"[DEBUG] Current End Date value: '{current_value}'")
        print(f"[DEBUG] New End Date to set: '{new_date}'")
        
        # 5. Update Date (Human-like interaction with visual feedback)
        print("[STEP 6] Highlighting field...")
        try:
            driver.execute_script("arguments[0].style.border='3px solid red'", end_date_input)
        except:
            pass
        
        print("[STEP 7] Clicking field...")
        end_date_input.click()
        time.sleep(0.3)
        
        print("[STEP 8] Selecting all text...")
        end_date_input.send_keys(Keys.CONTROL + "a")
        time.sleep(0.2)
        
        print("[STEP 9] Deleting selected text...")
        end_date_input.send_keys(Keys.DELETE)
        time.sleep(0.2)
        
        print(f"[STEP 10] Typing new date: '{new_date}'...")
        end_date_input.send_keys(new_date)
        time.sleep(0.5)
        
        print("[STEP 11] Pressing TAB to trigger validation...")
        end_date_input.send_keys(Keys.TAB)
        time.sleep(0.5)
        
        # 6. Verify the change
        updated_value = end_date_input.get_attribute('value')
        print(f"[DEBUG] Updated End Date value: '{updated_value}'")
        
        if updated_value != new_date:
            print(f"[WARNING] Value mismatch: expected '{new_date}', got '{updated_value}'")
        
        print(f"{'='*60}")
        print("[AUTOMATION] END DATE - Sequence Complete")
        print(f"{'='*60}\n")
        
        return jsonify({'success': True, 'message': f'End Date updated from {current_value} to {new_date}. Please Review and Save.'})

    except Exception as e:
        print(f"[CRITICAL ERROR] End Date Automation crashed: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


def inject_checklist_banner(driver, expected_data: dict, mode: str = 'create'):
    """
    v12.19: Inject a Checklist Banner into the MIS modal that shows expected values
    and validates fields in real-time as the user fills them.
    
    MODES:
    - 'create': Shows all fields including "Expected" value column (default)
    - 'compare': For comparing MIS to Google Sheet - same validation, cleaner UI
    
    Improvements:
    - Category shows progress (2/4 selected) with green/white text for matched/needed
    - Linked Brand handles empty expected (no linked brand = empty is correct)
    - Vendor Rebate validates with proper percentage normalization
    - Weekday validated properly
    
    Each field shows: [EMOJI] (green) if correct, [EMOJI] (red) if incorrect, [EMOJI] (gray) if empty
    Blocks save if Weekday or Rebate Type is empty.
    """
    import json
    
    expected_json = json.dumps(expected_data)
    mode_json = json.dumps(mode)
    
    js_code = f'''
    (function() {{
        // Remove any existing checklist banner
        const existingBanner = document.getElementById('checklist-banner-v18');
        if (existingBanner) existingBanner.remove();
        
        const EXPECTED = {expected_json};
        const MODE = {mode_json};
        console.log('[CHECKLIST v12.19] Expected data:', EXPECTED);
        console.log('[CHECKLIST v12.19] Mode:', MODE);
        
        // Field configuration: [display name, field ID, fieldType, isMultiSelect, expectedKey]
        // fieldType: 'select2' | 'input' | 'checkbox'
        const FIELDS = [
            ['Weekday', 'weekday_ids', 'select2', true, 'weekday'],
            ['Store/Locations', 'store_ids', 'select2', true, 'locations'],
            ['Brand', 'brand_id', 'select2', false, 'brand'],
            ['Linked Brand', 'linked_brand_id', 'select2', false, 'linked_brand'],
            ['Category', 'category_ids', 'select2', true, 'categories'],
            ['Discount %', 'discount_rate', 'input', false, 'discount'],
            ['Rebate Type', 'daily_discount_type_id', 'select2', false, 'rebate_type'],
            ['Vendor Rebate %', 'rebate_percent', 'input', false, 'vendor_contrib'],
            ['After Wholesale?', 'rebate_wholesale_discount', 'checkbox', false, 'after_wholesale'],
            ['Start Date', 'date_start', 'input', false, 'start_date'],
            ['End Date', 'date_end', 'input', false, 'end_date']
        ];
        
        // Create banner container
        const banner = document.createElement('div');
        banner.id = 'checklist-banner-v18';
        banner.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #4a90d9;
            border-radius: 12px;
            padding: 15px;
            z-index: 100000;
            font-family: 'Segoe UI', system-ui, sans-serif;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            color: #fff;
        `;
        
        // Header - mode-aware title
        const headerTitle = MODE === 'compare' ? '[EMOJI] Compare to Sheet' : '[EMOJI] Deal Entry Checklist';
        const header = document.createElement('div');
        header.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid #4a90d9;">
                <span style="font-size: 16px; font-weight: 600; color: #4a90d9;">${{headerTitle}}</span>
                <button id="checklist-close-btn" style="background: #dc3545; color: white; border: none; border-radius: 4px; padding: 4px 10px; cursor: pointer; font-size: 12px;">[EMOJI]</button>
            </div>
            <div style="font-size: 11px; color: #888; margin-bottom: 10px;">
                [EMOJI] = Correct | [EMOJI] = Mismatch | [EMOJI] = Empty | [EMOJI] = Partial
            </div>
        `;
        banner.appendChild(header);
        
        // Create checklist items
        const checklist = document.createElement('div');
        checklist.id = 'checklist-items';
        
        FIELDS.forEach(([label, fieldId, fieldType, isMulti, expectedKey]) => {{
            const expectedVal = EXPECTED[expectedKey];
            let displayExpected;
            
            // Handle display of expected value
            if (expectedVal === true) {{
                displayExpected = 'Yes';
            }} else if (expectedVal === false) {{
                displayExpected = 'No';
            }} else if (expectedVal === '' || expectedVal === null || expectedVal === undefined) {{
                // Empty string means "no value expected" (e.g., no linked brand)
                if (expectedKey === 'linked_brand') {{
                    displayExpected = '(none - leave empty)';
                }} else {{
                    displayExpected = '(not specified)';
                }}
            }} else {{
                displayExpected = expectedVal;
            }}
            
            const row = document.createElement('div');
            row.className = 'checklist-row';
            row.dataset.fieldId = fieldId;
            row.dataset.expectedKey = expectedKey;
            row.dataset.fieldType = fieldType;
            row.dataset.isMulti = String(isMulti);
            row.style.cssText = `
                display: flex;
                align-items: flex-start;
                padding: 8px 10px;
                margin: 4px 0;
                background: rgba(255,255,255,0.05);
                border-radius: 6px;
                border-left: 3px solid #666;
                transition: all 0.2s;
            `;
            
            // v12.19: Mode-aware row rendering (hide "Expected" in compare mode)
            const expectedRowHTML = MODE === 'compare' ? '' : `
                <div class="expected-val" style="font-size: 11px; color: #aaa; margin-top: 2px;">
                    Expected: <span style="color: #4a90d9;">${{displayExpected}}</span>
                </div>
            `;
            
            row.innerHTML = `
                <span class="status-icon" style="font-size: 16px; margin-right: 10px; min-width: 20px;">[EMOJI]</span>
                <div style="flex: 1;">
                    <div style="font-weight: 500; font-size: 13px; color: #fff;">${{label}}</div>
                    ${{expectedRowHTML}}
                    <div class="actual-val" style="font-size: 11px; color: #888; margin-top: 2px;">
                        Current: <span style="color: #fff;">-</span>
                    </div>
                    <div class="progress-info" style="font-size: 10px; color: #ffc107; margin-top: 2px; display: none;"></div>
                </div>
            `;
            
            checklist.appendChild(row);
        }});
        
        banner.appendChild(checklist);
        
        // Status summary
        const summary = document.createElement('div');
        summary.id = 'checklist-summary';
        summary.style.cssText = `
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid #4a90d9;
            font-size: 12px;
            text-align: center;
        `;
        summary.innerHTML = '<span style="color: #888;">Validating...</span>';
        banner.appendChild(summary);
        
        // Critical warning area
        const criticalWarning = document.createElement('div');
        criticalWarning.id = 'critical-warning';
        criticalWarning.style.cssText = `
            margin-top: 10px;
            padding: 8px;
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid #dc3545;
            border-radius: 6px;
            font-size: 11px;
            color: #ff6b6b;
            display: none;
        `;
        banner.appendChild(criticalWarning);
        
        document.body.appendChild(banner);
        
        // Close button handler
        document.getElementById('checklist-close-btn').onclick = () => {{
            banner.style.display = banner.style.display === 'none' ? 'block' : 'none';
        }};
        
        // ========================================
        // HELPER FUNCTIONS
        // ========================================
        
        // v12.22.8: Fixed to handle both single-select and multi-select Select2 dropdowns
        function getSelect2Value(fieldId, isMulti) {{
            // Single-select Select2: Read from container's title attribute
            // This is how inject_mis_validation() correctly reads these values
            if (!isMulti) {{
                const containerId = 'select2-' + fieldId + '-container';
                const container = document.getElementById(containerId);
                if (container) {{
                    const title = container.getAttribute('title');
                    if (title && title !== '- Select -') {{
                        return [title];  // Return as array for consistent handling
                    }}
                }}
                return [];
            }}
            
            // Multi-select: Read from native select options (existing logic)
            const select = document.getElementById(fieldId);
            if (!select) return [];
            const selected = [];
            for (let i = 0; i < select.options.length; i++) {{
                if (select.options[i].selected) {{
                    const text = select.options[i].text.trim();
                    if (text && text !== '- Select -') {{
                        selected.push(text);
                    }}
                }}
            }}
            return selected;
        }}
        
        function getInputValue(fieldId) {{
            const input = document.getElementById(fieldId);
            return input ? input.value.trim() : '';
        }}
        
        function getCheckboxValue(fieldId) {{
            const checkbox = document.getElementById(fieldId);
            return checkbox ? checkbox.checked : false;
        }}
        
        function normalizePercent(val) {{
            if (val === null || val === undefined) return '';
            let s = String(val).trim().toLowerCase();
            s = s.replace(/%/g, '').replace(/\\s/g, '');
            // Handle "0.00" vs "0" comparison
            const num = parseFloat(s);
            if (!isNaN(num)) {{
                return num.toString();
            }}
            return s;
        }}
        
        function normalizeString(val) {{
            if (val === null || val === undefined) return '';
            return String(val).trim().toLowerCase();
        }}
        
        // ========================================
        // VALIDATION FUNCTIONS
        // ========================================
        
        function compareMultiSelect(actual, expected, expectedKey) {{
            // actual = array of selected values
            // expected = comma-separated string of expected values
            
            const actualArr = Array.isArray(actual) ? actual : [];
            const expectedStr = (expected || '').toLowerCase().trim();
            
            // v12.22.7: Handle "All Locations" explicitly
            // In MIS, empty Store/Locations selection means "All Locations"
            if (expectedKey === 'locations') {{
                if (!expected || expected === '' || 
                    expectedStr === 'all locations' || 
                    expectedStr === 'all' ||
                    expectedStr.startsWith('all locations')) {{
                    // "All Locations" = empty selection in MIS is correct
                    if (actualArr.length === 0) {{
                        return {{ status: 'correct', matched: [], missing: [], extra: [] }};
                    }}
                    // If user selected specific stores but expected "All", that's also acceptable
                    // (selecting all 12 stores = same as "All")
                    // Return correct if they have any selection when "All" is expected
                    return {{ status: 'correct', matched: actualArr, missing: [], extra: [] }};
                }}
            }}
            
            // v12.22.7: Handle "All Categories" explicitly
            // In MIS, empty Category selection means "All Categories"
            if (expectedKey === 'categories') {{
                if (!expected || expected === '' || 
                    expectedStr === 'all categories' || 
                    expectedStr === 'all' ||
                    expectedStr.startsWith('all categories')) {{
                    // "All Categories" = empty selection in MIS is correct
                    if (actualArr.length === 0) {{
                        return {{ status: 'correct', matched: [], missing: [], extra: [] }};
                    }}
                    // If user selected specific categories but expected "All", that's also acceptable
                    return {{ status: 'correct', matched: actualArr, missing: [], extra: [] }};
                }}
            }}
            
            // Original logic for non-"All" cases
            if (!expected || expected === '') {{
                return {{ status: 'empty', matched: [], missing: [], extra: [] }};
            }}
            
            const expectedArr = String(expected).split(',').map(s => s.trim()).filter(s => s);
            
            if (actualArr.length === 0) {{
                return {{ status: 'empty', matched: [], missing: expectedArr, extra: [] }};
            }}
            
            // Normalize for comparison
            const actualLower = actualArr.map(s => s.toLowerCase());
            const expectedLower = expectedArr.map(s => s.toLowerCase());
            
            // Find matched and missing
            const matched = [];
            const missing = [];
            
            expectedArr.forEach((exp, idx) => {{
                const expLower = expectedLower[idx];
                const found = actualLower.some(act => 
                    act === expLower || act.includes(expLower) || expLower.includes(act)
                );
                if (found) {{
                    matched.push(exp);
                }} else {{
                    missing.push(exp);
                }}
            }});
            
            // Find extra (selected but not expected)
            const extra = actualArr.filter(act => {{
                const actLower = act.toLowerCase();
                return !expectedLower.some(exp => 
                    exp === actLower || exp.includes(actLower) || actLower.includes(exp)
                );
            }});
            
            if (missing.length === 0 && extra.length === 0) {{
                return {{ status: 'correct', matched, missing, extra }};
            }} else if (matched.length > 0) {{
                return {{ status: 'partial', matched, missing, extra }};
            }} else {{
                return {{ status: 'mismatch', matched, missing, extra }};
            }}
        }}
        
        function compareSingleValue(actual, expected, expectedKey) {{
            // Handle linked_brand special case: empty expected means empty should be selected
            if (expectedKey === 'linked_brand') {{
                if (!expected || expected === '') {{
                    // No linked brand expected
                    if (!actual || actual === '' || actual === '- Select -' || (Array.isArray(actual) && actual.length === 0)) {{
                        return 'correct';  // Empty is correct
                    }}
                    return 'mismatch';  // Has value but shouldn't
                }}
            }}
            
            // Handle after_wholesale boolean
            if (expectedKey === 'after_wholesale') {{
                if (typeof expected === 'boolean') {{
                    return (actual === expected) ? 'correct' : 'mismatch';
                }}
            }}
            
            // Handle percentage fields
            if (expectedKey === 'discount' || expectedKey === 'vendor_contrib') {{
                const actualNorm = normalizePercent(actual);
                const expectedNorm = normalizePercent(expected);
                
                if (!expectedNorm) return 'empty';  // No expected value
                if (!actualNorm) return 'empty';   // No actual value
                
                return (actualNorm === expectedNorm) ? 'correct' : 'mismatch';
            }}
            
            // Standard comparison
            if (!expected || expected === '') {{
                return 'empty';  // No expected value
            }}
            
            const actualVal = Array.isArray(actual) ? (actual[0] || '') : actual;
            const actualNorm = normalizeString(actualVal);
            const expectedNorm = normalizeString(expected);
            
            if (!actualNorm || actualNorm === '- select -') return 'empty';
            
            return (actualNorm === expectedNorm || actualNorm.includes(expectedNorm) || expectedNorm.includes(actualNorm)) ? 'correct' : 'mismatch';
        }}
        
        function validateAllFields() {{
            const rows = document.querySelectorAll('.checklist-row');
            let correctCount = 0;
            let mismatchCount = 0;
            let emptyCount = 0;
            let partialCount = 0;
            let criticalMissing = [];
            
            rows.forEach(row => {{
                const fieldId = row.dataset.fieldId;
                const expectedKey = row.dataset.expectedKey;
                const fieldType = row.dataset.fieldType;
                const isMulti = row.dataset.isMulti === 'true';
                
                const expected = EXPECTED[expectedKey];
                let actual;
                
                // Get actual value based on field type
                if (fieldType === 'select2') {{
                    // v12.22.8: Pass isMulti to handle single-select vs multi-select differently
                    actual = getSelect2Value(fieldId, isMulti);
                }} else if (fieldType === 'checkbox') {{
                    actual = getCheckboxValue(fieldId);
                }} else {{
                    actual = getInputValue(fieldId);
                }}
                
                const icon = row.querySelector('.status-icon');
                const actualSpan = row.querySelector('.actual-val span');
                const progressInfo = row.querySelector('.progress-info');
                
                let status;
                
                if (isMulti) {{
                    // Multi-select validation with progress tracking
                    const result = compareMultiSelect(actual, expected, expectedKey);
                    status = result.status;
                    
                    // Update actual value display
                    if (Array.isArray(actual) && actual.length > 0) {{
                        actualSpan.textContent = actual.join(', ');
                    }} else {{
                        actualSpan.textContent = '(empty)';
                    }}
                    
                    // Show progress for multi-select fields
                    if (result.matched.length > 0 || result.missing.length > 0) {{
                        const total = result.matched.length + result.missing.length;
                        const matchedCount = result.matched.length;
                        
                        if (status === 'partial') {{
                            progressInfo.style.display = 'block';
                            progressInfo.innerHTML = `
                                <span style="color: #28a745;">[EMOJI] ${{result.matched.join(', ')}}</span><br>
                                <span style="color: #ffc107;">[EMOJI] Need: ${{result.missing.join(', ')}}</span>
                                <span style="color: #aaa;"> (${{matchedCount}}/${{total}})</span>
                            `;
                        }} else if (status === 'correct') {{
                            progressInfo.style.display = 'none';
                        }} else {{
                            progressInfo.style.display = 'block';
                            progressInfo.innerHTML = `<span style="color: #dc3545;">Need: ${{result.missing.join(', ')}}</span>`;
                        }}
                        
                        if (result.extra.length > 0) {{
                            progressInfo.style.display = 'block';
                            progressInfo.innerHTML += `<br><span style="color: #dc3545;">[EMOJI] Extra: ${{result.extra.join(', ')}}</span>`;
                        }}
                    }} else {{
                        progressInfo.style.display = 'none';
                    }}
                }} else {{
                    // Single value validation
                    status = compareSingleValue(actual, expected, expectedKey);
                    
                    // Update actual value display
                    if (typeof actual === 'boolean') {{
                        actualSpan.textContent = actual ? 'Yes' : 'No';
                    }} else if (Array.isArray(actual)) {{
                        actualSpan.textContent = actual.length > 0 ? actual[0] : '(empty)';
                    }} else {{
                        actualSpan.textContent = actual || '(empty)';
                    }}
                    
                    progressInfo.style.display = 'none';
                }}
                
                // Update status icon and styling
                if (status === 'correct') {{
                    icon.textContent = '[EMOJI]';
                    icon.style.color = '#28a745';
                    row.style.borderLeftColor = '#28a745';
                    row.style.background = 'rgba(40, 167, 69, 0.1)';
                    correctCount++;
                }} else if (status === 'partial') {{
                    icon.textContent = '[EMOJI]';
                    icon.style.color = '#ffc107';
                    row.style.borderLeftColor = '#ffc107';
                    row.style.background = 'rgba(255, 193, 7, 0.1)';
                    partialCount++;
                }} else if (status === 'mismatch') {{
                    icon.textContent = '[EMOJI]';
                    icon.style.color = '#dc3545';
                    row.style.borderLeftColor = '#dc3545';
                    row.style.background = 'rgba(220, 53, 69, 0.1)';
                    mismatchCount++;
                }} else {{
                    icon.textContent = '[EMOJI]';
                    icon.style.color = '#888';
                    row.style.borderLeftColor = '#666';
                    row.style.background = 'rgba(255,255,255,0.05)';
                    emptyCount++;
                }}
                
                // Track critical fields (Weekday and Rebate Type must be filled)
                if (expectedKey === 'weekday' && (status === 'empty' || (Array.isArray(actual) && actual.length === 0))) {{
                    criticalMissing.push('Weekday');
                }}
                if (expectedKey === 'rebate_type' && (status === 'empty' || !actual || (Array.isArray(actual) && actual.length === 0))) {{
                    criticalMissing.push('Rebate Type');
                }}
            }});
            
            // Update summary
            const summary = document.getElementById('checklist-summary');
            if (mismatchCount > 0) {{
                summary.innerHTML = `<span style="color: #dc3545;">[EMOJI] ${{mismatchCount}} field(s) don't match</span>`;
            }} else if (partialCount > 0) {{
                summary.innerHTML = `<span style="color: #ffc107;">[EMOJI] ${{partialCount}} field(s) partially filled</span>`;
            }} else if (emptyCount > 0) {{
                summary.innerHTML = `<span style="color: #888;">[EMOJI] ${{emptyCount}} field(s) need to be filled</span>`;
            }} else {{
                summary.innerHTML = `<span style="color: #28a745;">[EMOJI] All fields validated!</span>`;
            }}
            
            // Critical warning for Weekday and Rebate Type
            const criticalWarning = document.getElementById('critical-warning');
            if (criticalMissing.length > 0) {{
                criticalWarning.style.display = 'block';
                criticalWarning.innerHTML = `[EMOJI] <strong>CANNOT SAVE:</strong> ${{criticalMissing.join(' and ')}} must be selected!`;
            }} else {{
                criticalWarning.style.display = 'none';
            }}
            
            return {{ correctCount, mismatchCount, emptyCount, partialCount, criticalMissing }};
        }}
        
        // ========================================
        // SAVE BUTTON INTERCEPTION
        // ========================================
        function interceptSaveButton() {{
            const saveBtn = document.querySelector('.btn-submit, button[type="submit"]');
            if (saveBtn && !saveBtn.dataset.checklistIntercepted) {{
                saveBtn.dataset.checklistIntercepted = 'true';
                const originalOnClick = saveBtn.onclick;
                
                saveBtn.onclick = function(e) {{
                    const result = validateAllFields();
                    if (result.criticalMissing.length > 0) {{
                        e.preventDefault();
                        e.stopPropagation();
                        alert('[EMOJI] Cannot save: ' + result.criticalMissing.join(' and ') + ' must be selected!');
                        return false;
                    }}
                    if (originalOnClick) return originalOnClick.call(this, e);
                }};
            }}
        }}
        
        // ========================================
        // START MONITORING
        // ========================================
        validateAllFields();
        interceptSaveButton();
        
        // Continuous validation every 500ms
        const validationInterval = setInterval(() => {{
            if (!document.getElementById('checklist-banner-v18')) {{
                clearInterval(validationInterval);
                return;
            }}
            if (!document.querySelector('.modal.show, .modal[style*="display: block"]')) {{
                // Modal closed, remove banner
                document.getElementById('checklist-banner-v18')?.remove();
                clearInterval(validationInterval);
                return;
            }}
            validateAllFields();
            interceptSaveButton();
        }}, 500);
        
        console.log('[CHECKLIST v12.18.1] Banner injected with expected data:', EXPECTED);
    }})();
    '''
    
    try:
        driver.execute_script(js_code)
        print("[CHECKLIST] v12.18.1 Checklist Banner injected successfully")
    except Exception as e:
        print(f"[CHECKLIST] Failed to inject banner: {e}")


@app.route('/api/mis/automate-create-deal', methods=['POST'])
def api_mis_automate_create_deal():
    """
    v12.18.1: Automates creating a NEW deal with CHECKLIST BANNER approach.
    
    Auto-fills these fields:
    - Brand, Linked Brand, Rebate Type, Discount, Vendor Rebate, Start Date, End Date
    
    Shows Checklist Banner for user to manually fill:
    - Weekday, Store/Locations, Category, After Wholesale
    
    The checklist validates all fields in real-time with:
    - Green checkmark ([EMOJI]) for correct values
    - Yellow half-circle ([EMOJI]) for partial multi-select progress
    - Red X ([EMOJI]) for mismatches
    - Gray circle ([EMOJI]) for empty
    
    Blocks save if Weekday or Rebate Type is empty.
    """
    try:
        print("\n" + "="*60)
        print("[AUTOMATION] STARTING CREATE DEAL SEQUENCE v12.15")
        print("="*60)

        data = request.get_json()
        print(f"[DEBUG] Raw Payload Received: {json.dumps(data, indent=2)}")

        # =========================================================
        # v12.15: WEEKDAY INTERSECTION HELPER
        # =========================================================
        def calculate_weekday_intersection(google_weekdays_str: str, start_date_str: str, end_date_str: str) -> list:
            """
            Calculate which weekdays from Google Sheet actually occur in the date range.
            CRITICAL: Prevents data integrity issues when creating deals.
            """
            from datetime import datetime, timedelta
            
            if not google_weekdays_str or not start_date_str or not end_date_str:
                return []
            
            weekday_names = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
            weekday_map = {
                'monday': 0, 'mon': 0, 'mo': 0,
                'tuesday': 1, 'tue': 1, 'tu': 1, 'tues': 1,
                'wednesday': 2, 'wed': 2, 'we': 2,
                'thursday': 3, 'thu': 3, 'th': 3, 'thur': 3, 'thurs': 3,
                'friday': 4, 'fri': 4, 'fr': 4,
                'saturday': 5, 'sat': 5, 'sa': 5,
                'sunday': 6, 'sun': 6, 'su': 6
            }
            
            sheet_weekday_indices = set()
            for w in google_weekdays_str.split(','):
                w_clean = w.strip().lower()
                if w_clean in weekday_map:
                    sheet_weekday_indices.add(weekday_map[w_clean])
            
            if not sheet_weekday_indices:
                return []
            
            try:
                for fmt in ['%m/%d/%y', '%m/%d/%Y']:
                    try:
                        start = datetime.strptime(start_date_str, fmt)
                        break
                    except ValueError:
                        continue
                else:
                    return []
                
                for fmt in ['%m/%d/%y', '%m/%d/%Y']:
                    try:
                        end = datetime.strptime(end_date_str, fmt)
                        break
                    except ValueError:
                        continue
                else:
                    return []
            except:
                return []
            
            valid_weekdays = set()
            current = start
            while current <= end:
                if current.weekday() in sheet_weekday_indices:
                    valid_weekdays.add(weekday_names[current.weekday()])
                current += timedelta(days=1)
            
            return list(valid_weekdays)

        # =========================================================
        # 1. EXTRACT DATA
        # =========================================================
        sheet_data = data.get('sheet_data', {})
        section_type = data.get('section_type', 'unknown')
        
        def clean(val): return str(val).strip() if val else ""

        target_brand = clean(sheet_data.get('brand'))
        target_linked = clean(sheet_data.get('linked_brand'))
        target_weekday_raw = clean(sheet_data.get('weekday'))
        target_category = clean(sheet_data.get('categories'))
        target_locations = clean(sheet_data.get('locations'))
        target_discount = clean(sheet_data.get('discount')).replace('%', '')
        target_vendor = clean(sheet_data.get('vendor_contrib')).replace('%', '')
        
        # v12.15: Extract Rebate Type fields
        target_retail = clean(sheet_data.get('retail')).upper()
        target_wholesale = clean(sheet_data.get('wholesale')).upper()
        target_after_wholesale = clean(sheet_data.get('after_wholesale')).upper()
        target_min_weight = clean(sheet_data.get('min_weight'))
        target_max_weight = clean(sheet_data.get('max_weight'))
        
        req_start = data.get('start_date', '')
        req_end = data.get('end_date', '')

        print(f"[DEBUG] PARSED TARGETS:")
        print(f" - Section: '{section_type}'")
        print(f" - Brand: '{target_brand}'")
        print(f" - Linked: '{target_linked}'")
        print(f" - Weekday (Raw): '{target_weekday_raw}'")
        print(f" - Category: '{target_category}'")
        print(f" - Locations: '{target_locations}'")
        print(f" - Discount: '{target_discount}'")
        print(f" - Vendor: '{target_vendor}'")
        print(f" - Retail: '{target_retail}', Wholesale: '{target_wholesale}'")
        print(f" - After Wholesale: '{target_after_wholesale}'")
        print(f" - Min/Max Weight: '{target_min_weight}' / '{target_max_weight}'")
        print(f" - Start/End: '{req_start}' to '{req_end}'")

        # =========================================================
        # v12.15: CALCULATE WEEKDAY INTERSECTION
        # =========================================================
        if req_start and req_end and target_weekday_raw:
            intersected_weekdays = calculate_weekday_intersection(target_weekday_raw, req_start, req_end)
            target_weekday = ', '.join(intersected_weekdays) if intersected_weekdays else ""
            print(f"[WEEKDAY-CALC] Raw: '{target_weekday_raw}' -> Intersected: '{target_weekday}'")
            if not intersected_weekdays:
                print(f"[WARNING] No weekdays intersect with date range!")
        else:
            target_weekday = target_weekday_raw
            print(f"[FALLBACK] Using raw weekday: '{target_weekday}'")

        # =========================================================
        # DETERMINE REBATE TYPE
        # =========================================================
        rebate_type = None
        if target_wholesale == 'TRUE':
            rebate_type = 'Wholesale'
        elif target_retail == 'TRUE':
            rebate_type = 'Retail'
        print(f"[DEBUG] Determined Rebate Type: '{rebate_type}'")
        
        after_wholesale = target_after_wholesale == 'TRUE'
        print(f"[DEBUG] After Wholesale: {after_wholesale}")

        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        
        ensure_mis_ready(driver)

        # =========================================================
        # ROBUST ATOMIC HELPERS (From ID Matcher)
        # =========================================================
        
        def log(msg, level="INFO"):
            print(f"[{level}] {msg}")

        def click_backdrop():
            try: 
                driver.find_element(By.CSS_SELECTOR, "h4.modal-title").click()
            except: 
                pass

        def build_xpath_contains(text):
            """Build XPath contains() that handles quotes properly"""
            if "'" not in text:
                return f"'{text}'"
            elif '"' not in text:
                return f'"{text}"'
            else:
                parts = text.split("'")
                return "concat('" + "', \"'\", '".join(parts) + "')"

        def atomic_text_input(input_id, value, field_name):
            """Fill a text input field by ID or name"""
            if value is None or str(value).strip() == '':
                log(f"Skipping {field_name} (no value)", "SKIP")
                return True
            
            log(f"ATOMIC TEXT: {field_name} = {value}", "INFO")
            
            try:
                el = None
                # Try by ID first
                try:
                    el = driver.find_element(By.ID, input_id)
                except:
                    pass
                
                # Try by NAME
                if not el:
                    try:
                        el = driver.find_element(By.NAME, input_id)
                    except:
                        pass
                
                if not el:
                    log(f"Could not find input for {field_name}", "ERROR")
                    return False
                
                el.click()
                time.sleep(0.1)
                el.send_keys(Keys.CONTROL + "a")
                el.send_keys(Keys.DELETE)
                el.send_keys(str(value))
                el.send_keys(Keys.TAB)
                log(f"Filled {field_name}", "SUCCESS")
                return True
                
            except Exception as e:
                log(f"Error in atomic_text_input for {field_name}: {e}", "ERROR")
                return False

        def atomic_toggle(label_for_id, should_enable, field_name):
            """Toggle a checkbox by its label's for attribute"""
            log(f"ATOMIC TOGGLE: {field_name} = {should_enable}", "INFO")
            
            try:
                checkbox = None
                try:
                    checkbox = driver.find_element(By.ID, label_for_id)
                except:
                    pass
                
                if not checkbox:
                    try:
                        checkbox = driver.find_element(By.NAME, label_for_id)
                    except:
                        pass
                
                if not checkbox:
                    log(f"Could not find checkbox for {field_name}", "ERROR")
                    return False
                
                is_checked = checkbox.is_selected()
                
                if should_enable and not is_checked:
                    checkbox.click()
                    log(f"Enabled {field_name}", "SUCCESS")
                elif not should_enable and is_checked:
                    checkbox.click()
                    log(f"Disabled {field_name}", "SUCCESS")
                else:
                    log(f"{field_name} already in desired state", "SKIP")
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_toggle for {field_name}: {e}", "ERROR")
                return False

        def atomic_single_select(label_text, value, field_name):
            """
            Fill a single-select dropdown using SIMULATED MOUSE CLICKS.
            Handles BOTH searchable and non-searchable dropdowns (like Rebate Type).
            """
            if not value:
                log(f"Skipping {field_name} (no value)", "SKIP")
                return True
            
            log(f"ATOMIC SINGLE-SELECT: {field_name} = {value}", "INFO")
            
            FIELD_SELECT_MAP = {
                'Brand': 'brand_id',
                'Linked Brand': 'linked_brand_id',
                'Rebate Type': 'daily_discount_type_id'
            }
            
            select_id = FIELD_SELECT_MAP.get(field_name, field_name.lower().replace(' ', '_'))
            
            try:
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.1)
                click_backdrop()
                time.sleep(0.15)
                
                container = None
                
                # Method A: Find by select ID
                try:
                    container_css = f"select#{select_id} + .select2-container, .select2-container[aria-labelledby*='{select_id}']"
                    container = driver.find_element(By.CSS_SELECTOR, container_css)
                    log(f"  [{field_name}] Found container via select ID", "DEBUG")
                except:
                    pass
                
                # Method B: Find by label
                if not container:
                    try:
                        xpath_value = build_xpath_contains(label_text)
                        container_xpath = f"//label[contains(text(), {xpath_value})]/following::span[contains(@class, 'select2-container')][1]"
                        container = driver.find_element(By.XPATH, container_xpath)
                        log(f"  [{field_name}] Found container via label", "DEBUG")
                    except:
                        pass
                
                # Method C: Known IDs fallback
                if not container:
                    try:
                        id_map = {
                            'Brand': 'select2-brand_id-container',
                            'Linked Brand': 'select2-linked_brand_id-container',
                            'Rebate Type': 'select2-daily_discount_type_id-container'
                        }
                        if field_name in id_map:
                            container = driver.find_element(By.ID, id_map[field_name])
                            log(f"  [{field_name}] Found container via known ID", "DEBUG")
                    except:
                        pass
                
                if not container:
                    log(f"  [{field_name}] Could not find Select2 container!", "ERROR")
                    return False
                
                # Click to open dropdown
                actions = ActionChains(driver)
                actions.move_to_element(container)
                actions.click()
                actions.perform()
                time.sleep(0.25)
                
                # Check if search input exists and is VISIBLE
                search_input = None
                search_is_visible = False
                
                try:
                    search_elements = driver.find_elements(By.CSS_SELECTOR, ".select2-dropdown .select2-search__field")
                    for elem in search_elements:
                        if elem.is_displayed():
                            search_input = elem
                            search_is_visible = True
                            break
                except:
                    pass
                
                if search_is_visible and search_input:
                    actions = ActionChains(driver)
                    actions.move_to_element(search_input)
                    actions.click()
                    actions.perform()
                    time.sleep(0.1)
                    search_input.send_keys(str(value))
                    time.sleep(0.5)
                
                # Find and click the matching option
                try:
                    option = None
                    option_xpath_value = build_xpath_contains(str(value))
                    
                    # Try exact text match
                    try:
                        exact_xpath = f"//li[contains(@class, 'select2-results__option') and normalize-space(text())={option_xpath_value}]"
                        option = WebDriverWait(driver, 1).until(EC.element_to_be_clickable((By.XPATH, exact_xpath)))
                    except:
                        pass
                    
                    # Try contains match
                    if not option:
                        try:
                            contains_xpath = f"//li[contains(@class, 'select2-results__option') and contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 1.5).until(EC.element_to_be_clickable((By.XPATH, contains_xpath)))
                        except:
                            pass
                    
                    # Special handling for Rebate Type
                    if not option and field_name == 'Rebate Type':
                        try:
                            results_xpath = f"//ul[@id='select2-daily_discount_type_id-results']//li[contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 1).until(EC.element_to_be_clickable((By.XPATH, results_xpath)))
                        except:
                            pass
                    
                    if option:
                        actions = ActionChains(driver)
                        actions.move_to_element(option)
                        actions.click()
                        actions.perform()
                        log(f"  [{field_name}] Selected '{value}'", "SUCCESS")
                    else:
                        # Fallback: keyboard navigation
                        if search_input and search_is_visible:
                            search_input.send_keys(Keys.ENTER)
                        else:
                            ActionChains(driver).send_keys(Keys.ARROW_DOWN).perform()
                            time.sleep(0.1)
                            ActionChains(driver).send_keys(Keys.ENTER).perform()
                        log(f"  [{field_name}] Selected '{value}' via keyboard", "SUCCESS")
                        
                except Exception as e:
                    log(f"  [{field_name}] Click failed, using ENTER: {e}", "WARN")
                    ActionChains(driver).send_keys(Keys.ENTER).perform()
                
                time.sleep(0.1)
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.08)
                click_backdrop()
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_single_select for {field_name}: {e}", "ERROR")
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                click_backdrop()
                return False

        def atomic_multi_select(label_text, values, field_name):
            """Fill a multi-select dropdown by CLICKING OPTIONS DIRECTLY."""
            if not values:
                log(f"Skipping {field_name} (no values)", "SKIP")
                return True
            
            # Convert string to list if needed
            if isinstance(values, str):
                if 'all' in values.lower() and field_name != 'Weekday':
                    log(f"Skipping {field_name} ('All' detected)", "SKIP")
                    return True
                values = [v.strip() for v in values.split(',') if v.strip()]
            
            if not values:
                log(f"Skipping {field_name} (empty list)", "SKIP")
                return True
            
            log(f"ATOMIC MULTI-SELECT: {field_name} = {values}", "INFO")
            
            FIELD_SELECT_MAP = {
                'Store': 'store_ids',
                'Weekday': 'weekday_ids',
                'Category': 'category_ids'
            }
            
            select_id = FIELD_SELECT_MAP.get(field_name, field_name.lower().replace(' ', '_'))
            
            try:
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.1)
                click_backdrop()
                time.sleep(0.15)
                
                container = None
                
                try:
                    container_css = f"select#{select_id} + .select2-container, .select2-container[aria-labelledby*='{select_id}']"
                    container = driver.find_element(By.CSS_SELECTOR, container_css)
                except:
                    pass
                
                if not container:
                    try:
                        xpath_value = build_xpath_contains(label_text)
                        container_xpath = f"//label[contains(text(), {xpath_value})]/following::span[contains(@class, 'select2-container')][1]"
                        container = driver.find_element(By.XPATH, container_xpath)
                    except:
                        pass
                
                if not container:
                    log(f"  [{field_name}] Could not find Select2 container!", "ERROR")
                    return False
                
                # Weekday name normalization
                day_map = {'mon':'Monday','tue':'Tuesday','wed':'Wednesday','thu':'Thursday','fri':'Friday','sat':'Saturday','sun':'Sunday'}
                
                # FIX v12.18: Open dropdown ONCE before iterating values
                # This prevents accidentally clicking an option when reopening dropdown each iteration
                log(f"  [{field_name}] Opening dropdown once for all {len(values)} values...", "DEBUG")
                
                # Click the selection area specifically (not options) to open dropdown
                try:
                    selection_area = container.find_element(By.CSS_SELECTOR, ".select2-selection")
                    selection_area.click()
                except:
                    # Fallback to container click
                    actions = ActionChains(driver)
                    actions.move_to_element(container)
                    actions.click()
                    actions.perform()
                
                time.sleep(0.3)
                
                # Wait for dropdown to open and search field to be ready
                search_input = None
                try:
                    search_input = WebDriverWait(driver, 2).until(
                        EC.visibility_of_element_located((By.CSS_SELECTOR, ".select2-dropdown .select2-search__field"))
                    )
                    log(f"  [{field_name}] Dropdown open, search field ready", "DEBUG")
                except:
                    log(f"  [{field_name}] Warning: Could not find search field", "WARN")
                
                for val in values:
                    val_clean = str(val).strip()
                    if not val_clean:
                        continue
                    
                    # Normalize weekday names
                    if field_name == 'Weekday':
                        val_lower = val_clean.lower()[:3]
                        if val_lower in day_map:
                            val_clean = day_map[val_lower]
                    
                    log(f"  [{field_name}] Adding '{val_clean}'...", "DEBUG")
                    
                    # Type to filter (dropdown already open, search field should be focused)
                    if search_input:
                        try:
                            search_input.clear()
                            search_input.send_keys(val_clean)
                            time.sleep(0.4)
                        except:
                            # Re-acquire search field if stale
                            try:
                                search_input = driver.find_element(By.CSS_SELECTOR, ".select2-dropdown .select2-search__field")
                                search_input.clear()
                                search_input.send_keys(val_clean)
                                time.sleep(0.4)
                            except:
                                pass
                    
                    # Click option
                    try:
                        option_xpath_value = build_xpath_contains(val_clean)
                        option_xpath = f"//li[contains(@class, 'select2-results__option') and contains(text(), {option_xpath_value})]"
                        option = WebDriverWait(driver, 1.5).until(EC.element_to_be_clickable((By.XPATH, option_xpath)))
                        
                        actions = ActionChains(driver)
                        actions.move_to_element(option)
                        actions.click()
                        actions.perform()
                        log(f"    -> Added '{val_clean}'", "SUCCESS")
                    except:
                        # Fallback: press Enter to select highlighted option
                        ActionChains(driver).send_keys(Keys.ENTER).perform()
                        log(f"    -> Added '{val_clean}' via ENTER", "SUCCESS")
                    
                    time.sleep(0.2)
                    
                    # Clear search for next value (dropdown stays open for multi-select)
                    if search_input:
                        try:
                            search_input.clear()
                            time.sleep(0.1)
                        except:
                            pass
                
                # Close dropdown after all values selected
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                click_backdrop()
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_multi_select for {field_name}: {e}", "ERROR")
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                click_backdrop()
                return False

        # =========================================================
        # EXECUTION FLOW - v12.18 CHECKLIST BANNER APPROACH
        # Only automate: Brand, Linked Brand, Rebate Type, Start Date, End Date
        # Show checklist for all other fields
        # =========================================================
        warnings = []
        automated_fields = []

        # 1. Open Modal
        print("\n[ACTION] Clicking 'Add New' button...")
        try:
            btn = WebDriverWait(driver, 3).until(EC.element_to_be_clickable((By.CSS_SELECTOR, "button.btn-add-dialog")))
            btn.click()
        except:
            print("[WARN] Standard button not found, trying text fallback...")
            driver.find_element(By.XPATH, "//button[contains(text(), 'Add New')]").click()
        
        print("[WAIT] Waiting for modal animation...")
        time.sleep(2.0)

        # v12.18: ONLY AUTOMATE THESE 5 FIELDS
        # =====================================
        
        # 2. BRAND (single-select) - AUTOMATE
        if target_brand:
            if atomic_single_select("Brand", target_brand, "Brand"):
                automated_fields.append('Brand')
            else:
                warnings.append('Could not fill Brand')

        # 3. LINKED BRAND (single-select) - AUTOMATE
        if target_linked:
            if atomic_single_select("Linked Brand", target_linked, "Linked Brand"):
                automated_fields.append('Linked Brand')
            else:
                warnings.append('Could not fill Linked Brand')

        # 4. REBATE TYPE (single-select) - AUTOMATE
        if rebate_type:
            if atomic_single_select("Rebate Type", rebate_type, "Rebate Type"):
                automated_fields.append('Rebate Type')
            else:
                warnings.append('Could not fill Rebate Type')
        else:
            print("[WARNING] Rebate Type not determined - field will require manual selection!")
            warnings.append('Rebate Type not determined from source data')

        # 5. DISCOUNT RATE (text input) - AUTOMATE
        if target_discount:
            if atomic_text_input("discount_rate", target_discount, "Discount Rate"):
                automated_fields.append('Discount')
            else:
                warnings.append('Could not fill Discount Rate')

        # 6. VENDOR REBATE % (text input) - AUTOMATE
        if target_vendor:
            if atomic_text_input("rebate_percent", target_vendor, "Vendor Rebate"):
                automated_fields.append('Vendor Rebate')
            else:
                warnings.append('Could not fill Vendor Rebate')

        # 7. START DATE (text input) - AUTOMATE
        if req_start:
            if atomic_text_input("date_start", req_start, "Start Date"):
                automated_fields.append('Start Date')
            else:
                warnings.append('Could not fill Start Date')

        # 8. END DATE (text input) - AUTOMATE
        if req_end:
            if atomic_text_input("date_end", req_end, "End Date"):
                automated_fields.append('End Date')
            else:
                warnings.append('Could not fill End Date')

        # v12.18: DO NOT automate these fields - show in checklist instead:
        # - Weekday, Store/Locations, Category, After Wholesale
        
        # v12.18: Lookup linked brand from Settings tab if not provided
        if not target_linked and target_brand:
            brand_settings = GLOBAL_DATA.get('brand_settings', {})
            target_linked = brand_settings.get(target_brand.lower(), '')
            if target_linked:
                print(f"[LINKED BRAND] Found from Settings tab: '{target_linked}'")
            else:
                print(f"[LINKED BRAND] Brand '{target_brand}' has no linked brand in Settings")

        print("\n" + "="*60)
        print("[AUTOMATION] v12.18 PARTIAL AUTOMATION COMPLETE")
        print("="*60)
        print(f"[AUTOMATED] {len(automated_fields)} fields: {', '.join(automated_fields)}")
        print(f"[MANUAL] User must fill: Weekday, Store, Category, After Wholesale")
        if warnings:
            print(f"[WARNINGS] {len(warnings)} issue(s): {', '.join(warnings)}")
        print("="*60 + "\n")

        # v12.18: INJECT CHECKLIST BANNER with expected values
        expected_data = {
            'weekday': target_weekday,
            'locations': target_locations,
            'brand': target_brand,
            'linked_brand': target_linked,  # May be empty string if no linked brand
            'categories': target_category,
            'discount': target_discount,
            'rebate_type': rebate_type or '',
            'vendor_contrib': target_vendor,
            'after_wholesale': after_wholesale,
            'start_date': req_start,
            'end_date': req_end
        }
        
        # Inject the checklist validation banner
        inject_checklist_banner(driver, expected_data)
        
        result_msg = f'Form partially filled for {target_brand}. Review checklist and fill remaining fields.'
        if warnings:
            result_msg += f' ({len(warnings)} warning(s) - check console)'
        
        return jsonify({
            'success': True, 
            'message': result_msg, 
            'warnings': warnings,
            'automated_fields': automated_fields,
            'expected_data': expected_data
        })

    except Exception as e:
        print(f"[CRITICAL FAILURE] {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[EXIT] Shutting down...")
        sys.exit(0)
    except Exception as e:
        print(f"\n[CRITICAL ERROR] {e}")
        traceback.print_exc()
        input("Press Enter to exit...")
