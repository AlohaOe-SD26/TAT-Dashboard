# [BLAZE MIS Project 2 - Phase 2 Implementation] - v12.11 COMPREHENSIVE BANNER
# v12.11 CHANGELOG (COMPREHENSIVE BANNER - SHOWS ALL ERRORS):
#   - FIXED: Banner now shows ALL errors (critical AND advisory) in single list
#     * Was: Banner only showed advisory warnings, ignored critical errors
#     * Now: Banner shows comprehensive list of ALL issues
#     * Critical errors listed first with üî¥ + "(BLOCKS SAVE)"
#     * Advisory warnings listed second with üüß
#   - IMPROVED: Banner color priority
#     * RED banner: Any critical errors (even if advisory too)
#     * ORANGE banner: Only advisory warnings (no critical)
#     * GREEN banner: All fields correct
#   - IMPROVED: Banner updates for critical validation changes
#     * Change Rebate Type ‚Üí Banner updates ‚úÖ
#     * Change Weekday ‚Üí Banner updates ‚úÖ
#     * Any critical field change ‚Üí Banner reflects immediately ‚úÖ
#   - ENHANCED: Comprehensive error tracking
#     * criticalErrors object: {rebateType, weekday}
#     * Deep comparison for critical validation state
#     * Banner updates when EITHER critical OR advisory changes
#   - NEW: Header shows blocking count
#     * "‚ö†Ô∏è 3 Issues Found (2 errors blocking save)"
#     * Clear indication of what blocks Save button
#   - Examples:
#     * 2 critical + 1 advisory ‚Üí RED banner, lists all 3
#     * 0 critical + 2 advisory ‚Üí ORANGE banner, lists both
#     * 1 critical + 0 advisory ‚Üí RED banner, shows critical
#     * 0 critical + 0 advisory ‚Üí GREEN banner, all correct
# v12.10.3 CHANGELOG (BANNER INITIALIZATION FIX):
#   - FIXED: Banner now appears immediately on first validation run
#     * Was: Banner missing when automation fills correctly (0 warnings ‚Üí 0 warnings)
#     * Why: Deep compare on first run: JSON.stringify({}) === JSON.stringify({})
#     * Now: Check if banner exists, create if missing (even if warnings unchanged)
#     * Logic: if (warningsChanged || bannerMissing) { create banner }
#   - IMPROVED: Banner initialization
#     * First validation run ‚Üí Banner created immediately ‚úÖ
#     * User makes edit ‚Üí Banner updates correctly ‚úÖ
#     * No more "banner appears only after edit" bug ‚úÖ
#   - Added logging for initial banner creation
#     * Console shows: "Initial banner created (first validation run)"
#     * Helps debug initialization timing issues
# v12.10.2 CHANGELOG (BANNER UPDATE FIX):
#   - FIXED: Banner now updates dynamically as fields change
#     * Was: Only updated when warning COUNT changed (0‚Üí1, 1‚Üí2)
#     * Now: Updates when ANY warning CONTENT changes
#     * Uses deep comparison: JSON.stringify(warnings) vs old warnings
#     * Catches: Count changes, field changes, value changes
#   - IMPROVED: Banner update detection
#     * Before: if (warningCount !== oldWarningCount || warningCount === 0)
#     * After: if (JSON.stringify(warnings) !== JSON.stringify(oldWarnings))
#     * No more "stuck banner" after automation
#   - Examples now working:
#     * Change Brand: Stiiizy ‚Üí Jeeter ‚Üí Banner updates ‚úÖ
#     * Fix Brand, break Discount (1‚Üí1 warnings) ‚Üí Banner updates ‚úÖ
#     * Change Discount: 20% ‚Üí 25% ‚Üí Banner updates ‚úÖ
#     * All correct ‚Üí Change anything ‚Üí Banner updates immediately ‚úÖ
# v12.10.1 CHANGELOG (SYNTAX FIX):
#   - CRITICAL: Weekday is now RED (blocks Save) like Rebate Type
#     * Weekday MUST have at least one day selected
#     * RED box appears if blank
#     * Save button hidden until at least one day selected
#     * Applies to BOTH automation AND manual mode
#   - FIXED: Multi-select detection for Weekday and Stores
#     * Proper iteration: for (let i = 0; i < select.options.length; i++)
#     * Was using for...of which didn't work properly
#     * Now detects ALL selected values correctly
#     * Added debug logging to show selected count
#   - FIXED: Categories "All Categories (Except: *)" logic
#     * "*" is now recognized as filler exception (ignored)
#     * Blank actual = "All Categories" when expected is "All Categories (Except: *)"
#     * No false warnings for this common Google Sheet pattern
#   - UPDATED: Manual mode validation
#     * Now validates: Rebate Type + Weekday (both RED, both block Save)
#     * Banner shows: "Manual mode: Validating Rebate Type + Weekday only"
#     * Was: Only Rebate Type
#   - UPDATED: Error messages
#     * hideSaveButton now shows errors for BOTH fields if invalid
#     * Banner advisory text: "can save if Rebate Type and Weekday are filled"
#     * Was: "can save if Rebate Type is filled"
#   - UPDATED: Validation loop
#     * Checks BOTH rebateValid AND weekdayValid
#     * Hide save if EITHER is invalid
#     * Show save only when BOTH are valid
#   - IMPROVED: State tracking
#     * Added weekdayValid to validation state
#     * Proper cleanup on modal close
#   - REMOVED: Duplicate validation script (723 lines deleted)
#     * Was causing confusion with multiple versions
#     * Now single clean validation script
# v12.9 CHANGELOG (PERSISTENT VALIDATION + MODE TRACKING):
#   - NEW: Persistent validation banner (ALWAYS visible until Save clicked)
#     * Green banner when all correct: "‚úÖ All Fields Correct - Ready to Save!"
#     * Orange banner when warnings: "‚ö†Ô∏è X Fields May Need Review"
#     * Shows validation mode (Automation vs Manual)
#     * Only disappears when Save clicked or modal closed
#   - NEW: Save button detection
#     * Detects when user clicks Save button
#     * Stops validation immediately
#     * Cleans up banner and Force button
#     * Signals end of validation session
#   - NEW: Cancel button detection
#     * Detects when user clicks Cancel/Close button
#     * Clears automation expected data
#     * Switches to manual validation mode
#     * Prevents "ghosting" of old automation data
#   - NEW: Validation mode tracking (Automation vs Manual)
#     * Automation mode: Validates all fields against Google Sheet
#     * Manual mode: Only validates Rebate Type (CRITICAL)
#     * Mode displayed in banner
#     * Switches automatically on Cancel
#   - NEW: Category validation (Phase 2)
#     * Validates categories against Google Sheet
#     * Case-insensitive, order-independent
#     * Multi-select support
#     * ORANGE boxes for mismatches
#   - NEW: Linked Brand validation (Phase 2)
#     * Validates linked brand against Google Sheet
#     * ORANGE boxes for mismatches
#   - IMPROVED: Manual entry detection
#     * If user manually clicks "Add New", starts in manual mode
#     * No expected data = manual mode automatically
#   - IMPROVED: Persistent UI
#     * Banner always visible (green or orange)
#     * Force button persistent until modal close
#     * Clear feedback at all times
#   - IMPROVED: Better lifecycle management
#     * Save = end validation
#     * Cancel = switch to manual mode
#     * Modal close = full cleanup
# v12.8.3 CHANGELOG (ENHANCED VALIDATION LOGIC):
#   - FIXED: Weekday validation now case-insensitive
#     * "MONDAY" vs "Monday" vs "monday" all match correctly
#     * No false positives for different capitalization
#   - FIXED: Stores validation handles blank = "All Locations"
#     * When actual stores field is blank (no selections), validates as "All Locations"
#     * No false warning when automation correctly leaves field blank
#   - ENHANCED: Full support for "All Locations Except:" validation
#     * Validates "All Locations Except: X, Y, Z" correctly
#     * Compares expected stores (master list minus exceptions) vs actual selections
#     * Matches Python's MASTER_STORE_LIST for consistency
#     * Example: "All Locations Except: Beverly, Davis" validates correctly
#   - ENHANCED: Store validation logic with three cases:
#     * Case 1: "All Locations" ‚Üí expects blank field
#     * Case 2: "All Locations Except: X, Y" ‚Üí expects master list minus exceptions
#     * Case 3: Specific stores "Beverly, Davis" ‚Üí expects exact match
#   - IMPROVED: Case-insensitive store comparisons
#     * "Beverly" vs "beverly" match correctly
#     * Order doesn't matter (Beverly, Davis == Davis, Beverly)
#   - IMPROVED: Better error messages for store mismatches
#     * Shows "(blank)" when field is empty
#     * Lists actual vs expected stores clearly
# v12.8.2 CHANGELOG (ORANGE BOX FIX + ENHANCED SUMMARY):
#   - FIXED: ORANGE boxes now properly visible on all field types
#     * Select2 dropdowns (Brand, Weekday, Stores): 3px solid orange border
#     * Input fields (Discount, Vendor Contrib): 3px solid orange border + glow
#     * Toggle (After Wholesale): Orange border on entire row
#     * Increased border width from 2px to 3px for better visibility
#     * Enhanced shadow/glow effect for prominence
#   - ENHANCED: Summary banner now shows detailed error breakdown
#     * Lists each field with Expected vs Actual values
#     * Color-coded boxes for expected/actual values
#     * Clear field names: Brand, Weekday, Stores, Discount, etc.
#     * Example: "Brand: Expected [Stiiizy], Actual [Jeeter]"
#     * Makes it easy to see what needs correction at a glance
#   - IMPROVED: Better logging for debugging
#     * Logs when ORANGE boxes are added/removed
#     * Logs field IDs and types
#     * Helps diagnose styling issues
#   - IMPROVED: Tooltip positioning and styling
#     * Works on all field types correctly
#     * Clear error messages with context
# v12.8 PHASE 2 CHANGELOG (FULL FIELD VALIDATION):
#   - NEW: Full field validation against Google Sheet data
#     * Compares ALL fields to expected values from automation
#     * Fields validated: Brand, Weekday, Discount, Vendor Contrib, Stores, After Wholesale toggle
#     * ORANGE boxes (2px solid) for mismatches (advisory, doesn't block Save)
#     * Hover tooltips showing "Expected: X, Actual: Y"
#   - NEW: Error summary banner at top of modal
#     * Shows count: "‚ö†Ô∏è 3 fields may need review"
#     * Clarifies these are advisory (can still save)
#     * Updates dynamically as fields change
#   - NEW: Smart field comparison logic
#     * Handles multi-select fields (Weekday, Stores)
#     * Compares percentages (Discount, Vendor Contrib)
#     * Validates boolean toggle (After Wholesale)
#     * Ignores blank/unselected fields (no false positives)
#   - IMPROVED: Two-tier validation system
#     * Phase 1 (RED): Rebate Type MUST be filled ‚Üí Blocks Save
#     * Phase 2 (ORANGE): All other fields ‚Üí Advisory only
#   - IMPROVED: Enhanced tooltips
#     * RED: "‚ùå Rebate Type is required!"
#     * ORANGE: "‚ö†Ô∏è Brand mismatch: Expected 'Stiiizy', found 'Jeeter'"
#   - IMPROVED: Console logging for debugging
#     * Logs all validation checks
#     * Shows which fields have warnings
#     * Helps diagnose automation issues
# v12.8.1 CHANGELOG (BUGFIX - PERSISTENT FORCE BUTTON):
#   - FIXED: Force Show Save button now persistent during entire validation session
#     * Previously: Button disappeared after being clicked
#     * Now: Button remains visible until modal closes
#     * Allows multiple uses if needed
#     * Prevents confusion if error reoccurs
#   - IMPROVED: Force button behavior more intuitive
#     * Logs when clicked (for debugging)
#     * Only removes when modal closes
#     * User can click multiple times safely
# v12.8 CHANGELOG - PHASE 1 (MIS VALIDATION SYSTEM - REBATE TYPE):
#   - NEW: MIS Creation Modal Validation System
#     * Automatically monitors when MIS creation modal is open
#     * CRITICAL validation: Rebate Type must not be "- Select -"
#     * RED box with tooltip around Rebate Type field when invalid
#     * Save button automatically hidden when validation fails
#     * Clear error message explaining the issue
#   - NEW: Force Show Save safety button
#     * Floating button (top-left) to override validation if needed
#     * Prevents soft-lock if validation glitches
#     * Removes itself after use
#   - NEW: Validation injection system
#     * JavaScript injected after automation fills form
#     * Monitors modal open/close state
#     * Validates on 500ms interval (no performance impact)
#     * Console logging for debugging
#   - NEW: Manual validation endpoint (/api/mis/inject-validation)
#     * Can be triggered independently for manual entries
#     * Enables validation without running automation
#   - IMPROVED: Prevents saving with blank Rebate Type
#     * Applies to both automation AND manual entries
#     * Visual feedback (RED box, tooltip, error message)
#     * Non-intrusive (doesn't block field interaction)
#   - PHASE 2 READY: Architecture supports full field validation
#     * Current: Rebate Type only (critical error)
#     * Future: All fields compared against Google Sheet
#     * Future: ORANGE boxes for mismatches, dates validation
# v12.7.3 CHANGELOG (SIMPLIFIED NAVIGATION):
#   - FIXED: Removed unreliable button detection completely
#   - ENHANCED: Direct navigation to creation URL
#     * URL: https://retail.blaze.me/company-promotions/promotions/add#promotion-type
#     * This URL automatically opens the discount creation interface
#     * Bypasses need to find and click "Add Company Promotions" button
#   - ENHANCED: Validates page load by waiting for discount type options
#     * Waits for BOGO/Bundle/Global/Collection buttons to appear
#     * Confirms creation interface loaded successfully
#     * More reliable than button detection
#   - IMPROVED: Cleaner, simpler, more maintainable code
#   - IMPROVED: Faster automation (no button search delays)
# v12.7.2 CHANGELOG (SMART NAVIGATION + ROBUST BUTTON SELECTOR):
#   - ENHANCED: Smart page detection before navigation
#     * Checks if already on promotions page with valid URL patterns:
#       - https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=25
#       - https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=50
#       - https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=100
#     * Verifies "Add Company Promotions" button is visible
#     * Skips navigation if both conditions met (saves time)
#   - ENHANCED: Robust button selector for "Add Company Promotions"
#     * Primary selector: Matches MUI classes + text (handles React rendering)
#     * Fallback selector: Simple text match (if primary fails)
#     * Better error messages for debugging
#     * Handles multiple HTML structures
#   - IMPROVED: Logging clarity for navigation and button detection
# v12.7.1 CHANGELOG (BUGFIX):
#   - FIXED: Title suggestions dropdown in Create popup now closes properly
#     * Closes when clicking outside the input field
#     * Closes when tabbing to another field
#     * Closes when clicking on another part of the form
#     * Uses 150ms delay to ensure click events on suggestions register first
#   - Added: hideTitleSuggestions() helper function
#   - Added: onblur handler to title input field
# v12.7 CHANGELOG (CREATE BLAZE AUTOMATION + ENHANCED UX):
#   - NEW: Auto-load existing Blaze selections from Google Sheet
#     * When opening modal, parses "Blaze Discount Title" column
#     * Validates titles against Blaze promotions
#     * Found titles ‚Üí Added to queue normally
#     * Not found titles ‚Üí Added with ‚ö†Ô∏è warning icon, grayed out, [Create] button
#     * Not found items are removable with red [X] button
#   - NEW: [View] button on all queue, suggestion, and library items
#     * Opens existing detail modal (showDetailModal)
#     * Shows full discount details without leaving page
#   - NEW: Enhanced hover tooltips (FUTURE - PLACEHOLDER)
#     * Will show detail info + value calculations per store
#     * Currently uses existing tooltip behavior
#   - NEW: [Create] button in modal header (next to Locations)
#     * Opens creation popup form
#     * Title field: Empty with suggested variations dropdown
#     * Type dropdown: Manual selection with auto-detected suggestion text
#     * Description: Manual entry with [Autofill] button
#     * Autofill fills: Brand, Type, Value, Locations, Creation Date+Time
#   - NEW: Blaze creation automation (/api/blaze/create-discount)
#     * Switches to/opens Blaze browser tab
#     * Logs in if needed using credentials from setup
#     * Navigates to company-promotions page
#     * Clicks "Add Company Promotions" button
#     * Selects discount type from dropdown (Bundle/BOGO/Global/Collection)
#     * Fills title field
#     * PAUSES for manual completion (dates, products, locations, etc.)
#     * Future enhancement: Auto-fill remaining fields
#   - NEW: Duplicate name detection
#     * Before creating, checks if name exists in Blaze
#     * If exists: Prompt user to select existing OR continue with modified name
#     * Modified name: User can add note/suffix (e.g., "v2", "2025")
#   - NEW: Title input with undo functionality
#     * Click input ‚Üí Shows suggested title variations
#     * Type freely ‚Üí Can still select suggestions
#     * Select suggestion after typing ‚Üí [Undo] button appears
#     * Click [Undo] ‚Üí Reverts to typed text
#   - NEW: Sheet write enhancement for not-found items
#     * Writes: "Title Name (NOTE: Needs to be created)"
#     * Red text only on "(NOTE: Needs to be created)" portion
#     * Rest of title remains normal color
#   - ENHANCED: Queue now shows [Create] button for not-found items
#     * Click [Create] ‚Üí Opens creation modal with title pre-filled
#   - ENHANCED: Suggestions/Library items now have [View] buttons
#     * Non-intrusive placement
#     * Maintains checkbox click functionality
# v12.6 CHANGELOG (UX ENHANCEMENTS + CRITICAL BUG FIX):
#   - CRITICAL BUGFIX: OK button no longer clears Blaze Discount selections
#     * approveSingleMatch() now preserves existing blaze_titles array
#     * Both multi-brand and first-approval cases updated
#     * User can now approve MIS IDs without losing Blaze discount selections
#   - NEW: Collapsible Weekday Headers in Breakdown List (default: collapsed)
#     * Cleaner view - weekday sections start collapsed
#     * Click weekday header to expand/collapse
#     * Shows deal count even when collapsed
#   - NEW: Pink Multi-Day Reference sections (default: collapsed)
#     * Multi-day deal references now have PINK background (#ffe6f0)
#     * Collapsed by default showing "Multi Day Deals Present: [brands]"
#     * Click to expand and see full reference rows
#     * Helps reduce clutter in Breakdown view
#   - ENHANCED: Scrollable Queue in Blaze Modal
#     * Queue section now scrolls after 2 visible rows
#     * Header shows counter: "Selected Queue (X items)"
#     * Prevents modal from becoming too tall
#   - ENHANCED: Full Library section now collapsible (default: collapsed)
#     * Click "Full Library" header to expand/collapse
#     * Starts collapsed to reduce initial modal height
#   - FIXED: Filter dropdown now strictly filters by brand name
#     * All filter options (NONE/BOGO/B2G1/BULK) respect brand name + alternates
#     * No more irrelevant promotions appearing in filtered results
# v12.5 CHANGELOG (BLAZE DISCOUNT TITLE INTEGRATION + BUG FIX):
#   - BUGFIX: Breakdown view now preserves Monthly and Sale sections
#     * Previously, switching to Breakdown mode deleted non-weekly rows
#     * Now saves monthly/sale rows before rebuild, re-appends after
#   - NEW: Blaze Discount Title selection in ID Matcher
#     * Blue "Blaze" button added to Actions column for each row
#     * Opens modal popup for selecting Blaze discounts to link to Google Sheet row
#     * Modal shows current row details, suggested matches, and full library
#     * Suggested matches scored by brand name appearing in Blaze promo title
#     * Full library searchable by name with status filter (All/Active/Inactive)
#     * Drag-and-drop queue to order selected titles
#     * Multiple discounts can be linked to single sheet row
#     * Auto-fetches Blaze data if not already synced (shows loading spinner)
#   - NEW: Suggestion filter dropdown (NONE/BOGO/B2G1/BULK)
#     * NONE: Default, shows all brand matches
#     * BOGO: Filters to titles containing "BOGO"
#     * B2G1: Filters to titles containing "B2G1"
#     * BULK: Filters to bulk patterns (Bulk, Mix & Match, X for $Y)
#   - NEW: Alternate Brand Names input
#     * Add alternate spellings/variations of brand name
#     * Expands suggestion search to include alternates
#     * Tags display with remove button
#   - NEW: Status filter for Full Library (All/Active/Inactive)
#   - REMOVED: 10 suggestion limit - now shows ALL matching suggestions
#   - NEW: Three separate Apply buttons in ID Matcher
#     * "Apply MIS IDs" - Only writes MIS IDs to Google Sheet
#     * "Apply Blaze Titles" - Only writes Blaze Discount Titles to sheet
#     * "Apply All" - Writes both MIS IDs and Blaze Titles
#   - NEW: Blaze Discount Title column support
#     * Auto-detects "Blaze Discount Title" column in Google Sheet
#     * Writes newline-separated titles preserving queue order
#     * Supports editing existing values before applying
#   - VISUAL: Smaller Approve/Deny buttons to fit Blaze button
#     * Approve/Deny buttons now use compact styling
#     * Blaze button shows blue outline when empty, solid blue with count when selected
#   - ENHANCED: approvedMatches now tracks both MIS IDs and Blaze titles
#     * Format: {mis_ids: [...], brands: [...], blaze_titles: [...], section: '...'}
#     * Approve/Deny buttons affect both MIS and Blaze selections
#   - NEW: /api/mis/apply-blaze-titles endpoint
#     * Writes Blaze titles to Google Sheet "Blaze Discount Title" column
#     * Preserves order from selection queue
# v12.4 CHANGELOG (MULTI-DAY REFERENCE SYSTEM):
#   - NEW: Multi-day deals now show yellow reference rows on subsequent weekdays
#     * First weekday: Full group with all members (yellow background)
#     * Subsequent weekdays: Yellow reference rows showing ONLY members for that day
#     * Yellow rows have "First instance: Monday" in Notes column
#     * Yellow row buttons (not purple) for better differentiation
#     * Orange border (#ff9800) around entire group of reference rows
#     * Reference rows appear BEFORE regular deals in each weekday section
#   - NEW: Header notes for multi-day deals
#     * Format: [Rows] Brand - D: X% V: Y% Mon, Thu
#     * Appears on ALL weekdays where the multi-day deal runs
#     * [Rows] button opens dropdown with brand-specific row buttons
#     * Multi-brand deals show "Terra...+" with full brand list in dropdown
#     * Dropdown format: "Terra [Row 10 Mon] [Row 15 Wed] [Row 20 Fri]"
#     * Notes stacked vertically for easier reading
#   - VISUAL: Weekday headers now have BRIGHT CYAN background (#00ffff)
#     * Dark blue text (#003366) for better contrast
#     * Brands list stacked vertically (numbered list)
#     * Notes stacked vertically (one per line)
#     * Stand out more clearly from deal rows
#   - LOGIC: Multi-day detection now collects ALL unique weekdays from ALL member rows
#     * Handles complex groups where members have different weekdays
#     * Correctly identifies Monday + Thursday groups even with 2+ brands
#     * Sorts weekdays in calendar order (Mon √¢‚Ä†‚Äô Sun)
#   - FIXED: Deal count now includes yellow reference rows
#     * Monday shows: 21 deals (includes groups + singles)
#     * Thursday shows: 15 deals (includes yellow refs + regular deals)
# v12.3 CHANGELOG (MULTI-DAY GROUP FIXES):
#   - FIXED: Multi-day group deals now appear correctly in Breakdown List
#     * Group headers only have 1 cell (expand/collapse button)
#     * BUG: Cell count check (cells.length <= 3) ran BEFORE weekday extraction
#     * Result: All group headers exited early with "Not enough cells" error
#     * Solution: Move cell count check INSIDE single row branch only
#     * Group headers now: Extract groupId √¢‚Ä†‚Äô Find members √¢‚Ä†‚Äô Get weekday from first member
#     * Single rows now: Check cell count √¢‚Ä†‚Äô Get weekday from row
#     * Multi-day groups appear under first weekday with all members
#     * Notes appear on subsequent weekdays with clickable row buttons
#   - FIXED: Case sensitivity bug (MONDAY vs Monday)
#     * Weekday text from cells is all caps: "MONDAY", "TUESDAY", etc.
#     * Bucket keys are proper case: "Monday", "Tuesday", etc.
#     * Solution: Normalize all weekday text to proper case before lookup
#   - FIXED: Full List not accessible after Breakdown
#     * Breakdown clears tbody, destroying original rows
#     * Solution: Save originalTableState on first breakdown trigger
#     * Full List restores from saved state
# v12.2 CHANGELOG (WEEKDAY BREAKDOWN LIST):
#   - NEW: Weekly Deals Breakdown List View
#     * Toggle between "Full List" (original) and "Breakdown List" (organized by weekday)
#     * Breakdown List organizes deals by weekday sections (Monday √¢‚Ä†‚Äô Sunday)
#     * Each weekday header shows: deal count, brands list (tooltip), multi-day notes
#     * Multi-day deals: Full group appears under first weekday only
#     * Other weekdays show notes with clickable row buttons
#     * Single-day deals appear under their respective weekday
#     * Larger weekday text (1.4em) for better visibility
#   - SIMPLIFIED APPROACH: Breakdown reads from Full List (live tbody)
#     * Full List renders normally first (always works)
#     * Breakdown List reorganizes visible rows from live tbody
#     * No master cache - works directly with existing rendered rows
#     * filterMatchResultsBySection triggers breakdown with 50ms delay
#     * Extensive console logging added for debugging
# v12.2 CHANGELOG (CONTINUE ELIGIBILITY FIX):
#   - FIXED: ID Matcher Continue/Recycle eligibility now handles unparseable tab names gracefully
#     * Added cannotDetermineDate flag to checkContinueEligibility()
#     * When tab name can't be parsed √¢‚Ä†‚Äô shows "? UNDETERMINED" instead of "NEW ENTRY"
#     * No longer adds "Cannot parse tab name for date" to mismatches list
#     * Prevents false "NEW ENTRY" when tab name format is non-standard
#     * Only calculates new end date when tab can be successfully parsed
# v12.1 CHANGELOG (MAUDIT + MULTI-BRAND SUPPORT):
#   - NEW: goToSheetRow() function - Click row number to open Google Sheet at that row
#   - NEW: window.globalSpreadsheetId - Stores spreadsheet ID for navigation
#   - NEW: /api/mis/load-sheet now returns spreadsheet_id
#   - NEW: autoSyncBlazeData() - Auto-syncs Blaze Company Promotions on startup if token exists
#   - NEW: MAudit Tab - Verify Google Sheet deals against MIS CSV
#     * Subtabs: "ID Matcher" and "Google > MAudit" under ID Matcher section
#     * /api/mis/maudit endpoint for verification
#     * Compares: Discount, Vendor %, Start/End Dates, Brand, Locations
#     * Groups results: Verified, Mismatches, Not Found, Missing MIS ID
#     * Clickable row numbers (goToSheetRow) and MIS IDs (lookupMisId)
#   - NEW: Multi-Brand Helper Functions
#     * parse_multi_brand() - Parses "Brand A, Brand B" into list
#     * is_multi_brand() - Detects multi-brand rows
#     * get_brand_from_mis_id() - CSV lookup for brand ownership
#     * match_mis_ids_to_brands() - Maps MIS IDs to brands
#     * format_brand_mis_ids() - Formats tagged IDs back to string
#   - NEW: parse_mis_id_cell() all_tagged field
#     * Captures ALL (tag, id) pairs in order including duplicates
#     * Supports multi-brand with duplicate tags: W1: 12345, W1: 67890
#   - NEW: ID Matcher Multi-Brand Display
#     * Each brand in multi-brand rows gets separate entry
#     * Visual badge shows brand index (e.g., "1/2", "2/2")
#     * Dashed border separates multi-brand entries
#     * current_sheet_id shows only this brand's MIS IDs
#     * enhanced_match_mis_ids() creates separate matches per brand
#   - NEW: ID Matcher Clickable MIS ID Tags
#     * Current ID column shows [W1: 12345] [W2: 67890] buttons
#     * Tags displayed in small gray text, ID in bold
#     * Matching IDs get green border, non-matching get gray
#     * Each button calls lookupMisId() to search MIS browser
# v12 CHANGELOG (TAB RESTRUCTURE + MULTI-ACCOUNT):
#   - Renamed "MIS" main tab to "Audit"
#   - Renamed "CSV Generator - Google Sheet" to "Creation Checklist"
#   - Renamed "Split Audit" to "Up-Down Planning"
#   - Removed "Google Sheet - Audit" sub-tab (no longer needed)
#   - Removed "Audit Google Sheet vs MIS .CSV" sub-tab (no longer needed)
#   - Reordered sub-tabs: Creation Checklist, ID Matcher, Up-Down Planning, Conflict Audit
#   - Replaced corrupted emoji characters with [EMOJI] placeholder
#   - NEW: Multi-Account System with GUI profile management
#     * Profile dropdown in header (Google Chrome colors)
#     * Auto-loads last used profile on startup (no CMD menu)
#     * "Register New Profile" modal with step-by-step wizard
#     * First-run modal prompts to register when no profiles exist
#     * Profile switching with restart banner
#     * "Restart Now" button for seamless profile changes
#   - NEW: Profile API endpoints:
#     * /api/profiles - List all profiles
#     * /api/profile/current - Get active profile
#     * /api/profile/switch - Switch profile (requires restart)
#     * /api/profile/register - Register new profile
#     * /api/profile/check-credentials/<handle> - Check credentials file
#     * /api/restart - Restart application
#   - NEW: Reorganized folder structure:
#     * config/google_credentials/ - OAuth JSON files
#     * config/tokens/ - Google auth tokens per profile
#     * config/blaze_configs/ - MIS/Blaze credentials per profile
#     * config/last_profile.json - Remembers last used profile
#     * chrome_profiles/ - Isolated browser profiles
#     * reports/ - All report outputs
#   - NEW: Enhanced Help modal with tabs:
#     * Troubleshooting tab with common fixes
#     * New Account Setup tab with step-by-step guide
#     * Folder Structure tab with directory layout
# v10.9 CHANGELOG (ID MATCHER SECTION-AWARE TAGS):
#   - ID MATCHER now uses section-aware tags (W1, M1, S1) instead of "Part 1:"
#   - enhanced_match_mis_ids(): Added 'section' field to each match object
#   - Frontend approveSingleMatch(): Now stores {mis_id, section} for each approval
#   - /api/mis/apply-matches: Updated to detect section and use correct tag prefix
#     * Weekly deals √É∆í√Ç¬¢√É¬¢√¢‚Äö¬¨√Ç¬†√É¬¢√¢‚Äö¬¨√¢‚Äû¬¢ W1:
#     * Monthly deals √É∆í√Ç¬¢√É¬¢√¢‚Äö¬¨√Ç¬†√É¬¢√¢‚Äö¬¨√¢‚Äû¬¢ M1:
#     * Sale deals √É∆í√Ç¬¢√É¬¢√¢‚Äö¬¨√Ç¬†√É¬¢√¢‚Äö¬¨√¢‚Äû¬¢ S1:
#   - /api/mis/apply-split-id: Updated to use section-based tags
#     * Accepts 'section' parameter to determine prefix
#     * Converts legacy tags (part1, part2, gap, patch) to new format
#   - Backward compatible: Legacy format (just MIS ID string) defaults to weekly
# v10.8.1 CHANGELOG (REGEX-BASED PARSING FIX):
#   - FIXED: Phase 2 not finding Original/Continuation MIS IDs
#   - Root cause: Google Sheets may return newlines as literal '\n' strings
#     which broke the line-by-line parsing
#   - Solution: Rewrote parse_mis_id_cell() to use regex patterns
#     * Finds W1:, W2:, WP:, M1:, M2:, MP:, S1:, S2:, SP: anywhere in text
#     * Works regardless of separator (newlines, commas, spaces, literal \n)
#   - Added extensive debug output: [PARSE] prefix in console logs
#   - Handles edge cases: W1 at position 1, W2 at position 2, etc.
#   - Backward compatible with legacy Part 1/Part 2/GAP/Patch format
# v10.8 CHANGELOG (SECTION-BASED TAG FORMAT):
#   - NEW TAG FORMAT: Section-based prefixes replace old Part/GAP/Patch
#     * Weekly: W1 (Original), W2 (Cont.), WP (Patch)
#     * Monthly: M1 (Original), M2 (Cont.), MP (Patch)
#     * Sale: S1 (Original), S2 (Cont.), SP (Patch)
#   - parse_mis_id_cell(): Rewritten to parse new format
#     * Returns: {weekly: {parts: [], patch: null}, monthly: {...}, sale: {...}}
#     * Backward compatible with legacy Part 1/Part 2/GAP/Patch format
#   - format_tagged_mis_cell(): Section-aware formatting
#   - update_tagged_mis_cell(): Supports w1, w2, wp, m1, m2, mp, s1, s2, sp tags
#   - formatActionLabel(): Dynamic labels based on section
#     * CREATE_PART1 [EMOJI] "Weekly (Original)" / "Monthly (Original)" / "Sale (Original)"
#     * GAP [EMOJI] Shows interrupting section name ("Monthly" / "Sale")
#     * CREATE_PART2 [EMOJI] "Weekly (Cont.)" / "Monthly (Cont.)" / "Sale (Cont.)"
#     * PATCH [EMOJI] "Weekly (Patch)" / "Monthly (Patch)" / "Sale (Patch)"
#   - Phase 1 display: Updated to use section-based IDs and labels
#   - Phase 2 verification: Uses section-aware MIS ID lookup
#   - Split data now includes 'section' field (weekly/monthly/sale)
#   - Interrupting deal MIS ID now pulled from its own row correctly
# v10.7 CHANGELOG (CRITICAL BUG FIXES):
#   - Issue 1 FIX: Disabled auto-sync Blaze on browser ready (was crashing browser)
#     * checkBrowserStatus() no longer calls fetchBlazeData(true) automatically
#     * User must manually click Initialize or Sync buttons
#   - Issue 2 FIX: Pull MIS CSV debugging enhanced
#     * Added more console output for debugging
#   - Issue 3 FIX: Added MIS Reports folder access
#     * New button to open MIS Reports folder in file explorer
#     * Shows folder path in Setup tab for easy reference
#     * API endpoints: /api/get-mis-reports-folder, /api/open-mis-reports-folder
#   - Issue 4 FIX: Phase 2 verification improvements
#     * find_mis_entry_by_id() now tries multiple ID column names
#     * Calls strip_mis_id_tag() to remove prefixes before lookup
#     * Added extensive debug output to console for troubleshooting
#     * Shows parsed MIS IDs in console for verification
# v10.6 CHANGELOG (PHASE 1/2 IMPROVEMENTS):
#   - Location NaN handling: compare_deal_attributes() now treats
#     NaN/empty/blank as "All Locations" for matching
#   - Phase 2 improvements:
#     * MIS ID column now shows clickable buttons with automation
#     * Actual (CSV) column shows tooltip with suggestions when missing
#     * Suggestion confidence colors: green 80%+, yellow 60%+, gray below
#   - Phase 1 Part 1/Part 2 assignment fix:
#     * Backend now includes parsed_mis_ids in split data
#     * Frontend correctly shows Part 1 ID for Part 1 row
#     * Part 2 row shows existing Part 2 ID (if present) or input field
#     * Same for GAP and PATCH - shows existing or input
#     * Approve/Apply buttons hidden when ID already exists (shows "Done")
# v10.5 CHANGELOG (MIS ID BROWSER FIX + AUDIT TAB FIX):
#   - MIS ID Browser Lookup: Now strips tag prefixes before searching
#     * api_mis_lookup_mis_id: Calls strip_mis_id_tag() before search
#     * api_mis_review_discrepancy: Also strips tags
#     * renderClickableMisId(): Handles newline format, strips tags for lookup
#     * renderMisIdCell(): Same updates for consistency
#   - Audit Tab Sheet Selection: Now uses current dropdown value
#     * runAudit(): Uses document.getElementById('mis-tab').value
#     * No longer relies on stale misData.tabName
#     * Added validation for empty tab selection
# v10.4 CHANGELOG (VALUE NORMALIZATION + EMOJI FIX):
#   - compare_deal_attributes(): Improved normalize_numeric_value()
#     * Handles '50%' vs '50' comparison correctly
#     * Strips 'off', 'discount' text from values
#     * Converts decimal percentages (0.50 -> 50)
#     * Added values_match() helper with tolerance
#   - Fixed all corrupted emoji characters throughout script
#     * Replaced with HTML entities or ASCII equivalents
#     * [OK] for checkmarks, [X] for errors, [!] for warnings
# v10.3 CHANGELOG (TAGGED MIS ID FORMAT):
#   - New tagged format: "Part 1: 12345\nGAP: 67890\nPart 2: 54321"
#   - parse_mis_id_cell() - Now returns 'parts', 'gaps', 'patches' as lists
#   - format_tagged_mis_cell() - Format IDs into tagged newline format
#   - update_tagged_mis_cell() - Smart merge: update tag while preserving others
#   - strip_mis_id_tag() - Strip tag prefix for display/lookup
#   - /api/mis/apply-split-id - Now accepts 'tag' param (part1, part2, gap, patch)
#   - /api/mis/apply-matches - Uses "Part 1:" tag, preserves existing content
#   - Frontend Apply buttons now send tag parameter
#   - Phase 2 verification updated for list-based parsed_ids
#   - GAP MIS ID auto-pulls from interrupting Tier 1 deal's row
#   - Backward compatible with old comma-separated format
# v10.2 CHANGELOG (PHASE 2 CSV FIX):
#   - Fixed pullMisCsvForPhase2() - now uses correct endpoint /api/mis/pull-csv
#   - Added updatePhase2CsvStatus() - syncs CSV status when switching to Phase 2
#   - Backend: Added local_csv_path check in final-check endpoint
#   - Frontend: Added pulledCSVPath fallback in runPhase2FinalCheck()
#   - Phase 2 now properly recognizes CSV loaded from Setup tab
# v10.1 CHANGELOG (PHASE 2 FINAL VERIFICATION):
#   - Added Phase 2: Final Verification tab (replaces Gap Check)
#   - Backend: parse_mis_id_cell() - Parse MIS IDs with Gap:/Patch: prefixes
#   - Backend: find_mis_entry_by_id() - Find deals in CSV by ID
#   - Backend: compare_deal_attributes() - Compare expected vs actual
#   - Backend: generate_fuzzy_suggestions() - Fallback matching when ID missing
#   - Backend: /api/mis/split-audit/final-check endpoint
#   - Frontend: runPhase2FinalCheck(), renderPhase2Results()
#   - Frontend: Fuzzy suggestion selection and approval workflow
#   - Removed Phase 3 tab (consolidated into Phase 2)
# v94 CHANGELOG (LOCATION-AWARE CONFLICT DETECTION + PATCH):
#   - Added location-aware conflict detection with store name normalization
#   - Implemented PATCH entries for partial location conflicts
#   - PATCH maintains weekly deal at non-conflicting stores during conflict
#   - Handles "All Locations", "All Locations Except:", and specific store lists
#   - Added approvePatchId() and applyPatchIdToSheet() functions
#   - Changed Conflict Deal header from yellow to RED (text-danger)
#   - Fixed column widths across all three tables (Weekly/Conflict/MIS Entry Plan)
#   - Tables now use table-layout:fixed for consistent alignment
# # v93 CHANGELOG (STABLE REBUILD):
#   - Rebuilt from V33 (last known working version)
#   - Applied ONLY backend MIS ID changes (safe Python code)
#   - NO JavaScript changes - all buttons working
#   - Emojis intact from V33
# v89 CHANGELOG (EMOJI FIX + VERIFICATION):
#   - All corrupted emojis fixed using safe character-level replacement
#   - All Phase 1 enhancements verified present and working
#   - No structural changes to preserve button/file functionality
# v88 CHANGELOG (ID MATCHER FIX + SPLIT AUDIT ENHANCEMENTS):
#   FIX: ID MATCHER - Approval now works for Sale and Monthly sections (not just Weekly)
#     - Fixed global indexing issue where approvedMatches failed for non-Weekly sections
#   ENHANCED: Split Audit Phase 1 - Conflict Groups now show additional columns:
#     - Discount Value, Vendor %, Location columns added to conflict group display
#     - MIS IDs are now clickable buttons (triggers lookupMisId like ID MATCHER)
#   ENHANCED: Split Audit Phase 1 - Part 2 MIS ID Entry:
#     - Green checkmark "Approve" button for Part 2 MIS ID input
#     - "Apply" button writes MIS ID to Google Sheet (appends comma-separated if existing)
#   ENHANCED: Split Audit Phase 1 - Clean Deals section:
#     - Now shows full column layout matching ID MATCHER tab
#     - Includes: Row, Brand, Weekday, Notes, Deal Info, Discount, Vendor %, Locations, Categories, MIS ID
# v87 (Previous): LOGIC GAP & SPLIT AUDIT
# v86 (Previous): DATE-AWARE CONFLICT DETECTION
# v85 (Previous): Google Sheet - Audit tab (pre-flight check)
# v84 (Previous): Sub-tabs for deal types in CSV Generator, ID Matcher, Audit, Conflict tabs
# Dependencies: pip install flask pandas google-auth google-auth-oauthlib google-api-python-client fuzzywuzzy python-Levenshtein openpyxl selenium undetected-chromedriver requests python-docx --break-system-packages




import os
import sys
import json
import socket
import time
import glob
import threading
import traceback
import urllib.parse as urlparse
import subprocess
import re
import hashlib
import zipfile
from pathlib import Path
from datetime import datetime, timedelta, date
from typing import Dict, List, Optional, Tuple, Any

# ============================================================================
# DEPENDENCY MANAGEMENT
# ============================================================================
def check_network() -> bool:
    try:
        socket.create_connection(("8.8.8.8", 53), timeout=3)
        return True
    except OSError:
        return False

def install_dependencies():
    required = {
        'flask': 'flask',
        'pandas': 'pandas',
        'google.auth': 'google-auth',
        'google_auth_oauthlib': 'google-auth-oauthlib',
        'googleapiclient': 'google-api-python-client',
        'fuzzywuzzy': 'fuzzywuzzy',
        'openpyxl': 'openpyxl',
        'selenium': 'selenium',
        'undetected_chromedriver': 'undetected-chromedriver',
        'requests': 'requests',
        'docx': 'python-docx'
    }
    
    missing = []
    print("[CHECK] Checking dependencies...")
    
    for import_name, pkg_name in required.items():
        try:
            __import__(import_name)
        except ImportError:
            missing.append(pkg_name)
    
    if missing:
        print(f"[INSTALL] Missing packages: {', '.join(missing)}")
        print(f"[INSTALL] Attempting auto-install...")
        
        try:
            # Try installing with --break-system-packages (for newer pip)
            subprocess.check_call(
                [sys.executable, "-m", "pip", "install"] + missing + ["--break-system-packages"]
            )
            print("[SUCCESS] Installation complete!")
        except subprocess.CalledProcessError:
            # Try without --break-system-packages (for older pip or venv)
            try:
                subprocess.check_call(
                    [sys.executable, "-m", "pip", "install"] + missing
                )
                print("[SUCCESS] Installation complete!")
            except subprocess.CalledProcessError as e:
                print(f"[ERROR] Auto-install failed. Please install manually:")
                print(f"pip install {' '.join(missing)}")
                input("Press Enter to exit...")
                sys.exit(1)

try:
    install_dependencies()
except Exception as e:
    print(f"[CRITICAL ERROR] {e}")
    traceback.print_exc()
    input("Press Enter to exit...")
    sys.exit(1)


# ============================================================================
# WINDOWS CONSOLE UTF-8 FIX
# ============================================================================
# Force UTF-8 encoding for Windows consoles to prevent mojibake
if sys.platform.startswith('win'):
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# ============================================================================
# SELF-INITIALIZATION & MULTI-ACCOUNT SYSTEM
# ============================================================================
BASE_DIR = Path(__file__).resolve().parent.parent

# Directory structure for multi-account support
CONFIG_DIR = BASE_DIR / 'config'
GOOGLE_CREDS_DIR = CONFIG_DIR / 'google_credentials'
TOKENS_DIR = CONFIG_DIR / 'tokens'
BLAZE_CONFIGS_DIR = CONFIG_DIR / 'blaze_configs'
CHROME_PROFILES_DIR = BASE_DIR / 'chrome_profiles'
REPORTS_DIR = BASE_DIR / 'reports'

# Template for blaze config
BLAZE_CONFIG_TEMPLATE = {
    "mis_username": "",
    "mis_password": "",
    "blaze_email": "",
    "blaze_password": "",
    "default_spreadsheet_id": "",
    "notes": "Fill in your MIS and Blaze credentials here"
}

def setup_environment():
    """
    Self-initialization: Create required directory structure and template files.
    Called on every startup to ensure environment is ready.
    """
    print("="*70)
    print("[INIT] Checking environment setup...")
    
    # Create all required directories
    directories = [
        CONFIG_DIR,
        GOOGLE_CREDS_DIR,
        TOKENS_DIR,
        BLAZE_CONFIGS_DIR,
        CHROME_PROFILES_DIR,
        REPORTS_DIR,
        REPORTS_DIR / 'MIS_CSV_REPORTS',
        REPORTS_DIR / 'BLAZE_CSV_REPORTS',
        REPORTS_DIR / 'BLAZE_CSV_REPORTS' / 'INVENTORY'
    ]
    
    created_dirs = []
    for dir_path in directories:
        if not dir_path.exists():
            dir_path.mkdir(parents=True, exist_ok=True)
            created_dirs.append(str(dir_path.relative_to(BASE_DIR)))
    
    if created_dirs:
        print(f"[INIT] Created directories: {', '.join(created_dirs)}")
    else:
        print("[INIT] All directories present.")
    
    # Create template blaze config if configs folder is empty
    template_file = BLAZE_CONFIGS_DIR / 'template_blaze_config.json'
    existing_configs = list(BLAZE_CONFIGS_DIR.glob('*.json'))
    
    if not existing_configs:
        with open(template_file, 'w') as f:
            json.dump(BLAZE_CONFIG_TEMPLATE, f, indent=4)
        print(f"[INIT] Created template config: {template_file.relative_to(BASE_DIR)}")
    
    print("[INIT] Environment ready.")
    print("="*70)

def get_available_profiles() -> list:
    """
    Scan tokens directory to find existing profiles.
    Returns list of email handles (e.g., ['john.doe', 'jane.smith'])
    """
    profiles = []
    if TOKENS_DIR.exists():
        for token_file in TOKENS_DIR.glob('token_*.json'):
            # Extract handle from "token_john.doe.json" -> "john.doe"
            handle = token_file.stem.replace('token_', '')
            if handle:
                profiles.append(handle)
    return sorted(profiles)

def check_credentials_for_handle(handle: str) -> bool:
    """Check if credentials file exists for the given handle."""
    creds_file = GOOGLE_CREDS_DIR / f'credentials_{handle}.json'
    return creds_file.exists()

def wait_for_credentials(handle: str):
    """Wait for user to place credentials file in the correct location."""
    creds_file = GOOGLE_CREDS_DIR / f'credentials_{handle}.json'
    
    print("\n" + "="*70)
    print(f"[SETUP] Credentials file not found for '{handle}'")
    print("="*70)
    print(f"\nPlease complete these steps:")
    print(f"  1. Download your OAuth JSON from Google Cloud Console")
    print(f"  2. Rename it to: credentials_{handle}.json")
    print(f"  3. Place it in: {GOOGLE_CREDS_DIR.relative_to(BASE_DIR)}/")
    print(f"\nExpected path: {creds_file.relative_to(BASE_DIR)}")
    print("="*70)
    return False

def get_last_used_profile() -> str:
    """Read last used profile from config file."""
    last_profile_file = CONFIG_DIR / 'last_profile.json'
    if last_profile_file.exists():
        try:
            with open(last_profile_file, 'r') as f:
                data = json.load(f)
                return data.get('last_profile', '')
        except:
            pass
    return ''

def save_last_used_profile(handle: str):
    """Save last used profile to config file."""
    last_profile_file = CONFIG_DIR / 'last_profile.json'
    try:
        with open(last_profile_file, 'w') as f:
            json.dump({'last_profile': handle}, f)
    except Exception as e:
        print(f"[WARN] Could not save last profile: {e}")

def auto_select_profile() -> dict:
    """
    Auto-select profile on startup (no interactive menu).
    Priority: last_profile.json > first available > None (first-run mode)
    """
    profiles = get_available_profiles()
    
    # Try last used profile
    last_profile = get_last_used_profile()
    if last_profile and last_profile in profiles:
        if check_credentials_for_handle(last_profile):
            print(f"[PROFILE] Auto-loaded last used profile: {last_profile}")
            save_last_used_profile(last_profile)
            return build_profile_config(last_profile)
    
    # Try first available profile with valid credentials
    for profile in profiles:
        if check_credentials_for_handle(profile):
            print(f"[PROFILE] Auto-loaded first available profile: {profile}")
            save_last_used_profile(profile)
            return build_profile_config(profile)
    
    # No valid profiles - first-run mode
    print("[PROFILE] No profiles found - running in first-run mode")
    print("[PROFILE] Please register a profile via the web interface")
    return {
        'handle': None,
        'credentials_file': None,
        'token_file': None,
        'blaze_config_file': None,
        'chrome_profile_dir': CHROME_PROFILES_DIR / 'chrome_default',
    }

def register_profile_api(handle: str) -> dict:
    """
    Register a new profile (called from API).
    Returns dict with success status and message.
    """
    import re
    
    # Validate handle
    handle = handle.strip().lower()
    if not handle:
        return {'success': False, 'error': 'Handle cannot be empty'}
    
    if not re.match(r'^[a-z0-9._-]+$', handle):
        return {'success': False, 'error': 'Handle can only contain: letters, numbers, dots, underscores, hyphens'}
    
    # Check if profile already exists
    existing = get_available_profiles()
    if handle in existing:
        return {'success': False, 'error': f'Profile "{handle}" already exists'}
    
    # Check for credentials file
    if not check_credentials_for_handle(handle):
        return {
            'success': False, 
            'error': 'credentials_not_found',
            'expected_path': str(GOOGLE_CREDS_DIR / f'credentials_{handle}.json')
        }
    
    # Create placeholder blaze config
    config_file = BLAZE_CONFIGS_DIR / f'blaze_config_{handle}.json'
    if not config_file.exists():
        with open(config_file, 'w') as f:
            config = BLAZE_CONFIG_TEMPLATE.copy()
            config['profile_handle'] = handle
            json.dump(config, f, indent=4)
    
    # Create empty token file to register the profile
    token_file = TOKENS_DIR / f'token_{handle}.json'
    if not token_file.exists():
        with open(token_file, 'w') as f:
            json.dump({}, f)
    
    return {'success': True, 'message': f'Profile "{handle}" registered successfully'}

def build_profile_config(handle: str) -> dict:
    """
    Build configuration paths for a given profile handle.
    Returns dict with all paths needed for the profile.
    """
    if handle is None:
        return {
            'handle': None,
            'credentials_file': None,
            'token_file': None,
            'blaze_config_file': None,
            'chrome_profile_dir': CHROME_PROFILES_DIR / 'chrome_default',
        }
    return {
        'handle': handle,
        'credentials_file': GOOGLE_CREDS_DIR / f'credentials_{handle}.json',
        'token_file': TOKENS_DIR / f'token_{handle}.json',
        'blaze_config_file': BLAZE_CONFIGS_DIR / f'blaze_config_{handle}.json',
        'chrome_profile_dir': CHROME_PROFILES_DIR / f'chrome_{handle}',
    }

# Run environment setup
setup_environment()

# Auto-select profile (no interactive menu)
ACTIVE_PROFILE = auto_select_profile()
if ACTIVE_PROFILE['handle']:
    print(f"[PROFILE] Active: {ACTIVE_PROFILE['handle']}")
    print(f"[PROFILE] Token: {ACTIVE_PROFILE['token_file'].name}")
    print(f"[PROFILE] Chrome: {ACTIVE_PROFILE['chrome_profile_dir'].name}")

# Dynamic path variables based on selected profile
TOKEN_FILE = ACTIVE_PROFILE['token_file']
CREDENTIALS_FILE = ACTIVE_PROFILE['credentials_file']
CHROME_PROFILE_DIR = ACTIVE_PROFILE['chrome_profile_dir']
BLAZE_CONFIG_FILE = ACTIVE_PROFILE['blaze_config_file']

# Ensure chrome profile directory exists
if CHROME_PROFILE_DIR:
    CHROME_PROFILE_DIR.mkdir(parents=True, exist_ok=True)

# ============================================================================
# CREDENTIALS LOADING (Profile-Aware)
# ============================================================================
def load_credentials_config() -> dict:
    """Load credentials from profile-specific blaze config file."""
    if BLAZE_CONFIG_FILE.exists():
        try:
            with open(BLAZE_CONFIG_FILE, 'r') as f:
                config = json.load(f)
                print(f"[CONFIG] Loaded profile config: {BLAZE_CONFIG_FILE.name}")
                return config
        except Exception as e:
            print(f"[WARN] Failed to load profile config: {e}")
            return {}
    else:
        print(f"[INFO] No profile config found: {BLAZE_CONFIG_FILE.name}")
        return {}

# Safe imports
from flask import Flask, render_template_string, request, jsonify, send_file
import pandas as pd
import requests
from fuzzywuzzy import fuzz
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build

# Selenium imports
try:
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.common.exceptions import TimeoutException, NoSuchElementException, StaleElementReferenceException
    from selenium.webdriver.support.ui import Select
    from selenium.webdriver.common.action_chains import ActionChains
    
    try:
        import undetected_chromedriver as uc
        USE_UNDETECTED = True
    except:
        USE_UNDETECTED = False
    
    SELENIUM_AVAILABLE = True
except ImportError:
    SELENIUM_AVAILABLE = False
    print("[WARN] Selenium not available")

# ============================================================================
# ADDITIONAL CONFIGURATION (Profile-Independent)
# ============================================================================
# Note: BASE_DIR, CREDENTIALS_FILE, TOKEN_FILE, CHROME_PROFILE_DIR 
# are defined dynamically above based on selected profile

BRAND_LIST_FILE = BASE_DIR / 'brand_list.txt'

# Blaze-specific (shared across profiles)
FILTERS_DIR = BASE_DIR / 'Custom_Filters'
GROUPS_FILE = BASE_DIR / 'promotion_groups.json'
BLAZE_TOKEN_FILE = BASE_DIR / 'blaze_token.json'


# Store Name Normalization Map (Google Sheet -> MIS CSV)
STORE_NAME_MAP = {
    "Beverly Hills": "Beverly",
    "Davis": "Davis",
    "Dixon": "Dixon",
    "El Sobrante": "El Sobrante",
    "Fresno (Palm)": "Fresno",
    "Fresno (Shaw)": "Fresno Shaw",
    "Hawthorne": "Hawthorne",
    "Koreatown": "Koreatown",
    "Laguna Woods": "Laguna Woods",
    "Oxnard": "Oxnard",
    "Riverside": "Riverside",
    "West Hollywood": "West Hollywood"
}

# All locations list
ALL_LOCATIONS = list(STORE_NAME_MAP.keys())

def parse_locations(location_str):
    """
    Parse location string into a set of store names.
    Handles: "All Locations", "All Locations Except: X, Y", "Store1, Store2, Store3"
    Returns: (store_set, is_all_except, excluded_stores)
    """
    if not location_str or location_str == '-':
        return set(), False, set()
    
    location_str = str(location_str).strip()
    
    # Handle "All Locations Except: X, Y, Z"
    if location_str.startswith("All Locations Except:"):
        excluded_part = location_str.replace("All Locations Except:", "").strip()
        excluded_stores = set()
        if excluded_part:
            excluded_stores = {s.strip() for s in excluded_part.split(',') if s.strip()}
        included_stores = set(ALL_LOCATIONS) - excluded_stores
        return included_stores, True, excluded_stores
    
    # Handle "All Locations"
    if location_str == "All Locations":
        return set(ALL_LOCATIONS), False, set()
    
    # Handle comma-separated list
    stores = {s.strip() for s in location_str.split(',') if s.strip()}
    return stores, False, set()

def calculate_location_conflict(weekly_locations, tier1_locations):
    """
    Calculate if locations overlap and return conflict type and details.
    Returns: (has_conflict, conflict_stores, non_conflict_stores, conflict_type)
    conflict_type: 'FULL' or 'PARTIAL' or 'NONE'
    """
    weekly_set, weekly_is_except, weekly_excluded = parse_locations(weekly_locations)
    tier1_set, tier1_is_except, tier1_excluded = parse_locations(tier1_locations)
    
    # Calculate intersection
    conflicting_stores = weekly_set & tier1_set
    
    if not conflicting_stores:
        # No overlap
        return False, set(), set(), 'NONE'
    
    # Non-conflicting stores (where weekly continues during conflict)
    non_conflicting_stores = weekly_set - tier1_set
    
    if non_conflicting_stores:
        # Partial conflict - need PATCH
        return True, conflicting_stores, non_conflicting_stores, 'PARTIAL'
    else:
        # Full conflict - all weekly locations affected
        return True, conflicting_stores, set(), 'FULL'

def format_location_set(stores, original_weekly_locations=""):
    """
    Format a set of stores back into a display string.
    If it matches "All Locations", return that. Otherwise list stores.
    """
    if not stores:
        return "-"
    
    stores_set = set(stores)
    all_locations_set = set(ALL_LOCATIONS)
    
    # If it's all locations, just say "All Locations"
    if stores_set == all_locations_set:
        return "All Locations"
    
    # If it's "All Locations Except" format
    excluded = all_locations_set - stores_set
    if excluded and len(excluded) < len(stores_set):
        # More efficient to show as "except"
        return f"All Locations Except: {', '.join(sorted(excluded))}"
    
    # Just list the stores
    return ", ".join(sorted(stores))

# MIS Exports Directory (for CSV downloads from MIS)
MIS_REPORTS_DIR = REPORTS_DIR / 'MIS_CSV_REPORTS'
MIS_REPORTS_DIR.mkdir(parents=True, exist_ok=True)

# Blaze Exports Directory (for Blaze-generated inventory reports)
BLAZE_REPORTS_DIR = REPORTS_DIR / 'BLAZE_CSV_REPORTS'
INVENTORY_DIR = BLAZE_REPORTS_DIR / 'INVENTORY'
INVENTORY_DIR.mkdir(parents=True, exist_ok=True)

TAX_CONFIG_FILE = BASE_DIR / 'tax_config.json'

# Inventory Reporter Config
INVENTORY_KEYS_FILE = BASE_DIR / 'blaze_inventory_keys.json'

# Default Tax Rates (Hardcoded - can be overridden via tax_config.json)
DEFAULT_TAX_RATES = {
    "Beverly Hills": 1.402361,
    "Davis": 1.3820125,
    "Dixon": 1.3086281,
    "El Sobrante": 1.33816875,
    "Fresno (Palm)": 1.295866,
    "Fresno Shaw": 1.295866,
    "Hawthorne": 1.3342875,
    "Koreatown": 1.402361,
    "Laguna Woods": 1.3630375,
    "Oxnard": 1.336783,
    "Riverside": 1.30108125,
    "West Hollywood": 1.36605625
}

# Google Sheets SCOPES
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']

# Note: CHROME_PROFILE_DIR is defined dynamically based on selected profile above

# ============================================================================
# GLOBAL DATA STORE
# ============================================================================
GLOBAL_DATA = {
    'config': {
        'spreadsheet_id': '',
        'source_tab': '',
        'tax_rates': DEFAULT_TAX_RATES.copy()
    },
    'browser_instance': None,
    'browser_ready': False,
    'sheets_service': None,
    'mis': {
        'credentials': {'username': '', 'password': ''},
        'deals_data': None,
        'audit_results': [],
        'filters': {},
        'filter_groups': {}
    },
    'blaze': {
        'credentials': {'username': '', 'password': ''},
        'promotions_data': None,
        'token': None,
        'inventory_running': False,
        'inventory_start_time': None,  # Track when operation started
        'inventory_logs': [],
        'inventory_data': None,  # Legacy: Full dataset (kept for backward compatibility)
        'inventory_cache': {},  # NEW: Per-store cache { 'store_name': { 'data': df, 'timestamp': datetime } }
        'inventory_brands': {}
    }
}

# Additional tax rates (these were in the original file but after the GLOBAL_DATA definition)


# Blaze Priority Mapping (rank -> human-readable)
PRIORITY_MAP = {
    1: "1 - Highest",
    2: "2 - High",
    3: "3 - Medium",
    4: "4 - Low",
    5: "5 - Lowest"
}

# MIS Store Mapping - UPDATED
STORE_MAPPING = {
    "West Hollywood": "West Hollywood",
    "Beverly": "Beverly Hills",
    "Beverly Hills": "Beverly Hills",
    "Koreatown": "Koreatown",
    "Riverside": "Riverside",
    "Fresno": "Fresno",
    "Fresno (Palm)": "Fresno",
    "Fresno Shaw": "Fresno Shaw",
    "Oxnard": "Oxnard",
    "El Sobrante": "El Sobrante",
    "Laguna Woods": "Laguna Woods",
    "Hawthorne": "Hawthorne",
    "Dixon": "Dixon",
    "Davis": "Davis"
}

# The strict list of stores that appear in the CSV (for 'All Except' logic)
CSV_TARGET_STORES = [
    "Dixon", "Davis", "Beverly Hills", "El Sobrante", "Fresno", 
    "Fresno Shaw", "Hawthorne", "Koreatown", "Laguna Woods", 
    "Oxnard", "Riverside", "West Hollywood"
]

ALL_STORES = list(set(STORE_MAPPING.values()))

# Strict list of categories for 'All Categories' expansion
ALL_CATEGORIES = [
    "Flowers", "Smalls Flower", "Prerolls", "Preroll Packs", 
    "Infused Prerolls", "Accessories", "AIO", "Capsules", 
    "Clones", "Drinks", "Edibles", "Infused Blnt Packs", 
    "Infused Blunts", "Infused Preroll Packs", "Solvent Extracts", 
    "Solventless Extracts", "Tinctures", "Topicals", "Vape Carts 1G"
]

FILTERS_DIR.mkdir(exist_ok=True)
if not GROUPS_FILE.exists():
    with open(GROUPS_FILE, 'w') as f:
        json.dump({}, f)

# MIS Store Mapping - UPDATED
STORE_MAPPING = {
    "West Hollywood": "West Hollywood",
    "Beverly": "Beverly Hills",
    "Beverly Hills": "Beverly Hills",
    "Koreatown": "Koreatown",
    "Riverside": "Riverside",
    "Fresno": "Fresno", # Updated per request
    "Fresno (Palm)": "Fresno",
    "Fresno Shaw": "Fresno Shaw",
    "Oxnard": "Oxnard",
    "El Sobrante": "El Sobrante",
    "Laguna Woods": "Laguna Woods",
    "Hawthorne": "Hawthorne",
    "Dixon": "Dixon",
    "Davis": "Davis"
}

# The strict list of stores that appear in the CSV (for 'All Except' logic)
CSV_TARGET_STORES = [
    "Dixon", "Davis", "Beverly Hills", "El Sobrante", "Fresno", 
    "Fresno Shaw", "Hawthorne", "Koreatown", "Laguna Woods", 
    "Oxnard", "Riverside", "West Hollywood"
]

ALL_STORES = list(set(STORE_MAPPING.values()))

# Strict list of categories for 'All Categories' expansion
ALL_CATEGORIES = [
    "Flowers", "Smalls Flower", "Prerolls", "Preroll Packs", 
    "Infused Prerolls", "Accessories", "AIO", "Capsules", 
    "Clones", "Drinks", "Edibles", "Infused Blnt Packs", 
    "Infused Blunts", "Infused Preroll Packs", "Solvent Extracts", 
    "Solventless Extracts", "Tinctures", "Topicals", "Vape Carts 1G"
]

# ============================================================================
# GLOBAL STATE (UNIFIED)
# ============================================================================

# ============================================================================
# BROWSER OPERATION LOCK (Thread Safety)
# ============================================================================
BROWSER_LOCK = threading.Lock()

# ============================================================================
# LOGIN DETECTION & BACKGROUND HELPERS
# ============================================================================
def check_login_state(driver, tab_type: str) -> str:
    """
    Check if user is logged in to MIS or Blaze.
    Returns: 'logged_in', 'logged_out', or 'unknown'
    """
    try:
        if tab_type == 'mis':
            # Layer 1: URL check
            if '/login' in driver.current_url:
                return 'logged_out'
            
            # Layer 2: Form check
            try:
                driver.find_element(By.NAME, 'email')
                return 'logged_out'
            except:
                pass
            
            # Layer 3: Logged-in element check (look for daily discount page)
            try:
                driver.find_element(By.CSS_SELECTOR, '#daily-discount, .daily-discount')
                return 'logged_in'
            except:
                pass
            
            # If no indicators, assume logged in
            return 'logged_in'
                
        elif tab_type == 'blaze':
            # Layer 1: Logout URL check
            if 'action=logout' in driver.current_url:
                return 'logged_out'
            
            # Layer 2: Login form check
            try:
                driver.find_element(By.CSS_SELECTOR, 'input[type="password"]')
                return 'logged_out'
            except:
                pass
            
            # Assume logged in if no logout indicators
            return 'logged_in'
            
    except Exception as e:
        print(f"[WARN] Login state check failed: {e}")
        return 'unknown'

def find_tab_by_url(driver, url_fragment: str):
    """Find browser tab by URL fragment. Returns window handle or None."""
    try:
        original = driver.current_window_handle
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if url_fragment in driver.current_url:
                driver.switch_to.window(original)
                return handle
        driver.switch_to.window(original)
    except:
        pass
    return None

def ensure_logged_in(driver, tab_type: str, gui_username: str = '', gui_password: str = '') -> bool:
    """
    Check login state and auto-login if needed.
    Completely silent unless error occurs.
    Raises exception with user-friendly message on failure.
    
    Priority: 
    1. Try GUI credentials (from Setup tab fields)
    2. If GUI fails or empty, try JSON credentials
    3. Only try JSON if different from GUI
    """
    state = check_login_state(driver, tab_type)
    
    if state == 'logged_in':
        return True  # All good
    
    if state == 'logged_out':
        # Try GUI credentials first
        username = gui_username.strip() if gui_username else ''
        password = gui_password.strip() if gui_password else ''
        
        # If GUI credentials empty, fall back to JSON
        if not username or not password:
            creds = load_credentials_config()
            if tab_type == 'mis':
                username = creds.get('mis_username', '')
                password = creds.get('mis_password', '')
            elif tab_type == 'blaze':
                username = creds.get('blaze_username', '')
                password = creds.get('blaze_password', '')
        
        # Check if we have any credentials at all
        if not username or not password:
            if tab_type == 'mis':
                raise Exception("[!] [EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è MIS Login Required\n\nPlease enter MIS credentials in Setup tab before using this feature.")
            elif tab_type == 'blaze':
                raise Exception("[!] [EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è Blaze Login Required\n\nPlease enter Blaze credentials in Setup tab before using this feature.")
        
        # Attempt login
        if tab_type == 'mis':
            try:
                print(f"[AUTO-LOGIN] Attempting MIS login with {'GUI' if gui_username else 'JSON'} credentials...")
                mis_login_silent(driver, username, password)
                time.sleep(3)
                
                # Verify login succeeded
                new_state = check_login_state(driver, 'mis')
                if new_state != 'logged_in':
                    # If GUI credentials failed, try JSON if different
                    if gui_username:
                        json_creds = load_credentials_config()
                        json_user = json_creds.get('mis_username', '')
                        json_pass = json_creds.get('mis_password', '')
                        
                        if json_user and json_pass and (json_user != gui_username or json_pass != gui_password):
                            print("[AUTO-LOGIN] GUI credentials failed, trying JSON credentials...")
                            mis_login_silent(driver, json_user, json_pass)
                            time.sleep(3)
                            
                            if check_login_state(driver, 'mis') != 'logged_in':
                                raise Exception("Login verification failed with both GUI and JSON credentials")
                        else:
                            raise Exception("Login verification failed - still on login page")
                    else:
                        raise Exception("Login verification failed")
                
                print("[AUTO-LOGIN] [OK] MIS login successful")
                return True
                
            except Exception as e:
                error_msg = str(e)
                if "still on login page" in error_msg or "verification failed" in error_msg:
                    raise Exception(f"[X] MIS Login Failed\n\nCredentials did not work. Please check your username/password in Setup tab.")
                else:
                    raise Exception(f"[X] MIS Login Failed\n\n{error_msg}")
        
        elif tab_type == 'blaze':
            # For Blaze, just raise exception - token-based login handled elsewhere
            raise Exception("[!] [EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è Blaze Session Expired\n\nPlease click 'Initialize Blaze Browser' to refresh your session.")
    
    # Unknown state - proceed cautiously
    return True

def execute_in_background(tab_type: str, operation_func, *args, **kwargs):
    """
    Execute browser operation without switching user's visible tab.
    
    Args:
        tab_type: 'mis' or 'blaze'
        operation_func: Function to execute (receives driver as first arg)
        *args, **kwargs: Additional arguments for operation_func
        gui_username: Optional GUI username from Setup tab
        gui_password: Optional GUI password from Setup tab
    
    Returns:
        dict with 'success' and either 'result' or 'error'
    """
    print(f"[BG-EXEC] Starting background operation for: {tab_type}")
    
    if not GLOBAL_DATA['browser_instance']:
        print(f"[BG-EXEC] ERROR: Browser not initialized")
        return {'success': False, 'error': 'Browser not initialized'}
    
    driver = GLOBAL_DATA['browser_instance']
    original_tab = None
    
    # Extract GUI credentials if provided
    gui_username = kwargs.pop('gui_username', '')
    gui_password = kwargs.pop('gui_password', '')
    
    try:
        original_tab = driver.current_window_handle
        print(f"[BG-EXEC] Original tab saved: {original_tab}")
    except:
        pass  # Might fail if no tabs open
    
    try:
        # Find or create target tab
        if tab_type == 'mis':
            # Use the new intelligent MIS session manager
            print(f"[BG-EXEC] Using ensure_mis_ready for MIS tab...")
            ensure_mis_ready(driver, gui_username, gui_password)
            # ensure_mis_ready leaves us on MIS tab, so get current handle
            target_tab = driver.current_window_handle
            print(f"[BG-EXEC] MIS ready, target tab: {target_tab}")
        elif tab_type == 'blaze':
            target_tab = find_tab_by_url(driver, 'blaze.me')
            if not target_tab:
                # Create new tab in background using JavaScript
                if original_tab:
                    driver.switch_to.window(original_tab)
                driver.execute_script("window.open('https://app.blaze.me', '_blank');")
                time.sleep(1)
                target_tab = driver.window_handles[-1]
            
            # Switch to target tab
            driver.switch_to.window(target_tab)
            
            # Check login for Blaze
            print(f"[BG-EXEC] Checking Blaze login status...")
            ensure_logged_in(driver, 'blaze', gui_username, gui_password)
        else:
            target_tab = original_tab
            if target_tab:
                driver.switch_to.window(target_tab)
        
        # Execute operation
        print(f"[BG-EXEC] Executing operation...")
        result = operation_func(driver, *args, **kwargs)
        print(f"[BG-EXEC] Operation complete, result: {result}")
        
        return {'success': True, 'result': result}
        
    except Exception as e:
        return {'success': False, 'error': str(e)}
        
    finally:
        # ALWAYS return to user's original tab
        if original_tab:
            try:
                driver.switch_to.window(original_tab)
            except:
                pass  # Tab might have closed

def mis_login_silent(driver, username: str, password: str):
    """Silent MIS login without tab switching visibility."""
    try:
        # Wait for login page to load
        time.sleep(1)
        
        # Find and fill email
        email_field = driver.find_element(By.NAME, 'email')
        email_field.clear()
        email_field.send_keys(username)
        
        # Find and fill password
        password_field = driver.find_element(By.NAME, 'password')
        password_field.clear()
        password_field.send_keys(password)
        
        # Submit
        password_field.submit()
        time.sleep(3)
        
        # Check if login successful
        if '/login' in driver.current_url:
            raise Exception("Still on login page after submission")
            
    except Exception as e:
        raise Exception(f"Login failed: {str(e)}")

# ============================================================================
# ============================================================================
# BLAZE HELPER FUNCTIONS
# ============================================================================
def load_groups():
    try:
        with open(GROUPS_FILE, 'r') as f:
            return json.load(f)
    except:
        return {}

def save_groups(groups_data):
    with open(GROUPS_FILE, 'w') as f:
        json.dump(groups_data, f, indent=2)

def load_stored_token() -> Optional[str]:
    """Reads the Blaze token from a local JSON file."""
    try:
        if BLAZE_TOKEN_FILE.exists():
            with open(BLAZE_TOKEN_FILE, 'r') as f:
                data = json.load(f)
                token = data.get('token')
                if token:
                    return str(token).strip()
    except Exception as e:
        print(f"[WARN] Failed to load stored token: {e}")
    return None

def save_stored_token(token: str):
    """Saves the Blaze token to a local JSON file."""
    try:
        with open(BLAZE_TOKEN_FILE, 'w') as f:
            json.dump({'token': token, 'updated': str(datetime.now())}, f)
        print("[INFO] Blaze token saved to file.")
    except Exception as e:
        print(f"[WARN] Failed to save token: {e}")

def validate_token(token: str) -> bool:
    """
    Checks if a token is valid by making a lightweight API call.
    Returns True if valid (200 OK), False otherwise.
    """
    if not token: return False
    headers = {"Authorization": f"Token {token}"}
    try:
        # We fetch 1 shop just to see if the server accepts the token
        r = requests.get("https://api.blaze.me/api/v1/mgmt/shops?start=0&limit=1", headers=headers, timeout=5)
        return r.status_code == 200
    except:
        return False

def robust_login(email: str, password: str) -> Optional[str]:
    """
    Blaze login with 'Session Check' optimization.
    1. Tries to go directly to Promotions.
    2. If redirected to Login/Logout, performs full login.
    3. Always returns 'LOGIN_SUCCESSFUL' if we end up on the right page.
    """
    driver = GLOBAL_DATA['browser_instance']
    if not driver: return None
    
    target_url = "https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=100"
    
    try:
        # 1. OPTIMIZATION: Try to access the page directly (Session Check)
        print("[LOGIN] Checking for existing session...")
        # Create tab in background
        original_handle = driver.current_window_handle
        driver.execute_script(f"window.open('{target_url}', '_blank');")
        time.sleep(1)
        # Switch to new tab
        driver.switch_to.window(driver.window_handles[-1])
        time.sleep(2) # Wait for page load
        
        current_url = driver.current_url.lower()
        
        # If we are STILL on the promotions page (or similar internal page), we are good!
        if "company-promotions" in current_url and "login" not in current_url:
            print("[LOGIN] Session active! Skipping credentials.")
            return "LOGIN_SUCCESSFUL"
            
        # 2. If we got bounced to login/logout, proceed with full login
        print("[LOGIN] Session expired or invalid. Logging in...")
        driver.get("https://retail.blaze.me/login")
        
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.NAME, "email")))
        driver.find_element(By.NAME, "email").send_keys(email)
        driver.find_element(By.NAME, "password").send_keys(password + Keys.RETURN)
        
        time.sleep(5)
        
        print("[INFO] Navigating to Promotions page to capture token...")
        driver.get(target_url)
        time.sleep(8)
        
        return "LOGIN_SUCCESSFUL"

    except Exception as e:
        print(f"[ERROR] Blaze login failed: {e}")
        return None

def analyze_blaze_network_traffic():
    """
    DIAGNOSTIC: Analyzes browser network logs to find the actual Collections API endpoint.
    Call this after navigating to Smart Collections page.
    """
    driver = GLOBAL_DATA['browser_instance']
    if not driver:
        print("[DIAG] No browser instance")
        return
    
    print("\n" + "="*70)
    print("[DIAGNOSTIC] Analyzing Blaze Network Traffic...")
    print("="*70)
    
    try:
        logs = driver.get_log('performance')
        collections_requests = []
        
        for entry in logs:
            try:
                msg = json.loads(entry['message'])['message']
                if msg['method'] == 'Network.requestWillBeSent':
                    req = msg['params']['request']
                    url = req.get('url', '')
                    
                    # Look for any request that might be collections-related
                    if 'api.blaze.me' in url and any(keyword in url.lower() for keyword in ['collection', 'smart', 'group', 'category']):
                        collections_requests.append({
                            'url': url,
                            'method': req.get('method', 'GET'),
                            'headers': req.get('headers', {}),
                            'postData': req.get('postData', None)
                        })
            except:
                continue
        
        if collections_requests:
            print(f"\n[DIAG] Found {len(collections_requests)} potential Collections API calls:")
            for idx, req in enumerate(collections_requests, 1):
                print(f"\n--- Request #{idx} ---")
                print(f"URL: {req['url']}")
                print(f"Method: {req['method']}")
                if req['postData']:
                    print(f"POST Data: {req['postData'][:200]}")
        else:
            print("[DIAG] No collections-related API calls found in logs")
            print("[DIAG] Try manually clicking around the Smart Collections page first")
        
        print("="*70 + "\n")
        
    except Exception as e:
        print(f"[DIAG] Error analyzing logs: {e}")
        traceback.print_exc()

def get_api_data(token_input):
    """
    Fetch Blaze API data with FLEXIBLE token input.
    Accepts: Dict {'promo_token': '...', 'group_token': '...'} OR single string token
    Routes requests to appropriate token based on endpoint.
    """
    # --- FLEXIBLE INPUT HANDLING ---
    if isinstance(token_input, dict):
        promo_token = token_input.get('promo_token', '')
        group_token = token_input.get('group_token', '')
        
        # Fallback if one is missing
        if not promo_token:
            promo_token = group_token
        if not group_token:
            group_token = promo_token
            
        print(f"[API] Using dual tokens: Promo={promo_token[:10]}... | Group={group_token[:10]}...")
    else:
        # Legacy single-token mode
        promo_token = str(token_input)
        group_token = str(token_input)
        print(f"[API] Using single token mode: {promo_token[:10]}...")
    
    # 1. Fetch Shops (uses promo_token)
    shops = {}
    try:
        headers = {"Authorization": f"Token {promo_token}"}
        r = requests.get("https://api.blaze.me/api/v1/mgmt/shops?start=0&limit=500", 
                        headers=headers, timeout=10)
        if r.ok:
            for s in r.json().get('values', []):
                shops[s['id']] = s['name']
        print(f"[API] [OK] Fetched {len(shops)} shops")
    except Exception as e:
        print(f"[API] [ERROR] Shops fetch failed: {e}")
    
    # 2. Fetch Collections (uses group_token)
    colls = {}
    skip = 0  # [SUCCESS] CHANGE 1: Use 'skip' instead of 'start'
    try:
        headers = {"Authorization": f"Token {group_token}"}
        
        while True:
            # [SUCCESS] CHANGE 2: Add '/search' to endpoint
            # [SUCCESS] CHANGE 3: Use 'skip=' parameter instead of 'start='
            url = f"https://api.blaze.me/api/v1/mgmt/smartcollections/search?skip={skip}&limit=200"
            r = requests.get(url, headers=headers, timeout=10)
            
            if not r.ok:
                print(f"[API] [ERROR] Collections endpoint returned {r.status_code}: {r.text[:100]}")
                break
            
            data = r.json()
            vals = data if isinstance(data, list) else data.get('values', [])
            
            if not vals:
                break
            
            for c in vals:
                c_id = c.get('id', c.get('_id'))
                c_name = c.get('name')
                if c_id and c_name:
                    colls[c_id] = c_name
            
            if len(vals) < 200:
                break
            skip += 200  # [SUCCESS] CHANGE 3b: Increment 'skip' not 'start'
        
        print(f"[API] [OK] Fetched {len(colls)} collections")
        
        # DEBUG: Print first 3 collections to verify
        if colls:
            sample = list(colls.items())[:3]
            print(f"[API] Sample collections: {sample}")
        else:
            print("[API] [!] [EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è WARNING: Zero collections returned!")
            
    except Exception as e:
        print(f"[API] [ERROR] Collections fetch failed: {e}")
        traceback.print_exc()
    
    # 3. Fetch Promotions (uses promo_token)
    promos = []
    start = 0
    try:
        headers = {"Authorization": f"Token {promo_token}"}
        
        while True:
            r = requests.get(
                f"https://api.blaze.me/api/v1/mgmt/company/promotions?start={start}&limit=100",
                headers=headers, timeout=10
            )
            if not r.ok:
                print(f"[API] [ERROR] Promotions endpoint returned {r.status_code}")
                break
            
            vals = r.json().get('values', [])
            if not vals:
                break
            
            promos.extend(vals)
            
            if len(promos) >= r.json().get('total', 0):
                break
            start += 100
        
        print(f"[API] [OK] Fetched {len(promos)} promotions")
    except Exception as e:
        print(f"[API] [ERROR] Promotions fetch failed: {e}")
    
    return shops, colls, promos


def scrape_blaze_data_from_browser():
    """
    Retrieves Blaze Data with "Smart Collection" Page Redirect.
    UPDATED: Uses a temporary background tab for token sniffing to avoid hijacking the Dashboard.
    LOGIC UPDATE: Strictly enforces fetching fresh Smart Collections to ensure new groups appear.
    """
    driver = GLOBAL_DATA.get('browser_instance')
    if not driver:
        return None, "Browser not initialized - cannot sniff token."

    # --- HELPER: LOG SNIFFER ---
    def sniff_token_from_logs(target_endpoint):
        print(f"[TOKEN] Sniffing logs for endpoint: {target_endpoint}...")
        try:
            logs = driver.get_log('performance')
            for entry in logs:
                try:
                    message_obj = json.loads(entry['message'])
                    message = message_obj.get('message', {})
                    if message.get('method') == 'Network.requestWillBeSent':
                        req = message['params']['request']
                        url = req.get('url', '')
                        if 'api.blaze.me' in url and target_endpoint in url:
                            headers = req.get('headers', {})
                            auth = next((v for k, v in headers.items() if k.lower() == 'authorization'), None)
                            if auth and 'Token' in auth:
                                return auth.replace('Token ', '').strip()
                except: continue
        except Exception as e:
            print(f"[WARN] Log sniff error: {e}")
        return None

    # --- STEP 1: TEST EXISTING TOKEN ---
    current_token = load_stored_token() or GLOBAL_DATA['blaze'].get('token')
    shops, raw_promos = {}, []
    colls = load_groups() # Load cache first
    
    # Check if we already have a token that works for EVERYTHING
    if current_token:
        print(f"[TOKEN] Verifying current token...")
        shops, new_colls, raw_promos = get_api_data(current_token)
        
        # Merge new groups into cache
        if new_colls: 
            colls.update(new_colls)
            save_groups(colls)
        
        # LOGIC UPDATE: Ensure we actually fetched groups if we have a token
        # If new_colls is empty but we have cached groups, it implies the token 
        # failed to fetch groups (Limited Scope). We should force a refresh.
        groups_valid = False
        if new_colls and len(new_colls) > 0:
            groups_valid = True
        elif len(colls) == 0:
            # If cache is empty and API is empty, allow it (maybe truly 0 groups)
            groups_valid = True 
        
        if groups_valid and len(raw_promos) > 0:
            print("[TOKEN] Current token is VALID for both Groups and Promos. No redirect needed.")
            GLOBAL_DATA['blaze']['token'] = current_token
        else:
            print("[TOKEN] Token is PARTIAL or INVALID (Groups missing). Initiating re-scrape sequence...")
            current_token = None # Trigger scrape
            # We don't wipe 'colls' here so we preserve old names if scrape fails, 
            # but we force the scrape to try and get new ones.

    # --- STEP 2: REDIRECT SEQUENCE (If needed) ---
    if not current_token:
        print("[NAV] Token invalid or missing. Opening background tab to sniff...")
        
        # SAVE CURRENT TAB
        try:
            original_handle = driver.current_window_handle
        except:
            original_handle = driver.window_handles[0]

        # OPEN NEW TAB & SWITCH
        driver.execute_script("window.open('about:blank', '_blank');")
        time.sleep(0.5)
        new_handle = driver.window_handles[-1]
        driver.switch_to.window(new_handle)
        
        try:
            # A. Go to Smart Collections to generate the right traffic
            print("[NAV] Redirecting to Smart Collections page (Background)...")
            driver.get("https://retail.blaze.me/company-promotions/smart-collections")
            time.sleep(6) # Wait for page load & API calls
            
            # B. Sniff specifically for the smartcollections endpoint
            collections_token = sniff_token_from_logs('smartcollections')
            
            if collections_token:
                print("[TOKEN] captured fresh Collections Token!")
                current_token = collections_token
                save_stored_token(current_token)
            else:
                print("[WARN] Failed to capture token even after redirect.")
        
        except Exception as e:
            print(f"[ERROR] Background sniff failed: {e}")
            
        finally:
            # C. CLOSE TAB & RETURN
            print("[NAV] Closing background tab and returning...")
            try:
                driver.close()
                driver.switch_to.window(original_handle)
            except:
                print("[WARN] Could not switch back to original tab")

        # D. Fetch Data with new token
        if current_token:
            shops, new_colls, raw_promos = get_api_data(current_token)
            if new_colls:
                colls.update(new_colls)
                save_groups(colls)

    # --- STEP 3: PARSE DATA ---
    GLOBAL_DATA['blaze']['token'] = current_token
    
    if not raw_promos: 
        return None, "Token expired or missing. Please Login to Blaze in a new tab."

    parsed = []
    
    # Map Collection IDs to Names
    def get_group_name(gid):
        return colls.get(gid, gid) 
    
    # Helper: Format buy requirements from criteria
    def parse_buy_requirements(criteria_groups):
        requirements = []
        for cg in criteria_groups:
            rules = []
            if isinstance(cg, list): 
                rules = cg 
            elif isinstance(cg, dict): 
                rules = cg.get('criteria', [])
            
            for rule in rules:
                qty = rule.get('minimum', 1)
                items = []
                
                # Check products
                if rule.get('products'):
                    items.extend([p.get('name', 'Product') for p in rule.get('products', [])])
                
                # Check smart collections
                if rule.get('smartCollectionIds'):
                    items.extend([get_group_name(cid) for cid in rule.get('smartCollectionIds', [])])
                
                # Check categories
                if rule.get('categories'):
                    items.extend([c.get('name', 'Category') for c in rule.get('categories', [])])
                
                if items:
                    requirements.append({
                        'quantity': qty,
                        'items': items
                    })
        
        return requirements
    
    # Helper: Format time constraint
    def parse_time_constraint(tc):
        if not tc:
            return None
        return {
            'days': tc.get('daysOfWeek', []),
            'start_time': tc.get('startTime', ''),
            'end_time': tc.get('endTime', '')
        }
    
    # Helper: Parse priority with robust error handling
    def parse_priority(promo_data):
        try:
            raw_rank = int(promo_data.get('rank', 5))  # Force integer conversion
        except (ValueError, TypeError):
            raw_rank = 5  # Default safe fallback
        return PRIORITY_MAP.get(raw_rank, f"{raw_rank} (Unknown)")

    for p in raw_promos:
        try:
            target = p.get('target', {})
            shop_ids = p.get('shopIds', [])
            
            names = []
            for sid in shop_ids:
                raw_name = shops.get(sid, sid)
                # Updated Regex to remove "Davisville Business Enterprises, Inc." as well
                clean_name = re.sub(r"^(The Artist Tree|Davisville Business Enterprises, Inc\.|Club 420)\s*[--]?\s*", "", str(raw_name), flags=re.IGNORECASE).strip()
                names.append(clean_name)

            if len(names) >= 12:
                loc_display = "All Locations"
            else:
                loc_display = ', '.join(sorted(names)) if names else "Unknown"

            buy_groups = []
            c_groups = p.get('criteriaGroups', [])
            for cg in c_groups:
                rules = []
                if isinstance(cg, list): rules = cg 
                elif isinstance(cg, dict): rules = cg.get('criteria', [])
                for rule in rules:
                    for cid in rule.get('smartCollectionIds', []):
                        buy_groups.append({'id': cid, 'name': get_group_name(cid)})
            
            get_groups = []
            for cid in target.get('smartCollectionIds', []): 
                get_groups.append({'id': cid, 'name': get_group_name(cid)})

            auto_apply = p.get('autoApply', False)
            buy_requirements = parse_buy_requirements(c_groups)
            restrictions = {
                'member_groups': p.get('memberGroups', []),
                'consumer_types': p.get('consumerTypes', []),
                'sales_channels': p.get('salesChannels', [])
            }
            time_constraint = parse_time_constraint(p.get('timeConstraint'))

            parsed.append({
                'ID': p.get('id'),
                'Name': p.get('name'),
                'Status': 'Active' if p.get('active') else 'Inactive',
                'Locations': loc_display,
                'buy_groups': buy_groups, 
                'get_groups': get_groups,
                'Discount Value Type': target.get('discountType'),
                'Discount Value': target.get('discountAmt'),
                'Start Date': datetime.fromtimestamp(p.get('startDate', 0)/1000).strftime('%Y-%m-%d') if p.get('startDate') else '',
                'End Date': datetime.fromtimestamp(p.get('endDate', 0)/1000).strftime('%Y-%m-%d') if p.get('endDate') else '',
                'auto_apply': auto_apply,
                'description': p.get('description', ''),
                'buy_requirements': buy_requirements,
                'target_type': target.get('discountType', ''),
                'target_value': target.get('discountAmt', ''),
                'stackable': p.get('stackable', False),
                'apply_lowest_price_first': p.get('applyLowestPriceFirst', False),
                'priority': parse_priority(p),
                'enable_promo_code': p.get('enablePromoCode', False),
                'promo_code': p.get('promoCode', ''),
                'max_uses': p.get('maxUses', 'Unlimited'),
                'max_uses_per_consumer': p.get('maxUsesPerConsumer', 'Unlimited'),
                'restrictions': restrictions,
                'time_constraint': time_constraint,
            })
        except Exception as inner_e:
            print(f"[ERROR] Parsing promotion failed: {inner_e}")
            continue

    return parsed, None

def update_single_promotion_in_memory(promo_id: str):
    """
    Fetches a single promotion by ID and updates the global DataFrame.
    """
    # Try global memory first, then file storage
    token = GLOBAL_DATA['blaze'].get('token') or load_stored_token()
    
    if not token:
        print("[WARN] No token available for single-row update.")
        return

    headers = {"Authorization": f"Token {token}"}
    try:
        # Fetch just the one item
        url = f"https://api.blaze.me/api/v1/mgmt/company/promotions/{promo_id}"
        print(f"[SYNC] Fetching single row: {promo_id}...")
        r = requests.get(url, headers=headers)
        
        if not r.ok:
            print(f"[WARN] Failed to fetch row {promo_id}: {r.status_code}")
            return

        p = r.json()
        target = p.get('target', {})
        
        # Construct the row update (Matches structure of full scrape)
        new_row = {
            'ID': p.get('id'),
            'Name': p.get('name'),
            'Status': 'Active' if p.get('active') else 'Inactive',
            # We keep existing location/group data to avoid complex parsing in this lightweight update
            # or you can fetch shops if strictly needed. For speed, we update the core edit fields.
            'Discount Value Type': target.get('discountType'),
            'Discount Value': target.get('discountAmt'),
            'Start Date': datetime.fromtimestamp(p.get('startDate', 0)/1000).strftime('%Y-%m-%d') if p.get('startDate') else '',
            'End Date': datetime.fromtimestamp(p.get('endDate', 0)/1000).strftime('%Y-%m-%d') if p.get('endDate') else '',
        }
        
        # UPDATE THE DATAFRAME IN MEMORY
        df = GLOBAL_DATA['blaze'].get('df_raw')
        if df is not None and not df.empty and 'ID' in df.columns:
            # Check if ID exists
            idx = df.index[df['ID'] == promo_id].tolist()
            if idx:
                row_idx = idx[0]
                # Update specific fields
                df.at[row_idx, 'Name'] = new_row['Name']
                df.at[row_idx, 'Status'] = new_row['Status']
                df.at[row_idx, 'Discount Value Type'] = new_row['Discount Value Type']
                df.at[row_idx, 'Discount Value'] = new_row['Discount Value']
                df.at[row_idx, 'Start Date'] = new_row['Start Date']
                df.at[row_idx, 'End Date'] = new_row['End Date']
                
                print(f"[SYNC] Successfully updated row {promo_id} in memory.")
                
                # Signal Frontend to refresh
                GLOBAL_DATA['blaze']['last_update_ts'] = time.time()
            else:
                print("[SYNC] ID not found in cache. Full refresh recommended.")
    except Exception as e:
        print(f"[ERROR] Single row sync failed: {e}")

def monitor_browser_return(promo_id: str):
    """
    Watches the browser URL. When it returns to the list page, triggers a single-row sync.
    """
    driver = GLOBAL_DATA.get('browser_instance')
    if not driver: return

    print(f"[WATCHER] Monitoring browser for return from {promo_id}...")
    
    # Wait loop (Timeout after 60 seconds to save resources)
    max_wait = 60
    for _ in range(max_wait):
        try:
            current_url = driver.current_url
            # If we are back on the main list page
            if "company-promotions/promotions" in current_url and promo_id not in current_url:
                print("[WATCHER] Detected return to list! Waiting 300ms...")
                time.sleep(0.3) # User requested delay
                
                # Trigger Update
                update_single_promotion_in_memory(promo_id)
                return
            time.sleep(1)
        except:
            break
    print("[WATCHER] Timed out or browser closed.")

# ============================================================================
# GOOGLE SHEETS AUTHENTICATION (SHARED)
# ============================================================================
def authenticate_google_sheets() -> Optional[object]:
    """Authenticate with Google Sheets API."""
    creds = None
    
    if TOKEN_FILE.exists():
        try:
            creds = Credentials.from_authorized_user_file(str(TOKEN_FILE), SCOPES)
        except Exception as e:
            print(f"[WARN] Token corrupted: {e}")
    
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                creds.refresh(Request())
            except:
                creds = None
        
        if not creds:
            if not CREDENTIALS_FILE.exists():
                return None
            
            max_wait = 10
            waited = 0
            while not GLOBAL_DATA['browser_ready'] and waited < max_wait:
                time.sleep(1)
                waited += 1
            
            if not GLOBAL_DATA['browser_ready']:
                flow = InstalledAppFlow.from_client_secrets_file(str(CREDENTIALS_FILE), SCOPES)
                creds = flow.run_local_server(port=8080, prompt='consent')
            else:
                driver = GLOBAL_DATA['browser_instance']
                flow = InstalledAppFlow.from_client_secrets_file(str(CREDENTIALS_FILE), SCOPES)
                flow.redirect_uri = 'http://localhost:8080/'
                auth_url, _ = flow.authorization_url(prompt='consent')
                
                driver.execute_script(f"window.open('{auth_url}', '_blank');")
                driver.switch_to.window(driver.window_handles[-1])
                
                try:
                    WebDriverWait(driver, 120).until(
                        lambda d: 'localhost:8080' in d.current_url or 'code=' in d.current_url
                    )
                    
                    current_url = driver.current_url
                    if 'code=' in current_url:
                        parsed = urlparse.urlparse(current_url)
                        code = urlparse.parse_qs(parsed.query).get('code', [None])[0]
                        if code:
                            flow.fetch_token(code=code)
                            creds = flow.credentials
                    
                    driver.close()
                    driver.switch_to.window(driver.window_handles[0])
                except TimeoutException:
                    driver.close()
                    driver.switch_to.window(driver.window_handles[0])
                    return None
        
        with open(TOKEN_FILE, 'w') as token:
            token.write(creds.to_json())
    
    try:
        service = build('sheets', 'v4', credentials=creds)
        return service
    except Exception as e:
        print(f"[ERROR] Failed to build service: {e}")
        return None

# ============================================================================
# BLAZE TOKEN MANAGER (BACKGROUND API CALLS)
# ============================================================================
class BlazeTokenManager:
    """
    Manages Blaze API authentication tokens with caching and validation.
    Supports headless and GUI fallback login for background API operations.
    Does NOT interfere with the main browser instance used for MIS automation.
    """
    TOKEN_FILE = BASE_DIR / 'blaze_token_cache.json'
    
    @staticmethod
    def validate(token):
        """Validate token by making a test API call."""
        if not token:
            return False
        try:
            r = requests.get(
                "https://api.blaze.me/api/v1/mgmt/shops?start=0&limit=1",
                headers={"Authorization": f"Token {token}"},
                timeout=5
            )
            return r.status_code == 200
        except:
            return False

    @classmethod
    def get_token(cls):
        """
        Get a valid token using this priority:
        1. Try cached token from file
        2. If expired, sniff new token (headless first, GUI fallback)
        3. Save and return new token
        """
        # 1. Try Cache
        if cls.TOKEN_FILE.exists():
            try:
                with open(cls.TOKEN_FILE, 'r') as f:
                    cached = json.load(f).get('token')
                    if cls.validate(cached):
                        print("[TOKEN] Using cached session.")
                        return cached
            except:
                pass
        
        # 2. Sniff new token (Headless -> GUI Fallback)
        creds = load_credentials_config().get('blaze', {})
        email = creds.get('email')
        password = creds.get('password')
        
        if not email or not password:
            print("[TOKEN] No credentials found in config.")
            return None

        print("[TOKEN] Cache expired. Sniffing new token...")
        token = cls._sniff_login(email, password, headless=True)
        
        if not token:
            print("[TOKEN] Headless failed. Trying visible browser...")
            token = cls._sniff_login(email, password, headless=False)
            
        if token:
            cls._save(token)
            return token
        
        print("[TOKEN] Failed to obtain token.")
        return None

    @staticmethod
    def _sniff_login(email, password, headless=True):
        """
        Login to Blaze and sniff the Authorization token from network logs.
        Uses a separate browser instance to avoid interfering with main GUI.
        """
        driver = None
        try:
            from selenium import webdriver
            from selenium.webdriver.common.by import By
            from selenium.webdriver.common.keys import Keys
            from selenium.webdriver.support.ui import WebDriverWait
            from selenium.webdriver.support import expected_conditions as EC
            
            options = webdriver.ChromeOptions()
            if headless:
                options.add_argument('--headless=new')
            options.add_argument('--no-sandbox')
            options.add_argument('--disable-dev-shm-usage')
            options.set_capability('goog:loggingPrefs', {'performance': 'ALL'})
            
            driver = webdriver.Chrome(options=options)
            driver.get("https://retail.blaze.me/login")
            
            # Wait for login form
            WebDriverWait(driver, 15).until(
                EC.presence_of_element_located((By.NAME, "email"))
            )
            
            # Login
            driver.find_element(By.NAME, "email").send_keys(email)
            driver.find_element(By.NAME, "password").send_keys(password + Keys.RETURN)
            
            time.sleep(5)  # Wait for login to complete
            
            # Navigate to promotions page to trigger API calls
            driver.get("https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=20")
            time.sleep(5)  # Wait for API calls
            
            # Sniff logs for token
            logs = driver.get_log('performance')
            for entry in logs:
                try:
                    msg = json.loads(entry['message'])['message']
                    if 'Network.requestWillBeSent' in msg.get('method', ''):
                        req = msg['params']['request']
                        if 'api.blaze.me' in req.get('url', ''):
                            headers = req.get('headers', {})
                            auth = next(
                                (v for k, v in headers.items() if k.lower() == 'authorization'),
                                None
                            )
                            if auth:
                                token = auth.replace('Token ', '').replace('Bearer ', '').strip()
                                print(f"[TOKEN] Successfully captured token!")
                                return token
                except:
                    pass
                    
        except Exception as e:
            print(f"[TOKEN] Login Error: {e}")
        finally:
            if driver:
                driver.quit()
        
        return None

    @classmethod
    def _save(cls, token):
        """Save token to cache file."""
        try:
            with open(cls.TOKEN_FILE, 'w') as f:
                json.dump({
                    'token': token,
                    'updated': str(datetime.now())
                }, f)
            print(f"[TOKEN] Saved to cache: {cls.TOKEN_FILE}")
        except Exception as e:
            print(f"[TOKEN] Failed to save cache: {e}")

    @classmethod
    def fetch_global_brands(cls, token=None) -> Dict[str, str]:
        """
        Fetch the master brand list from Blaze API.
        Returns: {brandId: brandName}
        """
        if not token:
            token = cls.get_token()
        if not token:
            print("[BRANDS] No token available for brand fetch.")
            return {}

        headers = {"Authorization": f"Token {token}"}
        brands_map = {}
        start = 0
        limit = 500  # Blaze API max per page
        
        try:
            print("[BRANDS] Fetching global brand list...")
            while True:
                url = f"https://api.blaze.me/api/v1/mgmt/brands?start={start}&limit={limit}"
                
                try:
                    r = requests.get(url, headers=headers, timeout=10)
                    
                    if r.status_code == 404:
                        print("[BRANDS] WARNING: Global brand endpoint not available (404). Using fallback methods.")
                        break  # Not an error, just not available
                    
                    if r.status_code != 200:
                        print(f"[BRANDS] API Error {r.status_code}: {r.text[:100]}")
                        break
                    
                    data = r.json()
                    items = data.get('values', [])
                    
                    if not items:
                        break
                    
                    for brand in items:
                        brand_id = brand.get('id')
                        brand_name = brand.get('name')
                        if brand_id and brand_name:
                            brands_map[brand_id] = brand_name
                    
                    # Check if we got all brands
                    total = data.get('total', 0)
                    if len(brands_map) >= total or len(items) < limit:
                        break
                    
                    start += limit
                    
                except requests.exceptions.RequestException as req_err:
                    print(f"[BRANDS] WARNING: Network error: {req_err}")
                    break
            
            if brands_map:
                print(f"[BRANDS] SUCCESS: Fetched {len(brands_map)} brands")
            else:
                print(f"[BRANDS] WARNING: No brands fetched (will use brandName fallback)")
            return brands_map
            return brands_map
            
        except Exception as e:
            print(f"[BRANDS] ERROR: Fetch failed: {e}")
            return {}

# ============================================================================
# BROWSER AUTOMATION (UNIFIED)
# ============================================================================
def init_browser():
    """Initialize unified browser using Standard Selenium with Download Prefs."""
    if not SELENIUM_AVAILABLE:
        return None
    
    try:
        print("[INIT] Launching Standard Chrome for Token Sniffing & Downloads...")
        
        options = webdriver.ChromeOptions()
        options.add_argument(f'user-data-dir={CHROME_PROFILE_DIR}')
        options.add_argument('profile-directory=Default')
        options.add_argument('--no-sandbox')
        options.add_argument('--disable-dev-shm-usage')
        options.add_argument('--start-maximized')
        options.add_argument('--remote-allow-origins=*')
        
        # Hide automation indicators
        options.add_argument('--disable-blink-features=AutomationControlled')
        options.add_experimental_option("excludeSwitches", ["enable-automation", "enable-logging"])
        options.add_experimental_option('useAutomationExtension', False)
        
        # Suppress console errors (QUOTA_EXCEEDED, google_apis warnings)
        options.add_argument('--log-level=3')  # Only show fatal errors
        options.add_argument('--silent')
        options.add_argument('--disable-logging')
        
        # NEW: Configure Download Directory
        prefs = {
            "download.default_directory": str(MIS_REPORTS_DIR),
            "download.prompt_for_download": False,
            "download.directory_upgrade": True,
            "safebrowsing.enabled": True,
            "credentials_enable_service": False,
            "profile.password_manager_enabled": False,
            # Suppress quota warnings
            "profile.default_content_setting_values.notifications": 2,
            "profile.default_content_settings.popups": 0
        }
        options.add_experimental_option("prefs", prefs)
        options.set_capability('goog:loggingPrefs', {'performance': 'ALL'})
        
        driver = webdriver.Chrome(options=options)
        
        GLOBAL_DATA['browser_instance'] = driver
        GLOBAL_DATA['browser_ready'] = True
        
        return driver
    except Exception as e:
        print(f"[ERROR] Browser init failed: {e}")
        traceback.print_exc()
        return None

def mis_login(driver, username: str, password: str, new_tab: bool = True) -> bool:
    """MIS login automation."""
    try:
        target_url = "https://mis.theartisttree.com/daily-discount"
        
        mis_tab_found = False
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if "daily-discount" in driver.current_url or "mis.theartisttree.com" in driver.current_url:
                mis_tab_found = True
                break
        
        if not mis_tab_found:
            if new_tab:
                # Create tab in background
                original_handle = driver.current_window_handle
                driver.execute_script(f"window.open('{target_url}', '_blank');")
                time.sleep(1)
                driver.switch_to.window(driver.window_handles[-1])
            else:
                driver.get(target_url)
        
        try:
            WebDriverWait(driver, 5).until(
                lambda d: d.find_elements(By.ID, "daily-discount") or d.find_elements(By.NAME, "email")
            )
        except:
            pass
        
        if len(driver.find_elements(By.ID, "daily-discount")) > 0:
            print("[OK] Already logged in to MIS")
            login_success = True
        else:
            login_success = False
        
        if not login_success:
            try:
                email_field = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.NAME, "email"))
                )
                password_field = driver.find_element(By.NAME, "password")
                submit_btn = driver.find_element(By.CSS_SELECTOR, "button[type='submit']")
                
                email_field.click()
                email_field.send_keys(Keys.CONTROL + "a")
                email_field.send_keys(Keys.DELETE)
                email_field.send_keys(username)
                
                password_field.click()
                password_field.send_keys(Keys.CONTROL + "a")
                password_field.send_keys(Keys.DELETE)
                password_field.send_keys(password)
                
                submit_btn.click()
                
                WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "daily-discount"))
                )
                login_success = True
            except Exception as e:
                print(f"[ERROR] MIS login failed: {e}")
                return False
        
        if login_success:
            try:
                search_input = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
                )
                search_input.click()
                search_input.send_keys(Keys.CONTROL + "a")
                search_input.send_keys(Keys.DELETE)
                try:
                    driver.find_element(By.NAME, "daily-discount_length").send_keys("All")
                except:
                    pass
            except:
                pass
        
        return True
    except Exception as e:
        print(f"[ERROR] MIS login error: {e}")
        return False

def ensure_mis_ready(driver, gui_username: str = '', gui_password: str = '') -> bool:
    """
    INTELLIGENT MIS SESSION MANAGER
    
    Ensures MIS browser tab is open and logged in before any automation.
    Call this at the start of any MIS automation function.
    
    Steps:
    1. Find existing MIS tab OR create new one
    2. Switch to MIS tab
    3. Hard refresh the page
    4. Check login state (look for email field = logged out)
    5. If logged out, perform login using Setup tab credentials
    6. Verify login succeeded
    7. Return True when ready, raise Exception on failure
    
    Args:
        driver: Selenium WebDriver instance
        gui_username: Username from Setup tab (optional, will load from config if empty)
        gui_password: Password from Setup tab (optional, will load from config if empty)
    
    Returns:
        True if MIS is ready for automation
        
    Raises:
        Exception with user-friendly message on failure
    """
    MIS_URL = "https://mis.theartisttree.com/daily-discount"
    MIS_URL_FRAGMENT = "mis.theartisttree.com"
    
    print("[MIS-READY] Ensuring MIS session is ready...")
    
    try:
        # Store original tab to return to later if needed
        original_handle = driver.current_window_handle
        
        # Step 1: Find existing MIS tab
        mis_tab = None
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if MIS_URL_FRAGMENT in driver.current_url:
                mis_tab = handle
                print(f"[MIS-READY] Found existing MIS tab")
                break
        
        # Step 2: If no MIS tab exists, create one
        if not mis_tab:
            print(f"[MIS-READY] No MIS tab found, creating new tab...")
            driver.execute_script(f"window.open('{MIS_URL}', '_blank');")
            time.sleep(2)
            # Switch to the new tab (last one)
            mis_tab = driver.window_handles[-1]
            driver.switch_to.window(mis_tab)
            print(f"[MIS-READY] Created new MIS tab")
        
        # Step 3: Hard refresh the page
        print(f"[MIS-READY] Refreshing page to check session...")
        driver.refresh()
        time.sleep(2)
        
        # Step 4: Wait for page to load (either login form or daily-discount table)
        try:
            WebDriverWait(driver, 10).until(
                lambda d: d.find_elements(By.NAME, "email") or d.find_elements(By.ID, "daily-discount")
            )
        except:
            # Page might be slow, give it more time
            time.sleep(3)
        
        # Step 5: Check if logged out (email field present)
        is_logged_out = len(driver.find_elements(By.NAME, "email")) > 0
        is_logged_in = len(driver.find_elements(By.ID, "daily-discount")) > 0
        
        if is_logged_in:
            print(f"[MIS-READY] √¢≈ì‚Äú Already logged in to MIS")
            return True
        
        if is_logged_out:
            print(f"[MIS-READY] Session expired, performing login...")
            
            # Get credentials - prefer GUI credentials, fallback to JSON config
            username = gui_username.strip() if gui_username else ''
            password = gui_password.strip() if gui_password else ''
            
            if not username or not password:
                # Try loading from config file
                try:
                    creds = load_credentials_config()
                    username = creds.get('mis_username', '')
                    password = creds.get('mis_password', '')
                except:
                    pass
            
            # Verify we have credentials
            if not username or not password:
                raise Exception(
                    "√¢≈°¬†√Ø¬∏¬è MIS Login Required\n\n"
                    "MIS session has expired and no credentials are saved.\n\n"
                    "Please enter your MIS credentials in the Setup tab and try again."
                )
            
            # Perform login
            try:
                email_field = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.NAME, "email"))
                )
                password_field = driver.find_element(By.NAME, "password")
                submit_btn = driver.find_element(By.CSS_SELECTOR, "button[type='submit']")
                
                # Clear and enter email
                email_field.click()
                email_field.send_keys(Keys.CONTROL + "a")
                email_field.send_keys(Keys.DELETE)
                email_field.send_keys(username)
                
                # Clear and enter password
                password_field.click()
                password_field.send_keys(Keys.CONTROL + "a")
                password_field.send_keys(Keys.DELETE)
                password_field.send_keys(password)
                
                # Submit
                submit_btn.click()
                print(f"[MIS-READY] Login submitted, waiting for verification...")
                
                # Wait for login to complete
                WebDriverWait(driver, 15).until(
                    EC.presence_of_element_located((By.ID, "daily-discount"))
                )
                
                print(f"[MIS-READY] √¢≈ì‚Äú Login successful!")
                
                # Set table to show all records
                try:
                    length_select = driver.find_element(By.NAME, "daily-discount_length")
                    length_select.send_keys("All")
                    time.sleep(1)
                except:
                    pass
                
                return True
                
            except Exception as login_error:
                raise Exception(
                    f"√¢¬ù≈í MIS Login Failed\n\n"
                    f"Could not log in to MIS. Please check your credentials in the Setup tab.\n\n"
                    f"Error: {str(login_error)}"
                )
        
        # If we get here, page state is unknown - try navigating to MIS URL directly
        print(f"[MIS-READY] Unknown page state, navigating to MIS...")
        driver.get(MIS_URL)
        time.sleep(3)
        
        # Check again
        if len(driver.find_elements(By.ID, "daily-discount")) > 0:
            print(f"[MIS-READY] √¢≈ì‚Äú MIS is ready")
            return True
        elif len(driver.find_elements(By.NAME, "email")) > 0:
            # Recursively call self to handle login
            return ensure_mis_ready(driver, gui_username, gui_password)
        else:
            raise Exception("√¢¬ù≈í Could not determine MIS page state. Please try Initialize again.")
            
    except Exception as e:
        print(f"[MIS-READY] Error: {e}")
        raise

def filter_and_open_mis_id(driver, mis_id: str) -> bool:
    """Filter MIS table and open edit popup."""
    try:
        try:
            close_buttons = driver.find_elements(By.CSS_SELECTOR, "button.close[data-dismiss='modal']")
            for btn in close_buttons:
                if btn.is_displayed():
                    btn.click()
                    time.sleep(0.5)
                    break
        except:
            pass
        
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "daily-discount"))
        )
        
        try:
            length_select = WebDriverWait(driver, 3).until(
                EC.presence_of_element_located((By.NAME, "daily-discount_length"))
            )
            length_select.send_keys("All")
        except:
            pass
        
        search_input = driver.find_element(By.CSS_SELECTOR, "input[type='search']")
        search_input.click()
        search_input.send_keys(Keys.CONTROL + "a")
        search_input.send_keys(Keys.DELETE)
        search_input.send_keys(str(mis_id))
        time.sleep(1)
        
        edit_btn = WebDriverWait(driver, 5).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, f"a.btn-table-dialog[data-id='{mis_id}']"))
        )
        edit_btn.click()
        time.sleep(1)
        return True
    except Exception as e:
        print(f"[ERROR] Failed to filter/open MIS ID {mis_id}: {e}")
        return False

def open_google_sheet_in_browser(spreadsheet_id: str, sheet_name: str, row_number: int = None) -> bool:
    """Open Google Sheet with native tab management."""
    try:
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return False
        
        gid = get_sheet_gid(spreadsheet_id, sheet_name)
        base_url = f"https://docs.google.com/spreadsheets/d/{spreadsheet_id}/edit"
        
        target_url = base_url
        if gid:
            target_url += f"#gid={gid}"
        if row_number:
            target_url += f"&range={row_number}:{row_number}"
        
        sheet_tab_found = False
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if spreadsheet_id in driver.current_url:
                sheet_tab_found = True
                if row_number or gid:
                    driver.get(target_url)
                break
        
        if not sheet_tab_found:
            driver.switch_to.new_window('tab')
            driver.get(target_url)
        
        return True
    except Exception as e:
        print(f"[ERROR] Failed to open Google Sheet: {e}")
        return False

def get_sheet_gid(spreadsheet_id: str, sheet_name: str) -> Optional[str]:
    """Get GID for specific sheet."""
    try:
        service = GLOBAL_DATA['sheets_service']
        if not service:
            return None
        metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        sheets = metadata.get('sheets', [])
        for sheet in sheets:
            if sheet['properties']['title'] == sheet_name:
                return str(sheet['properties']['sheetId'])
        return None
    except:
        return None

# ============================================================================
# MIS HELPER FUNCTIONS
# ============================================================================
def extract_spreadsheet_id(url: str) -> Optional[str]:
    match = re.search(r'/spreadsheets/d/([a-zA-Z0-9-_]+)', url)
    return match.group(1) if match else None

def get_available_tabs(spreadsheet_id: str) -> List[str]:
    try:
        service = GLOBAL_DATA['sheets_service']
        if not service:
            return []
        metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        return [sheet['properties']['title'] for sheet in metadata.get('sheets', [])]
    except:
        return []

def detect_header_row(sheet_data: List[List[str]]) -> int:
    """
    Detects the header row index by scanning for key column names.
    Scans first 10 rows for keywords like 'Brand', 'Deal', 'Discount'.
    """
    key_columns = ['Brand', 'Weekday', 'Deal', 'Discount', 'Location']
    for row_idx, row in enumerate(sheet_data[:10]):
        row_str = ' '.join([str(cell).strip() for cell in row]).lower()
        matches = sum(1 for keyword in key_columns if keyword.lower() in row_str)
        # If we find at least 3 matching keywords, we assume this is the header row
        if matches >= 3:
            return row_idx
    return 0

def fetch_google_sheet_data(tab_name: str) -> Dict[str, pd.DataFrame]:
    """
    Fetch Google Sheet data and split into sections: Weekly, Monthly, Sale.
    Returns: {'weekly': df, 'monthly': df, 'sale': df}
    """
    try:
        service = GLOBAL_DATA['sheets_service']
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        
        if not service or not spreadsheet_id:
            raise ValueError("Service not available")
        
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{tab_name}'!A1:AZ2000"
        ).execute()
        
        values = result.get('values', [])
        empty_ret = {'weekly': pd.DataFrame(), 'monthly': pd.DataFrame(), 'sale': pd.DataFrame()}
        if not values:
            return empty_ret
        
        header_row_idx = detect_header_row(values)
        GLOBAL_DATA['mis']['header_row_idx'] = header_row_idx
        
        # Get standardized headers from the first section (Weekly)
        headers = [str(cell).strip() for cell in values[header_row_idx]]
        headers.append('_SHEET_ROW_NUM')
        expected_cols = len(headers)
        
        # Cleanup column names
        clean_cols = [col if col == '_SHEET_ROW_NUM' else col.strip().replace('\n', ' ') for col in headers]
        
        sections = {'weekly': [], 'monthly': [], 'sale': []}
        current_section = 'weekly'
        
        # Start scanning AFTER the first header
        i = header_row_idx + 1
        while i < len(values):
            row = values[i]
            row_str = " ".join([str(cell).strip() for cell in row]).upper()
            
            # --- SECTION SWITCHING LOGIC ---
            if "END420" in row_str:
                print(f"[SHEET-PARSE] Found END420 at row {i+1}, stopping parse")
                break # Stop parsing completely
            
            if "MONTHLYSTART" in row_str:
                print(f"[SHEET-PARSE] Found MONTHLYSTART at row {i+1}, switching to monthly section")
                current_section = 'monthly'
                i += 2 # Skip this flag row AND the next row (the new header)
                continue
                
            if "SALESTART" in row_str:
                print(f"[SHEET-PARSE] Found SALESTART at row {i+1}, switching to sale section")
                current_section = 'sale'
                i += 2 # Skip this flag row AND the next row (the new header)
                continue
                
            if "BREAK420" in row_str:
                i += 1
                continue
            
            # Process Data Row
            if len(row) >= 2 and str(row[1]).strip():
                # Pad/Slice to match header length exactly
                padded_row = row + [''] * (expected_cols - len(row))
                padded_row = padded_row[:expected_cols - 1] 
                padded_row.append(i + 1) # Add 1-based row number
                
                sections[current_section].append(padded_row)
            
            i += 1
            
        # Convert lists to DataFrames
        print(f"[SHEET-PARSE] Section summary: weekly={len(sections['weekly'])}, monthly={len(sections['monthly'])}, sale={len(sections['sale'])}")
        final_dfs = {}
        for sec, rows in sections.items():
            if rows:
                df = pd.DataFrame(rows, columns=clean_cols)
            else:
                df = pd.DataFrame(columns=clean_cols)
            final_dfs[sec] = df
            
        GLOBAL_DATA['mis']['current_sheet'] = tab_name
        return final_dfs

    except Exception as e:
        print(f"[ERROR] Failed to fetch sheet: {e}")
        traceback.print_exc()
        return {'weekly': pd.DataFrame(), 'monthly': pd.DataFrame(), 'sale': pd.DataFrame()}

def fetch_tax_rates() -> dict:
    """
    Fetch tax rates with priority: DEFAULT_TAX_RATES < tax_config.json overrides
    No longer depends on Google Sheets for reliability.
    Returns: dict mapping store names to tax rates
    """
    # Start with hardcoded defaults
    tax_rates = DEFAULT_TAX_RATES.copy()
    
    # Try to load local overrides from tax_config.json
    if TAX_CONFIG_FILE.exists():
        try:
            with open(TAX_CONFIG_FILE, 'r') as f:
                local_overrides = json.load(f)
                # Merge: local overrides take precedence
                tax_rates.update(local_overrides)
                print(f"[TAX] Loaded {len(tax_rates)} tax rates (default + local overrides)")
        except Exception as e:
            print(f"[TAX] Failed to load tax_config.json: {e}")
            print(f"[TAX] Using {len(tax_rates)} default tax rates")
    else:
        print(f"[TAX] Using {len(tax_rates)} default tax rates (no local overrides)")
    
    return tax_rates

def get_col(row: pd.Series, possible_names: List[str], default: Any = '') -> Any:
    for name in possible_names:
        if name in row.index and pd.notna(row[name]):
            return row[name]
    return default

def manage_brand_list(mis_df: pd.DataFrame) -> List[str]:
    """Manage brand list."""
    stored_brands = set()
    if BRAND_LIST_FILE.exists():
        try:
            with open(BRAND_LIST_FILE, 'r', encoding='utf-8') as f:
                stored_brands = {line.strip() for line in f if line.strip()}
        except:
            pass
    
    mis_brands = set()
    if 'Brand' in mis_df.columns:
        mis_brands = {str(b).strip() for b in mis_df['Brand'].dropna().unique() if str(b).strip()}
    
    new_brands = mis_brands - stored_brands
    if new_brands:
        updated_brands = stored_brands.union(new_brands)
        try:
            with open(BRAND_LIST_FILE, 'w', encoding='utf-8') as f:
                for brand in sorted(updated_brands, key=str.lower):
                    f.write(f"{brand}\n")
        except:
            pass
        return list(updated_brands)
    return list(stored_brands)

def parse_percentage(value: Any) -> float:
    if pd.isna(value):
        return 0.0
    val_str = str(value).strip().replace('%', '').replace(',', '')
    try:
        return float(val_str)
    except:
        return 0.0

def parse_end_date(contracted_duration: str, default: str = '') -> Tuple[str, str]:
    if not contracted_duration or pd.isna(contracted_duration):
        return (default, default)
    parts = str(contracted_duration).split('-')
    if len(parts) == 2:
        return (parts[0].strip(), parts[1].strip())
    return (default, default)

def format_location_display(locations: str, exceptions: str) -> str:
    if pd.isna(locations) or not str(locations).strip():
        return "Not Specified"
    loc_str = str(locations).strip()
    exc_str = str(exceptions).strip() if pd.notna(exceptions) else ""
    if exc_str:
        if "except" in loc_str.lower():
            loc_str = "All Locations"
        return f"{loc_str} (Except: {exc_str})"
    return loc_str

def format_category_display(categories: str, exceptions: str) -> str:
    if pd.isna(categories) or not str(categories).strip():
        return "Not Specified"
    cat_str = str(categories).strip()
    exc_str = str(exceptions).strip() if pd.notna(exceptions) else ""
    return f"{cat_str} (Except: {exc_str})" if exc_str else cat_str

# ============================================================================
# DATE-AWARE CONFLICT DETECTION HELPERS
# ============================================================================
def parse_tab_month_year(tab_name: str) -> Tuple[int, int]:
    """
    Parse tab name (e.g., "December 2025", "Jan 2026", "Dec 25") to extract month and year.
    Returns: (month_number, year) or (current_month, current_year) as fallback
    """
    import calendar
    from datetime import datetime
    
    # Default to current month/year
    now = datetime.now()
    default_month, default_year = now.month, now.year
    
    if not tab_name:
        return (default_month, default_year)
    
    tab_clean = tab_name.strip()
    
    # Month name mappings (full and abbreviated)
    month_names = {
        'january': 1, 'jan': 1,
        'february': 2, 'feb': 2,
        'march': 3, 'mar': 3,
        'april': 4, 'apr': 4,
        'may': 5,
        'june': 6, 'jun': 6,
        'july': 7, 'jul': 7,
        'august': 8, 'aug': 8,
        'september': 9, 'sep': 9, 'sept': 9,
        'october': 10, 'oct': 10,
        'november': 11, 'nov': 11,
        'december': 12, 'dec': 12
    }
    
    # Try to extract month and year
    import re
    
    # Pattern 1: "December 2025" or "Dec 2025"
    match = re.search(r'([a-zA-Z]+)\s*(\d{4})', tab_clean)
    if match:
        month_str = match.group(1).lower()
        year = int(match.group(2))
        if month_str in month_names:
            return (month_names[month_str], year)
    
    # Pattern 2: "Dec 25" or "December 25" (assume 20XX)
    match = re.search(r'([a-zA-Z]+)\s*(\d{2})$', tab_clean)
    if match:
        month_str = match.group(1).lower()
        year_short = int(match.group(2))
        year = 2000 + year_short if year_short < 100 else year_short
        if month_str in month_names:
            return (month_names[month_str], year)
    
    # Pattern 3: Just month name (use current or next year)
    for month_str, month_num in month_names.items():
        if month_str in tab_clean.lower():
            # If the month is in the past this year, assume next year
            if month_num < now.month:
                return (month_num, now.year + 1)
            return (month_num, now.year)
    
    return (default_month, default_year)

def expand_weekday_to_dates(weekday_str: str, target_month: int, target_year: int) -> List[date]:
    """
    For Weekly deals: Convert day name (e.g., "Monday", "Tue") to all dates in the target month.
    Returns: List of datetime.date objects for all occurrences of that weekday in the month.
    """
    import calendar
    from datetime import date
    
    if not weekday_str or weekday_str.strip().lower() in ['', 'nan', 'none', '-']:
        return []
    
    # Weekday mappings (0=Monday, 6=Sunday)
    weekday_map = {
        'monday': 0, 'mon': 0, 'mo': 0,
        'tuesday': 1, 'tue': 1, 'tu': 1, 'tues': 1,
        'wednesday': 2, 'wed': 2, 'we': 2,
        'thursday': 3, 'thu': 3, 'th': 3, 'thur': 3, 'thurs': 3,
        'friday': 4, 'fri': 4, 'fr': 4,
        'saturday': 5, 'sat': 5, 'sa': 5,
        'sunday': 6, 'sun': 6, 'su': 6
    }
    
    day_key = weekday_str.strip().lower()
    if day_key not in weekday_map:
        return []
    
    target_weekday = weekday_map[day_key]
    
    # Get all days in the target month
    num_days = calendar.monthrange(target_year, target_month)[1]
    result_dates = []
    
    for day in range(1, num_days + 1):
        d = date(target_year, target_month, day)
        if d.weekday() == target_weekday:
            result_dates.append(d)
    
    return result_dates

def parse_monthly_dates(date_str: str, target_month: int, target_year: int) -> List[date]:
    """
    For Monthly deals: Parse ordinals ("10th", "1st, 15th") or date formats ("12/25/25").
    Returns: List of datetime.date objects.
    """
    import re
    from datetime import date
    import calendar
    
    if not date_str or date_str.strip().lower() in ['', 'nan', 'none', '-']:
        return []
    
    result_dates = []
    date_clean = date_str.strip()
    
    # Split by common delimiters: comma, &, "and"
    parts = re.split(r'[,&]|\band\b', date_clean, flags=re.IGNORECASE)
    
    for part in parts:
        part = part.strip()
        if not part:
            continue
        
        # Pattern 1: Ordinal numbers ("1st", "2nd", "3rd", "10th", "21st")
        ordinal_match = re.search(r'(\d+)(?:st|nd|rd|th)', part, re.IGNORECASE)
        if ordinal_match:
            day = int(ordinal_match.group(1))
            num_days = calendar.monthrange(target_year, target_month)[1]
            if 1 <= day <= num_days:
                result_dates.append(date(target_year, target_month, day))
            continue
        
        # Pattern 2: Full date "MM/DD/YY" or "MM/DD/YYYY" or "MM-DD-YY"
        date_match = re.search(r'(\d{1,2})[/\-](\d{1,2})[/\-](\d{2,4})', part)
        if date_match:
            month = int(date_match.group(1))
            day = int(date_match.group(2))
            year = int(date_match.group(3))
            if year < 100:
                year = 2000 + year
            try:
                result_dates.append(date(year, month, day))
            except ValueError:
                pass  # Invalid date
            continue
        
        # Pattern 3: Just a number (assume day of target month)
        num_match = re.search(r'^(\d+)$', part)
        if num_match:
            day = int(num_match.group(1))
            num_days = calendar.monthrange(target_year, target_month)[1]
            if 1 <= day <= num_days:
                result_dates.append(date(target_year, target_month, day))
    
    return result_dates

def parse_sale_dates(date_str: str, target_month: int, target_year: int) -> List[date]:
    """
    For Sale deals: Parse formats like "12/24/25 - Wednesday", "12/31/25 - Wednesday".
    Extracts the date portion, ignoring the day name suffix.
    Returns: List of datetime.date objects.
    """
    import re
    from datetime import date
    
    if not date_str or date_str.strip().lower() in ['', 'nan', 'none', '-']:
        return []
    
    result_dates = []
    date_clean = date_str.strip()
    
    # Split by common delimiters: comma, &, "and"
    parts = re.split(r'[,&]|\band\b', date_clean, flags=re.IGNORECASE)
    
    for part in parts:
        part = part.strip()
        if not part:
            continue
        
        # Pattern 1: "MM/DD/YY - DayName" or "MM/DD/YYYY - DayName"
        # Extract just the date portion before the dash+day
        date_match = re.search(r'(\d{1,2})[/\-](\d{1,2})[/\-](\d{2,4})', part)
        if date_match:
            month = int(date_match.group(1))
            day = int(date_match.group(2))
            year = int(date_match.group(3))
            if year < 100:
                year = 2000 + year
            try:
                result_dates.append(date(year, month, day))
            except ValueError:
                pass  # Invalid date
            continue
        
        # Pattern 2: Ordinal ("25th", "1st") - treat as target month
        ordinal_match = re.search(r'(\d+)(?:st|nd|rd|th)', part, re.IGNORECASE)
        if ordinal_match:
            day_num = int(ordinal_match.group(1))
            import calendar
            num_days = calendar.monthrange(target_year, target_month)[1]
            if 1 <= day_num <= num_days:
                result_dates.append(date(target_year, target_month, day_num))
    
    return result_dates

def get_all_weekdays_for_multiday_group(group_data: Dict, section_df: pd.DataFrame, section_key: str, target_month: int, target_year: int) -> List[date]:
    """
    For a multi-day group (e.g., Stiiizy Mon/Tue/Wed), expand ALL weekdays to actual dates.
    Returns: Combined list of dates from all weekdays in the group.
    """
    all_dates = []
    weekdays = group_data.get('weekdays', [])
    
    for weekday in weekdays:
        if weekday and weekday != '[!] [EMOJI]√É‚Äö√Ç¬è  MISSING':
            dates = expand_weekday_to_dates(weekday, target_month, target_year)
            all_dates.extend(dates)
    
    return list(set(all_dates))  # Remove duplicates

# ============================================================================
# MULTI-DAY DEAL DETECTION (NEW)
# ============================================================================
def detect_multi_day_groups(google_df: pd.DataFrame, section_type: str = 'weekly') -> Tuple[Dict[str, Dict], Dict[int, str]]:
    """
    Detect deals that span multiple days.
    UPDATED: Handles Column Swap for 'sale' section.
    """
    groups = {}
    row_to_group = {}
    
    for g_idx, g_row in google_df.iterrows():
        # Standard Logic for all sections (Removed Sale Swap)
        brand_raw = str(g_row.get('Brand', '')).strip()
        weekday_raw = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip().title()

        if not brand_raw:
            continue
        
        true_sheet_row = int(g_row['_SHEET_ROW_NUM']) if '_SHEET_ROW_NUM' in g_row else g_idx + 2
        
        discount = parse_percentage(get_col(g_row, ['Deal Discount Value/Type', 'Deal Discount'], ''))
        vendor_contrib = parse_percentage(get_col(g_row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
        loc_raw, exc_raw = resolve_location_columns(g_row)
        locations = format_location_display(loc_raw, exc_raw)
        categories = format_category_display(g_row.get('Categories', ''), g_row.get('Category Exceptions', ''))
        special_notes = str(g_row.get('SPECIAL NOTES', '')).strip()
        deal_info = str(get_col(g_row, ['Deal Information', 'Deal Info'], '')).strip()
        
        contracted_duration = get_col(g_row, ['Contracted Duration (MM/DD/YY - MM/DD/YY)', 'Contracted Duration'], '')
        start_date, end_date = parse_end_date(contracted_duration)
        
        group_key = f"{brand_raw}|{discount}|{vendor_contrib}|{locations}|{categories}|{special_notes}|{deal_info}|{start_date}|{end_date}"
        group_id = hashlib.md5(group_key.encode()).hexdigest()[:12]
        
        has_missing_weekday = not weekday_raw or weekday_raw.lower() in ['', 'nan', 'none']
        
        if group_id not in groups:
            groups[group_id] = {
                'rows': [],
                'weekdays': [],
                'brand': brand_raw,
                'has_missing_weekday': has_missing_weekday
            }
        
        groups[group_id]['rows'].append(true_sheet_row)
        groups[group_id]['weekdays'].append(weekday_raw if weekday_raw else '[!] [EMOJI]√É‚Äö√Ç¬è  MISSING')
        
        if has_missing_weekday:
            groups[group_id]['has_missing_weekday'] = True
        
        row_to_group[true_sheet_row] = group_id
    
    multi_day_groups = {gid: gdata for gid, gdata in groups.items() if len(gdata['rows']) > 1}
    
    return multi_day_groups, row_to_group

def should_skip_end420_row(row_dict: Dict) -> bool:
    """
    Check if a row should be skipped because it contains "END420" exactly in 2+ columns.
    This marks the end of valid data.
    
    Args:
        row_dict: Dictionary representing a row (can be from DataFrame.to_dict('records'))
    
    Returns:
        True if row should be skipped (has END420 in 2+ columns), False otherwise
    """
    end420_count = 0
    for value in row_dict.values():
        # Check for exact match "END420" (case-insensitive, strip whitespace)
        if isinstance(value, str) and value.strip().upper() == "END420":
            end420_count += 1
            if end420_count > 1:
                return True
    return False

def enhanced_match_mis_ids(google_df: pd.DataFrame, mis_df: pd.DataFrame, brand_list: List[str] = None, brand_settings: Dict[str, str] = None, section_type: str = 'weekly') -> List[Dict]:
    """
    V6 COMPATIBLE: Enhanced fuzzy matching with restored V1 SUGGESTIONS logic.
    - Generates confidence scores based on Brand, Discount, and Vendor %.
    - Returns top 5 suggestions for every row.
    - Handles Multi-Day Groups (Weekly only).
    - [FIX] Robust ID Column detection (ID vs MIS ID) and float cleanup.
    """
    matches = []
    header_offset = GLOBAL_DATA['mis'].get('header_row_idx', 0)
    
    if brand_settings is None:
        brand_settings = {}

    # --- [FIX] ROBUST ID COLUMN DETECTION ---
    # Find which column actually contains the ID in the CSV
    id_col_name = 'ID' # Default
    possible_cols = ['ID', 'id', 'MIS ID', 'Mis Id', 'MIS_ID', 'mis_id']
    for col in possible_cols:
        if col in mis_df.columns:
            id_col_name = col
            break
            
    # Helper to get clean ID string (removes .0 from floats, handles NaN)
    def get_clean_mis_id(row):
        val = row.get(id_col_name)
        if pd.isna(val): return ''
        # Convert to string, strip whitespace, remove decimal if float (12345.0 -> 12345)
        s = str(val).strip()
        if s.endswith('.0'):
            return s[:-2]
        return s
    
    # 1. Detect Multi-Day Groups (ONLY for Weekly section)
    if section_type == 'weekly':
        multi_day_groups, row_to_group = detect_multi_day_groups(google_df, section_type)
    else:
        multi_day_groups, row_to_group = {}, {}
    
    def get_target_day(d):
        d = str(d).strip().lower()
        if 'mon' in d: return 'monday'
        if 'tue' in d: return 'tuesday'
        if 'wed' in d: return 'wednesday'
        if 'thu' in d: return 'thursday'
        if 'fri' in d: return 'friday'
        if 'sat' in d: return 'saturday'
        if 'sun' in d: return 'sunday'
        return ''
    
    for g_idx, g_row in google_df.iterrows():
        if should_skip_end420_row(g_row.to_dict()):
            continue
        
        # Handle swapped columns for Sale section if necessary
        if section_type == 'sale':
            brand_raw = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
            weekday_raw = str(g_row.get('Brand', '')).strip()
        else:
            brand_raw = str(g_row.get('Brand', '')).strip()
            weekday_raw = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()

        if not brand_raw:
            continue
        
        true_sheet_row = int(g_row['_SHEET_ROW_NUM']) if '_SHEET_ROW_NUM' in g_row else header_offset + g_idx + 2
        
        # --- MULTI-DAY METADATA (base - will be extended per brand) ---
        base_group_metadata = None
        group_id = None
        if true_sheet_row in row_to_group:
            group_id = row_to_group[true_sheet_row]
            if group_id in multi_day_groups:
                group_data = multi_day_groups[group_id]
                current_idx = group_data['rows'].index(true_sheet_row)
                base_group_metadata = {
                    'group_id': group_id,
                    'total_days': len(group_data['rows']),
                    'row_numbers': group_data['rows'],
                    'weekdays': group_data['weekdays'],
                    'current_index': current_idx,
                    'has_missing_weekday': group_data['has_missing_weekday']
                }

        weekday_target = get_target_day(weekday_raw)
        
        discount = parse_percentage(get_col(g_row, ['Deal Discount Value/Type', 'Deal Discount'], ''))
        vendor_contrib = parse_percentage(get_col(g_row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
        category_raw = str(g_row.get('Categories', '')).strip()
        current_sheet_id = str(get_col(g_row, ['MIS ID', 'ID'], '')).strip()
        
        # v12.1: Parse multi-brand - create separate entries for each brand
        individual_brands = parse_multi_brand(brand_raw)
        is_multi_brand_row = len(individual_brands) > 1
        
        # For multi-brand, map existing MIS IDs to brands
        brand_to_ids = {}
        if is_multi_brand_row and current_sheet_id:
            brand_to_ids = match_mis_ids_to_brands(current_sheet_id, individual_brands, mis_df)
        
        # Process each brand separately (or just one if single brand)
        brands_to_process = individual_brands if individual_brands else [brand_raw]
        
        for brand_idx, current_brand in enumerate(brands_to_process):
            # v12.1: Create per-brand group_metadata with correct is_first flag
            group_metadata = None
            if base_group_metadata:
                current_idx = base_group_metadata['current_index']
                # is_first is True ONLY when first in day group AND first brand
                is_first_entry = (current_idx == 0) and (brand_idx == 0)
                total_entries = base_group_metadata['total_days'] * len(brands_to_process)
                
                group_metadata = {
                    'group_id': base_group_metadata['group_id'],
                    'total_days': base_group_metadata['total_days'],
                    'total_entries': total_entries,  # v12.1: Total entries (days * brands)
                    'row_numbers': base_group_metadata['row_numbers'],
                    'weekdays': base_group_metadata['weekdays'],
                    'current_index': current_idx,
                    'is_first': is_first_entry,  # v12.1: True only for first day + first brand
                    'is_first_brand': brand_idx == 0,  # v12.1: Track if first brand
                    'has_missing_weekday': base_group_metadata['has_missing_weekday'],
                    'brand_raw': brand_raw,  # v12.1: Full brand string for header
                    'is_multi_brand': is_multi_brand_row,  # v12.1: Flag for multi-brand group
                    'total_brands': len(brands_to_process)  # v12.1: Number of brands
                }
            
            # Filter candidates by Weekday (if applicable)
            try:
                if weekday_target:
                    candidates = mis_df[
                        mis_df['Weekday'].astype(str).str.lower().str.contains(weekday_target, regex=False, na=False)
                    ]
                else:
                    candidates = mis_df.copy()
            except:
                candidates = mis_df.copy()
            
            # --- SUGGESTION LOGIC FOR THIS SPECIFIC BRAND ---
            suggestions = []
            
            # v12.1: For multi-brand, get this brand's specific MIS IDs
            brand_specific_ids = []
            if is_multi_brand_row and current_brand in brand_to_ids:
                brand_specific_ids = [mis_id for (tag, mis_id) in brand_to_ids.get(current_brand, [])]
            
            # Current sheet ID for this brand
            if is_multi_brand_row:
                # For multi-brand, show this brand's IDs or empty if none
                brand_current_id = ', '.join([f"{tag}: {mid}" for tag, mid in brand_to_ids.get(current_brand, [])])
            else:
                brand_current_id = current_sheet_id

            for c_idx, c_row in candidates.iterrows():
                mis_brand = str(c_row.get('Brand', '')).strip()
                if not mis_brand:
                    continue
                
                best_brand_ratio = 0
                match_type = 'fuzzy'
                linked_brand_match = False  # v12.1: Track if linked brands match
                
                # v12.1: Match against this specific brand
                brand_part_clean = current_brand.strip()
                brand_lower = brand_part_clean.lower()
                mis_brand_lower = mis_brand.lower()
                
                # v12.1: Get MIS Linked Brand for comparison
                mis_linked_brand = str(c_row.get('Linked Brand (if applicable)', '')).strip()
                mis_linked_lower = mis_linked_brand.lower() if mis_linked_brand and mis_linked_brand.lower() not in ['n/a', 'nan', ''] else ''
                
                # v12.1: Get Google Sheet Linked Brand from Settings
                google_linked_brand = brand_settings.get(brand_part_clean, '')
                google_linked_lower = google_linked_brand.lower() if google_linked_brand else ''
                
                # STRICT MATCHING LOGIC:
                # 1. Exact Match (case-insensitive) - highest priority
                if brand_lower == mis_brand_lower:
                    best_brand_ratio = 100
                    match_type = 'exact'
                    # Check linked brand match for bonus
                    if google_linked_lower and mis_linked_lower:
                        if google_linked_lower == mis_linked_lower:
                            linked_brand_match = True
                
                # 2. Check for "contains but not exact" - PENALIZE this case
                # e.g., "Stiiizy" vs "Stiiizy Accessories" - one contains the other but not equal
                elif brand_lower in mis_brand_lower or mis_brand_lower in brand_lower:
                    # This is a partial containment - NOT a good match
                    # Give low score to prevent confusion between "Stiiizy" and "Stiiizy Accessories"
                    best_brand_ratio = 40  # Low score - will likely be filtered out
                    match_type = 'partial_contains'
                
                # 3. Linked Brand Match (from Settings)
                elif google_linked_lower:
                    # Check if MIS brand matches Google's linked brand
                    if google_linked_lower == mis_brand_lower:
                        best_brand_ratio = 90
                        match_type = 'linked_brand_match'
                        linked_brand_match = True
                    # Check if MIS linked brand matches Google's linked brand
                    elif mis_linked_lower and google_linked_lower == mis_linked_lower:
                        # Both have same linked brand - might be related
                        fuzzy_ratio = fuzz.token_set_ratio(brand_lower, mis_brand_lower)
                        if fuzzy_ratio > 80:
                            best_brand_ratio = fuzzy_ratio
                            match_type = 'linked_brand_partial'
                            linked_brand_match = True
                        else:
                            best_brand_ratio = fuzzy_ratio * 0.7  # Reduce score
                            match_type = 'linked_brand_weak'
                    else:
                        # Linked brand doesn't match - use fuzzy but reduced
                        fuzzy_ratio = fuzz.token_set_ratio(brand_lower, mis_brand_lower)
                        best_brand_ratio = fuzzy_ratio * 0.6  # Significant reduction
                        match_type = 'fuzzy_no_linked'
                
                # 4. Fuzzy Match as fallback (no linked brand configured)
                else:
                    fuzzy_ratio = fuzz.token_set_ratio(brand_lower, mis_brand_lower)
                    # Additional check: if fuzzy is high but it's a "contains" situation, penalize
                    if fuzzy_ratio > 85 and (brand_lower in mis_brand_lower or mis_brand_lower in brand_lower):
                        best_brand_ratio = 50  # Penalize high fuzzy that's actually partial
                        match_type = 'fuzzy_partial'
                    else:
                        best_brand_ratio = fuzzy_ratio
                        match_type = 'fuzzy'
            
                if best_brand_ratio < 60:
                    continue
            
                # Base Score
                score_brand = (best_brand_ratio / 100) * 50
                apply_bonuses = best_brand_ratio >= 75
                
                # v12.1: Linked brand match bonus
                if linked_brand_match:
                    score_brand += 5  # Bonus for matching linked brands
            
                # 2. Discount Match Score
                mis_discount = float(c_row.get('Daily Deal Discount', 0))
                score_discount = 0
                if apply_bonuses:
                    if abs(discount - mis_discount) < 0.01:
                        score_discount = 30
                    elif abs(discount - mis_discount) <= 5:
                        score_discount = 15
            
                # 3. Vendor Contribution Match Score
                mis_vendor = float(c_row.get('Discount paid by vendor', 0))
                score_vendor = 0
                if apply_bonuses:
                    if abs(vendor_contrib - mis_vendor) < 0.01:
                        score_vendor = 15
            
                # 4. Category Match Score
                mis_category = str(c_row.get('Category', '')).strip()
                score_category = 0
                if category_raw and mis_category:
                    google_cats = set(c.strip().lower() for c in category_raw.split(',') if c.strip())
                    mis_cats = set(c.strip().lower() for c in mis_category.split(',') if c.strip())
                    if google_cats == mis_cats: score_category = 5
                    elif google_cats.issubset(mis_cats): score_category = 5
                    elif len(google_cats & mis_cats) > 0: score_category = 3
                elif not category_raw and not mis_category:
                    score_category = 5
            
                # Final Confidence Calculation
                final_confidence = min(round(score_brand + score_discount + score_vendor + score_category), 100)
            
                # Build Display Data
                locs = str(c_row.get('Store', '')).strip()
                if not locs or locs.lower() == 'nan': locs = "All Locations"
            
                # [FIX] USE ROBUST ID GETTER HERE
                clean_mis_id = get_clean_mis_id(c_row)

                # v12.1: Capture all raw CSV data for "More Info" popup
                raw_csv_data = {}
                for col in c_row.index:
                    try:
                        val = c_row[col]
                        # Handle Series (duplicate columns) by taking first value
                        if hasattr(val, 'iloc'):
                            val = val.iloc[0] if len(val) > 0 else ''
                        # Convert to string and check for empty/nan
                        val_str = str(val).strip() if val is not None else ''
                        if val_str and val_str.lower() not in ['', 'nan', 'none', 'nat']:
                            raw_csv_data[col] = val_str
                    except:
                        pass  # Skip problematic columns

                mis_data_pack = {
                    'id': clean_mis_id,
                    'brand': mis_brand,
                    'linked_brand': str(c_row.get('Linked Brand (if applicable)', 'N/A')),
                    'locations': locs,
                    'weekdays': str(c_row.get('Weekday', 'N/A')),
                    'start_date': str(c_row.get('Start date', 'N/A')),
                    'end_date': str(c_row.get('End date', 'N/A')),
                    'category': mis_category or 'N/A',
                    'discount': mis_discount,
                    'vendor_contribution': mis_vendor,
                    'raw_csv_data': raw_csv_data,  # v12.1: All MIS CSV columns for More Info
                    'linked_brand_match': linked_brand_match,  # v12.1: Whether linked brands matched
                    'match_type': match_type  # v12.1: Type of brand match
                }

                # v12.1: Enhanced reasoning with match type details
                reasoning_parts = [f"Brand: {int(best_brand_ratio)}%"]
                if match_type == 'exact': 
                    reasoning_parts.append("(exact)")
                elif match_type == 'linked_brand_match': 
                    reasoning_parts.append("(linked)")
                elif match_type == 'partial_contains':
                    reasoning_parts.append("(partial - similar name)")
                elif match_type == 'fuzzy_partial':
                    reasoning_parts.append("(fuzzy - similar name)")
                if linked_brand_match:
                    reasoning_parts.append("[LB√¢≈ì‚Äú]")  # Linked Brand matched
            
                suggestions.append({
                    'mis_id': clean_mis_id,
                    'confidence': final_confidence,
                    'reasoning': ' '.join(reasoning_parts),
                    'mis_data': mis_data_pack
                })
        
            # Sort by confidence (Highest first) and take top 5
            suggestions = sorted(suggestions, key=lambda x: x['confidence'], reverse=True)[:5]
        
            # Determine Match Status based on top suggestion
            matched_mis_id = ''
            status = 'LOW'
            if suggestions:
                top_conf = suggestions[0]['confidence']
                if top_conf >= 85: 
                    matched_mis_id = suggestions[0]['mis_id']
                
                if top_conf >= 95: status = 'HIGH'
                elif top_conf >= 70: status = 'MEDIUM'
            
            # v12.1: Add to results with multi-brand metadata
            # Look up linked brand from brand_settings (same as Creation Checklist)
            linked_brand_from_settings = ''
            lookup_key = current_brand.lower().strip()
            if lookup_key in brand_settings:
                target_linked = brand_settings[lookup_key]
                if target_linked.lower() != current_brand.lower():
                    linked_brand_from_settings = target_linked
            
            # v12.1: Capture all raw row data for "More Info" popup
            raw_row_data = {}
            for col in g_row.index:
                try:
                    val = g_row[col]
                    # Handle Series (duplicate columns) by taking first value
                    if hasattr(val, 'iloc'):
                        val = val.iloc[0] if len(val) > 0 else ''
                    # Convert to string and check for empty/nan
                    val_str = str(val).strip() if val is not None else ''
                    # Include FALSE/True values for checkboxes - only exclude truly empty/invalid values
                    if val_str and val_str.lower() not in ['', 'nan', 'none', 'nat', '<na>']:
                        raw_row_data[col] = val_str
                except:
                    pass  # Skip problematic columns
            
            matches.append({
                'google_row': true_sheet_row,
                'brand': current_brand,  # v12.1: Individual brand, not full multi-brand string
                'brand_raw': brand_raw,  # v12.1: Original multi-brand string
                'linked_brand': linked_brand_from_settings,  # v12.1: From Settings tab (same as Creation Checklist)
                'is_multi_brand': is_multi_brand_row,  # v12.1: Flag for multi-brand
                'multi_brand_index': brand_idx if is_multi_brand_row else None,  # v12.1: Index in multi-brand list
                'multi_brand_total': len(brands_to_process) if is_multi_brand_row else 1,  # v12.1: Total brands in row
                'weekday': weekday_raw,
                'section': section_type,
                'discount': discount,
                'vendor_contrib': vendor_contrib,
                'current_sheet_id': brand_current_id,  # v12.1: This brand's MIS IDs only
                'current_sheet_id_raw': current_sheet_id,  # v12.1: Full MIS ID cell
                'matched_mis_id': matched_mis_id,
                'confidence': suggestions[0]['confidence'] if suggestions else 0,
                'status': status,
                'suggestions': suggestions,
                'locations': format_location_display(*resolve_location_columns(g_row)),
                'categories': format_category_display(g_row.get('Categories'), g_row.get('Category Exceptions')),
                'special_notes': str(g_row.get('SPECIAL NOTES', '')),
                'deal_info': str(get_col(g_row, ['Deal Information', 'Deal Info'], '')),
                'blaze_discount_title': str(get_col(g_row, ['Blaze Discount Title'], '')),  # v12.7: For auto-loading
                'multi_day_group': group_metadata,
                'raw_row_data': raw_row_data  # v12.1: All Google Sheet columns for More Info
            })
    
    return matches

def audit_google_vs_mis(google_df: pd.DataFrame, mis_df: pd.DataFrame, section_type: str = 'weekly') -> List[Dict]:
    """Audit with multi-day deal detection and section awareness."""
    results = []
    
    # 1. Detect Groups (ONLY for Weekly)
    if section_type == 'weekly':
        multi_day_groups, row_to_group = detect_multi_day_groups(google_df, section_type)
    else:
        multi_day_groups, row_to_group = {}, {}
    
    for g_idx, g_row in google_df.iterrows():
        if should_skip_end420_row(g_row.to_dict()):
            continue
        
        if section_type == 'sale':
            brand = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
            weekday = str(g_row.get('Brand', '')).strip()
        else:
            brand = str(g_row.get('Brand', '')).strip()
            weekday = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()

        if not brand:
            continue
        
        true_sheet_row = int(g_row['_SHEET_ROW_NUM']) if '_SHEET_ROW_NUM' in g_row else GLOBAL_DATA['mis'].get('header_row_idx', 0) + g_idx + 2
        
        discount = parse_percentage(get_col(g_row, ['Deal Discount Value/Type', 'Deal Discount'], ''))
        special_notes = str(g_row.get('SPECIAL NOTES', '')).strip()
        deal_info = str(get_col(g_row, ['Deal Information', 'Deal Info'], '')).strip()
        vendor_contrib = parse_percentage(get_col(g_row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
        
        loc_raw, exc_raw = resolve_location_columns(g_row)
        locations = format_location_display(loc_raw, exc_raw)
        categories = format_category_display(g_row.get('Categories', ''), g_row.get('Category Exceptions', ''))
        
        mis_ids_str = str(get_col(g_row, ['MIS ID', 'ID'], '')).strip()
        
        # --- MULTI-DAY METADATA ---
        group_metadata = None
        if true_sheet_row in row_to_group:
            group_id = row_to_group[true_sheet_row]
            if group_id in multi_day_groups:
                group_data = multi_day_groups[group_id]
                current_idx = group_data['rows'].index(true_sheet_row)
                group_metadata = {
                    'group_id': group_id,
                    'total_days': len(group_data['rows']),
                    'row_numbers': group_data['rows'],
                    'weekdays': group_data['weekdays'],
                    'current_index': current_idx,
                    'is_first': current_idx == 0,
                    'has_missing_weekday': group_data['has_missing_weekday']
                }
        
        if mis_ids_str:
            mis_ids = [id.strip() for id in mis_ids_str.split(',') if id.strip()]
            
            for mis_id in mis_ids:
                try:
                    matches = mis_df[mis_df['ID'].astype(str).str.strip() == mis_id]
                except KeyError:
                    results.append({
                        'google_row': true_sheet_row,
                        'mis_id': mis_id,
                        'brand': brand,
                        'status': 'ERROR',
                        'discrepancies': ['MIS CSV missing ID column'],
                        'weekday': weekday,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'categories': categories,
                        'special_notes': special_notes,
                        'deal_info': deal_info,
                        'multi_day_group': group_metadata
                    })
                    continue
                
                if matches.empty:
                    results.append({
                        'google_row': true_sheet_row,
                        'mis_id': mis_id,
                        'brand': brand,
                        'status': 'ID NOT FOUND IN MIS',
                        'discrepancies': [],
                        'weekday': weekday,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'categories': categories,
                        'special_notes': special_notes,
                        'deal_info': deal_info,
                        'multi_day_group': group_metadata
                    })
                    continue
                
                m_row = matches.iloc[0]
                discrepancies = []
                
                mis_discount = float(m_row.get('Daily Deal Discount', 0))
                if abs(discount - mis_discount) > 0.01:
                    discrepancies.append(f"Discount: Google={discount}% vs MIS={mis_discount}%")
                
                results.append({
                    'google_row': true_sheet_row,
                    'mis_id': mis_id,
                    'brand': brand,
                    'weekday': weekday,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'categories': categories,
                    'special_notes': special_notes,
                    'deal_info': deal_info,
                    'status': 'DISCREPANCIES' if discrepancies else 'MATCH',
                    'discrepancies': discrepancies,
                    'multi_day_group': group_metadata
                })
        else:
            try:
                def check_weekday_match(target, candidate):
                    if not target: return True
                    t = target.lower()
                    c = str(candidate).lower()
                    for d in ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']:
                        if d in t and d in c: return True
                    return False

                candidates = mis_df[mis_df.apply(lambda x: check_weekday_match(weekday, x['Weekday']), axis=1)] if weekday else mis_df.copy()
                
                best_match = None
                best_score = 0
                
                for c_idx, c_row in candidates.iterrows():
                    mis_brand = str(c_row.get('Brand', '')).strip()
                    if not mis_brand: continue
                    score = fuzz.token_set_ratio(brand.lower(), mis_brand.lower())
                    if score > best_score:
                        best_score = score
                        best_match = c_row
                
                if best_match is not None and best_score >= 60:
                    mis_discount = float(best_match.get('Daily Deal Discount', 0))
                    discrepancies = []
                    if abs(discount - mis_discount) > 0.01:
                        discrepancies.append(f"Discount: Google={discount}% vs MIS={mis_discount}%")
                    
                    results.append({
                        'google_row': true_sheet_row,
                        'mis_id': f"{best_match.get('ID', '')} (Estimated)",
                        'brand': brand,
                        'weekday': weekday,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'categories': categories,
                        'special_notes': special_notes,
                        'deal_info': deal_info,
                        'status': f'ESTIMATED MATCH ({best_score}%)',
                        'discrepancies': discrepancies,
                        'multi_day_group': group_metadata
                    })
                else:
                    results.append({
                        'google_row': true_sheet_row,
                        'mis_id': '-',
                        'brand': brand,
                        'status': 'NO MIS ID ASSIGNED',
                        'discrepancies': ['Run ID Matcher'],
                        'weekday': weekday,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'categories': categories,
                        'special_notes': special_notes,
                        'deal_info': deal_info,
                        'multi_day_group': group_metadata
                    })
            except KeyError as e:
                results.append({
                    'google_row': true_sheet_row,
                    'mis_id': '-',
                    'brand': brand,
                    'status': 'ERROR',
                    'discrepancies': [str(e)],
                    'weekday': weekday,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'categories': categories,
                    'special_notes': special_notes,
                    'deal_info': deal_info,
                    'multi_day_group': group_metadata
                })
    
    return results

def format_csv_locations(locations_raw: str, exceptions_raw: str) -> str:
    """
    Parses Google Sheet location columns and returns the CSV-formatted string.
    Logic:
    1. If 'All Locations' and no exceptions -> Return "" (Blank)
    2. If 'All Locations' AND exceptions -> Return All CSV Stores minus exceptions.
    3. If specific stores -> Return mapped stores comma-separated.
    """
    loc_str = str(locations_raw).strip()
    exc_str = str(exceptions_raw).strip()
    
    # Normalize input
    is_all_locs = "all locations" in loc_str.lower()
    
    final_stores = set()
    
    if is_all_locs:
        if not exc_str or exc_str.lower() in ['nan', 'none', '']:
            return "" # Return blank if All Locations with no exceptions
        
        # All Locations EXCEPT...
        # 1. Start with all target stores
        final_stores = set(CSV_TARGET_STORES)
        
        # 2. Identify exceptions
        exceptions = [e.strip() for e in exc_str.split(',') if e.strip()]
        mapped_exceptions = []
        for e in exceptions:
            mapped = STORE_MAPPING.get(e, e) # Try to map, else use raw
            mapped_exceptions.append(mapped)
            
        # 3. Remove exceptions
        for exc in mapped_exceptions:
            if exc in final_stores:
                final_stores.remove(exc)
    else:
        # Specific locations listed
        raw_list = [l.strip() for l in loc_str.split(',') if l.strip()]
        for r in raw_list:
            if r in STORE_MAPPING:
                final_stores.add(STORE_MAPPING[r])
            else:
                # Fallback: check if it's already a valid target store
                if r in CSV_TARGET_STORES:
                    final_stores.add(r)
    
    # Return comma-separated string sorted alphabetically
    return ", ".join(sorted(list(final_stores)))

def format_csv_categories(cat_raw: str, exc_raw: str) -> str:
    """
    Parses Categories.
    If 'All Categories' is detected:
      - Returns "All Categories" (or "All Categories (Except: X)") for the UI.
      - The CSV generator loop will handle converting this to BLANK for the file.
    """
    cat_str = str(cat_raw).strip()
    exc_str = str(exc_raw).strip()
    
    # Check if we need to handle 'All Categories'
    if "all categories" in cat_str.lower():
        if exc_str and exc_str.lower() not in ['nan', 'none', '']:
            # Return a special string we can use for display, 
            # but we will need to detect this specific phrase to blank it out for the CSV.
            return f"All Categories (Except: {exc_str})"
        else:
            return "All Categories"
        
    else:
        # Just specific categories listed, return as-is (cleaned)
        if not cat_str or cat_str.lower() in ['nan', 'none']:
            return ""
        
        # Clean up spacing between commas
        return ", ".join([c.strip() for c in cat_str.split(',') if c.strip()])

def load_brand_settings(spreadsheet_id: str) -> Dict[str, str]:
    """
    Reads a Settings tab to build a map of Brand -> Linked Brand.
    ROBUSTNESS UPGRADES:
    1. Scans first 10 rows for headers (Fuzzy Match).
    2. Handles "Short Rows" (Google API trimming empty trailing cells).
    3. SANITIZATION: Strips whitespace from keys/values for clean matching.
    """
    settings_map = {}
    try:
        service = GLOBAL_DATA['sheets_service']
        if not service: return {}
        
        # 1. Find the Settings tab
        metadata = service.spreadsheets().get(spreadsheetId=spreadsheet_id).execute()
        settings_tab_name = None
        
        print("\n[DEBUG] --- Loading Brand Settings ---")
        for s in metadata.get('sheets', []):
            title = s['properties']['title']
            if 'setting' in title.lower():
                settings_tab_name = title
                print(f"[DEBUG] Found settings tab: '{title}'")
                break
        
        if not settings_tab_name:
            print("[WARN] Could not find any tab with 'Settings' in the name.")
            return {}

        # 2. Fetch data
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{settings_tab_name}'!A1:Z1000" 
        ).execute()
        rows = result.get('values', [])
        if not rows: return {}

        # 3. SCAN FOR HEADERS (Fuzzy Logic)
        brand_idx = -1
        linked_idx = -1
        start_row_index = 0
        
        for i, row in enumerate(rows[:10]):
            row_lower = [str(x).strip().lower() for x in row]
            
            # Find 'Linked Brand' first
            for col_i, cell_val in enumerate(row_lower):
                if 'linked' in cell_val and 'brand' in cell_val:
                    linked_idx = col_i
                    break
            
            # Find 'Brand' second (Generic but NOT linked)
            for col_i, cell_val in enumerate(row_lower):
                if 'brand' in cell_val and 'linked' not in cell_val and 'contribution' not in cell_val:
                    brand_idx = col_i
                    break
            
            if brand_idx != -1 and linked_idx != -1:
                start_row_index = i + 1
                print(f"[DEBUG] Headers found on Row {i+1}: Brand (Col {brand_idx}), Linked (Col {linked_idx})")
                break
        
        if brand_idx == -1 or linked_idx == -1:
            print(f"[WARN] Failed to find headers in '{settings_tab_name}'.")
            return {}

        # 4. Build Map (With SAFE FETCHING)
        count = 0
        for r in rows[start_row_index:]:
            # We only strictly require the BRAND index to exist. 
            # If the row is too short for the Linked Brand index, we assume Linked is empty.
            if len(r) > brand_idx:
                b_name = str(r[brand_idx]).strip()
                
                # SAFE FETCH: Check if row is long enough for linked_idx, else empty string
                l_name = ""
                if len(r) > linked_idx:
                    l_name = str(r[linked_idx]).strip()
                
                if b_name:
                    # Store lowercase key for matching, but keep value clean
                    settings_map[b_name.lower()] = l_name
                    count += 1
                    
        print(f"[INFO] Successfully loaded {count} brand rules.")
        return settings_map

    except Exception as e:
        print(f"[ERROR] Failed to load settings: {e}")
        traceback.print_exc()
        return {}

def resolve_location_columns(row: pd.Series) -> Tuple[str, str]:
    """
    Logic Router for Location Columns.
    Prioritizes 'Locations (Discount Applies at)' column using FUZZY matching.
    Falls back to 'Locations (Marketing)' if needed.
    """
    # 1. FUZZY FIND the "Master Switch" column (Column N)
    # We scan the row's index (headers) for the column that contains 'discount' and 'applies'
    master_col_name = None
    for col in row.index:
        c_lower = str(col).lower()
        if 'discount' in c_lower and 'applies' in c_lower:
            master_col_name = col
            break
            
    # Read value if column found, else empty
    master_col_val = str(row[master_col_name]).strip() if master_col_name else ""
    master_clean = master_col_val.lower()
    
    # --- LOGIC BRANCH 1: "SAME AS MARKETING" FALLBACK ---
    # If explicitly "Same as Marketing" -> Look at Marketing column
    if "same as market" in master_clean:
        # Find Marketing column
        marketing_col_name = None
        for col in row.index:
            c_lower = str(col).lower()
            if 'marketing' in c_lower and 'location' in c_lower:
                marketing_col_name = col
                break
        
        if marketing_col_name:
            marketing_val = str(row[marketing_col_name]).strip()
            marketing_clean = marketing_val.lower()
            
            # ERROR CHECK: Circular reference
            if "same as market" in marketing_clean:
                print(f"[ERROR] Circular 'Same as Marketing' reference detected at row {row.name + 1}")
                print(f"[ERROR] Both 'Discount Applies at' and 'Marketing' columns say 'Same as Marketing'")
                return "", ""  # Return empty to skip this row
            
            # Recursively apply logic to Marketing column value
            # Create a temporary row with the marketing value
            temp_row = row.copy()
            temp_row[master_col_name] = marketing_val
            return resolve_location_columns(temp_row)
        else:
            print(f"[ERROR] 'Same as Marketing' specified but Marketing column not found at row {row.name + 1}")
            return "", ""

    # --- LOGIC BRANCH 2: EMPTY OR NAN ---
    if not master_col_val or master_clean == 'nan':
        return "", ""

    # --- LOGIC BRANCH 3: "ALL LOCATIONS EXCEPT" ---
    # If the phrase exists anywhere in the cell, ALL locations become exceptions
    if "all locations except" in master_clean:
        # Remove the trigger phrase to extract location names
        cleaned = master_col_val.replace("All Locations Except:", "").replace("all locations except:", "")
        # Split by comma and extract all location names
        exceptions = [loc.strip() for loc in cleaned.split(',') if loc.strip()]
        
        return "All Locations", ", ".join(exceptions)

    # --- LOGIC BRANCH 4: "ALL LOCATIONS" (Exact or Clean Match) ---
    if master_clean == "all locations":
        return "All Locations", ""

    # --- LOGIC BRANCH 5: SPECIFIC LIST ---
    # If we are here, it's just a list of stores (e.g. "Dixon, Davis")
    return master_col_val, ""

def generate_mis_csv_with_multiday(google_df: pd.DataFrame, section_type: str = 'weekly') -> Tuple[List[Dict], Dict]:
    """
    Generate MIS CSV. 
    UPDATED: Handles column swap for 'sale' section.
    """
    brand_settings = load_brand_settings(GLOBAL_DATA['mis']['spreadsheet_id'])
    multi_day_groups, row_to_group = detect_multi_day_groups(google_df, section_type)
    
    # Weekday ordering helper
    weekday_order = {
        'monday': 1, 'mon': 1, 'tuesday': 2, 'tue': 2, 'wednesday': 3, 'wed': 3,
        'thursday': 4, 'thu': 4, 'friday': 5, 'fri': 5, 'saturday': 6, 'sat': 6, 'sunday': 7, 'sun': 7
    }
    
    def get_weekday_sort_key(weekday_str):
        if not weekday_str: return 999
        # Basic check for day names in string
        d = weekday_str.lower()
        for k, v in weekday_order.items():
            if k in d: return v
        return 999
    
    csv_rows = []
    processed_groups = set()
    retail_alert_details = []
    multi_day_details = []
    
    for g_idx, g_row in google_df.iterrows():
        if should_skip_end420_row(g_row.to_dict()):
            continue
        
        # Standard Logic for all sections (Removed Sale Swap)
        brand_raw = str(g_row.get('Brand', '')).strip()
        weekday_val_input = str(get_col(g_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip().title()

        if not brand_raw:
            continue
        
        true_sheet_row = int(g_row['_SHEET_ROW_NUM']) if '_SHEET_ROW_NUM' in g_row else g_idx + 2
        
        is_in_group = true_sheet_row in row_to_group and row_to_group[true_sheet_row] in multi_day_groups
        
        special_notes_package = []
        deal_info_package = []
        
        if is_in_group:
            group_id = row_to_group[true_sheet_row]
            if group_id in processed_groups:
                continue 
            
            processed_groups.add(group_id)
            group_data = multi_day_groups[group_id]
            ref_row_num = group_data['rows'][0]
            ref_row = google_df[google_df['_SHEET_ROW_NUM'] == ref_row_num].iloc[0]
            
            # Combine weekdays
            raw_weekdays = [w for w in group_data['weekdays'] if w and w != '[!] [EMOJI]√É‚Äö√Ç¬è  MISSING']
            # For sale dates, sort by date logic? For now, keep simple sort.
            unique_weekdays = sorted(list(set(raw_weekdays)), key=get_weekday_sort_key)
            weekday_val = ', '.join(unique_weekdays)
            
            sort_key = min([get_weekday_sort_key(w) for w in unique_weekdays]) if unique_weekdays else 999
            multi_day_flag = f'YES ({len(unique_weekdays)} days)'
            google_rows_track = ', '.join([str(r) for r in group_data['rows']])
            
            data_source = ref_row
            
            # Summary Data
            row_day_combo = []
            for i, r_num in enumerate(group_data['rows']):
                d_name = group_data['weekdays'][i] if i < len(group_data['weekdays']) else "?"
                row_day_combo.append(f"(Row {r_num}) ({d_name})")
            
            multi_day_details.append({
                'brand': str(ref_row.get('Brand', '')).strip(), # Note: This might need swap logic if ref_row used directly
                'title_meta': f"({len(unique_weekdays)} Days)",
                'body_data': ", ".join(row_day_combo)
            })
            
            for r_num in group_data['rows']:
                sub_row = google_df[google_df['_SHEET_ROW_NUM'] == r_num].iloc[0]
                
                # Handle swap for notes
                if section_type == 'sale':
                    day_val = str(sub_row.get('Brand', '')).strip()
                else:
                    day_val = str(get_col(sub_row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                
                note_val = str(sub_row.get('SPECIAL NOTES', '')).strip()
                if note_val: special_notes_package.append({'row': r_num, 'day': day_val, 'note': note_val})
                    
                info_val = str(get_col(sub_row, ['Deal Information', 'Deal Info'], '')).strip()
                if info_val: deal_info_package.append({'row': r_num, 'day': day_val, 'info': info_val})
                    
        else:
            data_source = g_row
            weekday_val = weekday_val_input
            sort_key = get_weekday_sort_key(weekday_val)
            multi_day_flag = 'NO'
            google_rows_track = str(true_sheet_row)
            
            note_val = str(g_row.get('SPECIAL NOTES', '')).strip()
            if note_val: special_notes_package.append({'row': true_sheet_row, 'day': weekday_val, 'note': note_val})
                
            info_val = str(get_col(g_row, ['Deal Information', 'Deal Info'], '')).strip()
            if info_val: deal_info_package.append({'row': true_sheet_row, 'day': weekday_val, 'info': info_val})
            
        discount = parse_percentage(get_col(data_source, ['Deal Discount Value/Type', 'Deal Discount'], ''))
        vendor_contrib = parse_percentage(get_col(data_source, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
        
        cat_raw = str(data_source.get('Categories', ''))
        cat_exc = str(data_source.get('Category Exceptions', ''))
        categories = format_csv_categories(cat_raw, cat_exc)
        
        start_date, end_date = parse_end_date(get_col(data_source, ['Contracted Duration (MM/DD/YY - MM/DD/YY)', 'Contracted Duration'], ''))
        
        loc_raw, exc_raw = resolve_location_columns(data_source)
        store_str = format_csv_locations(loc_raw, exc_raw)
        
        display_store_str = store_str
        is_all_locs = "all locations" in loc_raw.lower()
        if is_all_locs:
            if exc_raw and exc_raw.lower() not in ['nan', 'none', '']:
                 display_store_str = f"All Locations Except: {exc_raw}" 
            else:
                 display_store_str = "All Locations"
        
        is_wholesale = str(get_col(data_source, ['Wholesale?', 'Wholesale'], '')).upper() == 'TRUE'
        is_retail = str(get_col(data_source, ['Retail?', 'Retail'], '')).upper() == 'TRUE'
        
        rebate_type_csv = ""
        notes_csv = ""
        ui_rebate_display = "-"
        
        if is_retail:
            rebate_type_csv = "" 
            notes_csv += "[ACTION: CHECK RETAIL TOGGLE] "
            ui_rebate_display = "Retail"
            retail_alert_details.append({
                'brand': brand_raw,
                'title_meta': "", 
                'body_data': f"Row {google_rows_track} ({weekday_val})"
            })
        elif is_wholesale:
            rebate_type_csv = "Wholesale"
            ui_rebate_display = "Wholesale"
            
        brands_list = [b.strip() for b in brand_raw.split(',') if b.strip()]
        split_group_id = f"split_{g_idx}_{int(time.time())}" if len(brands_list) > 1 else ""
        
        for b_idx, current_brand in enumerate(brands_list):
            final_brand_val = current_brand
            linked_brand_val = "" 

            lookup_key = current_brand.lower()
            if lookup_key in brand_settings:
                target_linked = brand_settings[lookup_key]
                if target_linked.lower() == current_brand.lower():
                    linked_brand_val = ""
                else:
                    linked_brand_val = target_linked

            row_ui_class = ""
            if len(brands_list) > 1:
                if b_idx == 0: row_ui_class = "split-group-start"
                elif b_idx == len(brands_list) - 1: row_ui_class = "split-group-end"
                else: row_ui_class = "split-group-middle"
                
            csv_category_val = categories
            if "All Categories" in categories:
                csv_category_val = ""

            row = {
                'ID': '',
                'Weekday': weekday_val,
                'Store': store_str,
                'Brand': final_brand_val,
                'Linked Brand (if applicable)': linked_brand_val,
                'Category': csv_category_val,
                'Daily Deal Discount': f"{discount:.2f}",
                'Rebate type': rebate_type_csv,
                'Discount paid by vendor': f"{vendor_contrib:.2f}",
                'Rebate After Wholesale Discount?': '',
                'Include clearance items?': '',
                'Specialty Discount (non-daily deal)?': '',
                'Start date': start_date,
                'End date': end_date,
                'Minimum Weight': '0',
                'Maximum Weight': '0',
                'Actions': 'Edit Archive',
                
                'GOOGLE_ROWS': google_rows_track,
                'MULTI_DAY_FLAG': multi_day_flag,
                'WEEKDAY_SORT_KEY': sort_key,
                'NOTES': notes_csv,
                'SPLIT_GROUP_ID': split_group_id,
                'ROW_UI_CLASS': row_ui_class,
                'DISPLAY_CATEGORY': categories,
                'DISPLAY_STORE': display_store_str,
                'UI_SPECIAL_NOTES': special_notes_package,
                'UI_DEAL_INFO': deal_info_package,
                'UI_REBATE_DISPLAY': ui_rebate_display
            }
            csv_rows.append(row)
    
    csv_rows_sorted = sorted(csv_rows, key=lambda x: x['WEEKDAY_SORT_KEY'])
    
    multi_day_summary = {
        'total_rows': len(csv_rows_sorted),
        'multi_day_deals': len([r for r in csv_rows_sorted if r['MULTI_DAY_FLAG'] != 'NO']),
        'single_day_deals': len([r for r in csv_rows_sorted if r['MULTI_DAY_FLAG'] == 'NO']),
        'groups_detected': len(multi_day_groups),
        'retail_alerts': len(retail_alert_details),
        'retail_details': retail_alert_details,
        'multiday_details': multi_day_details
    }
    
    return csv_rows_sorted, multi_day_summary

# ============================================================================
# NEW HELPER: DATE FILTERING
# ============================================================================
def filter_mis_by_date(df: pd.DataFrame, date_str: str, expand_month: bool) -> pd.DataFrame:
    """
    Filters the MIS DataFrame based on the 'Start date' column.
    Args:
        df: The dataframe to filter.
        date_str: The target date string (YYYY-MM-DD from HTML input).
        expand_month: If True, matches Month/Year. If False, matches exact Date.
    """
    if df.empty or 'Start date' not in df.columns:
        return df
    
    try:
        # Parse user input
        target_date = datetime.strptime(date_str, '%Y-%m-%d')
        
        # Convert DF column to datetime objects (handling errors gracefully)
        temp_dates = pd.to_datetime(df['Start date'], errors='coerce')
        
        if expand_month:
            # Filter by Month AND Year
            mask = (temp_dates.dt.month == target_date.month) & \
                   (temp_dates.dt.year == target_date.year)
            filter_desc = f"Month: {target_date.strftime('%B %Y')}"
        else:
            # Filter by exact Date
            mask = (temp_dates.dt.date == target_date.date())
            filter_desc = f"Date: {target_date.strftime('%Y-%m-%d')}"
            
        filtered_df = df[mask]
        print(f"[FILTER] Applied Focus. Criteria: {filter_desc}. Rows: {len(df)} -> {len(filtered_df)}")
        
        return filtered_df
        
    except Exception as e:
        print(f"[ERROR] Date filtering failed: {e}")
        traceback.print_exc()
        return df

# ============================================================================
# BLAZE INVENTORY REPORTER (INTEGRATED)
# ============================================================================
class BlazeInventoryReporter:
    def __init__(self):
        self.keys = self.load_keys()
        self.store_data = {}
        self.brand_map = {}  # Will store {brandId: brandName}
        # Clear previous logs
        GLOBAL_DATA['blaze']['inventory_logs'] = []
        GLOBAL_DATA['blaze']['inventory_running'] = True
        GLOBAL_DATA['blaze']['inventory_start_time'] = datetime.now()  # NEW: Track start time

    def log(self, message):
        """Log to console and Global State for UI"""
        timestamp = datetime.now().strftime('%H:%M:%S')
        full_msg = f"[{timestamp}] {message}"
        print(full_msg)
        GLOBAL_DATA['blaze']['inventory_logs'].append(full_msg)

    def load_keys(self):
        self.log(f"Loading keys from: {INVENTORY_KEYS_FILE}")
        if not INVENTORY_KEYS_FILE.exists():
            self.log("[X] CRITICAL: blaze_inventory_keys.json missing!")
            return {}
        try:
            with open(INVENTORY_KEYS_FILE, 'r') as f:
                keys = json.load(f)
                self.log(f"[OK] Successfully loaded {len(keys)} store configurations")
                return keys
        except Exception as e:
            self.log(f"[X] Error loading keys: {e}")
            return {}
    def fetch_global_brands(self):
        """Fetch and cache the global brand mapping."""
        self.log("Fetching global brand list...")
        try:
            # Try active session token first to avoid re-sniffing
            token = GLOBAL_DATA['blaze'].get('token')
            if not token:
                self.log("No cached token found, fetching new token...")
                token = BlazeTokenManager.get_token()
            else:
                self.log("Using cached session token")
            
            if not token:
                self.log("WARNING: No token available for brand fetch. Using brandId as fallback.")
                return
            
            self.brand_map = BlazeTokenManager.fetch_global_brands(token)
            
            if self.brand_map:
                self.log(f"SUCCESS: Loaded {len(self.brand_map)} brands")
                # Cache in global state for UI use
                GLOBAL_DATA['blaze']['inventory_brands'] = self.brand_map
            else:
                self.log("WARNING: Brand list empty. Products will show brandId instead.")
                
        except Exception as e:
            self.log(f"ERROR: Brand fetch error: {e}")
            return {}

    def fetch_store_products(self, store_name, headers):
        all_products = []
        limit = 1000
        start = 0
        page_num = 1
        
        self.log(f" PROCESSING: {store_name}")
        
        while True:
            if not GLOBAL_DATA['blaze']['inventory_running']: break # Stop flag

            url = "https://api.blaze.me/api/v1/mgmt/products"
            params = {"start": start, "limit": limit, "active": "true"}
            
            try:
                self.log(f"    Fetching Page {page_num} (Items {start}-{start+limit})...")
                r = requests.get(url, headers=headers, params=params, timeout=30)
                
                if r.status_code == 200:
                    data = r.json()
                    items = data.get('values', [])
                    
                    if not items:
                        self.log("      [SUCCESS] Page empty (Done).")
                        break
                        
                    all_products.extend(items)
                    
                    total_server = data.get('total', 0)
                    start += limit
                    page_num += 1
                    
                    if start > total_server and total_server > 0:
                        break
                else:
                    self.log(f"[!] [EMOJI]√É‚Äö√Ç¬è API Error {r.status_code}: {r.text[:50]}")
                    break
                    
            except Exception as e:
                self.log(f"[!] [EMOJI]√É‚Äö√Ç¬è Connection Error: {e}")
                break
                
        return all_products

    def normalize_products(self, products: List[Dict], store_name: str = "") -> pd.DataFrame:
        """Normalize products with brand name resolution."""
        clean_rows = []
        for p in products:
            total_qty = sum(float(q.get('quantity', 0)) for q in p.get('quantities', []))
            
            # BRAND RESOLUTION LOGIC (Multi-level fallback)
            brand_obj = p.get('brand', {})
            brand_name = None
            
            # STEP 1: Check brand.name
            if isinstance(brand_obj, dict):
                brand_name = brand_obj.get('name')
                # If name is missing, try resolving from brandId in global map
                if not brand_name:
                    brand_id = brand_obj.get('id')
                    if brand_id and self.brand_map:
                        brand_name = self.brand_map.get(brand_id, f"ID:{brand_id}")
            
            # STEP 2: CRITICAL FIX - Check root-level brandName key
            if not brand_name:
                brand_name = p.get('brandName')
            
            # STEP 3: Final fallback
            if not brand_name:
                brand_name = "N/A"
            
            row = {
                "BLAZE ID": p.get('id'),
                "Product Name": p.get('name'),
                "SKU": p.get('sku'),
                "Category": p.get('category', {}).get('name') if p.get('category') else "N/A",
                "Brand": brand_name,
                "Type": p.get('productType'),
                "Unit Price ($)": p.get('unitPrice', 0),
                "Total Quantity": total_qty,
                "Cannabis Type": p.get('cannabisType'),
                "Weight / Unit": p.get('weightPerUnit'),
                "Active": p.get('active'),
                "Low Threshold": p.get('lowInventoryThreshold'),
                "Potency (THC)": p.get('thc'),
                "Potency (CBD)": p.get('cbd'),
                "Created Date": datetime.fromtimestamp(p.get('created', 0)/1000).strftime('%Y-%m-%d') if p.get('created') else "",
                "Store": store_name  # Add store name for multi-store tracking
            }
            clean_rows.append(row)
        return pd.DataFrame(clean_rows)

    def run_report(self, target_store=None):
        """
        Run inventory report with GUARANTEED state reset using try/finally.
        This prevents the inventory_running flag from getting stuck if an exception occurs.
        """
        try:
            # Early validation
            if not self.keys:
                self.log("ERROR: No keys loaded. Aborting.")
                return False

            # Step 1: Fetch global brands FIRST
            self.fetch_global_brands()

            targets = self.keys if target_store == 'ALL' else {k: v for k, v in self.keys.items() if k == target_store}
            
            if not targets:
                self.log(f"ERROR: Store '{target_store}' not found in keys file.")
                return False

            all_data_frames = []  # Collect all store data
            
            for store_name, info in targets.items():
                if not GLOBAL_DATA['blaze']['inventory_running']: 
                    self.log("STOPPED: Operation cancelled by user")
                    break
                
                headers = info.get('full_headers_dump', {})
                headers['Accept'] = 'application/json, text/plain, */*'
                
                raw = self.fetch_store_products(store_name, headers)
                if raw:
                    df = self.normalize_products(raw, store_name)
                    self.store_data[store_name] = df
                    all_data_frames.append(df)
                else:
                    self.log(f"WARNING: No data found for {store_name}")

            # Combine all stores into single DataFrame for UI
            if all_data_frames:
                combined_df = pd.concat(all_data_frames, ignore_index=True)
                GLOBAL_DATA['blaze']['inventory_data'] = combined_df
                self.log(f"SUCCESS: Loaded {len(combined_df)} total products into memory")

            # Generate timestamped files
            if self.store_data:
                timestamp = datetime.now().strftime('%Y_%m_%d_%H_%M_%S')
                
                if len(self.store_data) == 1:
                    # Single store CSV export
                    store_name = list(self.store_data.keys())[0]
                    df = list(self.store_data.values())[0]
                    safe_store = store_name.replace("The Artist Tree - ", "").replace("/", "-").replace(":", "")
                    filename = f"{safe_store}_BLAZE_INVENTORY_{timestamp}.csv"
                    filepath = INVENTORY_DIR / filename
                    
                    self.log(f"Saving CSV: {filename}...")
                    try:
                        df.to_csv(filepath, index=False)
                        self.log(f"SUCCESS: Saved to: {filepath}")
                    except Exception as e:
                        self.log(f"ERROR: Write Error: {e}")
                else:
                    # Multi-store Excel export
                    filename = f"ALL_STORES_BLAZE_INVENTORY_{timestamp}.xlsx"
                    filepath = INVENTORY_DIR / filename
                    
                    self.log(f"Saving Multi-Store Excel: {filename}...")
                    try:
                        with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
                            for store_name, df in self.store_data.items():
                                safe_name = store_name.replace("The Artist Tree - ", "").replace("/", "-")[:30]
                                df.to_excel(writer, sheet_name=safe_name, index=False)
                        self.log(f"SUCCESS: Saved to: {filepath}")
                    except Exception as e:
                        self.log(f"ERROR: Write Error: {e}")
                        
                self.log("COMPLETE: Report generated successfully.")
            else:
                self.log("ERROR: No data collected to write.")
            
            return True
            
        except Exception as e:
            # Log the error but don't re-raise
            self.log(f"[X] CRITICAL ERROR: {str(e)}")
            self.log(f"Stack trace: {traceback.format_exc()}")
            return False
            
        finally:
            # CRITICAL: Always reset the running flag, no matter what
            GLOBAL_DATA['blaze']['inventory_running'] = False
            GLOBAL_DATA['blaze']['inventory_start_time'] = None
            self.log("[OK] State reset complete (inventory_running = False)")

# ============================================================================
# FLASK APPLICATION
# ============================================================================
app = Flask(__name__)

# HTML TEMPLATE (COMPLETE WITH MULTI-DAY SUPPORT)
HTML_TEMPLATE = r"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIS + Blaze Dashboard</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdn.datatables.net/1.13.6/css/dataTables.bootstrap5.min.css" rel="stylesheet">
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container-main {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { font-size: 1.1em; opacity: 0.9; }
        
        .main-nav {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
        }
        .main-nav-btn {
            flex: 1;
            padding: 20px;
            background: none;
            border: none;
            font-size: 1.3em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            color: #495057;
        }
        .main-nav-btn:hover { background: #e9ecef; }
        .main-nav-btn.active {
            background: white;
            color: #667eea;
            border-bottom: 4px solid #667eea;
        }
        
        .sub-nav {
            display: none;
            background: #ffffff;
            border-bottom: 1px solid #dee2e6;
            padding: 10px 20px;
        }
        .sub-nav.active { display: flex; }
        .sub-nav-btn {
            padding: 10px 20px;
            background: none;
            border: none;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            color: #6c757d;
            border-radius: 8px;
            margin-right: 5px;
        }
        .sub-nav-btn:hover { background: #f8f9fa; }
        .sub-nav-btn.active {
            background: #667eea;
            color: white;
        }
        
        /* DEAL TYPE SUB-TABS (Weekly/Monthly/Sale/All) */
        .deal-type-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            padding: 10px;
            background: #f1f3f5;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        .deal-type-btn {
            padding: 8px 16px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: #495057;
        }
        .deal-type-btn:hover {
            background: #e9ecef;
            border-color: #667eea;
        }
        .deal-type-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        .deal-type-btn .badge {
            margin-left: 6px;
            font-size: 0.75em;
            padding: 2px 6px;
        }
        .deal-type-content {
            display: none;
        }
        .deal-type-content.active {
            display: block;
        }
        
        .content {
            padding: 40px;
            min-height: 500px;
        }
        
        .main-section { display: none; }
        .main-section.active { display: block; }
        
        .sub-section { display: none; }
        .sub-section.active { display: block; }

        /* Split Audit Phase Styles (V29) */
        .split-phase-content { display: none; }
        .split-phase-content.active { display: block; }
        .split-phase-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: white !important;
            border-color: transparent !important;
        }
        
        .btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 5px;
        }
        .btn:hover { transform: translateY(-2px); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; }
        
        /* v12.5: Updated button styles - compact versions used in ID Matcher */
        .btn-approve { background: #28a745; padding: 8px 16px; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .btn-reject { background: #dc3545; padding: 8px 16px; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .btn-review { background: #17a2b8; padding: 8px 16px; color: white; border: none; border-radius: 4px; cursor: pointer; }
        .btn-blaze { color: #0d6efd; }
        
        .input-group {
            margin-bottom: 20px;
        }
        .input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
        }
        
        .config-section {
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            background: #f8f9fa;
        }
        .config-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        
        .table-container {
            overflow-y: auto; /* Enable vertical scrolling */
            overflow-x: auto; /* Enable horizontal scrolling if needed */
            margin-top: 20px;
            max-height: 70vh; /* CRITICAL: Give the container a fixed height so it CAN scroll */
            border: 1px solid #dee2e6; /* Optional: Adds a border around the scrollable area */
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        /* Debug Log Panel Styles */
        .debug-log-panel {
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            background: #f8f9fa;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .debug-messages {
            flex: 1;
            overflow-y: auto;
            max-height: 60px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 6px;
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.3;
        }
        .debug-messages .log-entry {
            margin-bottom: 2px;
            color: #495057;
        }
        .debug-messages .log-entry.success {
            color: #28a745;
        }
        .debug-messages .log-entry.error {
            color: #dc3545;
        }
        .debug-messages .log-entry.warning {
            color: #ffc107;
        }
        
        table {
            width: 100%;
            border-collapse: separate; /* Required for sticky headers to work properly in some browsers */
            border-spacing: 0;
            font-size: 0.9em;
        }
        th, td {
            padding: 12px 10px; /* Increased padding for readability */
            text-align: left;
            border-bottom: 1px solid #dee2e6;
            vertical-align: middle;
        }
        th {
            background: #667eea;
            color: white;
            font-weight: 600;
            position: sticky; /* The magic property */
            top: 0;           /* Sticks to the top of .table-container */
            z-index: 10;      /* Ensures it stays on top of content */
            box-shadow: 0 2px 2px -1px rgba(0, 0, 0, 0.4); /* Optional: Adds a shadow under header */
        }
        /* Fix for corner borders */
        th:first-child { border-top-left-radius: 4px; }
        th:last-child { border-top-right-radius: 4px; }
        tr:hover { background: #f8f9fa; }
        
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }
        .status-match { background: #d4edda; color: #155724; }
        .status-warning { background: #fff3cd; color: #856404; }
        .status-error { background: #f8d7da; color: #721c24; }
        .status-high { background: #d1ecf1; color: #0c5460; }
        .status-medium { background: #fff3cd; color: #856404; }
        .status-low { background: #f8d7da; color: #721c24; }
        
        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .alert-success { background: #d4edda; color: #155724; }
        .alert-warning { background: #fff3cd; color: #856404; }
        .alert-error { background: #f8d7da; color: #721c24; }
        .alert-info { background: #d1ecf1; color: #0c5460; }
        
        .row-approved { background: #d4edda !important; }
        .row-rejected { background: #f8d7da !important; opacity: 0.6; }
        
        .suggestion-indicator {
            display: inline-block;
            margin-left: 8px;
            cursor: pointer;
            font-size: 1.2em;
            vertical-align: middle;
        }
        .tooltip-container {
            position: absolute;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            z-index: 1000;
            min-width: 600px;
            max-width: 800px;
            display: none;
        }
        .tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #dee2e6;
        }
        .tooltip-close {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        .suggestion-row {
            padding: 10px;
            margin: 8px 0;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .suggestion-row:hover { background: #f8f9fa; }
        .suggestion-data {
            display: flex;
            align-items: center;
            gap: 15px;
            font-size: 0.9em;
        }
        .confidence-badge {
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 5px;
            min-width: 50px;
            text-align: center;
        }
        .confidence-high { background: #d4edda; color: #155724; }
        .confidence-medium { background: #fff3cd; color: #856404; }
        .confidence-low { background: #f8d7da; color: #721c24; }
        
        .brand-multi {
            background-color: #fff3cd !important;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            padding: 2px 6px;
            display: inline-block;
        }
        .brand-single {
            cursor: pointer;
            text-decoration: underline;
            color: #495057;
        }
        .brand-single:hover { color: #667eea; }
        
        .brand-popup {
            position: absolute;
            background: white;
            border: 1px solid #ced4da;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 2000;
            display: none;
            width: 200px;
            overflow: hidden;
        }
        .brand-popup-header {
            background: #f8f9fa;
            padding: 8px 12px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            font-size: 0.85em;
        }
        .brand-popup-close { cursor: pointer; color: #dc3545; font-weight: bold; }
        .brand-popup-body { padding: 5px; display: flex; flex-direction: column; gap: 4px; }
        .brand-select-btn {
            text-align: left;
            background: none;
            border: 1px solid transparent;
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .brand-select-btn:hover { background: #e9ecef; color: #667eea; }
        
        /* MULTI-DAY DEAL GROUPING */
        .group-container {
            border-left: 4px solid #ffc107;
            margin-bottom: 2px;
        }
        
        .group-header-row {
            background: #fff3cd !important;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .group-header-row:hover {
            background: #ffe69c !important;
        }
        
        .group-member-row {
            background: #fff3cd !important;  /* Match main definition - consistent yellow */
        }
        
        .group-member-row td {
            background: #fff3cd !important;  /* Ensure cells show yellow too */
        }
        
        .group-member-row.collapsed {
            display: none;
        }
        
        .group-toggle-icon {
            display: inline-block;
            margin-right: 8px;
            font-weight: bold;
            color: #856404;
            transition: transform 0.2s;
        }
        
        .group-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }
        
        .multi-day-badge {
            display: inline-block;
            background: #ffc107;
            color: #000;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
        }
        
        /* v12.2: Weekly Breakdown View - Weekday Section Headers */
        .weekday-header-row {
            background: #f0f4ff !important;
            border-top: 2px solid #007bff !important;
            font-weight: 500;
            cursor: default;
        }
        
        .weekday-header-row td {
            background: #f0f4ff !important;
            padding: 8px 10px !important;
        }
        
        .weekday-header-row:hover {
            background: #e3ecff !important;
        }
        
        .missing-weekday-warning {
            background: #f8d7da !important;
            border-left: 4px solid #dc3545 !important;
        }
        
        .weekday-missing-icon {
            color: #dc3545;
            font-weight: bold;
            margin-right: 4px;
        }
        
        .bulk-approve-btn {
            background: #28a745;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .bulk-approve-btn:hover {
            background: #218838;
        }
        
        .multi-day-banner {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        
        .multi-day-banner a {
            color: #667eea;
            text-decoration: underline;
            cursor: pointer;
            margin: 0 4px;
        }
        
        .multi-day-banner strong {
            color: #000;
            font-weight: bold;
        }

/* New Focus Styles */
        .focus-panel {
            background: #f1f3f5;
            border: 2px solid #ced4da;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .focus-panel.active {
            border-color: #667eea;
            background: #e7f5ff;
        }
        
        /* Search Enhancement Styles */
        .bi-search, .fa-search, [class*="search-icon"] {
            cursor: pointer;
            transition: color 0.2s;
        }

        .bi-search:hover, .fa-search:hover, [class*="search-icon"]:hover {
            color: #667eea;
        }

        .search-trigger-btn {
            transition: all 0.2s;
        }

        .search-trigger-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        input[type="search"] {
            transition: border-color 0.2s;
        }

        input[type="search"]:focus {
            border-color: #667eea !important;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

/* FIX: WIDER TOOLTIPS */
        .tooltip-inner {
            max-width: 800px !important;  /* Allow wide content */
            text-align: left !important;  /* Align text left for readability */
            white-space: pre-wrap;       /* Preserve formatting */
        }

/* ==================================================================
   FREEZE PANES - Excel-Style Sticky Headers
   ================================================================== */
        .scrollable-table-container {
            max-height: 65vh;
            overflow-y: auto;
            overflow-x: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            position: relative;
        }
        
        .scrollable-table-container table {
            width: 100%;
            margin-bottom: 0;
        }
        
        .scrollable-table-container thead {
            position: sticky;
            top: 0;
            z-index: 10;
            background: white;
        }
        
        .scrollable-table-container thead th {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            font-weight: 600;
            padding: 12px 8px;
            text-align: left;
            position: sticky;
            top: 0;
        }
        
        .scrollable-table-container tbody tr:hover {
            background-color: #f5f5f5;
        }

/* ==================================================================
   BLAZE TABLE - Column Width Adjustments
   ================================================================== */
        /* DataTables wrapper fix - ensure proper height and visibility */
        #promotionsTableWrapper {
            width: 100%;
        }
        #promotionsTableWrapper .dataTables_scrollBody {
            min-height: 200px;
        }
        #promotionsTable_wrapper {
            width: 100%;
        }
        
        /* Detail column - compact for emoji */
        #promotionsTable th:nth-child(1),
        #promotionsTable td:nth-child(1) {
            max-width: 50px;
            text-align: center;
        }
        
        /* Name column - reduced width by 30% */
        #promotionsTable th:nth-child(3),
        #promotionsTable td:nth-child(3) {
            max-width: 200px;  /* Reduced from ~285px (30% narrower) */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Auto/Manual column - compact */
        #promotionsTable th:nth-child(5),
        #promotionsTable td:nth-child(5) {
            max-width: 100px;
            text-align: center;
        }
        
        /* Groups columns - controlled by badge width */
        #promotionsTable th:nth-child(8),
        #promotionsTable td:nth-child(8),
        #promotionsTable th:nth-child(9),
        #promotionsTable td:nth-child(9) {
            max-width: 150px;
        }

/* ==================================================================
   AUDIT TAB - Multi-Day Group Background Shading
   ================================================================== */
        /* All multi-day group rows are ALWAYS yellow for consistency */
        .group-member-row {
            background-color: #fff3cd !important;  /* Light yellow - ALWAYS */
        }
        
        /* CRITICAL: Force td cells to inherit row background (Bootstrap applies white to cells) */
        .group-member-row td,
        .group-member-row > td,
        tr.group-member-row td {
            background-color: #fff3cd !important;  /* Match parent row */
            background: #fff3cd !important;
        }
        
        /* Ensure table-striped doesn't override group row colors */
        .table-striped tbody tr.group-member-row,
        .table-striped tbody tr.group-member-row:nth-of-type(odd),
        .table-striped tbody tr.group-member-row:nth-of-type(even) {
            background-color: #fff3cd !important;  /* Light yellow - ALWAYS */
        }
        
        .table-striped tbody tr.group-member-row td,
        .table tbody tr.group-member-row td {
            background-color: #fff3cd !important;
            background: #fff3cd !important;
        }
        
        /* Hover state for group rows - slightly darker yellow */
        .group-member-row:hover,
        .group-member-row:hover td {
            background-color: #ffe5b4 !important;  /* Peach on hover */
            background: #ffe5b4 !important;
        }
        
        /* Scrollable container override for group rows */
        .scrollable-table-container tbody tr.group-member-row,
        .scrollable-table-container tbody tr.group-member-row td {
            background-color: #fff3cd !important;
            background: #fff3cd !important;
        }
        
        .scrollable-table-container tbody tr.group-member-row:hover,
        .scrollable-table-container tbody tr.group-member-row:hover td {
            background-color: #ffe5b4 !important;
            background: #ffe5b4 !important;
        }

/* ==================================================================
   BLAZE DETAIL MODAL - Dual-State (Hover + Pin)
   ================================================================== */
        /* Modal Backdrop */
        #detailModalBackdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9998;
        }
        
        /* Modal Container */
        #detailModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 9999;
            padding: 20px;
        }
        
        /* Modal Header */
        #detailModal .modal-header {
            border-bottom: 2px solid #0066cc;
            padding-bottom: 15px;
            margin-bottom: 20px;
            position: relative;
        }
        
        #detailModal .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        
        #detailModal .modal-id {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        #detailModal .modal-type {
            font-size: 1rem;
            color: #0066cc;
            font-weight: bold;
        }
        
        /* Close Button */
        #detailModal .close-btn {
            position: absolute;
            top: 0;
            right: 0;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            font-weight: bold;
        }
        
        #detailModal .close-btn:hover {
            background: #c82333;
        }
        
        /* Modal Body */
        #detailModal .modal-body {
            line-height: 1.6;
        }
        
        #detailModal .section-header {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }
        
        #detailModal .data-row {
            margin-bottom: 8px;
            padding-left: 10px;
        }
        
        #detailModal .data-label {
            font-weight: bold;
            color: #555;
        }
        
        #detailModal .data-value {
            color: #333;
        }

        /* v63: TAX CALCULATOR MODAL STYLES */
        #calcModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        #calcModal.show {
            display: flex;
        }
        
        #calcModal .calc-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        
        #calcModal .calc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #667eea;
        }
        
        #calcModal .calc-header h2 {
            margin: 0;
            color: #667eea;
        }
        
        #calcModal .calc-close {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 20px;
            cursor: pointer;
            line-height: 1;
        }
        
        #calcModal .calc-close:hover {
            background: #c82333;
        }
        
        #calcModal .store-selector {
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        #calcModal .store-selector label {
            font-weight: bold;
            display: block;
            margin-bottom: 8px;
            color: #495057;
        }
        
        #calcModal .store-selector select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ced4da;
            border-radius: 6px;
            font-size: 1em;
        }
        
        #calcModal .store-selector .tax-rate-display {
            margin-top: 8px;
            padding: 8px;
            background: #e7f5ff;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            font-weight: bold;
            color: #495057;
        }
        
        #calcModal .calc-section {
            margin-bottom: 25px;
            padding: 20px;
            background: #ffffff;
            border: 2px solid #e9ecef;
            border-radius: 8px;
        }
        
        #calcModal .calc-section h3 {
            margin: 0 0 15px 0;
            color: #495057;
            font-size: 1.2em;
            padding-bottom: 8px;
            border-bottom: 1px solid #dee2e6;
        }
        
        #calcModal .calc-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        #calcModal .calc-row label {
            flex: 0 0 140px;
            font-weight: 600;
            color: #6c757d;
        }
        
        #calcModal .calc-row input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 1em;
        }
        
        #calcModal .calc-row .result {
            flex: 1;
            padding: 8px 12px;
            background: #e7f5ff;
            border: 2px solid #667eea;
            border-radius: 4px;
            font-weight: bold;
            color: #667eea;
        }
        
        #calcModal .calc-row button {
            padding: 8px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
        }
        
        #calcModal .calc-row button:hover {
            background: #5568d3;
        }


        /* Waterfall Filter Styles */
        .filter-row {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
        }

        .filter-group {
            flex: 1;
        }

        .filter-label {
            font-weight: 600;
            font-size: 0.9rem;
            color: #495057;
            margin-bottom: 5px;
        }

        .filter-select {
            width: 100%;
            padding: 8px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }

        .filter-select:focus {
            border-color: #667eea;
            outline: none;
        }

        /* Paperclip Tooltip Styles */
        .paperclip-tooltip {
            position: absolute;
            background: #2c3e50;
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.85rem;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
            min-width: 200px;
        }

        .paperclip-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .paperclip-item:last-child {
            border-bottom: none;
        }

        .paperclip-label {
            font-weight: 600;
            margin-right: 10px;
        }

        .paperclip-value {
            flex: 1;
            margin-right: 10px;
            word-break: break-all;
        }

        .paperclip-icon {
            cursor: pointer;
            font-size: 1.1rem;
            transition: transform 0.2s;
        }

        .paperclip-icon:hover {
            transform: scale(1.2);
        }

        .name-with-tooltip {
            cursor: help;
            position: relative;
        }

        /* Clickable Product Names */
        .clickable-name {
            cursor: pointer;
            transition: color 0.2s ease, text-decoration 0.2s ease;
        }

        .clickable-name:hover {
            color: #0d6efd;
            text-decoration: underline;
        }

        /* SKU Buttons */
        .sku-button {
            font-family: 'Courier New', monospace;
            font-weight: 600;
            padding: 2px 8px;
            font-size: 0.85rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .sku-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .sku-button:active {
            transform: translateY(0);
        }

        /* Spin animation for loading icon */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .spin {
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        /* Zombie Cleanup Styles */
        .zombie-toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }

        .zombie-toggle-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #495057;
            white-space: nowrap;
        }

        .zombie-toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
        }

        .zombie-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .zombie-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 20px;
        }

        .zombie-toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .zombie-toggle-switch input:checked + .zombie-toggle-slider {
            background-color: #dc3545;
        }

        .zombie-toggle-switch input:checked + .zombie-toggle-slider:before {
            transform: translateX(20px);
        }

        #zombieCleanupBtn {
            transition: all 0.3s ease;
        }

        #zombieCleanupBtn.cleanup-mode {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
            border-color: #28a745 !important;
        }

        /* Zombie Cleanup Modal */
        .zombie-modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 10000;
            display: none;
        }

        .zombie-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 25px;
            width: 500px;
            max-width: 90%;
            z-index: 10001;
            display: none;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .zombie-modal h3 {
            margin: 0 0 15px 0;
            color: #dc3545;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .zombie-modal p {
            color: #495057;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .zombie-modal .btn-group-vertical {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .zombie-modal .btn {
            padding: 12px 20px;
            font-weight: 600;
            border-radius: 8px;
        }

        .zombie-progress-container {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .zombie-progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .zombie-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc3545, #fd7e14);
            width: 0%;
            transition: width 0.3s ease;
        }

        .zombie-progress-text {
            font-size: 0.85rem;
            color: #6c757d;
            text-align: center;
        }

        /* Download Filtered Button */
        #downloadFilteredBtn {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container-main">
<div class="header">
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <!-- Profile Selector (Google Chrome Colors) -->
                <div style="display: flex; align-items: center; gap: 10px;">
                    <div style="display: flex; align-items: center; background: linear-gradient(135deg, #4285F4 0%, #34A853 50%, #FBBC05 75%, #EA4335 100%); padding: 2px; border-radius: 8px;">
                        <select id="profile-selector" class="form-select form-select-sm" 
                                style="font-weight: 600; border: none; border-radius: 6px; min-width: 160px; cursor: pointer;"
                                onchange="onProfileChange(this.value)">
                            <option value="">Loading profiles...</option>
                        </select>
                    </div>
                    <button class="btn btn-sm" onclick="openRegisterModal()" 
                            style="background: linear-gradient(135deg, #34A853 0%, #4285F4 100%); color: white; border: none; font-weight: 600; padding: 6px 12px;">
                        <i class="bi bi-plus-lg"></i> New
                    </button>
                </div>
                
                <!-- Tax Calculator Button -->
                <button id="calcDropdownBtn" class="btn btn-primary" onclick="toggleCalcModal()" 
                        style="font-size: 1.2em; padding: 10px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none;">
                     Tax Calculator
                </button>
            </div>
        </div>
        
        <!-- Restart Required Banner (hidden by default) -->
        <div id="restart-banner" style="display: none; background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%); color: white; padding: 12px 20px; text-align: center;">
            <strong><i class="bi bi-arrow-repeat"></i> Profile Changed!</strong> 
            <span id="restart-banner-text">Restart required to apply changes.</span>
            <button class="btn btn-light btn-sm ms-3" onclick="restartApplication()" style="font-weight: 600;">
                <i class="bi bi-power"></i> Restart Now
            </button>
            <button class="btn btn-outline-light btn-sm ms-2" onclick="hideRestartBanner()">
                Later
            </button>
        </div>
        
        <div class="main-nav" style="display: flex; background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
            <button class="main-nav-btn active" onclick="switchMainTab('setup', this)">&#x2699; Setup</button>
            <button class="main-nav-btn" onclick="switchMainTab('mis', this)"> Audit</button>
            <button class="main-nav-btn" onclick="switchMainTab('blaze', this)"> BLAZE</button>
        </div>
        
        <div id="mis-sub-nav" class="sub-nav" style="display:none; padding:10px 20px; background:#fff; border-bottom:1px solid #dee2e6;">
            <button class="sub-nav-btn active" onclick="switchMISTab('csv-gen', this)">Creation Checklist</button>
            <button class="sub-nav-btn" onclick="switchMISTab('id-match', this)">ID Matcher - Google Sheet > MIS CSV</button>
            <button class="sub-nav-btn" onclick="switchMISTab('cleanup-audit', this)" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none;">&#x1F9F9; Cleanup Audit</button>
            <button class="sub-nav-btn" onclick="switchMISTab('split-audit', this)" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none;">&#x2702; Up-Down Planning</button>
            <button class="sub-nav-btn" onclick="switchMISTab('conflict', this)">Conflict Audit - Active</button>
        </div>

        <div class="content" style="padding:40px;">
            <!-- SETUP TAB -->
            <div id="setup-section" class="main-section active">
                
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h2>Setup & Configuration</h2>
                    <div id="browser-ready-status" class="alert alert-secondary py-1 px-3 mb-0" style="font-size: 0.9em;">
                        <strong>Browser:</strong> <span id="browser-ready-text">Initializing...</span>
                    </div>
                </div>

                <div class="row g-3 mb-3">
                    
                    <div class="col-lg-7">
                        <div class="card h-100 shadow-sm">
                            <div class="card-header bg-light fw-bold text-uppercase text-muted small d-flex justify-content-between align-items-center">
                                <span><i class="bi bi-shield-lock"></i> System Credentials</span>
                                <button class="btn btn-danger btn-sm py-0" style="font-size: 0.8em;" data-bs-toggle="modal" data-bs-target="#helpModal">
                                    <i class="bi bi-question-circle-fill"></i> HELP!
                                </button>
                            </div>
                            <div class="card-body d-flex flex-column justify-content-center">
                                
                                <div class="d-flex align-items-center gap-3 mb-3 pb-3 border-bottom">
                                    <button class="btn btn-outline-primary btn-sm" onclick="authenticateGoogle()">Authenticate Google Sheets</button>
                                    <div id="auth-status" class="d-inline-block small"></div> 
                                </div>

                                <div class="row g-2 align-items-center mb-3">
                                    <div class="col-9">
                                        <div class="input-group">
                                            <span class="input-group-text bg-white"><i class="bi bi-link-45deg"></i></span>
                                            <input type="text" id="mis-sheet-url" class="form-control" placeholder="Google Sheet URL">
                                        </div>
                                    </div>
                                    <div class="col-3">
                                        <button class="btn btn-secondary w-100" onclick="loadMISSheetTabs(this)">Load Tabs</button>
                                    </div>
                                </div>

                                <div class="row g-2 align-items-center">
                                    <div class="col-md-6">
                                        <select id="mis-tab" class="form-select form-select-sm">
                                            <option value="">-- No tabs loaded --</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6 d-flex align-items-center gap-2">
                                        <div class="form-check form-switch mb-0" style="white-space: nowrap;">
                                            <input class="form-check-input" type="checkbox" id="mis-show-all-tabs" onchange="renderTabOptions()">
                                            <label class="form-check-label small" for="mis-show-all-tabs">All Tabs</label>
                                        </div>
                                        <button class="btn btn-primary btn-sm flex-grow-1" onclick="initializeSheetPage(this)">Open Sheet</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="col-lg-5">
                        <div class="card h-100 shadow-sm">
                            <div class="card-header bg-light fw-bold text-uppercase text-muted small">
                                <i class="bi bi-shield-lock"></i> System Credentials
                            </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6 border-end">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <div class="d-flex align-items-center gap-2">
                                        <h6 class="text-muted fw-bold mb-0">MIS Config</h6>
                                        <button class="btn btn-outline-success py-0 px-2" style="font-size: 0.75em; height: 20px; line-height: 1;" onclick="pullMisCsv(this)">
                                            <i class="bi bi-download"></i> MIS CSV
                                        </button>
                                        <button class="btn btn-outline-secondary py-0 px-2" style="font-size: 0.75em; height: 20px; line-height: 1;" onclick="openMisReportsFolder()" title="Open MIS Reports folder">
                                            <i class="bi bi-folder2-open"></i>
                                        </button>
                                    </div>
                                    <div style="width: 50%;">
                                        <input type="file" id="mis-csv" accept=".csv" class="form-control form-control-sm" style="font-size: 0.8em;" onchange="handleMISCSV(this)">
                                    </div>
                                </div>
                                <div id="mis-csv-status" class="small text-success text-end mb-2" style="min-height: 1.2em; font-size: 0.75em; margin-top:-5px;"></div>
                                <div id="mis-csv-folder-path" class="small text-muted text-end" style="font-size: 0.65em; margin-top:-10px; word-break: break-all;"></div>

                                <div class="mb-2">
                                    <input type="text" id="mis-username" class="form-control form-control-sm mb-1" placeholder="MIS Username">
                                    <input type="password" id="mis-password" class="form-control form-control-sm" placeholder="MIS Password">
                                </div>
                            </div>

                            <div class="col-md-6">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <div class="d-flex align-items-center gap-2">
                                        <h6 class="text-muted fw-bold mb-0">Blaze Config</h6>
                                        <button class="btn btn-outline-warning py-0 px-2" 
                                                style="font-size: 0.75em; height: 20px; line-height: 1; font-weight: bold; color: #d39e00; border-color: #ffc107;" 
                                                onclick="runTierUpdate(this)"
                                                title="Run automated tag updates for T1/T2/T3 Bag Days">
                                            Update Tier Promos
                                        </button>
                                    </div>
                                </div>
                                
                                <div id="blaze-sync-status" class="small mb-1" style="min-height:18px; font-size: 0.8em;"></div>

                                <div class="mb-2 mt-1">
                                    <input type="text" id="blaze-email" class="form-control form-control-sm mb-1" placeholder="Blaze Email">
                                    <input type="password" id="blaze-password" class="form-control form-control-sm" placeholder="Blaze Password">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                </div>  <!-- Close col-lg-5 -->
            </div>  <!-- Close row g-3 mb-3 -->


                <div class="d-grid gap-2">
                    <button class="btn btn-success btn-lg fw-bold" onclick="initializeAllSystems()">
                        <i class="bi bi-play-circle-fill"></i> Initialize Browser & Login to Both Systems
                    </button>
                    <div id="init-status" class="text-center mt-2"></div>
                </div>

                <!-- TAX RATES CONFIGURATION -->
                <div class="row g-3 mt-3">
                    <div class="col-12">
                        <div class="card shadow-sm">
                            <div class="card-header bg-light fw-bold text-uppercase text-muted small">
                                <i class="bi bi-calculator"></i> &#x1F5A9; Tax Rates Configuration
                            </div>
                            <div class="card-body">
                                <p class="text-muted small mb-3">
                                    Edit tax rates below. Default values are hardcoded. Changes are saved to <code>tax_config.json</code>.
                                </p>
                                <div class="row g-2" id="tax-rates-container">
                                    <!-- Tax rate inputs will be populated by JavaScript -->
                                </div>
                                <div class="d-flex justify-content-end gap-2 mt-3">
                                    <button class="btn btn-secondary" onclick="loadTaxRatesForEdit()">
                                        <i class="bi bi-arrow-clockwise"></i> Reload
                                    </button>
                                    <button class="btn btn-primary" onclick="saveTaxRates()">
                                        <i class="bi bi-save"></i> Save Tax Rates
                                    </button>
                                </div>
                                <div id="tax-save-status" class="mt-2 text-center small"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="setup-summary"></div>
            </div>
            
            <!-- MIS TAB -->
            <div id="mis-section" class="main-section">
                
                <!-- Creation Checklist -->
                <div id="csv-gen-section" class="sub-section active">
                    <h2>Creation Checklist</h2>
                    <button class="btn" onclick="generateCSV()">Generate CSV</button>
                    <div id="gen-results">
                        <!-- Deal type sub-tabs will be injected here by displayGeneratedCSV() -->
                    </div>
                </div>
                
                <!-- ID Matcher -->
                <div id="id-match-section" class="sub-section">
                    <h2>ID Matcher</h2>
                    
                    <!-- v12.1: Subtabs for ID Matcher and MAudit -->
                    <ul class="nav nav-tabs mb-3" id="idMatcherSubTabs">
                        <li class="nav-item">
                            <a class="nav-link active" href="#" onclick="switchIdMatcherSubTab('matcher', this); return false;">ID Matcher</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#" onclick="switchIdMatcherSubTab('maudit', this); return false;">Google > MAudit</a>
                        </li>
                    </ul>
                    
                    <!-- ID Matcher Subtab Content -->
                    <div id="id-matcher-subtab-matcher" class="id-matcher-subtab-content">
                        <div class="focus-panel" id="matcher-focus-panel">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="matcher-focus-enable" onchange="toggleFocus('matcher')">
                                <label class="form-check-label fw-bold" for="matcher-focus-enable"> Enable Focus</label>
                            </div>
                            <div id="matcher-focus-controls" style="display:flex; gap:15px; opacity:0.5; pointer-events:none;">
                                <input type="date" id="matcher-focus-date" class="form-control" style="width:auto;">
                                <div class="form-check form-switch pt-2">
                                    <input class="form-check-input" type="checkbox" id="matcher-focus-expand">
                                    <label class="form-check-label" for="matcher-focus-expand"> Expand to Month</label>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 10px; margin-left: auto;">
                                <button class="btn" onclick="runMatcher()">Run Matcher</button>
                                <div id="apply-btns-container" style="display:none;">
                                    <button id="apply-mis-btn" class="btn btn-success btn-sm" onclick="applyMatches('mis')" title="Apply only MIS IDs to Google Sheet">
                                        <i class="bi bi-file-earmark-plus"></i> Apply MIS IDs
                                    </button>
                                    <button id="apply-blaze-btn" class="btn btn-primary btn-sm" onclick="applyMatches('blaze')" title="Apply only Blaze Titles to Google Sheet">
                                        <i class="bi bi-lightning-charge"></i> Apply Blaze Titles
                                    </button>
                                    <button id="apply-all-btn" class="btn btn-warning btn-sm" onclick="applyMatches('all')" title="Apply both MIS IDs and Blaze Titles">
                                        <i class="bi bi-check2-all"></i> Apply All
                                    </button>
                                </div>
                                <span id="matcher-status" style="color: #666; font-style: italic; font-size: 0.9em;"></span>
                            </div>
                        </div>
                        <div id="match-results">
                            <!-- Deal type sub-tabs will be injected here by displayMatchResults() -->
                        </div>
                    </div>
                    
                    <!-- MAudit Subtab Content (v12.1) -->
                    <div id="id-matcher-subtab-maudit" class="id-matcher-subtab-content" style="display:none;">
                        <div class="alert alert-info mb-3">
                            <i class="bi bi-info-circle"></i> 
                            <strong>Google > MAudit:</strong> Verify Google Sheet deals against MIS CSV data.
                            <br><small class="text-muted">Compares: Discount, Vendor %, Start/End Dates, Brand, Locations. Groups by verification status.</small>
                        </div>
                        
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div>
                                <button class="btn btn-primary" onclick="runMAudit()">
                                    <i class="bi bi-check2-circle"></i> Run MAudit Verification
                                </button>
                                <span id="maudit-status" class="ms-2" style="color: #666; font-style: italic;"></span>
                            </div>
                        </div>
                        
                        <div id="maudit-results">
                            <!-- MAudit results will be injected here by renderMAuditResults() -->
                            <p class="text-muted">Click "Run MAudit Verification" to compare Google Sheet against MIS CSV.</p>
                        </div>
                    </div>
                </div>
                <div id="conflict-section" class="sub-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h2>[!] [EMOJI]√É‚Äö√Ç¬è Conflict Audit</h2>
                        <div>
                            <span id="conflict-stats" class="badge bg-secondary fs-6 me-2">Ready to Scan</span>
                            <button class="btn btn-warning fw-bold" onclick="runConflictAudit()">
                                <i class="bi bi-radioactive"></i> Run Conflict Check
                            </button>
                        </div>
                    </div>
                    
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle"></i> 
                        Scans <strong>Active Deals</strong> (running today) in MIS .CSV for duplicates/potential conflicts based on 
                        <strong>Brand and Weekday</strong>, ignores store location for now.
                    </div>

                    <div id="conflict-results">
                        <!-- Conflict results will be injected here by renderConflictResults() -->
                    </div>
                </div> 

                <!-- ============================================ -->
                <!-- CLEANUP AUDIT - Find stale MIS entries -->
                <!-- ============================================ -->
                <div id="cleanup-audit-section" class="sub-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h2 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                            &#x1F9F9; Cleanup Audit
                        </h2>
                        <div>
                            <span id="cleanup-audit-stats" class="badge bg-secondary fs-6 me-2">Ready</span>
                            <button class="btn btn-primary fw-bold" onclick="runCleanupAudit()">
                                <i class="bi bi-search"></i> Run Cleanup Audit
                            </button>
                        </div>
                    </div>

                    <div class="alert alert-info mb-3">
                        <strong><i class="bi bi-lightbulb"></i> Purpose:</strong> Find active MIS entries that should be turned off.
                        <br><small class="text-muted">
                            Identifies MIS entries that are <strong>active</strong> (no end date or end date in future) 
                            but are <strong>NOT</strong> found in the Google Sheet. These are potential stragglers from old deals.
                        </small>
                    </div>

                    <!-- Detection Method Sub-Tabs -->
                    <ul class="nav nav-tabs mb-3" id="cleanupMethodTabs">
                        <li class="nav-item">
                            <a class="nav-link active" href="#" onclick="switchCleanupMethod('full-match', this); return false;">
                                <i class="bi bi-check2-all"></i> Full Field Match
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#" onclick="switchCleanupMethod('id-only', this); return false;">
                                <i class="bi bi-hash"></i> MIS ID Only
                            </a>
                        </li>
                    </ul>

                    <!-- Method 1: Full Field Match -->
                    <div id="cleanup-method-full-match" class="cleanup-method-content" style="display:block;">
                        <div class="alert alert-secondary mb-3">
                            <strong>Full Field Match:</strong> Finds active MIS entries where Brand + Weekday + Discount + Vendor% + Locations 
                            do NOT match any row in the Google Sheet.
                        </div>
                        
                        <!-- Section Sub-Tabs (Weekly/Monthly/Sale) -->
                        <ul class="nav nav-pills mb-3" id="cleanupFullMatchSectionTabs">
                            <li class="nav-item">
                                <a class="nav-link active" href="#" onclick="filterCleanupSection('full-match', 'all', this); return false;">All</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('full-match', 'weekly', this); return false;">Weekly</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('full-match', 'monthly', this); return false;">Monthly</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('full-match', 'sale', this); return false;">Sale</a>
                            </li>
                        </ul>
                        
                        <div id="cleanup-full-match-results">
                            <p class="text-muted">Click "Run Cleanup Audit" to scan for stale MIS entries.</p>
                        </div>
                    </div>

                    <!-- Method 2: MIS ID Only -->
                    <div id="cleanup-method-id-only" class="cleanup-method-content" style="display:none;">
                        <div class="alert alert-secondary mb-3">
                            <strong>MIS ID Only:</strong> Finds active MIS entries whose ID does NOT appear anywhere 
                            in the Google Sheet's MIS ID column.
                        </div>
                        
                        <!-- Section Sub-Tabs (Weekly/Monthly/Sale) -->
                        <ul class="nav nav-pills mb-3" id="cleanupIdOnlySectionTabs">
                            <li class="nav-item">
                                <a class="nav-link active" href="#" onclick="filterCleanupSection('id-only', 'all', this); return false;">All</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('id-only', 'weekly', this); return false;">Weekly</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('id-only', 'monthly', this); return false;">Monthly</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="#" onclick="filterCleanupSection('id-only', 'sale', this); return false;">Sale</a>
                            </li>
                        </ul>
                        
                        <div id="cleanup-id-only-results">
                            <p class="text-muted">Click "Run Cleanup Audit" to scan for stale MIS entries.</p>
                        </div>
                    </div>
                </div>

                <!-- ============================================ -->
                <!-- UP-DOWN PLANNING (formerly Split Audit) -->
                <!-- ============================================ -->
                <div id="split-audit-section" class="sub-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h2 style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">
                            &#x2702; Up-Down Planning
                        </h2>
                        <span id="split-audit-stats" class="badge bg-secondary fs-6">Ready</span>
                    </div>

                    <div class="alert alert-info mb-3">
                        <strong><i class="bi bi-lightbulb"></i> Purpose:</strong> Manage Weekly Deal splits when interrupted by Sale/Monthly deals.
                        <br><small class="text-muted">
                            <strong>Dominance Hierarchy:</strong> Sale/Monthly (Tier 1) > Weekly (Tier 2). 
                            Weekly deals must be <em>split</em> in MIS to avoid overlap on conflict dates.
                        </small>
                    </div>

                    <!-- Phase Sub-Tabs -->
                    <div class="btn-group mb-3" role="group" style="width: 100%;">
                        <button type="button" class="btn btn-outline-primary active split-phase-btn" 
                                onclick="switchSplitPhase('planning', this)" style="flex: 1;">
                            <i class="bi bi-list-task"></i> Phase 1: Planning
                        </button>
                        <button type="button" class="btn btn-outline-success split-phase-btn" 
                                onclick="switchSplitPhase('final-check', this)" style="flex: 1;">
                            <i class="bi bi-check2-all"></i> Phase 2: Final Verification
                        </button>
                    </div>

                    <!-- Phase 1: Planning -->
                    <div id="split-phase-planning" class="split-phase-content active">
                        <div class="card shadow-sm">
                            <div class="card-header bg-primary text-white">
                                <strong><i class="bi bi-list-task"></i> Phase 1: Planning (Google Sheet Only)</strong>
                            </div>
                            <div class="card-body">
                                <p class="text-muted mb-3">
                                    <strong>Goal:</strong> Analyze your Google Sheet and generate a <em>To-Do List</em> for MIS entries.
                                    <br>If a Weekly deal conflicts with a Sale/Monthly deal on specific dates, you'll see exactly how to split it.
                                </p>
                                
                                <div class="text-center mb-4">
                                    <button class="btn btn-primary btn-lg fw-bold shadow" onclick="runSplitPlanningAudit()" style="padding: 15px 40px;">
                                        <i class="bi bi-calendar-check"></i> Generate Split Plan
                                    </button>
                                </div>

                                <div id="split-planning-results">
                                    <!-- Planning results will be injected here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Phase 2: Final Verification -->
                    <div id="split-phase-final-check" class="split-phase-content" style="display: none;">
                        <div class="card shadow-sm">
                            <div class="card-header bg-success text-white">
                                <strong><i class="bi bi-check2-all"></i> Phase 2: Final Verification (Sheet + MIS CSV)</strong>
                            </div>
                            <div class="card-body">
                                <p class="text-muted mb-3">
                                    <strong>Goal:</strong> Verify that deals created in MIS match the expected entry plans from Phase 1.
                                    <br>Compares MIS IDs logged in Google Sheet against actual CSV data.
                                </p>

                                <div class="alert alert-success">
                                    <i class="bi bi-info-circle"></i> 
                                    <strong>Prerequisites:</strong>
                                    <ul class="mb-0 mt-2">
                                        <li>Complete Phase 1 to generate split plans</li>
                                        <li>Create all deals in MIS (Part 1, GAP, PATCH, Part 2)</li>
                                        <li>Log MIS IDs in Google Sheet using Apply buttons (with prefixes: "Gap: ", "Patch: ")</li>
                                        <li>Pull the latest MIS CSV after creating all deals</li>
                                    </ul>
                                </div>
                                
                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <div class="card border-secondary">
                                            <div class="card-body text-center">
                                                <div class="mb-2 text-muted small">MIS CSV Status</div>
                                                <div id="phase2-csv-status" class="fw-bold text-secondary">
                                                    <i class="bi bi-file-earmark-x"></i> No CSV Loaded
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card border-secondary">
                                            <div class="card-body text-center">
                                                <button class="btn btn-outline-primary btn-sm" onclick="pullMisCsvForPhase2()">
                                                    <i class="bi bi-cloud-download"></i> Pull MIS CSV
                                                </button>
                                                <span class="text-muted small ms-2">(Updates global CSV)</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="text-center mb-4">
                                    <button class="btn btn-success btn-lg fw-bold shadow" onclick="runPhase2FinalCheck()" style="padding: 15px 40px;">
                                        <i class="bi bi-shield-check"></i> Run Final Verification
                                    </button>
                                </div>

                                <div id="split-final-check-results">
                                    <!-- Final verification results will be injected here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div> <div id="blaze-section" class="main-section">
                
                <div class="mb-3" style="border-bottom: 1px solid #dee2e6; padding-bottom: 10px;">
                    <div class="btn-group">
                        <button class="btn btn-outline-primary active" id="btn-blaze-promo" onclick="switchBlazeTab('promo')">
                            &#x1F5A9; Company Promotions
                        </button>
                        <button class="btn btn-outline-primary" id="btn-blaze-inv" onclick="switchBlazeTab('inv')">
                             Inventory Report
                        </button>
                    </div>
                </div>

                <div id="blaze-promo-content">
                    <div class="card shadow-sm">
                        <div class="card-header bg-white">
                            <div class="d-flex justify-content-between align-items-start gap-3">
                                <div style="flex: 1; min-width: 250px;">
                                    <div class="fw-bold mb-2"><i class="bi bi-table"></i> Live Promotions Data</div>
                                    <div class="input-group input-group-sm mb-2">
                                        <span class="input-group-text bg-light"><i class="bi bi-search"></i></span>
                                        <input type="text" id="blazeNameSearch" class="form-control" placeholder="Filter by Name..." onkeyup="handlePrimaryInput()">
                                    </div>
                                    <div class="input-group input-group-sm" id="subSearchContainer" style="display: none;">
                                        <span class="input-group-text bg-light"><i class="bi bi-filter"></i></span>
                                        <input type="text" id="blazeSubSearch" class="form-control" placeholder="Search within results..." onkeyup="applyBlazeFilters()">
                                    </div>
                                </div>
                                
                                <div style="font-size: 0.85em; display: flex; gap: 15px; flex: 1;">
                                    <div id="filteredStatsGroup" style="text-align: right; border-right: 1px solid #dee2e6; padding-right: 15px; display: none;">
                                        <div class="text-muted small fw-bold text-uppercase" style="font-size: 0.75em;">Filtered Results</div>
                                        <span class="badge bg-primary" id="filteredCount">0 Visible</span>
                                        <span class="badge bg-white text-success border border-success" id="filteredActive">0 Active</span>
                                        <span class="badge bg-white text-danger border border-danger" id="filteredInactive">0 Inactive</span>
                                        <span class="badge bg-danger" id="filteredZombie" title="Active deals past end date"> 0 Zombie</span>
                                    </div>

                                    <div style="text-align: right;">
                                        <div class="text-muted small fw-bold text-uppercase" style="font-size: 0.75em;">Total Count</div>
                                        <span class="badge bg-secondary" id="totalCount">0 Total Promotions</span>
                                        <span class="badge bg-white text-success border border-success" id="totalActive">0 Active</span>
                                        <span class="badge bg-white text-danger border border-danger" id="totalInactive">0 Inactive</span>
                                        <span class="badge bg-danger" id="totalZombie" title="Active deals past end date"> 0 Zombie</span>
                                    </div>
                                </div>
                                
                                <div style="min-width: 200px;">
                                    <div class="d-grid gap-2">
                                        <button onclick="fetchBlazeData()" class="btn btn-primary btn-sm fw-bold">
                                            <i class="bi bi-arrow-clockwise"></i> Refresh / Sync Data
                                        </button>
                                        <button onclick="exportData('full')" class="btn btn-primary btn-sm">
                                            <i class="bi bi-database"></i> Full Report
                                        </button>
                                        <button id="downloadFilteredBtn" onclick="exportFilteredData()" class="btn btn-info btn-sm">
                                            <i class="bi bi-funnel"></i> Download Filtered
                                        </button>
                                    </div>
                                    <div class="mt-2 d-flex gap-2 align-items-center">
                                        <div class="zombie-toggle-container">
                                            <span class="zombie-toggle-label"> Cleanup</span>
                                            <label class="zombie-toggle-switch">
                                                <input type="checkbox" id="zombieCleanupToggle" onchange="toggleZombieCleanupMode()">
                                                <span class="zombie-toggle-slider"></span>
                                            </label>
                                        </div>
                                        <button id="zombieCleanupBtn" onclick="startZombieCleanup()" class="btn btn-danger btn-sm" style="display: none;">
                                             Zombie Cleanup
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-body p-0">
                            <div id="promotionsTableWrapper">
                                <table id="promotionsTable" class="table table-striped table-hover w-100 mb-0" style="font-size: 0.8rem;">
                                    <thead>
                                        <tr>
                                            <th>Detail</th>
                                            <th>ID</th>
                                            <th>Name</th>
                                            <th>Status</th>
                                            <th>Auto/Manual</th>
                                            <th>Locations</th>
                                            <th>Groups (Buy)</th>
                                            <th>Groups (Get)</th>
                                            <th>Type</th>
                                            <th>Value</th>
                                            <th>Start</th>
                                            <th>End</th>
                                            <th>Days Until End</th>
                                        </tr>
                                    </thead>
                                    <tbody></tbody>
                                </table>
                            </div> 
                        </div> 
                    </div> 
                </div>

                <div id="blaze-inv-content" style="display:none;">
                    <!-- Control Bar -->
                    <div class="card shadow-sm mb-3">
                        <div class="card-body py-2">
                            <div class="row g-2">
                                <!-- Left Column: Fetch & Load (Stacked) -->
                                <div class="col-md-4">
                                    <!-- Fetch Fresh Section -->
                                    <div class="mb-2">
                                        <div class="input-group input-group-sm">
                                            <span class="input-group-text fw-bold"> Fetch Fresh</span>
                                            <select id="invStoreSelect" class="form-select">
                                                <option value="">-- Select Store --</option>
                                                <option value="The Artist Tree - West Hollywood">West Hollywood</option>
                                                <option value="The Artist Tree - Beverly Hills">Beverly Hills</option>
                                                <option value="The Artist Tree - Koreatown">Koreatown</option>
                                                <option value="The Artist Tree - Riverside">Riverside</option>
                                                <option value="The Artist Tree - Fresno">Fresno (Palm)</option>
                                                <option value="The Artist Tree - Fresno Shaw">Fresno Shaw</option>
                                                <option value="The Artist Tree - Oxnard">Oxnard</option>
                                                <option value="The Artist Tree - El Sobrante">El Sobrante</option>
                                                <option value="The Artist Tree - Laguna Woods">Laguna Woods</option>
                                                <option value="The Artist Tree - Hawthorne">Hawthorne</option>
                                                <option value="The Artist Tree - Dixon">Dixon</option>
                                                <option value="The Artist Tree - Davis">Davis</option>
                                            </select>
                                            <button id="btnFetchFresh" class="btn btn-primary btn-sm fw-bold" onclick="fetchInventoryData()">
                                                <i class="bi bi-cloud-download"></i> Fetch
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <!-- Load Saved Section -->
                                    <div>
                                        <div class="input-group input-group-sm">
                                            <span class="input-group-text fw-bold"> Load Saved</span>
                                            <select id="savedReportsDropdown" class="form-select">
                                                <option value="">-- Select Report --</option>
                                            </select>
                                            <button class="btn btn-info btn-sm fw-bold" onclick="loadSavedReport()">
                                                <i class="bi bi-folder-open"></i> Load
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Middle Column: Debug Log -->
                                <div class="col-md-6">
                                    <div class="debug-log-panel" id="debugLogPanel" style="display: none;">
                                        <div class="d-flex justify-content-between align-items-center mb-1">
                                            <span class="fw-bold text-primary small"> FETCH DEBUG LOG</span>
                                            <span class="small text-muted">
                                                <i class="bi bi-clock"></i> <span id="debugTimer">00:00</span> | 
                                                ETA: <span id="debugETA">--</span>
                                            </span>
                                        </div>
                                        <div class="progress mb-1" style="height: 8px;">
                                            <div id="debugProgress" class="progress-bar progress-bar-striped progress-bar-animated" 
                                                 role="progressbar" style="width: 0%"></div>
                                        </div>
                                        <div id="debugMessages" class="debug-messages small">
                                            <!-- Log messages appear here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- Right Column: Export Button -->
                                <div class="col-md-2 d-flex align-items-center justify-content-end">
                                    <button class="btn btn-success btn-sm fw-bold" onclick="openInventoryExportModal()">
                                        <i class="bi bi-file-earmark-excel"></i> Export
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    

                    <!-- Status Bar (shows current data info) -->
                    <div class="card shadow-sm mb-2" id="inventoryStatusCard" style="display: none;">
                        <div class="card-body py-1 bg-light">
                            <span id="inventoryStatusText" class="text-muted small"></span>
                        </div>
                    </div>

                    <!-- Filter Bar -->
                    <div class="card shadow-sm mb-2">
                        <div class="card-body py-2 bg-light">
                            <div class="row g-2">
                                <!-- First Row: Search Bars -->
                                <div class="col-md-3">
                                    <div class="input-group input-group-sm">
                                        <span class="input-group-text"></span>
                                        <input type="text" id="invSearchName" class="form-control form-control-sm" 
                                               placeholder="Search Name (Primary)..." 
                                               onkeyup="debouncedInventorySearch()">
                                        <button class="btn btn-outline-secondary btn-sm" onclick="clearSearchField('invSearchName')" title="Clear">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="input-group input-group-sm">
                                        <span class="input-group-text"></span>
                                        <input type="text" id="invSearchName2" class="form-control form-control-sm" 
                                               placeholder="Search Name (Secondary)..." 
                                               onkeyup="debouncedInventorySearch()">
                                        <button class="btn btn-outline-secondary btn-sm" onclick="clearSearchField('invSearchName2')" title="Clear">
                                            <i class="bi bi-x"></i>
                                        </button>
                                    </div>
                                </div>
                                <!-- Second Row: Dropdowns & Checkbox -->
                                <div class="col-md-2">
                                    <select id="invFilterBrand" class="form-select form-select-sm" onchange="applyInventoryFilters()">
                                        <option value="">All Brands</option>
                                    </select>
                                </div>
                                <div class="col-md-2">
                                    <select id="invFilterCategory" class="form-select form-select-sm" onchange="applyInventoryFilters()">
                                        <option value="">All Categories</option>
                                    </select>
                                </div>
                                <div class="col-md-2">
                                    <div class="form-check" style="padding-top: 6px;">
                                        <input class="form-check-input" type="checkbox" id="invHideZeroQty" 
                                               onchange="applyInventoryFilters()">
                                        <label class="form-check-label small" for="invHideZeroQty">
                                            &#x261E;[EMOJI]√É‚Äö√Ç¬è Hide 0 Qty
                                        </label>
                                    </div>
                                </div>
                                <!-- Third Row: Action Buttons & Count -->
                                <div class="col-md-12 text-end">
                                    <button class="btn btn-outline-secondary btn-sm" onclick="clearInventoryFilters()">
                                        <i class="bi bi-x-circle"></i> Clear All Filters
                                    </button>
                                    <span id="invRowCount" class="badge bg-secondary ms-2">0 Items</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Data Table -->
                    <div class="card shadow-sm">
                        <div class="card-body p-0">
                            <div class="table-responsive scrollable-table-container" style="height: 65vh;">
                                <table id="inventoryTable" class="table table-striped table-hover w-100 mb-0 table-sm" style="font-size: 0.85rem;">
                                    <thead class="sticky-top bg-white" style="z-index: 10;">
                                        <tr>
                                            <th style="width: 120px;">SKU</th>
                                            <th style="width: 300px;">Name</th>
                                            <th>Brand</th>
                                            <th>Category</th>
                                            <th class="text-end">Price</th>
                                            <th class="text-end">Qty</th>
                                            <th class="text-end">Weight</th>
                                        </tr>
                                    </thead>
                                    <tbody id="inventoryTableBody">
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Status Log -->
                    <div id="inventory-status-log" class="small text-muted mt-2 ps-2"></div>
                </div>

            </div>
    
    <div id="suggestion-tooltip" class="tooltip-container"></div>
    <div id="brand-sticky-popup" class="brand-popup">
        <div class="brand-popup-header">
            <span>Select Brand</span>
            <span class="brand-popup-close" onclick="closeBrandPopup()">X[EMOJI]√É‚Äö√Ç¬ù</span>
        </div>
        <div class="brand-popup-body" id="brand-popup-list"></div>
    </div>
    
    <!-- Paperclip Tooltip (Hidden, shown on hover) -->
    <div id="paperclip-tooltip" class="paperclip-tooltip"></div>

    <!-- Inventory Export Modal -->
    <div class="modal fade" id="inventoryExportModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"> Export Inventory Report</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="exportNoTabs" class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i> No data tabs are currently open. Please fetch or load data first.
                    </div>
                    
                    <div id="exportTabsSection" style="display: none;">
                        <label class="fw-bold mb-2">Select Tabs to Export:</label>
                        <div class="form-check mb-2">
                            <input class="form-check-input" type="checkbox" id="exportAllTabs" onchange="toggleAllTabsExport(this)" checked>
                            <label class="form-check-label fw-bold" for="exportAllTabs">
                                All Open Tabs
                            </label>
                        </div>
                        <hr class="my-2">
                        <div id="exportTabsList">
                            <!-- Checkboxes for open tabs will be dynamically added here -->
                        </div>
                        <div class="alert alert-info mt-3 small">
                            <strong>&#x1F4A1; Export Format:</strong><br>
                            &#x2022; 1 tab selected ->[EMOJI] CSV file<br>
                            &#x2022; Multiple tabs ->[EMOJI] Excel workbook (.xlsx) with separate sheets
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-success" onclick="generateInventoryReport()" id="exportDownloadBtn" disabled>
                        <i class="bi bi-download"></i> Download
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.0.js"></script>
    <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/1.13.6/js/dataTables.bootstrap5.min.js"></script>
    
    <script>
        let currentMainTab = 'setup';
        let currentMISTab = 'csv-gen';
        let approvedMatches = {};
        let matchesData = [];
        let misData = { tabName: '', csvFile: null, csvFilename: '', allLoadedTabs: [], localPath: null };
        let blazeData = { rawData: [], filteredData: [], table: null };

        const STRICT_OTD_STORES = ["Davis", "Dixon"];   
        const VALID_MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
        
        function switchMainTab(tabName, btnElement) {
            // 1. Hide all main sections
            document.querySelectorAll('.main-section').forEach(s => {
                s.style.display = 'none';
                s.classList.remove('active');
            });
            
            // 2. Deactivate all main buttons
            document.querySelectorAll('.main-nav-btn').forEach(b => b.classList.remove('active'));
            
            // 3. Show Target Section (Force Display Block)
            const target = document.getElementById(tabName + '-section');
            if (target) {
                target.style.display = 'block';
                target.classList.add('active');
            }
            
            // 4. Activate Button (Use 'this' if passed, else fallback)
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            currentMainTab = tabName;
            
            // 5. Handle MIS Sub-Nav Visibility
            const misNav = document.getElementById('mis-sub-nav');
            if (tabName === 'mis') {
                misNav.style.display = 'flex'; // Force Flex
            } else {
                misNav.style.display = 'none';
            }

            // 6. Blaze Tab Fix (Recalculate Table Widths)
            if (tabName === 'blaze') {
                setTimeout(function() {
                    if ($.fn.DataTable.isDataTable('#promotionsTable')) {
                        const table = $('#promotionsTable').DataTable();
                        table.columns.adjust();
                        table.draw(false); // false = don't reset paging
                        // Force scroll body to recalculate
                        $(window).trigger('resize');
                    }
                }, 100);
            }
        }
        
        function switchMISTab(tabName, btnElement) {
            // 1. Hide all sub-sections
            document.querySelectorAll('.sub-section').forEach(s => {
                s.style.display = 'none';
                s.classList.remove('active');
            });
            
            // 2. Deactivate all sub-nav buttons
            document.querySelectorAll('.sub-nav-btn').forEach(b => b.classList.remove('active'));
            
            // 3. Show Target (Force Display Block)
            const target = document.getElementById(tabName + '-section');
            if (target) {
                target.style.display = 'block';
                target.classList.add('active');
            }
            
            // 4. Activate Button
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            currentMISTab = tabName;
        }
        
        // ============================================
        // DEAL TYPE SUB-TAB SWITCHING (Weekly/Monthly/Sale/All)
        // ============================================
        function switchDealTypeTab(containerId, dealType, btnElement) {
            // Find the parent container
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // v88: Special handling for match-results which uses unified table with filtering
            if (containerId === 'match-results') {
                // Just filter rows by section, don't hide containers
                filterMatchResultsBySection(dealType);
                
                // Update button active state
                container.querySelectorAll('.deal-type-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                if (btnElement) {
                    btnElement.classList.add('active');
                }
                console.log(`[TAB] Filtered match-results to ${dealType}`);
                return;
            }
            
            // 1. Hide all deal-type-content sections within this container
            container.querySelectorAll('.deal-type-content').forEach(section => {
                section.style.display = 'none';
                section.classList.remove('active');
            });
            
            // 2. Deactivate all deal-type buttons within this container
            container.querySelectorAll('.deal-type-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 3. Show the target content
            const targetContent = container.querySelector(`#${containerId}-${dealType}`);
            if (targetContent) {
                targetContent.style.display = 'block';
                targetContent.classList.add('active');
            }
            
            // 4. Activate the clicked button
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            console.log(`[TAB] Switched to ${dealType} in ${containerId}`);
        }
        
        // Helper to generate deal-type sub-tab HTML structure
        function generateDealTypeTabsHTML(containerId, counts = {weekly: 0, monthly: 0, sale: 0}) {
            return `
                <div class="deal-type-tabs" style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                    <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'weekly', this)">
                        &#x1F4C5; Weekly Deals <span class="badge bg-primary">${counts.weekly}</span>
                    </button>
                    <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'monthly', this)">
                         Monthly Deals <span class="badge bg-info">${counts.monthly}</span>
                    </button>
                    <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'sale', this)">
                         Sale Deals <span class="badge bg-warning text-dark">${counts.sale}</span>
                    </button>
                    <button class="deal-type-btn active" onclick="switchDealTypeTab('${containerId}', 'all', this)">
                         All Deals <span class="badge bg-secondary">${counts.weekly + counts.monthly + counts.sale}</span>
                    </button>
                    
                    <div style="margin-left:auto; display:flex; align-items:center; gap:8px; padding:8px 12px; background:#f8f9fa; border-radius:6px; border:1px solid #dee2e6;">
                        <span style="font-size:0.85em; font-weight:500; color:#6c757d;">Weekly View:</span>
                        <div class="btn-group btn-group-sm" role="group">
                            <button type="button" class="btn btn-outline-secondary" id="weekly-view-breakdown" onclick="toggleWeeklyView('breakdown')" style="font-size:0.85em; padding:4px 12px;">
                                Breakdown List
                            </button>
                            <button type="button" class="btn btn-outline-secondary" id="weekly-view-full" onclick="toggleWeeklyView('full')" style="font-size:0.85em; padding:4px 12px;">
                                Full List
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // v12.2: Weekly view mode tracker (default: breakdown)
        let weeklyViewMode = 'breakdown';
        let originalTableState = null; // Store original table HTML before breakdown modifies it
        
        // v12.2: Toggle between Breakdown List and Full List for Weekly deals
        function toggleWeeklyView(mode) {
            weeklyViewMode = mode;
            
            // Update button states
            const breakdownBtn = document.getElementById('weekly-view-breakdown');
            const fullBtn = document.getElementById('weekly-view-full');
            if (breakdownBtn) breakdownBtn.classList.toggle('active', mode === 'breakdown');
            if (fullBtn) fullBtn.classList.toggle('active', mode === 'full');
            
            console.log('[TOGGLE] Switching to:', mode);
            
            if (mode === 'full') {
                // RESTORE ORIGINAL TABLE STATE
                const table = document.getElementById('match-results-unified-table');
                if (table && originalTableState) {
                    const tbody = table.querySelector('tbody');
                    if (tbody) {
                        console.log('[TOGGLE] Restoring original table state');
                        tbody.innerHTML = originalTableState;
                        
                        // Re-apply section filter
                        const activeBtn = document.querySelector('.deal-type-btn.active');
                        if (activeBtn) {
                            const btnText = activeBtn.textContent.toLowerCase();
                            if (btnText.includes('weekly')) {
                                filterMatchResultsBySection('weekly');
                            } else if (btnText.includes('all')) {
                                filterMatchResultsBySection('all');
                            }
                        }
                    }
                }
            } else {
                // Re-trigger the current filter to rebuild breakdown view
                const activeBtn = document.querySelector('.deal-type-btn.active');
                if (activeBtn) {
                    const btnText = activeBtn.textContent.toLowerCase();
                    if (btnText.includes('weekly')) {
                        filterMatchResultsBySection('weekly');
                    } else if (btnText.includes('all')) {
                        filterMatchResultsBySection('all');
                    }
                }
            }
        }
        
        // v12.2: Insert weekday headers - works from LIVE visible rows in Full List
        function insertWeekdayHeaders() {
            console.log('[BREAKDOWN] === STARTING BREAKDOWN LIST BUILD ===');
            
            const table = document.getElementById('match-results-unified-table');
            if (!table) {
                console.log('[BREAKDOWN] ERROR: Table not found');
                return;
            }
            
            const tbody = table.querySelector('tbody');
            if (!tbody) {
                console.log('[BREAKDOWN] ERROR: tbody not found');
                return;
            }
            
            // Get ALL currently visible rows from tbody
            const allVisibleRows = Array.from(tbody.querySelectorAll('tr[data-section="weekly"]'));
            console.log('[BREAKDOWN] Found', allVisibleRows.length, 'total weekly rows');
            
            if (allVisibleRows.length === 0) {
                console.log('[BREAKDOWN] No weekly rows found!');
                return;
            }
            
            // Find section header
            const sectionHeader = allVisibleRows.find(r => r.classList.contains('section-header-row'));
            if (!sectionHeader) {
                console.log('[BREAKDOWN] ERROR: No section header found');
                return;
            }
            
            // Get data rows (everything except section header)
            const dataRows = allVisibleRows.filter(r => !r.classList.contains('section-header-row'));
            console.log('[BREAKDOWN] Found', dataRows.length, 'data rows to organize');
            
            // STEP 1: Initialize Buckets
            const weekdayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
            const buckets = {};
            weekdayOrder.forEach(day => {
                buckets[day] = [];
            });
            
            // STEP 2: Sort rows into buckets
            const processedGroups = new Set();
            
            dataRows.forEach((row, idx) => {
                const isGroupMember = row.classList.contains('group-member-row');
                const isGroupHeader = row.classList.contains('group-header-row');
                
                console.log(`[BREAKDOWN] Row ${idx}: groupHeader=${isGroupHeader}, groupMember=${isGroupMember}`);
                
                // Skip group members - they'll be collected with their header
                if (isGroupMember) {
                    console.log(`[BREAKDOWN]   Skipping group member`);
                    return;
                }
                
                // Variables for processing
                let weekdayText = '';
                let groupId = null;
                let memberRows = [];
                
                if (isGroupHeader) {
                    // GROUP HEADER: Extract groupId, find members, detect multi-day
                    const toggleIcon = row.querySelector('[id^="toggle-"]');
                    if (!toggleIcon) {
                        console.log(`[BREAKDOWN]   ERROR: Group header has no toggle icon`);
                        return;
                    }
                    
                    groupId = toggleIcon.id.replace('toggle-', '');
                    
                    if (processedGroups.has(groupId)) {
                        console.log(`[BREAKDOWN]   Already processed group ${groupId}`);
                        return;
                    }
                    processedGroups.add(groupId);
                    
                    // Find all member rows for this group
                    memberRows = dataRows.filter(r => r.classList.contains(`group-${groupId}`));
                    
                    if (memberRows.length === 0) {
                        console.log(`[BREAKDOWN]   ERROR: No members found for group ${groupId}`);
                        return;
                    }
                    
                    console.log(`[BREAKDOWN]   Group ${groupId}: Found ${memberRows.length} members`);
                    
                    // Collect ALL unique weekdays from ALL member rows
                    const allWeekdaysSet = new Set();
                    memberRows.forEach(member => {
                        const memberCells = member.getElementsByTagName('td');
                        if (memberCells.length > 3) {
                            const memberWeekdayText = memberCells[3].textContent.trim();
                            if (memberWeekdayText && !memberWeekdayText.includes('MISSING')) {
                                // Normalize to proper case
                                const normalized = memberWeekdayText.trim().toLowerCase();
                                const properCase = normalized.charAt(0).toUpperCase() + normalized.slice(1);
                                allWeekdaysSet.add(properCase);
                            }
                        }
                    });
                    
                    const weekdays = Array.from(allWeekdaysSet);
                    weekdays.sort((a, b) => {
                        const order = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                        return order.indexOf(a) - order.indexOf(b);
                    });
                    
                    console.log(`[BREAKDOWN]   All weekdays in group:`, weekdays);
                    
                    if (weekdays.length === 0) {
                        console.log(`[BREAKDOWN]   ERROR: No valid weekdays found`);
                        return;
                    }
                    
                    const firstWeekday = weekdays[0];
                    const isMultiDay = weekdays.length > 1;
                    
                    // FIRST WEEKDAY: Add full group
                    if (buckets[firstWeekday]) {
                        buckets[firstWeekday].push({
                            type: 'dom',
                            element: row,
                            members: memberRows
                        });
                        console.log(`[BREAKDOWN]   √¢≈ì‚Äú Added group to ${firstWeekday} bucket`);
                    } else {
                        console.log(`[BREAKDOWN]   ERROR: Bucket "${firstWeekday}" not found!`);
                    }
                    
                    // SUBSEQUENT WEEKDAYS: Add multi-day reference rows + header notes
                    if (isMultiDay) {
                        // Extract group data for notes
                        const firstMember = memberRows[0];
                        const memberCells = firstMember.getElementsByTagName('td');
                        const brand = memberCells[1] ? memberCells[1].textContent.trim() : '';
                        const discountText = memberCells[6] ? memberCells[6].textContent.trim() : '';
                        const discount = discountText.replace('%', '').replace('EMPTY', '');
                        const vendorText = memberCells[7] ? memberCells[7].textContent.trim() : '';
                        const vendor = vendorText.replace('%', '').replace('-', '');
                        
                        // Collect brands and row numbers for dropdown
                        const brandRowMap = {}; // {brandName: {Monday: rowNum, Thursday: rowNum}}
                        memberRows.forEach(member => {
                            const mCells = member.getElementsByTagName('td');
                            const mBrand = mCells[1] ? mCells[1].textContent.trim() : '';
                            const mWeekdayText = mCells[3] ? mCells[3].textContent.trim() : '';
                            const mWeekday = mWeekdayText.trim().toLowerCase().charAt(0).toUpperCase() + mWeekdayText.trim().toLowerCase().slice(1);
                            const rowBtn = mCells[0] ? mCells[0].querySelector('button') : null;
                            const rowNum = rowBtn ? rowBtn.textContent.replace('Row ', '').trim() : '';
                            
                            // Extract just brand name (remove multi-brand badge like "1/4")
                            let cleanBrand = mBrand.replace(/^\d+\/\d+\s+/, '');
                            
                            if (!brandRowMap[cleanBrand]) {
                                brandRowMap[cleanBrand] = {};
                            }
                            brandRowMap[cleanBrand][mWeekday] = rowNum;
                        });
                        
                        const abbrDays = weekdays.map(d => d.substring(0, 3)).join(', ');
                        
                        // Add header note to ALL weekdays (including first)
                        weekdays.forEach(day => {
                            if (buckets[day]) {
                                buckets[day].push({
                                    type: 'header_note',
                                    brand: brand,
                                    discount: discount,
                                    vendor: vendor,
                                    days: abbrDays,
                                    brandRowMap: brandRowMap
                                });
                                console.log(`[BREAKDOWN]   √¢≈ì‚Äú Added header note to ${day} bucket`);
                            }
                        });
                        
                        // Add multi-day reference rows to subsequent weekdays
                        weekdays.slice(1).forEach(day => {
                            if (buckets[day]) {
                                // Find members that match this specific weekday
                                const dayMembers = memberRows.filter(member => {
                                    const mCells = member.getElementsByTagName('td');
                                    const mWeekdayText = mCells[3] ? mCells[3].textContent.trim() : '';
                                    const mWeekday = mWeekdayText.trim().toLowerCase().charAt(0).toUpperCase() + mWeekdayText.trim().toLowerCase().slice(1);
                                    return mWeekday === day;
                                });
                                
                                if (dayMembers.length > 0) {
                                    buckets[day].push({
                                        type: 'grey_reference',
                                        members: dayMembers,
                                        firstWeekday: firstWeekday
                                    });
                                    console.log(`[BREAKDOWN]   √¢≈ì‚Äú Added multi-day reference to ${day} bucket (${dayMembers.length} members)`);
                                }
                            }
                        });
                    }
                } else {
                    // SINGLE ROW: Get weekday from the row itself
                    const cells = row.getElementsByTagName('td');
                    if (cells.length <= 3) {
                        console.log(`[BREAKDOWN]   Not enough cells (${cells.length})`);
                        return;
                    }
                    
                    const weekdayText = cells[3].textContent.trim();
                    console.log(`[BREAKDOWN]   Weekday text: "${weekdayText}"`);
                    
                    if (!weekdayText || weekdayText.includes('MISSING')) {
                        console.log(`[BREAKDOWN]   Skipping - missing weekday`);
                        return;
                    }
                    
                    // Normalize to proper case
                    const normalized = weekdayText.trim().toLowerCase();
                    const firstWeekday = normalized.charAt(0).toUpperCase() + normalized.slice(1);
                    console.log(`[BREAKDOWN]   First weekday: "${firstWeekday}"`);
                    console.log(`[BREAKDOWN]   Single row - adding to ${firstWeekday}`);
                    
                    if (buckets[firstWeekday]) {
                        buckets[firstWeekday].push({
                            type: 'dom',
                            element: row
                        });
                        console.log(`[BREAKDOWN]   √¢≈ì‚Äú Added single row to ${firstWeekday} bucket`);
                    } else {
                        console.log(`[BREAKDOWN]   ERROR: Bucket "${firstWeekday}" not found!`);
                    }
                }
            });
            
            // Log final bucket counts
            console.log('[BREAKDOWN] === BUCKET SUMMARY ===');
            weekdayOrder.forEach(day => {
                const domCount = buckets[day].filter(item => item.type === 'dom').length;
                const noteCount = buckets[day].filter(item => item.type === 'header_note').length;
                const greyCount = buckets[day].filter(item => item.type === 'grey_reference').length;
                console.log(`  ${day}: ${domCount} deals, ${noteCount} header notes, ${greyCount} multi-day refs`);
            });
            
            // STEP 3: Rebuild table (PRESERVE Monthly and Sale sections!)
            console.log('[BREAKDOWN] Rebuilding table...');
            
            // v12.5 FIX: Save monthly and sale rows BEFORE clearing tbody
            const monthlyRows = Array.from(tbody.querySelectorAll('tr[data-section="monthly"]'));
            const saleRows = Array.from(tbody.querySelectorAll('tr[data-section="sale"]'));
            console.log(`[BREAKDOWN] Preserving ${monthlyRows.length} monthly rows and ${saleRows.length} sale rows`);
            
            tbody.innerHTML = '';
            tbody.appendChild(sectionHeader);
            
            weekdayOrder.forEach(day => {
                const dayBucket = buckets[day];
                const domItems = dayBucket.filter(item => item.type === 'dom');
                const headerNotes = dayBucket.filter(item => item.type === 'header_note');
                const greyRefs = dayBucket.filter(item => item.type === 'grey_reference');
                
                // Calculate deal count and brands
                const dealCount = domItems.length + greyRefs.length;
                const brands = new Set();
                
                domItems.forEach(item => {
                    if (item.element) {
                        const cells = item.element.getElementsByTagName('td');
                        const brandText = cells[1] ? cells[1].textContent.trim() : '';
                        if (brandText) brands.add(brandText);
                    }
                    if (item.members) {
                        item.members.forEach(member => {
                            const memberCells = member.getElementsByTagName('td');
                            const memberBrand = memberCells[1] ? memberCells[1].textContent.trim() : '';
                            if (memberBrand) brands.add(memberBrand);
                        });
                    }
                });
                
                // Add brands from multi-day reference rows
                greyRefs.forEach(item => {
                    if (item.members) {
                        item.members.forEach(member => {
                            const memberCells = member.getElementsByTagName('td');
                            const memberBrand = memberCells[1] ? memberCells[1].textContent.trim() : '';
                            if (memberBrand) brands.add(memberBrand);
                        });
                    }
                });
                
                // Create weekday header
                const headerRow = createWeekdayHeaderRow(day, dealCount, Array.from(brands), headerNotes);
                tbody.appendChild(headerRow);
                console.log(`[BREAKDOWN] Added header for ${day}`);
                
                // v12.6: Wrap multi-day reference rows in collapsible section with summary
                if (greyRefs.length > 0) {
                    // Collect brands from all reference rows
                    const refBrands = new Set();
                    greyRefs.forEach(item => {
                        if (item.members) {
                            item.members.forEach(member => {
                                const memberCells = member.getElementsByTagName('td');
                                const memberBrand = memberCells[1] ? memberCells[1].textContent.trim() : '';
                                if (memberBrand) refBrands.add(memberBrand);
                            });
                        }
                    });
                    
                    const brandsList = Array.from(refBrands).join(', ');
                    
                    // Create collapsible header for multi-day references
                    const multiDayHeader = document.createElement('tr');
                    multiDayHeader.classList.add('multi-day-ref-header');
                    multiDayHeader.setAttribute('data-weekday', day);
                    multiDayHeader.innerHTML = `
                        <td colspan="14" style="padding:6px 10px; background:#ffe6f0; cursor:pointer; border:2px solid #ff69b4;" 
                            onclick="toggleMultiDayRefs('${day}')">
                            <div style="display:flex; align-items:center; gap:10px;">
                                <span id="multi-day-toggle-${day}" style="font-size:1em; color:#c2185b;">‚ñ∂</span>
                                <strong style="color:#c2185b; font-size:0.95em;">Multi Day Deals Present:</strong>
                                <span style="color:#c2185b; font-size:0.85em;">${brandsList}</span>
                            </div>
                        </td>
                    `;
                    tbody.appendChild(multiDayHeader);
                    
                    // Append all multi-day reference rows
                    const allGreyRows = [];
                    greyRefs.forEach(item => {
                        if (item.members) {
                            item.members.forEach(member => {
                                const greyRow = createMultiDayReferenceRow(member, item.firstWeekday);
                                greyRow.classList.add(`multi-day-ref-${day}`);
                                allGreyRows.push(greyRow);
                            });
                        }
                    });
                    
                    // Add border styling to first and last reference rows
                    if (allGreyRows.length > 0) {
                        allGreyRows[0].style.borderTop = '2px solid #ff69b4';
                        allGreyRows[allGreyRows.length - 1].style.borderBottom = '2px solid #ff69b4';
                        allGreyRows.forEach((row, idx) => {
                            row.style.borderLeft = '2px solid #ff69b4';
                            row.style.borderRight = '2px solid #ff69b4';
                            tbody.appendChild(row);
                            console.log(`[BREAKDOWN] Added multi-day reference row to ${day}`);
                        });
                    }
                }
                
                // Append DOM rows (groups and singles)
                domItems.forEach(item => {
                    tbody.appendChild(item.element);
                    if (item.members) {
                        item.members.forEach(member => tbody.appendChild(member));
                    }
                    console.log(`[BREAKDOWN] Added deal row to ${day}`);
                });
            });
            
            // v12.5 FIX: Re-append Monthly and Sale sections
            if (monthlyRows.length > 0) {
                console.log(`[BREAKDOWN] Re-appending ${monthlyRows.length} monthly rows`);
                monthlyRows.forEach(row => tbody.appendChild(row));
            }
            if (saleRows.length > 0) {
                console.log(`[BREAKDOWN] Re-appending ${saleRows.length} sale rows`);
                saleRows.forEach(row => tbody.appendChild(row));
            }
            
            // v12.6: Collapse all weekday sections by default
            console.log('[BREAKDOWN] Collapsing all weekday sections by default...');
            weekdayOrder.forEach(day => {
                const allRows = Array.from(tbody.querySelectorAll('tr'));
                const headerIndex = allRows.findIndex(r => 
                    r.classList.contains('weekday-header-row') && 
                    r.getAttribute('data-weekday-header') === day
                );
                
                if (headerIndex !== -1) {
                    // Find next weekday header or end
                    let nextHeaderIndex = allRows.length;
                    for (let i = headerIndex + 1; i < allRows.length; i++) {
                        if (allRows[i].classList.contains('weekday-header-row') && 
                            allRows[i].getAttribute('data-weekday-header')) {
                            nextHeaderIndex = i;
                            break;
                        }
                    }
                    
                    // Hide all rows between this header and next header
                    const rowsToHide = allRows.slice(headerIndex + 1, nextHeaderIndex);
                    rowsToHide.forEach(row => {
                        if (!row.classList.contains('section-header-row') && 
                            !row.classList.contains('weekday-header-row')) {
                            row.style.display = 'none';
                        }
                    });
                    
                    console.log(`[BREAKDOWN] Collapsed ${day} section (${rowsToHide.length} rows)`);
                }
                
                // v12.6: Also collapse multi-day reference sections by default
                const multiDayRows = tbody.querySelectorAll(`.multi-day-ref-${day}`);
                if (multiDayRows.length > 0) {
                    multiDayRows.forEach(row => row.style.display = 'none');
                    console.log(`[BREAKDOWN] Collapsed multi-day refs for ${day} (${multiDayRows.length} rows)`);
                }
            });
            
            console.log('[BREAKDOWN] === BREAKDOWN LIST BUILD COMPLETE ===');
        }
        
        // v12.6: Create collapsible weekday header row with cyan background and multi-day notes
        function createWeekdayHeaderRow(weekday, dealCount, brands, headerNotes) {
            const row = document.createElement('tr');
            row.classList.add('weekday-header-row');
            row.setAttribute('data-section', 'weekly');
            row.setAttribute('data-weekday-header', weekday);
            
            const statusText = dealCount === 0 ? 'No deals' : `${dealCount} deal${dealCount > 1 ? 's' : ''}`;
            
            // Build brands HTML (vertical stack)
            let brandsHtml = '<div style="color:#003366; font-size:0.85em; max-height:150px; overflow-y:auto;">';
            if (brands.length === 0) {
                brandsHtml += 'None';
            } else {
                brandsHtml += brands.map((b, i) => `${i + 1}. ${b}`).join('<br>');
            }
            brandsHtml += '</div>';
            
            // Build notes HTML with [Rows] button (vertical stack)
            let notesHtml = '<div style="color:#003366; font-size:0.8em; max-height:150px; overflow-y:auto;">';
            if (headerNotes.length === 0) {
                notesHtml += '-';
            } else {
                const noteLines = headerNotes.map((note, idx) => {
                    // Extract clean brand names for display
                    const brandNames = Object.keys(note.brandRowMap);
                    let displayBrand = '';
                    
                    if (brandNames.length === 1) {
                        // Single brand: just show the brand name
                        displayBrand = brandNames[0];
                    } else {
                        // Multi-brand: show first brand + "...+"
                        const firstName = brandNames[0];
                        displayBrand = firstName + '...+';
                    }
                    
                    // Create dropdown ID for this note
                    const dropdownId = `note-dropdown-${weekday}-${idx}`;
                    
                    // Build dropdown content
                    let dropdownHtml = '<div class="note-dropdown" id="' + dropdownId + '" style="display:none; position:absolute; background:white; border:1px solid #ccc; padding:8px; z-index:1000; box-shadow:0 2px 8px rgba(0,0,0,0.15); min-width:200px;">';
                    brandNames.forEach(brandName => {
                        const rowMap = note.brandRowMap[brandName];
                        dropdownHtml += '<div style="margin-bottom:4px;"><strong>' + brandName + '</strong> ';
                        Object.keys(rowMap).forEach(day => {
                            const rowNum = rowMap[day];
                            dropdownHtml += '<button class="btn btn-sm btn-outline-primary py-0 px-1" onclick="openSheetRow(' + rowNum + ')" style="font-size:0.7em; margin-left:2px;" title="Go to row ' + rowNum + '">Row ' + rowNum + ' ' + day.substring(0, 3) + '</button> ';
                        });
                        dropdownHtml += '</div>';
                    });
                    dropdownHtml += '</div>';
                    
                    // Append dropdown to body (we'll position it later)
                    setTimeout(() => {
                        if (!document.getElementById(dropdownId)) {
                            document.body.insertAdjacentHTML('beforeend', dropdownHtml);
                        }
                    }, 10);
                    
                    return `<div class="multi-day-note" style="margin-bottom:4px;">` +
                           `<button class="btn btn-sm btn-outline-secondary py-0 px-1" onclick="toggleNoteDropdown('${dropdownId}', event)" style="font-size:0.75em;" title="Click to see all brands/rows">[Rows]</button> ` +
                           `${displayBrand} - D: ${note.discount}% V: ${note.vendor}% ${note.days}` +
                           `</div>`;
                }).join('');
                notesHtml += noteLines;
            }
            notesHtml += '</div>';
            
            // v12.6: Add collapse/expand indicator
            row.innerHTML = `
                <td colspan="14" style="padding:8px 10px; background:#00ffff; cursor:pointer;" onclick="toggleWeekdaySection('${weekday}')">
                    <div style="display:flex; align-items:flex-start; gap:15px;">
                        <div style="display:flex; align-items:center; gap:8px;">
                            <span id="weekday-toggle-${weekday}" style="font-size:1.2em; color:#003366;">‚ñ∂</span>
                            <strong style="font-size:1.4em; color:#003366; min-width:120px;">${weekday}</strong>
                        </div>
                        <span style="color:#003366; font-size:0.9em; align-self:center;">${statusText}</span>
                        <div style="flex:1; min-width:200px;">
                            <strong style="color:#003366; font-size:0.85em;">Brands:</strong>
                            ${brandsHtml}
                        </div>
                        <div style="flex:1; min-width:250px;">
                            <strong style="color:#003366; font-size:0.85em;">Notes:</strong>
                            ${notesHtml}
                        </div>
                    </div>
                </td>
            `;
            
            return row;
        }
        
        // v12.6: Toggle weekday section visibility
        function toggleWeekdaySection(weekday) {
            const tbody = document.querySelector('#match-results-unified-table tbody');
            if (!tbody) return;
            
            // Find all rows for this weekday (until next weekday header or end)
            const allRows = Array.from(tbody.querySelectorAll('tr'));
            const headerIndex = allRows.findIndex(r => 
                r.classList.contains('weekday-header-row') && 
                r.getAttribute('data-weekday-header') === weekday
            );
            
            if (headerIndex === -1) return;
            
            // Find next weekday header or end
            let nextHeaderIndex = allRows.length;
            for (let i = headerIndex + 1; i < allRows.length; i++) {
                if (allRows[i].classList.contains('weekday-header-row') && 
                    allRows[i].getAttribute('data-weekday-header')) {
                    nextHeaderIndex = i;
                    break;
                }
            }
            
            // Toggle all rows between this header and next header
            const rowsToToggle = allRows.slice(headerIndex + 1, nextHeaderIndex);
            const isCurrentlyVisible = rowsToToggle.length > 0 && rowsToToggle[0].style.display !== 'none';
            const toggleIcon = document.getElementById(`weekday-toggle-${weekday}`);
            
            rowsToToggle.forEach(row => {
                // Don't hide section headers or other weekday headers
                if (!row.classList.contains('section-header-row') && 
                    !row.classList.contains('weekday-header-row')) {
                    row.style.display = isCurrentlyVisible ? 'none' : '';
                }
            });
            
            // Update toggle icon
            if (toggleIcon) {
                toggleIcon.textContent = isCurrentlyVisible ? '‚ñ∂' : '‚ñº';
            }
        }
        
        // v12.6: Toggle multi-day reference section visibility
        function toggleMultiDayRefs(weekday) {
            const tbody = document.querySelector('#match-results-unified-table tbody');
            if (!tbody) return;
            
            const rows = tbody.querySelectorAll(`.multi-day-ref-${weekday}`);
            const isCurrentlyVisible = rows.length > 0 && rows[0].style.display !== 'none';
            const toggleIcon = document.getElementById(`multi-day-toggle-${weekday}`);
            
            rows.forEach(row => {
                row.style.display = isCurrentlyVisible ? 'none' : '';
            });
            
            // Update toggle icon
            if (toggleIcon) {
                toggleIcon.textContent = isCurrentlyVisible ? '‚ñ∂' : '‚ñº';
            }
        }
        
        // v12.3: Toggle note dropdown visibility
        function toggleNoteDropdown(dropdownId, event) {
            event.stopPropagation();
            const dropdown = document.getElementById(dropdownId);
            if (!dropdown) return;
            
            // Close all other dropdowns first
            document.querySelectorAll('.note-dropdown').forEach(d => {
                if (d.id !== dropdownId) d.style.display = 'none';
            });
            
            // Toggle this dropdown
            if (dropdown.style.display === 'none') {
                // Position dropdown near the button
                const rect = event.target.getBoundingClientRect();
                dropdown.style.display = 'block';
                dropdown.style.left = rect.left + 'px';
                dropdown.style.top = (rect.bottom + 5) + 'px';
            } else {
                dropdown.style.display = 'none';
            }
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.btn-outline-secondary')) {
                document.querySelectorAll('.note-dropdown').forEach(d => {
                    d.style.display = 'none';
                });
            }
        });
        
        // v12.6: Create multi-day reference row (PINK background with orange border)
        function createMultiDayReferenceRow(memberRow, firstWeekday) {
            const newRow = memberRow.cloneNode(true);
            newRow.style.backgroundColor = '#ffe6f0'; // v12.6: PINK background instead of yellow
            newRow.classList.add('multi-day-reference-row');
            newRow.classList.remove('group-member-row'); // Remove group styling
            
            // Update row button to pink/magenta theme
            const cells = newRow.getElementsByTagName('td');
            if (cells.length > 0) {
                const rowBtn = cells[0].querySelector('button');
                if (rowBtn) {
                    rowBtn.classList.remove('btn-outline-primary');
                    rowBtn.classList.add('btn-outline-danger');
                    rowBtn.style.backgroundColor = '#ffe6f0';
                    rowBtn.style.borderColor = '#ff69b4';
                    rowBtn.style.color = '#c2185b';
                }
            }
            
            // Update Notes column to show "First instance: Monday"
            if (cells.length >= 5) {
                cells[4].innerHTML = `<span style="font-style:italic; color:#c2185b;">First instance: ${firstWeekday}</span>`;
            }
            
            return newRow;
        }
        
        // v12.2: Remove all weekday header rows
        function removeWeekdayHeaders() {
            document.querySelectorAll('tr.weekday-header-row[data-weekday-header]').forEach(row => row.remove());
        }
        
        
        // ============================================
        // SPLIT AUDIT FUNCTIONS (V29)
        // ============================================
        function switchSplitPhase(phaseName, btnElement) {
            document.querySelectorAll('.split-phase-content').forEach(el => {
                el.style.display = 'none';
                el.classList.remove('active');
            });
            document.querySelectorAll('.split-phase-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const target = document.getElementById('split-phase-' + phaseName);
            if (target) {
                target.style.display = 'block';
                target.classList.add('active');
            }
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            // Update Phase 2 CSV status when switching to that tab
            if (phaseName === 'final-check') {
                updatePhase2CsvStatus();
            }
            
            console.log('[SPLIT AUDIT] Switched to phase:', phaseName);
        }

        async function runSplitPlanningAudit() {
            const resultsDiv = document.getElementById('split-planning-results');
            const statsEl = document.getElementById('split-audit-stats');
            const tabName = document.getElementById('mis-tab').value;
            
            if (!tabName) {
                alert('Please select a Google Sheet tab in Setup first.');
                return;
            }
            
            resultsDiv.innerHTML = '<div class="text-center"><div class="spinner-border text-primary"></div><p>Analyzing sheet for split requirements...</p></div>';
            statsEl.textContent = 'Analyzing...';
            statsEl.className = 'badge bg-warning fs-6';
            
            try {
                const response = await fetch('/api/mis/split-audit/planning', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ tab: tabName })
                });
                const data = await response.json();
                
                if (!data.success) {
                    resultsDiv.innerHTML = '<div class="alert alert-danger">' + data.error + '</div>';
                    statsEl.textContent = 'Error';
                    statsEl.className = 'badge bg-danger fs-6';
                    return;
                }
                
                renderSplitPlanningResults(data, resultsDiv);
                const splitCount = data.splits_required ? data.splits_required.length : 0;
                const noConflictCount = data.no_conflict ? data.no_conflict.length : 0;
                statsEl.textContent = splitCount + ' Splits | ' + noConflictCount + ' Clean';
                statsEl.className = splitCount > 0 ? 'badge bg-warning fs-6' : 'badge bg-success fs-6';
            } catch (err) {
                resultsDiv.innerHTML = '<div class="alert alert-danger">Error: ' + err.message + '</div>';
                statsEl.textContent = 'Error';
                statsEl.className = 'badge bg-danger fs-6';
            }
        }

        // v88: Store split planning data for apply functionality
        var splitPlanningData = {};
        var approvedSplitIds = {};
        
        function renderSplitPlanningResults(data, container) {
            // Store data for later use
            splitPlanningData = data;
            approvedSplitIds = {};
            
            var html = '<div class="alert alert-info mb-3"><strong>Analysis Complete:</strong> ' + (data.date_context || 'Unknown Month') +
                '<br>Weekly Deals: ' + (data.summary?.weekly_count || 0) + ' | Tier 1 Deals: ' + ((data.summary?.monthly_count || 0) + (data.summary?.sale_count || 0)) + '</div>';
            
            if (data.splits_required && data.splits_required.length > 0) {
                html += '<h5 class="text-danger mb-3"><i class="bi bi-exclamation-triangle"></i> Splits Required (' + data.splits_required.length + ')</h5>';
                data.splits_required.forEach(function(split, idx) {
                    var conflictType = split.conflict_type || 'FULL';
                    var badgeClass = conflictType === 'LOCATION_PARTIAL' ? 'bg-info' : 'bg-danger';
                    
                    // v88: Enhanced header with Row button
                    html += '<div class="card mb-3 border-danger">';
                    html += '<div class="card-header bg-danger text-white d-flex justify-content-between align-items-center">';
                    html += '<span>';
                    if (split.google_row) {
                        html += '<button class="btn btn-sm btn-light me-2" onclick="openSheetRow(' + split.google_row + ')">Row ' + split.google_row + '</button>';
                    }
                    html += '<strong>' + split.brand + '</strong> - Weekly (' + split.weekday + ')';
                    html += '</span>';
                    html += '<span class="badge ' + badgeClass + '">' + (conflictType === 'LOCATION_PARTIAL' ? 'Location-Partial' : 'Full Conflict') + '</span>';
                    html += '</div>';
                    
                    html += '<div class="card-body">';
                    
                    // v93: Stacked comparison tables with horizontal headers
                    
                    // TABLE 1: Weekly Deal
                    html += '<h6 class="text-primary mb-2"> Weekly Deal</h6>';
                    html += '<div class="table-responsive mb-3">';
                    html += '<table class="table table-sm table-bordered" style="font-size:0.85em; table-layout:fixed; width:100%;">';
                    html += '<thead class="table-light"><tr>';
                    html += '<th style="width:80px;">Row</th><th style="width:120px;">Brand</th><th style="width:100px;">Weekday</th><th style="width:100px;">Discount</th><th style="width:90px;">Vendor %</th>';
                    html += '<th style="width:140px;">Locations</th><th style="width:120px;">Deal Info</th><th style="width:120px;">Categories</th><th style="width:120px;">Notes</th><th style="width:110px;">MIS ID</th>';
                    html += '</tr></thead>';
                    html += '<tbody><tr>';
                    
                    // Row button
                    html += '<td>';
                    if (split.google_row) {
                        html += '<button class="btn btn-sm btn-outline-primary" onclick="openSheetRow(' + split.google_row + ')">Row ' + split.google_row + '</button>';
                    } else {
                        html += '-';
                    }
                    html += '</td>';
                    
                    // Brand
                    html += '<td><strong>' + (split.brand || '-') + '</strong></td>';
                    
                    // Weekday
                    html += '<td>' + (split.weekday || '-') + '</td>';
                    
                    // Discount
                    html += '<td>' + (split.discount || '-') + '</td>';
                    
                    // Vendor %
                    html += '<td>' + (split.vendor_contrib || '-') + '</td>';
                    
                    // Locations
                    html += '<td title="' + (split.locations || '') + '">' + truncateText(split.locations || '-', 25) + '</td>';
                    
                    // Deal Info
                    html += '<td title="' + (split.deal_info || '') + '">' + truncateText(split.deal_info || '-', 25) + '</td>';
                    
                    // Categories
                    html += '<td title="' + (split.categories || '') + '">' + truncateText(split.categories || '-', 20) + '</td>';
                    
                    // Notes
                    html += '<td title="' + (split.special_notes || '') + '">' + truncateText(split.special_notes || '-', 20) + '</td>';
                    
                    // MIS ID
                    html += '<td>';
                    if (split.original_mis_id) {
                        html += renderClickableMisId(split.original_mis_id);
                    } else {
                        html += '<span style="color:#999; font-style:italic;">No ID</span>';
                    }
                    html += '</td>';
                    
                    html += '</tr></tbody></table>';
                    html += '</div>';
                    
                    // TABLE 2: Conflict Deal (Interrupting)
                    html += '<h6 class="text-danger mb-2">[!][EMOJI] Conflict Deal (' + split.interrupting_deal_type + ')</h6>';
                    html += '<div class="table-responsive mb-3">';
                    html += '<table class="table table-sm table-bordered" style="font-size:0.85em; table-layout:fixed; width:100%;">';
                    html += '<thead class="table-warning"><tr>';
                    html += '<th style="width:80px;">Row</th><th style="width:120px;">Brand</th><th style="width:100px;">Date(s)</th><th style="width:100px;">Discount</th><th style="width:90px;">Vendor %</th>';
                    html += '<th style="width:140px;">Locations</th><th style="width:120px;">Deal Info</th><th style="width:120px;">Categories</th><th style="width:120px;">Notes</th><th style="width:110px;">MIS ID</th>';
                    html += '</tr></thead>';
                    html += '<tbody>';
                    
                    if (split.interrupting_deal) {
                        html += '<tr>';
                        
                        // Row button
                        html += '<td>';
                        if (split.interrupting_deal.google_row) {
                            html += '<button class="btn btn-sm btn-warning" onclick="openSheetRow(' + split.interrupting_deal.google_row + ')">Row ' + split.interrupting_deal.google_row + '</button>';
                        } else {
                            html += '-';
                        }
                        html += '</td>';
                        
                        // Brand
                        html += '<td><strong>' + (split.interrupting_deal.brand || split.brand || '-') + '</strong></td>';
                        
                        // Date(s)
                        html += '<td>' + (split.conflict_dates ? split.conflict_dates.join(', ') : '-') + '</td>';
                        
                        // Discount
                        html += '<td>' + (split.interrupting_deal.discount || '-') + '</td>';
                        
                        // Vendor %
                        html += '<td>' + (split.interrupting_deal.vendor_contrib || '-') + '</td>';
                        
                        // Locations
                        html += '<td title="' + (split.interrupting_deal.locations || '') + '">' + truncateText(split.interrupting_deal.locations || '-', 25) + '</td>';
                        
                        // Deal Info
                        html += '<td title="' + (split.interrupting_deal.deal_info || '') + '">' + truncateText(split.interrupting_deal.deal_info || '-', 25) + '</td>';
                        
                        // Categories
                        html += '<td title="' + (split.interrupting_deal.categories || '') + '">' + truncateText(split.interrupting_deal.categories || '-', 20) + '</td>';
                        
                        // Notes
                        html += '<td title="' + (split.interrupting_deal.special_notes || '') + '">' + truncateText(split.interrupting_deal.special_notes || '-', 20) + '</td>';
                        
                        // MIS ID
                        html += '<td>';
                        if (split.interrupting_deal.mis_id) {
                            html += renderClickableMisId(split.interrupting_deal.mis_id);
                        } else {
                            html += '<span style="color:#999; font-style:italic;">No ID</span>';
                        }
                        html += '</td>';
                        
                        html += '</tr>';
                    } else {
                        html += '<tr><td colspan="10" class="text-muted text-center">No conflict deal data available</td></tr>';
                    }
                    
                    html += '</tbody></table>';
                    html += '</div>';
                    
                                        if (conflictType === 'LOCATION_PARTIAL') {
                        html += '<p class="mb-2 text-info"><i class="bi bi-geo-alt"></i> <strong>Overlap Locations:</strong> ' + (split.overlap_locations?.join(', ') || 'N/A') + '<br><small>Weekly continues at other locations without split.</small></p>';
                    }
                    
                    // v88: MIS Entry Plan table with Discount, Vendor %, Location columns
                    html += '<hr><p class="mb-1"><strong>MIS Entry Plan:</strong></p>';
                    html += '<table class="table table-sm table-bordered" style="table-layout:fixed; width:100%;"><thead class="table-light"><tr>';
                    html += '<th style="width:90px;">Action</th><th style="width:140px;">Date Range</th><th style="width:100px;">Discount</th><th style="width:90px;">Vendor %</th><th style="width:140px;">Location</th><th style="width:110px;">MIS ID</th><th style="width:80px;">Approve</th><th style="width:80px;">Apply</th><th style="width:170px;">Notes</th>';
                    html += '</tr></thead><tbody>';
                    
                    split.plan.forEach(function(step, stepIdx) {
                        var rowClass = step.action === 'GAP' ? 'table-warning' : (step.action === 'PATCH' ? 'table-info' : '');
                        html += '<tr class="' + rowClass + '" id="split-row-' + idx + '-' + stepIdx + '">';
                        
                        // v10.8: Action column with dynamic labels based on section
                        const dealSection = split.section || 'weekly';
                        const intSection = split.interrupting_deal_type || '';
                        html += '<td>';
                        if (step.action === 'CREATE_PART1') {
                            html += '<span class="badge bg-primary">' + formatActionLabel(step.action, dealSection, intSection) + '</span>';
                        }
                        if (step.action === 'GAP') {
                            html += '<span class="badge bg-warning text-dark">' + formatActionLabel(step.action, dealSection, intSection) + '</span>';
                        }
                        if (step.action === 'PATCH') {
                            html += '<span class="badge bg-info text-dark">' + formatActionLabel(step.action, dealSection, intSection) + '</span>';
                        }
                        if (step.action === 'CREATE_PART2') {
                            html += '<span class="badge bg-success">' + formatActionLabel(step.action, dealSection, intSection) + '</span>';
                        }
                        html += '</td>';
                        
                        // Date Range column
                        html += '<td>' + (step.dates || '-') + '</td>';
                        
                        // v94: Discount column - PATCH uses Weekly discount
                        html += '<td>';
                        if (step.action === 'GAP' && split.interrupting_deal) {
                            html += '<span class="text-warning">' + (split.interrupting_deal.discount || '-') + '</span>';
                        } else if (step.action === 'PATCH') {
                            html += '<span class="text-info">' + (step.discount || split.discount || '-') + '</span>';
                        } else {
                            html += (split.discount || '-');
                        }
                        html += '</td>';
                        
                        // v94: Vendor % column - PATCH uses Weekly vendor %
                        html += '<td>';
                        if (step.action === 'GAP' && split.interrupting_deal) {
                            html += '<span class="text-warning">' + (split.interrupting_deal.vendor_contrib || '-') + '</span>';
                        } else if (step.action === 'PATCH') {
                            html += '<span class="text-info">' + (step.vendor_contrib || split.vendor_contrib || '-') + '</span>';
                        } else {
                            html += (split.vendor_contrib || '-');
                        }
                        html += '</td>';
                        
                        // v94: Location column - PATCH shows non-conflicting stores
                        html += '<td title="' + (step.action === 'GAP' && split.interrupting_deal ? (split.interrupting_deal.locations || '') : (step.action === 'PATCH' ? (step.locations || '') : (split.locations || ''))) + '">';
                        if (step.action === 'GAP' && split.interrupting_deal) {
                            html += '<span class="text-warning">' + truncateText(split.interrupting_deal.locations || '-', 20) + '</span>';
                        } else if (step.action === 'PATCH') {
                            html += '<span class="text-info">' + truncateText(step.locations || '-', 20) + '</span>';
                        } else {
                            html += truncateText(split.locations || '-', 20);
                        }
                        html += '</td>';
                        
                        // v94: MIS ID column - PATCH needs input like Part 2
                        // v10.8: Use section-based parsed MIS IDs (W1, W2, WP, M1, M2, MP, S1, S2, SP)
                        html += '<td>';
                        const parsedIds = split.parsed_mis_ids || {weekly: {parts: [], patch: null}, monthly: {parts: [], patch: null}, sale: {parts: [], patch: null}};
                        const sectionKey = (dealSection || 'weekly').toLowerCase();
                        const sectionIds = parsedIds[sectionKey] || {parts: [], patch: null};
                        const sectionPrefix = sectionKey === 'monthly' ? 'M' : (sectionKey === 'sale' ? 'S' : 'W');
                        
                        if (step.action === 'CREATE_PART1') {
                            // Show Original ID from parsed parts (first in list)
                            if (sectionIds.parts && sectionIds.parts.length > 0) {
                                html += renderClickableMisId(sectionPrefix + '1: ' + sectionIds.parts[0]);
                            } else if (split.original_mis_id && !split.original_mis_id.includes(':')) {
                                // Legacy: no tags, use as-is
                                html += renderClickableMisId(split.original_mis_id);
                            } else {
                                html += '<em>From Sheet</em>';
                            }
                        }
                        if (step.action === 'CREATE_PART2') {
                            // v10.8: Check if Continuation already exists in parsed IDs
                            if (sectionIds.parts && sectionIds.parts.length > 1) {
                                // Continuation already entered - show clickable ID
                                html += renderClickableMisId(sectionPrefix + '2: ' + sectionIds.parts[1]);
                            } else {
                                // No Continuation yet - show input field
                                html += '<input type="text" class="form-control form-control-sm" placeholder="New MIS ID" id="split-id-' + idx + '-' + stepIdx + '" style="width:100px;" data-split-idx="' + idx + '" data-step-idx="' + stepIdx + '" data-google-row="' + (split.google_row || '') + '" data-section="' + sectionKey + '">';
                            }
                        }
                        if (step.action === 'GAP') {
                            // v10.8: GAP ID comes from interrupting deal's row, not the split row
                            // Check the interrupting deal's MIS ID first
                            if (split.interrupting_deal && split.interrupting_deal.mis_id) {
                                html += renderClickableMisId(split.interrupting_deal.mis_id);
                            } else {
                                html += '<input type="text" class="form-control form-control-sm" placeholder="New MIS ID" id="split-gap-id-' + idx + '-' + stepIdx + '" style="width:100px;" data-split-idx="' + idx + '" data-step-idx="' + stepIdx + '" data-google-row="' + (split.interrupting_deal?.google_row || '') + '" data-section="' + (intSection || '').toLowerCase() + '">';
                            }
                        }
                        if (step.action === 'PATCH') {
                            // v10.8: Check for Patch ID using section prefix (WP, MP, SP)
                            if (sectionIds.patch) {
                                html += renderClickableMisId(sectionPrefix + 'P: ' + sectionIds.patch);
                            } else {
                                html += '<input type="text" class="form-control form-control-sm" placeholder="New MIS ID" id="split-patch-id-' + idx + '-' + stepIdx + '" style="width:100px;" data-split-idx="' + idx + '" data-step-idx="' + stepIdx + '" data-google-row="' + (split.google_row || '') + '" data-section="' + sectionKey + '">';
                            }
                        }
                        html += '</td>';
                        
                        // v10.8: Approve column - use section-based checks
                        html += '<td>';
                        const hasExistingCont = sectionIds.parts && sectionIds.parts.length > 1;
                        const hasExistingPatch = sectionIds.patch !== null;
                        const hasExistingInterrupt = split.interrupting_deal && split.interrupting_deal.mis_id;
                        
                        if (step.action === 'CREATE_PART2') {
                            if (hasExistingCont) {
                                html += '<span class="text-success" title="Already entered">&#10003;</span>';
                            } else {
                                html += '<button class="btn btn-success btn-sm" onclick="approveSplitId(' + idx + ', ' + stepIdx + ', \'' + sectionKey + '\')" title="Approve this MIS ID">&#10003;</button>';
                            }
                        } else if (step.action === 'GAP') {
                            if (hasExistingInterrupt) {
                                html += '<span class="text-success" title="Already entered">&#10003;</span>';
                            } else {
                                html += '<button class="btn btn-success btn-sm" onclick="approveGapId(' + idx + ', ' + stepIdx + ', \'' + (intSection || '').toLowerCase() + '\')" title="Approve this MIS ID">&#10003;</button>';
                            }
                        } else if (step.action === 'PATCH') {
                            if (hasExistingPatch) {
                                html += '<span class="text-success" title="Already entered">&#10003;</span>';
                            } else {
                                html += '<button class="btn btn-success btn-sm" onclick="approvePatchId(' + idx + ', ' + stepIdx + ', \'' + sectionKey + '\')" title="Approve this MIS ID">&#10003;</button>';
                            }
                        } else {
                            html += '-';
                        }
                        html += '</td>';
                        
                        // v10.8: Apply column - use section-based checks
                        html += '<td>';
                        if (step.action === 'CREATE_PART2') {
                            if (hasExistingCont) {
                                html += '<span class="badge bg-success">Done</span>';
                            } else {
                                html += '<button class="btn btn-primary btn-sm" id="apply-split-btn-' + idx + '-' + stepIdx + '" onclick="applySplitIdToSheet(' + idx + ', ' + stepIdx + ', \'' + sectionKey + '\')" title="Apply to Google Sheet" disabled>Apply</button>';
                            }
                        } else if (step.action === 'GAP') {
                            if (hasExistingInterrupt) {
                                html += '<span class="badge bg-success">Done</span>';
                            } else {
                                html += '<button class="btn btn-primary btn-sm" id="apply-gap-btn-' + idx + '-' + stepIdx + '" onclick="applyGapIdToSheet(' + idx + ', ' + stepIdx + ', \'' + (intSection || '').toLowerCase() + '\')" title="Apply to Google Sheet" disabled>Apply</button>';
                            }
                        } else if (step.action === 'PATCH') {
                            if (hasExistingPatch) {
                                html += '<span class="badge bg-success">Done</span>';
                            } else {
                                html += '<button class="btn btn-primary btn-sm" id="apply-patch-btn-' + idx + '-' + stepIdx + '" onclick="applyPatchIdToSheet(' + idx + ', ' + stepIdx + ', \'' + sectionKey + '\')" title="Apply to Google Sheet" disabled>Apply</button>';
                            }
                        } else {
                            html += '-';
                        }
                        html += '</td>';
                        
                        // Notes column
                        html += '<td><small>' + (step.notes || '') + '</small></td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody></table>';
                    
                    if (split.attribute_comparison) {
                        html += '<details class="mt-2"><summary class="text-muted" style="cursor:pointer;">View Attribute Comparison</summary><pre class="bg-light p-2 mt-1" style="font-size:0.8em;">' + JSON.stringify(split.attribute_comparison, null, 2) + '</pre></details>';
                    }
                    html += '</div></div>';
                });
            } else {
                html += '<div class="alert alert-success"><i class="bi bi-check-circle"></i> No splits required! All Weekly deals can run without interruption.</div>';
            }
            
            // v88: Enhanced Clean Deals section with full ID MATCHER columns
            if (data.no_conflict && data.no_conflict.length > 0) {
                html += '<details class="mt-4" open><summary class="h5 text-success" style="cursor:pointer;"><i class="bi bi-check-circle"></i> Clean Deals (' + data.no_conflict.length + ') - No Split Needed</summary>';
                html += '<div class="mt-2">';
                html += '<div class="scrollable-table-container" style="max-height:400px;">';
                html += '<table class="table table-sm table-striped" style="font-size:0.85em;">';
                html += '<thead class="table-light"><tr>';
                html += '<th>Row</th><th>Brand</th><th>Weekday</th><th>Notes</th><th>Deal Info</th>';
                html += '<th>Discount</th><th>Vendor %</th><th>Locations</th><th>Categories</th><th>MIS ID</th>';
                html += '</tr></thead><tbody>';
                
                data.no_conflict.forEach(function(deal, idx) {
                    html += '<tr>';
                    // Row button
                    html += '<td>';
                    if (deal.google_row) {
                        html += '<button class="btn btn-sm btn-outline-primary" onclick="openSheetRow(' + deal.google_row + ')">Row ' + deal.google_row + '</button>';
                    } else {
                        html += '-';
                    }
                    html += '</td>';
                    // Brand
                    html += '<td><strong>' + (deal.brand || '-') + '</strong></td>';
                    // Weekday
                    html += '<td>' + (deal.weekday || '-') + '</td>';
                    // Notes
                    html += '<td title="' + (deal.special_notes || '') + '">' + truncateText(deal.special_notes || '-', 20) + '</td>';
                    // Deal Info
                    html += '<td title="' + (deal.deal_info || '') + '">' + truncateText(deal.deal_info || '-', 20) + '</td>';
                    // Discount
                    html += '<td>' + (deal.discount || '-') + '</td>';
                    // Vendor %
                    html += '<td>' + (deal.vendor_contrib || '-') + '</td>';
                    // Locations
                    html += '<td title="' + (deal.locations || '') + '">' + truncateText(deal.locations || '-', 25) + '</td>';
                    // Categories
                    html += '<td title="' + (deal.categories || '') + '">' + truncateText(deal.categories || '-', 15) + '</td>';
                    // MIS ID - clickable
                    html += '<td>';
                    if (deal.mis_id) {
                        html += renderClickableMisId(deal.mis_id);
                    } else {
                        html += '<span style="color:#999; font-style:italic;">No ID</span>';
                    }
                    html += '</td>';
                    html += '</tr>';
                });
                
                html += '</tbody></table></div></div></details>';
            }
            
            container.innerHTML = html;
        }
        
        // v88: Helper to truncate text
        function truncateText(text, maxLen) {
            if (!text) return '-';
            text = String(text);
            return text.length > maxLen ? text.substring(0, maxLen) + '...' : text;
        }
        
        // v88: Helper to render clickable MIS ID(s)
        function renderClickableMisId(misIdStr, rowData) {
            if (!misIdStr || misIdStr === '-') {
                return '<span style="color:#999; font-style:italic;">No ID</span>';
            }
            
            // Helper to strip tag prefix (Part 1:, GAP:, Patch:, etc.)
            function stripTag(str) {
                if (!str) return '';
                str = String(str).trim();
                if (str.indexOf(':') !== -1) {
                    return str.split(':').pop().trim();
                }
                return str;
            }
            
            // Handle both newline-separated (new format) and comma-separated (legacy)
            var rawStr = String(misIdStr);
            var ids = [];
            
            if (rawStr.indexOf('\n') !== -1) {
                // New tagged format with newlines
                ids = rawStr.split('\n').map(function(line) { return line.trim(); }).filter(function(line) { return line; });
            } else {
                // Legacy comma-separated format
                ids = rawStr.split(',').map(function(id) { return id.trim(); }).filter(function(id) { return id; });
            }
            
            if (ids.length === 0) {
                return '<span style="color:#999; font-style:italic;">No ID</span>';
            }
            
            // Prepare row data for validation (if provided)
            var rowDataJson = null;
            if (rowData) {
                var validationData = {
                    brand: rowData.brand || '',
                    linked_brand: rowData.linked_brand || '',
                    weekday: rowData.weekday || '',
                    categories: rowData.categories || '',
                    discount: rowData.discount || '',
                    vendor_contrib: rowData.vendor_contrib || rowData.vendor_percentage || '',
                    locations: rowData.locations || 'All Locations',
                    rebate_type: rowData.rebate_type || '',
                    after_wholesale: rowData.after_wholesale || false
                };
                rowDataJson = JSON.stringify(validationData).replace(/"/g, '&quot;');
            }
            
            return ids.map(function(id) {
                var cleanId = stripTag(id);  // Strip tag for lookup
                var displayId = id;  // Keep full display (with tag)
                
                // Use enhanced validation if row data is available
                if (rowDataJson) {
                    return '<span data-row=\'' + rowDataJson + '\' onclick="lookupMisIdWithValidation(this, \'' + cleanId + '\')" style="cursor:pointer; font-weight:bold; padding:2px 6px; border-radius:4px; background:#667eea; color:white; text-decoration:underline; display:inline-block; margin:1px;" title="Click to lookup and validate in MIS">' + displayId + '</span>';
                } else {
                    return '<span onclick="lookupMisId(\'' + cleanId + '\')" style="cursor:pointer; font-weight:bold; padding:2px 6px; border-radius:4px; background:#667eea; color:white; text-decoration:underline; display:inline-block; margin:1px;" title="Click to lookup in MIS">' + displayId + '</span>';
                }
            }).join(' ');
        }
        
        // v88: Approve split ID
        function approveSplitId(splitIdx, stepIdx) {
            var inputEl = document.getElementById('split-id-' + splitIdx + '-' + stepIdx);
            if (!inputEl) {
                alert('Input field not found');
                return;
            }
            
            var misId = inputEl.value.trim();
            if (!misId) {
                alert('Please enter a MIS ID first');
                return;
            }
            
            // Store the approved ID
            var key = splitIdx + '-' + stepIdx;
            approvedSplitIds[key] = {
                mis_id: misId,
                google_row: inputEl.getAttribute('data-google-row')
            };
            
            // Visual feedback
            var row = document.getElementById('split-row-' + splitIdx + '-' + stepIdx);
            if (row) {
                row.style.backgroundColor = '#d4edda';
            }
            inputEl.style.backgroundColor = '#d4edda';
            inputEl.style.fontWeight = 'bold';
            
            // Enable apply button
            var applyBtn = document.getElementById('apply-split-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) {
                applyBtn.disabled = false;
            }
            
            console.log('[SPLIT] Approved MIS ID:', misId, 'for row:', inputEl.getAttribute('data-google-row'));
        }
        
        // v88: Apply split ID to Google Sheet (appends if existing)
        // Updated v10.3: Uses tagged format (Part 2, Part 3, etc.)
        async function applySplitIdToSheet(splitIdx, stepIdx) {
            var key = splitIdx + '-' + stepIdx;
            var approvedData = approvedSplitIds[key];
            
            if (!approvedData || !approvedData.mis_id) {
                alert('Please approve a MIS ID first');
                return;
            }
            
            if (!approvedData.google_row) {
                alert('No Google Sheet row associated with this split');
                return;
            }
            
            var applyBtn = document.getElementById('apply-split-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) {
                applyBtn.disabled = true;
                applyBtn.textContent = 'Applying...';
            }
            
            // Determine the part number (Part 2, Part 3, etc.)
            var partNumber = approvedData.part_number || 2;
            var tag = 'part' + partNumber;
            
            try {
                // Call API to apply with tag
                var response = await fetch('/api/mis/apply-split-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        google_row: parseInt(approvedData.google_row),
                        new_mis_id: approvedData.mis_id,
                        tag: tag,
                        append: true
                    })
                });
                
                var data = await response.json();
                
                if (data.success) {
                    alert('Part ' + partNumber + ' applied!\n\nRow: ' + approvedData.google_row + '\nMIS ID: ' + approvedData.mis_id);
                    
                    // Update UI
                    if (applyBtn) {
                        applyBtn.textContent = 'Applied';
                        applyBtn.className = 'btn btn-outline-success btn-sm';
                    }
                    
                    // Make the ID clickable now
                    var inputEl = document.getElementById('split-id-' + splitIdx + '-' + stepIdx);
                    if (inputEl && inputEl.parentNode) {
                        inputEl.parentNode.innerHTML = renderClickableMisId(approvedData.mis_id);
                    }
                } else {
                    alert('Error: ' + data.error);
                    if (applyBtn) {
                        applyBtn.disabled = false;
                        applyBtn.textContent = 'Apply';
                    }
                }
            } catch (err) {
                alert('Error: ' + err.message);
                if (applyBtn) {
                    applyBtn.disabled = false;
                    applyBtn.textContent = 'Apply';
                }
            }
        }

        
        function approveGapId(splitIdx, stepIdx) {
            var inputEl = document.getElementById('split-gap-id-' + splitIdx + '-' + stepIdx);
            if (!inputEl) { alert('Input field not found'); return; }
            var misId = inputEl.value.trim();
            if (!misId) { alert('Please enter a MIS ID first'); return; }
            var key = 'gap-' + splitIdx + '-' + stepIdx;
            approvedSplitIds[key] = { mis_id: misId, google_row: inputEl.getAttribute('data-google-row') };
            var row = document.getElementById('split-row-' + splitIdx + '-' + stepIdx);
            if (row) row.style.backgroundColor = '#d4edda';
            inputEl.style.backgroundColor = '#d4edda';
            inputEl.style.fontWeight = 'bold';
            var applyBtn = document.getElementById('apply-gap-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) applyBtn.disabled = false;
        }
        
        async function applyGapIdToSheet(splitIdx, stepIdx) {
            var key = 'gap-' + splitIdx + '-' + stepIdx;
            var approvedData = approvedSplitIds[key];
            if (!approvedData || !approvedData.mis_id) { alert('Please approve a MIS ID first'); return; }
            if (!approvedData.google_row) { alert('No Google Sheet row associated'); return; }
            var applyBtn = document.getElementById('apply-gap-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) { applyBtn.disabled = true; applyBtn.textContent = 'Applying...'; }
            try {
                var response = await fetch('/api/mis/apply-split-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ google_row: parseInt(approvedData.google_row), new_mis_id: approvedData.mis_id, tag: 'gap', append: true })
                });
                var data = await response.json();
                if (data.success) {
                    alert('[OK] MIS ID applied successfully!\n\nRow: ' + approvedData.google_row + '\nNew Value: ' + data.new_value);
                    if (applyBtn) { applyBtn.textContent = '[OK] Applied'; applyBtn.className = 'btn btn-outline-success btn-sm'; }
                    var inputEl = document.getElementById('split-gap-id-' + splitIdx + '-' + stepIdx);
                    if (inputEl && inputEl.parentNode) inputEl.parentNode.innerHTML = renderClickableMisId(data.new_value);
                } else {
                    alert('Error: ' + data.error);
                    if (applyBtn) { applyBtn.disabled = false; applyBtn.textContent = 'Apply'; }
                }
            } catch (err) {
                alert('Error: ' + err.message);
                if (applyBtn) { applyBtn.disabled = false; applyBtn.textContent = 'Apply'; }
            }
        }

        // v94: PATCH approve and apply functions (for partial location conflicts)
        function approvePatchId(splitIdx, stepIdx) {
            var inputEl = document.getElementById('split-patch-id-' + splitIdx + '-' + stepIdx);
            if (!inputEl) { alert('Input field not found'); return; }
            var misId = inputEl.value.trim();
            if (!misId) { alert('Please enter a MIS ID first'); return; }
            var key = 'patch-' + splitIdx + '-' + stepIdx;
            approvedSplitIds[key] = { mis_id: misId, google_row: inputEl.getAttribute('data-google-row') };
            var row = document.getElementById('split-row-' + splitIdx + '-' + stepIdx);
            if (row) row.style.backgroundColor = '#d1ecf1';
            inputEl.style.backgroundColor = '#d1ecf1';
            inputEl.style.fontWeight = 'bold';
            var applyBtn = document.getElementById('apply-patch-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) applyBtn.disabled = false;
        }
        
        async function applyPatchIdToSheet(splitIdx, stepIdx) {
            var key = 'patch-' + splitIdx + '-' + stepIdx;
            var approvedData = approvedSplitIds[key];
            if (!approvedData || !approvedData.mis_id) { alert('Please approve a MIS ID first'); return; }
            if (!approvedData.google_row) { alert('No Google Sheet row associated'); return; }
            var applyBtn = document.getElementById('apply-patch-btn-' + splitIdx + '-' + stepIdx);
            if (applyBtn) { applyBtn.disabled = true; applyBtn.textContent = 'Applying...'; }
            try {
                var response = await fetch('/api/mis/apply-split-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ google_row: parseInt(approvedData.google_row), new_mis_id: approvedData.mis_id, tag: 'patch', append: true })
                });
                var data = await response.json();
                if (data.success) {
                    alert('[OK] MIS ID applied successfully!\n\nRow: ' + approvedData.google_row + '\nNew Value: ' + data.new_value);
                    if (applyBtn) { applyBtn.textContent = '[OK] Applied'; applyBtn.className = 'btn btn-outline-success btn-sm'; }
                    var inputEl = document.getElementById('split-patch-id-' + splitIdx + '-' + stepIdx);
                    if (inputEl && inputEl.parentNode) inputEl.parentNode.innerHTML = renderClickableMisId(data.new_value);
                } else {
                    alert('Error: ' + data.error);
                    if (applyBtn) { applyBtn.disabled = false; applyBtn.textContent = 'Apply'; }
                }
            } catch (err) {
                alert('Error: ' + err.message);
                if (applyBtn) { applyBtn.disabled = false; applyBtn.textContent = 'Apply'; }
            }
        }

        // ============================================
        // PHASE 2: FINAL VERIFICATION FUNCTIONS
        // ============================================
        
        let phase2ApprovedSuggestions = {}; // Store approved suggestions: {splitIdx_actionIdx: {mis_id, ...}}
        
        // Update Phase 2 CSV status display (called when switching to Phase 2 tab)
        function updatePhase2CsvStatus() {
            const statusEl = document.getElementById('phase2-csv-status');
            if (!statusEl) return;
            
            if (misData.localPath || misData.csvFile || misData.pulledCSVPath) {
                const filename = misData.csvFilename || 'CSV Loaded';
                statusEl.innerHTML = '<span class="text-success"><i class="bi bi-check-circle"></i> ' + filename + '</span>';
            } else {
                statusEl.innerHTML = '<span class="text-secondary"><i class="bi bi-file-earmark-x"></i> No CSV Loaded</span>';
            }
        }
        
        async function pullMisCsvForPhase2() {
            // Same as Setup tab - uses /api/mis/pull-csv with credentials
            const statusEl = document.getElementById('phase2-csv-status');
            statusEl.innerHTML = '<span class="text-warning"><i class="bi bi-hourglass-split"></i> Pulling CSV...</span>';
            
            // Get credentials from Setup tab
            const misUsername = document.getElementById('mis-username').value;
            const misPassword = document.getElementById('mis-password').value;
            
            if (!misUsername || !misPassword) {
                statusEl.innerHTML = '<span class="text-danger"><i class="bi bi-x-circle"></i> Enter MIS credentials in Setup tab first</span>';
                return;
            }
            
            try {
                const response = await fetch('/api/mis/pull-csv', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mis_username: misUsername,
                        mis_password: misPassword
                    })
                });
                const data = await response.json();
                
                if (data.success) {
                    // Update global misData (same as Setup tab)
                    misData.localPath = data.path;
                    misData.csvFile = null;
                    misData.csvFilename = data.filename;
                    misData.pulledCSVPath = data.path;
                    
                    statusEl.innerHTML = '<span class="text-success"><i class="bi bi-check-circle"></i> ' + data.filename + '</span>';
                    
                    // Also update Setup tab status
                    const setupStatus = document.getElementById('mis-csv-status');
                    if (setupStatus) {
                        setupStatus.innerHTML = '<div class="alert alert-success p-2 mb-0" style="font-size: 0.9rem;"><strong>Active CSV:</strong> ' + data.filename + '<br><small class="text-muted">Pulled from Phase 2 tab</small></div>';
                    }
                    
                    console.log('[PHASE2-CSV] CSV pulled successfully:', data.filename);
                } else {
                    statusEl.innerHTML = '<span class="text-danger"><i class="bi bi-x-circle"></i> ' + data.error + '</span>';
                }
            } catch (err) {
                statusEl.innerHTML = '<span class="text-danger"><i class="bi bi-x-circle"></i> Error: ' + err.message + '</span>';
            }
        }
        
        async function runPhase2FinalCheck() {
            const resultsDiv = document.getElementById('split-final-check-results');
            const statsEl = document.getElementById('split-audit-stats');
            const csvStatusEl = document.getElementById('phase2-csv-status');
            const tabName = document.getElementById('mis-tab').value;
            
            if (!tabName) {
                alert('Please select a Google Sheet tab in Setup first.');
                return;
            }
            
            // CSV VALIDATION - check all possible sources
            const hasCSV = misData.csvFile || misData.localPath || misData.pulledCSVPath;
            if (!hasCSV) {
                alert('No MIS CSV found.\n\nPlease either:\n1. Upload a CSV in the Setup Tab\n2. Click "Pull MIS CSV" button above\n3. Use "MIS CSV" button in Setup tab');
                return;
            }
            
            resultsDiv.innerHTML = '<div class="text-center"><div class="spinner-border text-success"></div><p>Running final verification...</p></div>';
            statsEl.textContent = 'Verifying...';
            statsEl.className = 'badge bg-warning fs-6';
            
            // BUILD FORM DATA - check all possible CSV sources
            const formData = new FormData();
            formData.append('tab', tabName);
            if (misData.csvFile) {
                formData.append('csv', misData.csvFile);
            } else if (misData.localPath) {
                formData.append('local_csv_path', misData.localPath);
            } else if (misData.pulledCSVPath) {
                formData.append('local_csv_path', misData.pulledCSVPath);
            }
            // If none of the above, backend will use GLOBAL_DATA fallback
            
            try {
                const response = await fetch('/api/mis/split-audit/final-check', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (!data.success) {
                    resultsDiv.innerHTML = '<div class="alert alert-danger">' + data.error + '</div>';
                    statsEl.textContent = 'Error';
                    statsEl.className = 'badge bg-danger fs-6';
                    return;
                }
                
                renderPhase2Results(data, resultsDiv);
                
                // Update stats
                const summary = data.summary || {};
                const correct = summary.fully_correct || 0;
                const errors = summary.partial_errors || 0;
                const missing = summary.missing_ids || 0;
                
                if (errors === 0 && missing === 0) {
                    statsEl.textContent = correct + ' Verified';
                    statsEl.className = 'badge bg-success fs-6';
                } else {
                    statsEl.textContent = correct + ' OK | ' + errors + ' Errors | ' + missing + ' Missing';
                    statsEl.className = 'badge bg-danger fs-6';
                }
                
            } catch (err) {
                resultsDiv.innerHTML = '<div class="alert alert-danger">Error: ' + err.message + '</div>';
                statsEl.textContent = 'Error';
                statsEl.className = 'badge bg-danger fs-6';
            }
        }
        
        function renderPhase2Results(data, container) {
            const results = data.verification_results || [];
            const noConflict = data.no_conflict || [];
            const summary = data.summary || {};
            
            let html = '';
            
            // Summary Stats
            html += '<div class="row mb-3">';
            html += '<div class="col-12">';
            html += '<div class="d-flex gap-2 flex-wrap">';
            html += '<span class="badge bg-success fs-6"><i class="bi bi-check-circle"></i> ' + (summary.fully_correct || 0) + ' Verified</span>';
            html += '<span class="badge bg-danger fs-6"><i class="bi bi-x-circle"></i> ' + (summary.partial_errors || 0) + ' Errors</span>';
            html += '<span class="badge bg-warning text-dark fs-6"><i class="bi bi-question-circle"></i> ' + (summary.missing_ids || 0) + ' Missing IDs</span>';
            html += '<span class="badge bg-secondary fs-6"><i class="bi bi-dash-circle"></i> ' + (summary.no_conflict_count || 0) + ' No Conflict</span>';
            html += '</div>';
            html += '</div>';
            html += '</div>';
            
            // Verification Results Table
            if (results.length > 0) {
                html += '<h5 class="mb-3"><i class="bi bi-list-check"></i> Verification Results</h5>';
                
                results.forEach((split, splitIdx) => {
                    const statusClass = split.overall_status === 'CORRECT' ? 'border-success' : 
                                       split.overall_status === 'MISSING_ID' ? 'border-warning' : 'border-danger';
                    const headerClass = split.overall_status === 'CORRECT' ? 'bg-success text-white' : 
                                       split.overall_status === 'MISSING_ID' ? 'bg-warning text-dark' : 'bg-danger text-white';
                    
                    html += '<div class="card mb-3 ' + statusClass + '" style="border-width: 2px;">';
                    html += '<div class="card-header ' + headerClass + '">';
                    html += '<div class="d-flex justify-content-between align-items-center">';
                    html += '<strong>' + (split.brand || 'Unknown') + '</strong>';
                    html += '<span class="badge bg-white text-dark">' + (split.weekday || '-') + ' | Row ' + (split.google_row || '-') + '</span>';
                    html += '</div>';
                    html += '<small>Conflict Type: ' + (split.conflict_type || 'FULL') + ' | Dates: ' + (split.conflict_dates || []).join(', ') + '</small>';
                    html += '</div>';
                    html += '<div class="card-body p-0">';
                    
                    // Details table
                    html += '<div class="table-responsive">';
                    html += '<table class="table table-sm table-bordered mb-0" style="font-size: 0.85rem;">';
                    html += '<thead class="table-light">';
                    html += '<tr>';
                    html += '<th style="width: 100px;">Action</th>';
                    html += '<th style="width: 80px;">MIS ID</th>';
                    html += '<th>Expected</th>';
                    html += '<th>Actual (CSV)</th>';
                    html += '<th style="width: 80px;">Status</th>';
                    html += '<th>Issues / Suggestions</th>';
                    html += '</tr>';
                    html += '</thead>';
                    html += '<tbody>';
                    
                    const details = split.details || [];
                    details.forEach((entry, actionIdx) => {
                        const rowClass = entry.status === 'CORRECT' ? 'table-success' : 
                                        entry.status === 'MISSING_ID' ? 'table-warning' : 'table-danger';
                        const statusIcon = entry.status === 'CORRECT' ? '<i class="bi bi-check-circle text-success"></i>' : 
                                          entry.status === 'MISSING_ID' ? '<i class="bi bi-question-circle text-warning"></i>' : 
                                          '<i class="bi bi-x-circle text-danger"></i>';
                        
                        html += '<tr class="' + rowClass + '">';
                        // v10.8: Pass section info for dynamic labels
                        const dealSection = split.section || 'weekly';
                        const intSection = split.interrupting_deal_type || '';
                        html += '<td><strong>' + formatActionLabel(entry.action, dealSection, intSection) + '</strong><br><small class="text-muted">' + (entry.expected_dates || '') + '</small></td>';
                        
                        // MIS ID - make clickable for browser automation
                        html += '<td>';
                        if (entry.mis_id) {
                            html += renderClickableMisId(entry.mis_id);
                        } else {
                            html += '<em class="text-muted">-</em>';
                        }
                        html += '</td>';
                        
                        html += '<td>' + formatExpectedAttrs(entry.expected) + '</td>';
                        
                        // Actual (CSV) - add tooltip with suggestions when available
                        html += '<td>';
                        if (entry.actual) {
                            html += formatActualAttrs(entry.actual);
                        } else if (entry.status === 'MISSING_ID' && entry.suggestions && entry.suggestions.length > 0) {
                            // Show suggestions in tooltip like ID MATCHER
                            const tooltipContent = entry.suggestions.map(s => 
                                s.score + '%: ID ' + s.mis_id + ' - ' + (s.brand || '') + ' ' + (s.discount || '')
                            ).join('&#10;');
                            html += '<span class="badge bg-info" data-bs-toggle="tooltip" data-bs-html="true" title="' + tooltipContent + '" style="cursor:help;">?? Suggestions</span>';
                        } else {
                            html += '<em class="text-muted">Not found</em>';
                        }
                        html += '</td>';
                        
                        html += '<td class="text-center">' + statusIcon + '</td>';
                        html += '<td>';
                        
                        if (entry.issues && entry.issues.length > 0) {
                            html += '<ul class="mb-0 ps-3 small text-danger">';
                            entry.issues.forEach(issue => {
                                html += '<li>' + escapeHtml(issue) + '</li>';
                            });
                            html += '</ul>';
                        }
                        
                        if (entry.status === 'MISSING_ID' && entry.suggestions && entry.suggestions.length > 0) {
                            html += '<div class="mt-2">';
                            html += '<strong class="small">Suggestions:</strong>';
                            html += '<div class="d-flex flex-column gap-1 mt-1">';
                            entry.suggestions.forEach((sug, sugIdx) => {
                                const sugKey = splitIdx + '_' + actionIdx + '_' + sugIdx;
                                const confClass = sug.score >= 80 ? 'bg-success' : sug.score >= 60 ? 'bg-warning text-dark' : 'bg-secondary';
                                html += '<div class="d-flex align-items-center gap-2">';
                                html += '<span class="badge ' + confClass + '">' + sug.score + '%</span>';
                                html += '<span class="small">' + renderClickableMisId(sug.mis_id) + ' - ' + (sug.brand || '') + ' ' + (sug.discount || '') + '</span>';
                                html += '<button class="btn btn-outline-primary btn-sm py-0 px-1" onclick="selectPhase2Suggestion(' + splitIdx + ', ' + actionIdx + ', \'' + sug.mis_id + '\')">Select</button>';
                                html += '</div>';
                            });
                            html += '</div>';
                            html += '<div class="mt-2" id="phase2-approve-' + splitIdx + '-' + actionIdx + '" style="display:none;">';
                            html += '<input type="text" class="form-control form-control-sm mb-1" id="phase2-selected-id-' + splitIdx + '-' + actionIdx + '" placeholder="Selected MIS ID">';
                            html += '<button class="btn btn-success btn-sm" onclick="approvePhase2Suggestion(' + splitIdx + ', ' + actionIdx + ', ' + split.google_row + ')"><i class="bi bi-check"></i> Approve & Apply</button>';
                            html += '</div>';
                            html += '</div>';
                        }
                        
                        html += '</td>';
                        html += '</tr>';
                    });
                    
                    html += '</tbody>';
                    html += '</table>';
                    html += '</div>';
                    html += '</div>';
                    html += '</div>';
                });
            }
            
            // No Conflict deals (collapsible)
            if (noConflict.length > 0) {
                html += '<details class="mt-4">';
                html += '<summary class="h5" style="cursor: pointer;"><i class="bi bi-check-all text-success"></i> No Conflict Deals (' + noConflict.length + ')</summary>';
                html += '<div class="table-responsive mt-2">';
                html += '<table class="table table-sm table-striped">';
                html += '<thead><tr><th>Row</th><th>Brand</th><th>Weekday</th><th>Discount</th><th>Locations</th><th>MIS ID</th></tr></thead>';
                html += '<tbody>';
                noConflict.forEach(deal => {
                    html += '<tr>';
                    html += '<td>' + (deal.google_row || '-') + '</td>';
                    html += '<td>' + (deal.brand || '-') + '</td>';
                    html += '<td>' + (deal.weekday || '-') + '</td>';
                    html += '<td>' + (deal.discount || '-') + '</td>';
                    html += '<td>' + (deal.locations || '-') + '</td>';
                    html += '<td>' + (deal.mis_id || '-') + '</td>';
                    html += '</tr>';
                });
                html += '</tbody></table>';
                html += '</div>';
                html += '</details>';
            }
            
            if (results.length === 0 && noConflict.length === 0) {
                html += '<div class="alert alert-info"><i class="bi bi-info-circle"></i> No deals to verify. Run Phase 1 first to identify splits.</div>';
            }
            
            container.innerHTML = html;
            
            // Initialize Bootstrap tooltips for suggestion hovers
            if (typeof bootstrap !== 'undefined') {
                const tooltipTriggerList = container.querySelectorAll('[data-bs-toggle="tooltip"]');
                tooltipTriggerList.forEach(el => new bootstrap.Tooltip(el));
            }
        }
        
        // v10.8: Format action labels based on section and action type
        function formatActionLabel(action, section, interruptingSection) {
            // section: 'weekly', 'monthly', 'sale' - the deal being split
            // interruptingSection: 'monthly', 'sale' - what's causing the interruption (for GAP)
            section = section || 'weekly';
            
            const sectionNames = {
                'weekly': 'Weekly',
                'monthly': 'Monthly',
                'sale': 'Sale'
            };
            
            const sectionName = sectionNames[section.toLowerCase()] || 'Weekly';
            const intName = interruptingSection ? (sectionNames[interruptingSection.toLowerCase()] || interruptingSection) : '';
            
            if (action === 'CREATE_PART1' || action === 'ORIGINAL') {
                return sectionName + ' (Original)';
            } else if (action === 'CREATE_PART2' || action === 'CONTINUATION') {
                return sectionName + ' (Cont.)';
            } else if (action === 'GAP' || action === 'INTERRUPTING') {
                return intName || 'Interrupting Deal';
            } else if (action === 'PATCH') {
                return sectionName + ' (Patch)';
            }
            
            return action;
        }
        
        function formatExpectedAttrs(expected) {
            if (!expected) return '<em class="text-muted">-</em>';
            let parts = [];
            if (expected.discount) parts.push('Disc: ' + expected.discount);
            if (expected.vendor_pct) parts.push('Vendor: ' + expected.vendor_pct);
            if (expected.locations) parts.push('Loc: ' + expected.locations.substring(0, 30) + (expected.locations.length > 30 ? '...' : ''));
            return parts.length > 0 ? '<small>' + parts.join('<br>') + '</small>' : '<em class="text-muted">-</em>';
        }
        
        function formatActualAttrs(actual) {
            if (!actual) return '<em class="text-muted">Not Found</em>';
            let parts = [];
            if (actual.discount) parts.push('Disc: ' + actual.discount);
            if (actual.vendor_pct) parts.push('Vendor: ' + actual.vendor_pct);
            if (actual.locations) parts.push('Loc: ' + actual.locations.substring(0, 30) + (actual.locations.length > 30 ? '...' : ''));
            if (actual.start_date && actual.end_date) parts.push('Dates: ' + actual.start_date + ' - ' + actual.end_date);
            return parts.length > 0 ? '<small>' + parts.join('<br>') + '</small>' : '<em class="text-muted">-</em>';
        }
        
        function selectPhase2Suggestion(splitIdx, actionIdx, misId) {
            // Show the approve section and fill in the selected ID
            const approveDiv = document.getElementById('phase2-approve-' + splitIdx + '-' + actionIdx);
            const inputEl = document.getElementById('phase2-selected-id-' + splitIdx + '-' + actionIdx);
            
            if (approveDiv) approveDiv.style.display = 'block';
            if (inputEl) {
                inputEl.value = misId;
                inputEl.style.backgroundColor = '#d4edda';
            }
        }
        
        async function approvePhase2Suggestion(splitIdx, actionIdx, googleRow) {
            const inputEl = document.getElementById('phase2-selected-id-' + splitIdx + '-' + actionIdx);
            if (!inputEl || !inputEl.value.trim()) {
                alert('Please select or enter a MIS ID first.');
                return;
            }
            
            const misId = inputEl.value.trim();
            
            // Determine the prefix based on action type - ask user
            const actionType = prompt('What type of entry is this?\nEnter: gap, patch, part1, or part2', 'part2');
            if (!actionType) return;
            
            let prefix = '';
            if (actionType.toLowerCase() === 'gap') {
                prefix = 'Gap: ';
            } else if (actionType.toLowerCase() === 'patch') {
                prefix = 'Patch: ';
            }
            
            const finalValue = prefix + misId;
            
            try {
                const response = await fetch('/api/mis/apply-split-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        google_row: googleRow,
                        new_mis_id: finalValue,
                        append: true
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert('Applied MIS ID to row ' + googleRow + ': ' + data.new_value);
                    inputEl.style.backgroundColor = '#c3e6cb';
                    inputEl.disabled = true;
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (err) {
                alert('Error: ' + err.message);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // END PHASE 2 FINAL VERIFICATION FUNCTIONS
        // ============================================
        
        async function searchMisBrand(brandName) {
            closeBrandPopup();
            const originalTitle = document.title;
            document.title = "Searching: " + brandName;
            try {
                await fetch('/api/mis/search-brand', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ brand: brandName })
                });
            } catch (e) { 
                alert('Search Error: ' + e.message); 
            } finally { 
                setTimeout(() => document.title = originalTitle, 2000); 
            }
        }

        function toggleBrandPopup(event, brandsStr) {
            event.stopPropagation();
            const popup = document.getElementById('brand-sticky-popup');
            const listContainer = document.getElementById('brand-popup-list');
            
            if (popup.style.display === 'block' && popup.dataset.trigger === event.target.id) {
                closeBrandPopup(); 
                return;
            }

            const brands = brandsStr.split(',').map(b => b.trim()).filter(b => b);
            listContainer.innerHTML = '';
            brands.forEach(b => {
                const btn = document.createElement('button');
                btn.className = 'brand-select-btn';
                btn.innerText = b;
                btn.onclick = () => searchMisBrand(b);
                listContainer.appendChild(btn);
            });

            const rect = event.target.getBoundingClientRect();
            popup.style.top = (window.scrollY + rect.bottom + 5) + 'px';
            popup.style.left = (window.scrollX + rect.left) + 'px';
            popup.style.display = 'block';
            popup.dataset.trigger = event.target.id;
        }

        function closeBrandPopup() {
            document.getElementById('brand-sticky-popup').style.display = 'none';
        }

        function renderBrandCell(brandStr, rowIdx, prefix = '') {
            if (!brandStr) return '<span style="color:#999;">-</span>';
            
            const brandList = brandStr.split(',').map(s => s.trim()).filter(s => s);
            const uniqueId = `${prefix}-brand-${rowIdx}`;
            
            if (brandList.length > 1) {
                return `<div id="${uniqueId}" class="brand-multi" onclick="toggleBrandPopup(event, '${brandStr.replace(/'/g, "&apos;")}')">${brandList[0]}...</div>`;
            } else {
                return `<span class="brand-single" onclick="searchMisBrand('${brandStr.replace(/'/g, "&apos;")}')">${brandStr}</span>`;
            }
        }
        
        // v12.1: Navigate to specific row in Google Sheet
        function goToSheetRow(rowNum) {
            // Use the globally stored spreadsheet ID
            // This is set when /api/mis/load-sheet returns the spreadsheet_id
            const spreadsheetId = window.globalSpreadsheetId || '';
            if (!spreadsheetId) {
                alert('Spreadsheet ID not available. Please load the sheet first.');
                return;
            }
            const url = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/edit#gid=0&range=A${rowNum}`;
            window.open(url, '_blank');
        }
        
        // v12.2: Global helper - Parse month/year from tab name (e.g., "January 2026")
        function parseTabMonthYear(tabName) {
            const months = ['january','february','march','april','may','june','july','august','september','october','november','december'];
            const parts = (tabName || '').toLowerCase().trim().split(/\s+/);
            let month = -1, year = -1;
            for (const p of parts) {
                const mIdx = months.indexOf(p);
                if (mIdx >= 0) month = mIdx;
                if (/^\d{4}$/.test(p)) year = parseInt(p);
            }
            return { month, year };
        }
        
        // v12.2: Global helper - Get last day of month (handles leap years)
        function getLastDayOfMonth(year, month) {
            // month is 0-indexed (0=Jan, 11=Dec)
            return new Date(year, month + 1, 0).getDate();
        }
        
        async function lookupMisId(misId) {
            if (!misId || misId === '-') return;
            
            const originalTitle = document.title;
            document.title = "Looking up: " + misId;
            try {
                await fetch('/api/mis/lookup-mis-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ mis_id: misId })
                });
            } catch (e) { 
                console.error('Lookup Error:', e); 
            } finally { 
                setTimeout(() => document.title = originalTitle, 2000); 
            }
        }
        
        async function lookupMisIdWithValidation(buttonElement, misId) {
            /**
             * Enhanced MIS ID lookup that includes row data for validation.
             * Extracts row data from button's data-row attribute and sends to backend.
             */
            if (!misId || misId === '-') return;
            
            const originalTitle = document.title;
            document.title = "Looking up: " + misId;
            
            try {
                // Try to get row data from button element
                let rowData = null;
                if (buttonElement && buttonElement.getAttribute) {
                    try {
                        const rowDataJson = buttonElement.getAttribute('data-row');
                        if (rowDataJson) {
                            rowData = JSON.parse(rowDataJson);
                            console.log('[MIS ID LOOKUP] Row data found:', rowData);
                        }
                    } catch (e) {
                        console.warn('[MIS ID LOOKUP] Could not parse row data:', e);
                    }
                }
                
                // Send request with optional row data
                await fetch('/api/mis/lookup-mis-id', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        mis_id: misId,
                        row_data: rowData  // Will be null if not available
                    })
                });
                
                if (rowData) {
                    console.log('[MIS ID LOOKUP] Validation will be applied');
                } else {
                    console.log('[MIS ID LOOKUP] No validation (no row data)');
                }
                
            } catch (e) { 
                console.error('[MIS ID LOOKUP] Error:', e); 
            } finally { 
                setTimeout(() => document.title = originalTitle, 2000); 
            }
        }

        function renderMisIdCell(misIdStr, rowData) {
            if (!misIdStr || misIdStr === '-') {
                return '<span style="color:#999; font-style:italic;">No ID</span>';
            }
            
            // Helper to strip tag prefix (Part 1:, GAP:, Patch:, etc.)
            function stripTag(str) {
                if (!str) return '';
                str = String(str).trim();
                if (str.indexOf(':') !== -1) {
                    return str.split(':').pop().trim();
                }
                return str;
            }
            
            // Handle both newline-separated (new format) and comma-separated (legacy)
            const rawStr = String(misIdStr);
            let ids = [];
            
            if (rawStr.indexOf('\n') !== -1) {
                // New tagged format with newlines
                ids = rawStr.split('\n').map(line => line.trim()).filter(line => line);
            } else {
                // Legacy comma-separated format
                ids = rawStr.split(',').map(id => id.trim()).filter(id => id);
            }
            
            if (ids.length === 0) {
                return '<span style="color:#999; font-style:italic;">No ID</span>';
            }
            
            // Prepare row data for validation (if provided)
            let rowDataJson = null;
            if (rowData) {
                const validationData = {
                    brand: rowData.brand || '',
                    linked_brand: rowData.linked_brand || '',
                    weekday: rowData.weekday || '',
                    categories: rowData.categories || '',
                    discount: rowData.discount || '',
                    vendor_contrib: rowData.vendor_contrib || rowData.vendor_percentage || '',
                    locations: rowData.locations || 'All Locations',
                    rebate_type: rowData.rebate_type || '',
                    after_wholesale: rowData.after_wholesale || false
                };
                rowDataJson = JSON.stringify(validationData).replace(/"/g, '&quot;');
            }
            
            // Make each ID clickable
            const clickableIds = ids.map(id => {
                let cleanId = stripTag(id.replace(' (Estimated)', '').trim());
                const displayId = id; // Keep original format with tag and (Estimated) if present
                
                // Use enhanced validation if row data is available
                if (rowDataJson) {
                    return `<span data-row='${rowDataJson}' 
                                  onclick="lookupMisIdWithValidation(this, '${cleanId}')" 
                                  style="cursor:pointer; font-weight:bold; text-decoration:underline; color:#667eea;" 
                                  title="Click to lookup and validate in MIS">${displayId}</span>`;
                } else {
                    // Fallback to old method without validation
                    return `<span onclick="lookupMisId('${cleanId}')" 
                                  style="cursor:pointer; font-weight:bold; text-decoration:underline; color:#667eea;" 
                                  title="Click to lookup in MIS">${displayId}</span>`;
                }
            });
            
            return clickableIds.join(', ');
        }
        
        async function openSheetRow(rowNum) {
            try {
                await fetch('/api/mis/open-sheet-row', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ row: rowNum })
                });
            } catch (e) { 
                console.error('Row Navigation Error:', e); 
            }
        }

        function renderRowButton(rowNum) {
            return `<button class="btn" style="padding:4px 8px; font-size:0.85em;" onclick="openSheetRow(${rowNum})">Row ${rowNum}</button>`;
        }
        
        function displayMatchResults(matchesObj) {
            const containerId = 'match-results';
            const titles = {'weekly': ' WEEKLY DEALS', 'monthly': ' MONTHLY DEALS', 'sale': ' SALE DEALS'};
            
            // DEBUG: Log what we received
            console.log('[DISPLAY] Received matchesObj:', Object.keys(matchesObj));
            console.log('[DISPLAY] Weekly count:', (matchesObj.weekly || []).length);
            console.log('[DISPLAY] Monthly count:', (matchesObj.monthly || []).length);
            console.log('[DISPLAY] Sale count:', (matchesObj.sale || []).length);
            
            // 1. Flatten Matches for Global Indexing (Source of Truth)
            matchesData = [];
            ['weekly', 'monthly', 'sale'].forEach(key => {
                if (matchesObj[key]) {
                    console.log(`[DISPLAY] Adding ${matchesObj[key].length} ${key} matches to matchesData`);
                    matchesData = matchesData.concat(matchesObj[key]);
                }
            });
            console.log('[DISPLAY] Total matchesData:', matchesData.length);

            // Count items per section
            const counts = {
                weekly: (matchesObj.weekly || []).length,
                monthly: (matchesObj.monthly || []).length,
                sale: (matchesObj.sale || []).length
            };

            // Header and actions
            let headerHtml = '<h3>Match Results</h3>';
            headerHtml += '<p>&#x3030; Multi-day deals are grouped. Use <b>Approve All Days</b> for bulk approval.</p>';
            headerHtml += `
                <div style="margin-bottom:15px;">
                    <button class="btn btn-success btn-sm" onclick="approveAll()" style="margin-right: 5px;" title="Approve all visible matches">[OK] Approve All Sections</button>
                    <button class="btn btn-danger btn-sm" onclick="denyAll()" title="Deny all visible matches">[X] Deny All Sections</button>
                </div>
            `;
            
            // Generate deal type tabs
            headerHtml += generateDealTypeTabsHTML(containerId, counts);

            // Build a single unified table with data-section attributes for filtering
            let unifiedHtml = '<div class="scrollable-table-container" style="max-height:600px; margin-bottom:20px;">';
            unifiedHtml += '<table class="table table-sm" id="match-results-unified-table" style="font-size:0.85em;">';
            unifiedHtml += '<thead><tr>';
            unifiedHtml += '<th>Row</th><th>Brand</th><th style="color:#6c757d;">Linked</th><th>Weekday</th><th>Notes</th><th>Deal Info</th><th>Discount</th>';
            unifiedHtml += '<th>Vendor %</th><th>Locations</th><th>Categories</th><th>Confidence</th><th>Current ID</th>';
            unifiedHtml += '<th>Suggested MIS ID</th>';
            unifiedHtml += '<th style="white-space: nowrap;">Actions</th>';
            unifiedHtml += '</tr></thead><tbody>';

            // Re-render all matches into unified table with section markers
            let globalIdx = 0;
            ['weekly', 'monthly', 'sale'].forEach(sectionKey => {
                const sectionMatches = matchesObj[sectionKey] || [];
                console.log(`[DISPLAY] Processing section ${sectionKey}: ${sectionMatches.length} matches`);
                if (sectionMatches.length === 0) {
                    console.log(`[DISPLAY] Skipping empty section: ${sectionKey}`);
                    return;
                }

                // Add section header row
                unifiedHtml += `<tr class="section-header-row" data-section="${sectionKey}"><td colspan="14" style="background:#e9ecef; font-weight:bold; padding:10px;">${titles[sectionKey]} <small class="text-muted">(${sectionMatches.length} Items)</small></td></tr>`;
                console.log(`[DISPLAY] Added section header for ${sectionKey}`);

                const renderedGroups = new Set();

                sectionMatches.forEach((m) => {
                    const idx = globalIdx++;
                    const isGrouped = m.multi_day_group !== null && m.multi_day_group !== undefined;
                    const isFirstInGroup = isGrouped && m.multi_day_group.is_first;
                    const groupId = isGrouped ? m.multi_day_group.group_id : null;

                    if (isGrouped && !isFirstInGroup) {
                        return; // Skip non-first members
                    }

                    if (isGrouped && isFirstInGroup) {
                        renderedGroups.add(groupId);
                        const groupData = m.multi_day_group;
                        const hasMissingWeekday = groupData.has_missing_weekday;
                        const warningIcon = hasMissingWeekday ? '<span class="weekday-missing-icon" title="Missing weekday data!">[!] </span>' : '';
                        
                        // v12.1: Get weekdays list for display
                        const weekdaysList = (groupData.weekdays || []).filter(w => w && !w.toLowerCase().includes('missing')).join(', ');
                        
                        // v12.1: For multi-brand groups, show full brand string and total entries
                        const headerBrand = groupData.brand_raw || m.brand;
                        const isMultiBrandGroup = groupData.is_multi_brand || false;
                        const totalEntries = groupData.total_entries || groupData.total_days;
                        const totalBrands = groupData.total_brands || 1;
                        
                        // Badge text: show days and brands info for multi-brand
                        let badgeText = '';
                        if (isMultiBrandGroup) {
                            badgeText = `[EMOJI] ${groupData.total_days}-Day √É‚Äî ${totalBrands}-Brand Deal`;
                        } else {
                            badgeText = `[EMOJI] ${groupData.total_days}-Day Deal`;
                        }
                        
                        // Button text: use total entries for multi-brand
                        const buttonText = isMultiBrandGroup ? 
                            `[OK] Approve All ${totalEntries} Entries` : 
                            `[OK] Approve All ${groupData.total_days} Days`;
                        
                        unifiedHtml += `<tr class="group-header-row" data-section="${sectionKey}" onclick="toggleGroup('${groupId}')" title="Click to collapse/expand">`;
                        unifiedHtml += `<td colspan="14">`;
                        unifiedHtml += `<span class="group-toggle-icon" id="toggle-${groupId}">&#x25BC;</span>`;
                        unifiedHtml += `${warningIcon}<strong>${headerBrand}</strong>`;
                        unifiedHtml += `<span class="multi-day-badge">${badgeText}</span>`;
                        unifiedHtml += ` (Rows: ${[...new Set(groupData.row_numbers)].join(', ')}) `;
                        unifiedHtml += `<span style="color:#6c757d; font-size:0.85em;">[${weekdaysList}]</span>`;
                        
                        if (!hasMissingWeekday) {
                            unifiedHtml += `<button class="bulk-approve-btn" onclick="event.stopPropagation(); approveAllDaysInGroup('${groupId}')">${buttonText}</button>`;
                        }
                        unifiedHtml += `</td></tr>`;

                        // Render group members
                        const groupMembers = sectionMatches.filter(gm => gm.multi_day_group && gm.multi_day_group.group_id === groupId);
                        groupMembers.forEach((gm) => {
                            const memberGlobalIdx = matchesData.indexOf(gm);
                            unifiedHtml += renderMatchRowWithSection(gm, memberGlobalIdx, groupId, hasMissingWeekday, sectionKey);
                        });
                    } else {
                        // Single (non-grouped) row
                        unifiedHtml += renderMatchRowWithSection(m, idx, null, false, sectionKey);
                    }
                });
            });

            unifiedHtml += '</tbody></table></div>';

            // Build final HTML
            let finalHtml = headerHtml;
            finalHtml += `<div id="${containerId}-unified" class="deal-type-content active" style="display:block;">${unifiedHtml}</div>`;
            
            document.getElementById('match-results').innerHTML = finalHtml;
            
            // v12.2: Set default weekly view button state
            setTimeout(() => {
                const breakdownBtn = document.getElementById('weekly-view-breakdown');
                const fullBtn = document.getElementById('weekly-view-full');
                if (breakdownBtn && fullBtn) {
                    breakdownBtn.classList.add('active');
                    fullBtn.classList.remove('active');
                }
            }, 10);
            
            // Apply initial filter - this will trigger breakdown view if enabled
            filterMatchResultsBySection('all');
        }

// v10.9.3: FIX 0% DISPLAY vs EMPTY
        function renderMatchRowWithSection(m, idx, groupId, hasMissingWeekday, sectionKey) {
            const statusClass = m.status === 'HIGH' ? 'status-high' : m.status === 'MEDIUM' ? 'status-medium' : 'status-low';
            const rowBtn = renderRowButton(m.google_row);
            
            // v12.1: Add multi-brand badge if applicable, BOLD the brand name
            let brandCell = `<strong>${renderBrandCell(m.brand, idx, 'match')}</strong>`;
            if (m.is_multi_brand) {
                const brandIdx = (m.multi_brand_index || 0) + 1;
                const total = m.multi_brand_total || 1;
                brandCell = `<span class="badge bg-info text-dark me-1" title="Multi-brand deal: ${m.brand_raw}">${brandIdx}/${total}</span> <strong>${renderBrandCell(m.brand, idx, 'match')}</strong>`;
            }
            
            // v12.1: Get linked brand from Settings tab (same as Creation Checklist)
            let linkedBrandDisplay = '-';
            if (m.linked_brand && m.linked_brand !== '') {
                linkedBrandDisplay = `<span style="color:#6c757d;">${m.linked_brand}</span>`;
            }
            
            let weekdayDisplay = m.weekday || '-';
            if (!m.weekday || m.weekday.trim() === '') {
                weekdayDisplay = '<span class="weekday-missing-icon">[!] </span><span style="color:#dc3545; font-style:italic;">MISSING</span>';
            }

            // --- DISCOUNT DISPLAY LOGIC ---
            // If null/undefined/empty string -> Show RED "EMPTY"
            // If 0 or any number -> Show "0%" or "20%"
            let discountDisplay = '';
            if (m.discount === null || m.discount === undefined || m.discount === '') {
                discountDisplay = '<span style="color:#dc3545; font-weight:bold; font-size:0.85em;">EMPTY</span>';
            } else {
                discountDisplay = `${m.discount}%`;
            }

            // --- VENDOR DISPLAY LOGIC ---
            // Applying similar logic for consistency: Ensure 0% shows as 0%, not -%
            let vendorDisplay = '';
            if (m.vendor_contrib === null || m.vendor_contrib === undefined || m.vendor_contrib === '') {
                vendorDisplay = '-';
            } else {
                vendorDisplay = `${m.vendor_contrib}%`;
            }

            // v12.1: Handle tagged MIS IDs (W1: 12345, W2: 67890, etc.) - Individual clickable buttons
            let currentIdDisplay = '<span style="color:#999; font-style:italic;">No ID</span>';
            const currentIdStr = m.current_sheet_id ? String(m.current_sheet_id).trim() : '';
            const suggestedId = m.matched_mis_id ? String(m.matched_mis_id).trim() : '';

            if (currentIdStr) {
                // Parse tagged IDs: W1: 12345, W1: 67890, W2: 11111, WP: 99999, etc.
                const tagPattern = /([WwMmSs][1-9Pp]|[Pp]art\s*\d+|[Gg][Aa][Pp]|[Pp]atch)\s*:\s*(\d+)/g;
                let taggedIds = [];
                let match;
                while ((match = tagPattern.exec(currentIdStr)) !== null) {
                    let tag = match[1].toUpperCase().replace(/\s+/g, '');
                    // Normalize legacy tags
                    if (tag.startsWith('PART')) {
                        const partNum = tag.match(/\\d+/)[0];
                        tag = 'W' + partNum;
                    } else if (tag === 'GAP') {
                        tag = 'GAP';
                    } else if (tag === 'PATCH') {
                        tag = 'WP';
                    }
                    taggedIds.push({ tag: tag, id: match[2] });
                }
                
                // If no tags found, try comma-separated plain IDs
                if (taggedIds.length === 0) {
                    const plainIds = currentIdStr.split(',').map(s => s.trim()).filter(s => /^\\d{5,7}$/.test(s));
                    taggedIds = plainIds.map(id => ({ tag: '', id: id }));
                }
                
                if (taggedIds.length > 0) {
                    currentIdDisplay = taggedIds.map(item => {
                        const isMatch = (item.id === suggestedId);
                        const bg = isMatch ? '#d4edda' : '#e9ecef';
                        const color = isMatch ? '#155724' : '#495057';
                        const border = isMatch ? '1px solid #28a745' : '1px solid #ced4da';
                        const tagDisplay = item.tag ? `<span style="font-size:0.75em; color:#6c757d;">${item.tag}:</span> ` : '';
                        return `<span onclick="lookupMisId('${item.id}')" 
                                      style="cursor:pointer; font-weight:bold; padding:2px 6px; border-radius:4px; 
                                             background:${bg}; color:${color}; border:${border};
                                             text-decoration:underline; display:inline-block; margin:2px;">
                                    ${tagDisplay}${item.id}
                                </span>`;
                    }).join('');
                }
            }

            let inputHtml = '';
            if (hasMissingWeekday && (!m.weekday || m.weekday.trim() === '')) {
                inputHtml = '<span style="color:#dc3545; font-style:italic;">[!] Manual entry required</span>';
            } else {
                // SUGGESTION LOGIC: ALWAYS USE MAGNIFYING GLASS (No Dropdowns)
                const hasSuggestions = m.suggestions && m.suggestions.length > 0;
                
                const iconColor = hasSuggestions ? '#ffc107' : '#e2e6ea'; 
                const iconCursor = hasSuggestions ? 'pointer' : 'default';
                const iconTitle = hasSuggestions ? `View ${m.suggestions.length} Suggestions` : 'No Suggestions found';
                const iconShadow = hasSuggestions ? 'text-shadow: 0 0 2px rgba(255, 193, 7, 0.5);' : '';
                
                const clickAction = hasSuggestions ? `onclick="showSuggestionTooltip(${idx})"` : '';

                inputHtml = `
                    <div style="min-width:150px;" id="input-container-${idx}">
                        <div style="display:flex; gap:5px; align-items:center;">
                            <input type="text" id="input-mis-${idx}" class="mis-id-input" value="${m.matched_mis_id || ''}" 
                                   style="width:90px; font-weight:bold; padding:4px;" data-row="${idx}" placeholder="MIS ID">
                            
                            <span class="suggestion-indicator" ${clickAction} 
                                  title="${iconTitle}" 
                                  style="cursor:${iconCursor}; color:${iconColor}; font-size:1.3em; vertical-align:middle; ${iconShadow}">
                                &#128269;
                            </span>

                            <button class="btn btn-sm btn-outline-secondary" style="padding:0px 5px;" onclick="addIdField(${idx})">+</button>
                        </div>
                    </div>`;
            }

            const truncate = (text, len) => {
                if (!text) return '-';
                text = String(text);
                return text.length > len ? text.substring(0, len) + '...' : text;
            };
            
            // v12.1: Format locations with numbered list for tooltip
            const formatLocationsNumbered = (locStr) => {
                if (!locStr || locStr === '-') return '-';
                const locs = locStr.split(',').map(l => l.trim()).filter(l => l);
                return locs.map((loc, i) => (i + 1) + '. ' + loc).join('&#10;');
            };
            const locationsTooltip = formatLocationsNumbered(m.locations);

            let actionHtml = '';
            if (hasMissingWeekday && (!m.weekday || m.weekday.trim() === '')) {
                actionHtml = '<span style="color:#999; font-style:italic;">N/A</span>';
            } else {
                // v12.5: Smaller Approve/Deny buttons + Blue Blaze button
                const existingBlazeTitles = approvedMatches[m.google_row]?.blaze_titles || [];
                const blazeBtnClass = existingBlazeTitles.length > 0 ? 'btn-primary' : 'btn-outline-primary';
                const blazeBtnText = existingBlazeTitles.length > 0 ? '<i class="bi bi-lightning-charge-fill"></i> ' + existingBlazeTitles.length : '<i class="bi bi-lightning-charge"></i>';
                
                actionHtml = `
                    <div style="display:flex; gap:2px; align-items:center; flex-wrap:nowrap;">
                        <button class="btn btn-success btn-sm btn-approve" style="padding:1px 4px; font-size:0.7rem;" onclick="approveSingleMatch(${idx})" title="Approve">[OK]</button>
                        <button class="btn btn-danger btn-sm btn-reject" style="padding:1px 4px; font-size:0.7rem;" onclick="rejectMatch(${idx})" title="Deny">[X]</button>
                        <button class="btn ${blazeBtnClass} btn-sm btn-blaze" style="padding:1px 5px; font-size:0.7rem;" onclick="openBlazeModal(${idx})" title="Select Blaze Discount">${blazeBtnText}</button>
                    </div>`;
            }

            const rowClass = groupId ? `group-member-row group-${groupId}` : '';
            const warningClass = (hasMissingWeekday && (!m.weekday || m.weekday.trim() === '')) ? 'missing-weekday-warning' : '';
            const bgStyle = groupId ? 'style="background-color: #fff3cd !important;"' : '';
            
            // v12.1: Add dashed border for multi-brand rows after first brand
            const multiBrandStyle = m.is_multi_brand && m.multi_brand_index > 0 ? 'style="border-top: 1px dashed #dee2e6 !important;"' : bgStyle;

            return `<tr id="match-row-${idx}" class="${rowClass} ${warningClass}" data-section="${sectionKey}" data-group="${groupId || ''}" ${multiBrandStyle}>
                <td>${rowBtn}</td>
                <td>${brandCell}</td>
                <td>${linkedBrandDisplay}</td>
                <td>${weekdayDisplay}</td>
                <td title="${m.special_notes || ''}">${truncate(m.special_notes, 15)}</td>
                <td title="${m.deal_info || ''}">${truncate(m.deal_info, 15)}</td>
                <td>${discountDisplay}</td>
                <td>${vendorDisplay}</td>
                <td title="${locationsTooltip}">${truncate(m.locations, 25)}</td>
                <td title="${m.categories || ''}">${truncate(m.categories, 15)}</td>
                <td><span class="status-badge ${statusClass}">${m.confidence || 0}%</span></td>
                <td>${currentIdDisplay}</td>
                <td>${inputHtml}</td>
                <td>${actionHtml}</td>
            </tr>`;
        }
        
        // v88: Filter function for section tabs
        function filterMatchResultsBySection(section) {
            console.log('[FILTER] Filtering to section:', section);
            
            const rows = document.querySelectorAll('#match-results-unified-table tbody tr');
            rows.forEach(row => {
                const rowSection = row.getAttribute('data-section');
                if (section === 'all' || rowSection === section) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
            
            console.log('[FILTER] Rows visible, weeklyViewMode:', weeklyViewMode);
            
            // v12.2: If weekly section is visible AND breakdown mode is on, reorganize into weekday sections
            if ((section === 'weekly' || section === 'all') && weeklyViewMode === 'breakdown') {
                console.log('[FILTER] Triggering breakdown view');
                
                // SAVE ORIGINAL TABLE STATE before breakdown modifies it
                const table = document.getElementById('match-results-unified-table');
                if (table) {
                    const tbody = table.querySelector('tbody');
                    if (tbody && !originalTableState) {
                        originalTableState = tbody.innerHTML;
                        console.log('[FILTER] Saved original table state');
                    }
                }
                
                setTimeout(() => insertWeekdayHeaders(), 50); // Small delay to ensure rows are visible
            }
        }


        function toggleGroup(groupId) {
            const members = document.querySelectorAll(`.group-${groupId}`);
            const toggleIcon = document.getElementById(`toggle-${groupId}`);
            
            members.forEach(member => {
                member.classList.toggle('collapsed');
            });
            
            if (toggleIcon) {
                toggleIcon.classList.toggle('collapsed');
                toggleIcon.textContent = toggleIcon.classList.contains('collapsed') ? '->[EMOJI]' : '->[EMOJI]';
            }
        }

        function approveAllDaysInGroup(groupId) {
            const members = document.querySelectorAll(`.group-${groupId}`);
            const rowIndices = [];
            
            members.forEach(member => {
                const rowId = member.id;
                if (rowId && rowId.startsWith('match-row-')) {
                    const idx = parseInt(rowId.replace('match-row-', ''));
                    rowIndices.push(idx);
                }
            });
            
            if (rowIndices.length === 0) {
                alert('No rows found in this group');
                return;
            }
            
            rowIndices.forEach(idx => {
                approveSingleMatch(idx);
            });
            
            alert(`[OK] Approved all ${rowIndices.length} days in this group`);
        }

        function addIdField(idx) {
            const container = document.getElementById(`input-container-${idx}`);
            if (!container) return;
            
            const newDiv = document.createElement('div');
            newDiv.style.cssText = "display:flex; gap:5px; align-items:center; margin-top:4px;";
            
            newDiv.innerHTML = `
                <input type="text" class="mis-id-input" value="" 
                       style="width:80px; font-weight:bold; padding:4px;" data-row="${idx}">
                <span class="suggestion-indicator" onclick="showSuggestionTooltip(${idx}, this)" 
                      title="View Suggestions" style="cursor:pointer;"></span>
                <button class="btn" style="padding:2px 6px; font-size:1.1em; color:#dc3545;" 
                        onclick="this.parentElement.remove()">-</button>
            `;
            
            container.appendChild(newDiv);
        }

        function approveAll() {
            // v12.1: Show popup with section selection
            showBulkActionModal('approve');
        }
        
        function denyAll() {
            // v12.1: Show popup with section selection
            showBulkActionModal('deny');
        }
        
        // v12.1: Smart bulk action modal with section selection
        function showBulkActionModal(actionType) {
            // Remove any existing modal
            const existing = document.getElementById('bulk-action-modal-overlay');
            if (existing) existing.remove();
            
            const actionLabel = actionType === 'approve' ? 'Approve' : 'Deny';
            const actionColor = actionType === 'approve' ? '#28a745' : '#dc3545';
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.id = 'bulk-action-modal-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.5); z-index: 9998;
                display: flex; justify-content: center; align-items: center;
            `;
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #fff; padding: 25px; border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3); text-align: center;
                min-width: 350px;
            `;
            
            modal.innerHTML = `
                <h4 style="margin-bottom: 20px; color: ${actionColor};">${actionLabel} MIS IDs</h4>
                <p style="color: #666; margin-bottom: 20px;">Select which section to ${actionType.toLowerCase()}:<br>
                <small>(Only rows with MIS IDs entered will be processed)</small></p>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <button class="btn btn-lg" style="background: ${actionColor}; color: white; font-weight: bold;"
                            onclick="executeBulkAction('${actionType}', 'all')">
                        All Sections!
                    </button>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="btn btn-primary" style="flex: 1;"
                                onclick="executeBulkAction('${actionType}', 'weekly')">
                            Weekly
                        </button>
                        <button class="btn btn-success" style="flex: 1;"
                                onclick="executeBulkAction('${actionType}', 'monthly')">
                            Monthly
                        </button>
                        <button class="btn btn-warning" style="flex: 1;"
                                onclick="executeBulkAction('${actionType}', 'sale')">
                            Sale
                        </button>
                    </div>
                    <button class="btn btn-outline-secondary" onclick="closeBulkActionModal()">
                        Cancel
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Click outside to close
            overlay.onclick = function(e) {
                if (e.target === overlay) closeBulkActionModal();
            };
        }
        
        function closeBulkActionModal() {
            const modal = document.getElementById('bulk-action-modal-overlay');
            if (modal) modal.remove();
        }
        
        function executeBulkAction(actionType, section) {
            let count = 0;
            let skipped = 0;
            
            matchesData.forEach((match, idx) => {
                // Check if this row matches the selected section
                if (section !== 'all' && match.section !== section) {
                    return;
                }
                
                // Check if row is visible (not filtered out)
                const row = document.getElementById('match-row-' + idx);
                if (!row || row.style.display === 'none') {
                    return;
                }
                
                if (actionType === 'approve') {
                    // Only approve rows that have MIS IDs entered
                    const container = document.getElementById(`input-container-${idx}`);
                    if (container) {
                        const inputs = container.querySelectorAll('input.mis-id-input');
                        const values = Array.from(inputs)
                            .map(i => i.value.trim())
                            .filter(v => v.length > 0);
                        
                        if (values.length > 0) {
                            if (approveSingleMatch(idx)) {
                                count++;
                            }
                        } else {
                            skipped++;
                        }
                    }
                } else {
                    // Deny - remove from approved and mark as rejected
                    rejectMatch(idx);
                    count++;
                }
            });
            
            closeBulkActionModal();
            
            const sectionLabel = section === 'all' ? 'all sections' : section;
            if (actionType === 'approve') {
                let msg = `Approved ${count} rows in ${sectionLabel}.`;
                if (skipped > 0) {
                    msg += `\\nSkipped ${skipped} rows without MIS IDs.`;
                }
                alert(msg);
            } else {
                alert(`Denied ${count} rows in ${sectionLabel}.`);
            }
            
            console.log(`[BULK] ${actionType} completed: ${count} rows in ${sectionLabel}`);
        }
        
        function approveSingleMatch(idx) {
            const container = document.getElementById(`input-container-${idx}`);
            if (!container) {
                console.error(`Container not found for idx ${idx}`);
                return;
            }
            
            const inputs = container.querySelectorAll('input.mis-id-input');
            const values = Array.from(inputs)
                .map(i => i.value.trim())
                .filter(v => v.length > 0);
            
            if (values.length === 0) {
                // For bulk operations, silently skip rows without IDs
                return false;
            }
            
            const newMisId = values.join(', ');
            const match = matchesData[idx];
            
            if (!match) {
                console.error(`Match data not found for idx ${idx}`);
                return false;
            }
            
            // v12.1: Handle multi-brand deals - append MIS IDs instead of overwriting
            const existingApproval = approvedMatches[match.google_row];
            
            if (existingApproval && match.is_multi_brand) {
                // Same row already has an approval - this is a multi-brand situation
                // Append the new MIS ID to existing ones
                const existingIds = existingApproval.mis_ids || [existingApproval.mis_id];
                const existingBrands = existingApproval.brands || [];
                
                // Check if this brand was already approved (avoid duplicates)
                if (!existingBrands.includes(match.brand)) {
                    existingIds.push(newMisId);
                    existingBrands.push(match.brand);
                    
                    // v12.6 FIX: Preserve existing blaze_titles when updating MIS IDs
                    const existingBlazeTitles = existingApproval.blaze_titles || [];
                    
                    approvedMatches[match.google_row] = {
                        mis_ids: existingIds,
                        brands: existingBrands,
                        section: match.section || 'weekly',
                        is_multi_brand: true,
                        blaze_titles: existingBlazeTitles  // ‚úÖ PRESERVE blaze_titles
                    };
                    console.log(`[MULTI-BRAND] Row ${match.google_row}: Added ${match.brand} (${newMisId}). Total: ${existingIds.length} brands`);
                } else {
                    // Brand already approved - update its MIS ID
                    const brandIdx = existingBrands.indexOf(match.brand);
                    existingIds[brandIdx] = newMisId;
                    approvedMatches[match.google_row].mis_ids = existingIds;
                    console.log(`[MULTI-BRAND] Row ${match.google_row}: Updated ${match.brand} to ${newMisId}`);
                }
            } else {
                // First approval for this row or single-brand deal
                // v12.6 FIX: Check if there are existing blaze_titles to preserve
                const existingBlazeTitles = existingApproval?.blaze_titles || [];
                
                approvedMatches[match.google_row] = {
                    mis_ids: [newMisId],
                    brands: [match.brand],
                    section: match.section || 'weekly',
                    is_multi_brand: match.is_multi_brand || false,
                    blaze_titles: existingBlazeTitles  // ‚úÖ PRESERVE blaze_titles
                };
            }
            
            const row = document.getElementById('match-row-' + idx);
            if (row) {
                row.classList.add('row-approved');
                row.classList.remove('row-rejected');
            }
            
            // v12.1: Turn input text box green to show approval
            inputs.forEach(input => {
                input.style.backgroundColor = '#d4edda';
                input.style.borderColor = '#28a745';
                input.style.color = '#155724';
            });
            
            updateApplyButtonsVisibility();
            return true; // Return true to indicate success
        }

        function rejectMatch(idx) {
            const match = matchesData[idx];
            if (!match) return;
            
            const row = document.getElementById('match-row-' + idx);
            
            // v12.1: Handle multi-brand rejection properly
            const existingApproval = approvedMatches[match.google_row];
            if (existingApproval) {
                if (existingApproval.is_multi_brand && existingApproval.brands && existingApproval.brands.length > 1) {
                    // Multi-brand: Only remove this specific brand
                    const brandIdx = existingApproval.brands.indexOf(match.brand);
                    if (brandIdx !== -1) {
                        existingApproval.mis_ids.splice(brandIdx, 1);
                        existingApproval.brands.splice(brandIdx, 1);
                        console.log(`[MULTI-BRAND] Row ${match.google_row}: Rejected ${match.brand}. Remaining: ${existingApproval.brands.join(', ')}`);
                        
                        // If only one brand left, convert back to simple format
                        if (existingApproval.brands.length === 1) {
                            existingApproval.is_multi_brand = false;
                        }
                    }
                } else {
                    // Single brand or last brand: delete entire entry
                    delete approvedMatches[match.google_row];
                }
            }
            
            if (row) {
                row.classList.add('row-rejected');
                row.classList.remove('row-approved');
            }
            
            // v12.1: Clear green styling from input if it was approved
            const container = document.getElementById(`input-container-${idx}`);
            if (container) {
                const inputs = container.querySelectorAll('input.mis-id-input');
                inputs.forEach(input => {
                    input.style.backgroundColor = '';
                    input.style.borderColor = '';
                    input.style.color = '';
                });
            }
        }

// HELPER: Normalize date to YYYY-MM-DD format for comparison
        function normalizeDate(dateStr) {
            if (!dateStr || dateStr === 'N/A') return null;
            
            // Already in YYYY-MM-DD format
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateStr;
            }
            
            // Handle MM/DD/YYYY or M/D/YYYY format
            if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateStr)) {
                const parts = dateStr.split('/');
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = parts[2];
                return `${year}-${month}-${day}`;
            }
            
            // Handle MM/DD/YY or M/D/YY format (2-digit year)
            if (/^\d{1,2}\/\d{1,2}\/\d{2}$/.test(dateStr)) {
                const parts = dateStr.split('/');
                const month = parts[0].padStart(2, '0');
                const day = parts[1].padStart(2, '0');
                const year = '20' + parts[2]; // Assume 2000s
                return `${year}-${month}-${day}`;
            }
            
            return null; // Invalid format
        }

  // v12.1: ENHANCED MODAL for Suggestions with full comparison
        function showSuggestionTooltip(rowIdx) {
            // Remove any existing modals first
            const existing = document.getElementById('suggestion-modal-overlay');
            if (existing) existing.remove();

            const match = matchesData[rowIdx];
            if (!match || !match.suggestions || match.suggestions.length === 0) return;

            // Create Overlay (Dark Background)
            const overlay = document.createElement('div');
            overlay.id = 'suggestion-modal-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.5); z-index: 9998;
                display: flex; justify-content: center; align-items: center;
            `;
            overlay.onclick = function(e) {
                if(e.target === overlay) overlay.remove();
            };

            // v12.1: Adaptive width - 1500px or screen width minus padding, whichever is smaller
            const screenWidth = window.innerWidth;
            const modalWidth = Math.min(1500, screenWidth - 40); // 40px padding total
            
            // Create Modal Box - adaptive width with horizontal scroll
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #fff; padding: 20px; border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                width: ${modalWidth}px; max-width: 98%; max-height: 85vh;
                overflow-y: auto; overflow-x: auto; z-index: 9999; position: relative;
            `;
            
            // v12.1: Helper to format locations vertically for tooltip
            const formatLocationsVertical = (locations) => {
                if (!locations || locations === '-') return '-';
                // Split by comma, trim each, join with newlines
                return locations.split(',').map(loc => loc.trim()).filter(loc => loc).join('&#10;');
            };

            // Helper: Get cell style based on match
            const getMatchStyle = (sourceVal, targetVal, isNumeric = false) => {
                if (!sourceVal && !targetVal) return '';
                if (!sourceVal || !targetVal) return 'background:#fff3cd; color:#856404;'; // Yellow - missing
                
                let matches = false;
                if (isNumeric) {
                    const s = parseFloat(String(sourceVal).replace(/[%$,]/g, '')) || 0;
                    const t = parseFloat(String(targetVal).replace(/[%$,]/g, '')) || 0;
                    matches = Math.abs(s - t) < 0.01;
                } else {
                    matches = String(sourceVal).toLowerCase().trim() === String(targetVal).toLowerCase().trim();
                }
                
                return matches ? 'background:#d4edda; color:#155724;' : 'background:#f8d7da; color:#721c24;';
            };
            
            // Helper: Fuzzy match for brand
            const getBrandMatchStyle = (sourceBrand, targetBrand) => {
                if (!sourceBrand || !targetBrand) return 'background:#fff3cd; color:#856404;';
                const s = String(sourceBrand).toLowerCase().trim();
                const t = String(targetBrand).toLowerCase().trim();
                if (s === t) return 'background:#d4edda; color:#155724;'; // Exact match - green
                if (s.includes(t) || t.includes(s)) return 'background:#d4edda; color:#155724;'; // Contains - green
                return 'background:#f8d7da; color:#721c24;'; // No match - red
            };
            
            // v12.1: Get tab name for month/year parsing
            const currentTabName = document.getElementById('sheet-select') ? 
                document.getElementById('sheet-select').options[document.getElementById('sheet-select').selectedIndex]?.text || '' : '';
            
            // v12.1: Parse month/year from tab name (e.g., "January 2026")
            const parseTabMonthYear = (tabName) => {
                const months = ['january','february','march','april','may','june','july','august','september','october','november','december'];
                const parts = tabName.toLowerCase().trim().split(/\s+/);
                let month = -1, year = -1;
                for (const p of parts) {
                    const mIdx = months.indexOf(p);
                    if (mIdx >= 0) month = mIdx;
                    if (/^\d{4}$/.test(p)) year = parseInt(p);
                }
                return { month, year };
            };
            
            // v12.1: Get last day of month (handles leap years)
            const getLastDayOfMonth = (year, month) => {
                // month is 0-indexed (0=Jan, 11=Dec)
                return new Date(year, month + 1, 0).getDate();
            };
            
            // v12.1: Format date as YYYY-MM-DD
            const formatDate = (year, month, day) => {
                const m = String(month + 1).padStart(2, '0');
                const d = String(day).padStart(2, '0');
                return year + '-' + m + '-' + d;
            };
            
            // v12.1: Parse date string to {year, month, day}
            const parseDate = (dateStr) => {
                if (!dateStr || dateStr === '-' || dateStr === 'N/A') return null;
                // Try YYYY-MM-DD
                let m = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
                if (m) return { year: parseInt(m[1]), month: parseInt(m[2]) - 1, day: parseInt(m[3]) };
                // Try MM/DD/YYYY
                m = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                if (m) return { year: parseInt(m[3]), month: parseInt(m[1]) - 1, day: parseInt(m[2]) };
                // Try MM/DD/YY
                m = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);
                if (m) return { year: 2000 + parseInt(m[3]), month: parseInt(m[1]) - 1, day: parseInt(m[2]) };
                return null;
            };
            
            // v12.1: Normalize weekdays for comparison
            const normalizeWeekdays = (weekdayStr) => {
                if (!weekdayStr || weekdayStr === '-' || weekdayStr === 'N/A') return [];
                const days = ['mon','tue','wed','thu','fri','sat','sun'];
                const result = [];
                const lower = weekdayStr.toLowerCase();
                days.forEach(d => {
                    if (lower.includes(d)) result.push(d);
                });
                return result.sort();
            };
            
            // v12.1: Normalize locations for comparison
            const normalizeLocations = (locStr) => {
                if (!locStr || locStr === '-') return [];
                return locStr.split(',').map(l => l.trim().toLowerCase()).filter(l => l).sort();
            };
            
            // v12.1: Check if suggestion is a perfect match for Continue/Recycle
            const checkContinueEligibility = (searchingFor, suggestion, sectionType) => {
                const result = {
                    isContinue: false,
                    isPartialContinue: false,
                    mismatches: [],
                    newEndDate: null,
                    currentEndDate: null,
                    needsManualReview: false,
                    needsLinkedBrand: false,  // v12.1: Flag if MIS needs linked brand added
                    cannotDetermineDate: false  // Flag when tab name can't be parsed
                };
                
                // Parse tab for target month/year
                const tabInfo = parseTabMonthYear(currentTabName);
                if (tabInfo.month < 0 || tabInfo.year < 0) {
                    // Can't determine Continue eligibility without valid date - mark as indeterminate
                    result.cannotDetermineDate = true;
                    // Still check field matches for partial info
                }
                
                // Calculate new end date (last day of target month) - only if we have valid date
                if (!result.cannotDetermineDate) {
                    const lastDay = getLastDayOfMonth(tabInfo.year, tabInfo.month);
                    result.newEndDate = formatDate(tabInfo.year, tabInfo.month, lastDay);
                }
                
                // Get current MIS end date
                const misEndDate = suggestion.mis_data.end_date;
                result.currentEndDate = misEndDate;
                
                // Check each key field
                // 1. Brand - v12.1: STRICT match, no partial "includes" allowed
                const srcBrand = String(searchingFor.brand || '').toLowerCase().trim();
                const tgtBrand = String(suggestion.mis_data.brand || '').toLowerCase().trim();
                if (srcBrand !== tgtBrand) {
                    // Strict match only - "Stiiizy" should NOT match "Stiiizy Accessories"
                    result.mismatches.push('Brand');
                }
                
                // 2. Linked Brand - v12.1: Enhanced check with needsLinkedBrand flag
                const srcLinked = String(searchingFor.linked_brand || '').toLowerCase().trim();
                const tgtLinked = String(suggestion.mis_data.linked_brand || '').toLowerCase().trim();
                const srcHasLinked = srcLinked && srcLinked !== 'n/a' && srcLinked !== '';
                const tgtHasLinked = tgtLinked && tgtLinked !== 'n/a' && tgtLinked !== '';
                
                if (srcHasLinked) {
                    if (!tgtHasLinked) {
                        // Google Sheet has linked brand but MIS doesn't
                        result.needsLinkedBrand = true;
                    } else if (srcLinked !== tgtLinked) {
                        // Both have linked brand but they don't match
                        result.mismatches.push('Linked Brand');
                    }
                }
                
                // 3. Discount
                const srcDiscount = parseFloat(String(searchingFor.discount || 0).replace(/[%]/g, '')) || 0;
                const tgtDiscount = parseFloat(String(suggestion.mis_data.discount || 0).replace(/[%]/g, '')) || 0;
                if (Math.abs(srcDiscount - tgtDiscount) > 0.01) {
                    result.mismatches.push('Discount');
                }
                
                // 4. Vendor %
                const srcVendor = parseFloat(String(searchingFor.vendor_contrib || 0).replace(/[%]/g, '')) || 0;
                const tgtVendor = parseFloat(String(suggestion.mis_data.vendor_contribution || 0).replace(/[%]/g, '')) || 0;
                if (Math.abs(srcVendor - tgtVendor) > 0.01) {
                    result.mismatches.push('Vendor %');
                }
                
                // 5. Locations
                const srcLocs = normalizeLocations(searchingFor.locations);
                const tgtLocs = normalizeLocations(suggestion.mis_data.locations);
                if (JSON.stringify(srcLocs) !== JSON.stringify(tgtLocs)) {
                    result.mismatches.push('Locations');
                }
                
                // 6. Weekdays (for Weekly deals)
                if (sectionType === 'weekly') {
                    // Get all weekdays from multi-day group if applicable
                    let srcWeekdays = [];
                    if (searchingFor.multi_day_group && searchingFor.multi_day_group.weekdays) {
                        srcWeekdays = searchingFor.multi_day_group.weekdays.map(w => w.toLowerCase().substring(0,3)).filter(w => w && !w.includes('missing')).sort();
                    } else {
                        srcWeekdays = normalizeWeekdays(searchingFor.weekday);
                    }
                    const tgtWeekdays = normalizeWeekdays(suggestion.mis_data.weekdays);
                    if (JSON.stringify(srcWeekdays) !== JSON.stringify(tgtWeekdays)) {
                        result.mismatches.push('Weekdays');
                    }
                }
                
                // 7. Categories
                const srcCat = String(searchingFor.categories || '').toLowerCase().trim();
                const tgtCat = String(suggestion.mis_data.category || '').toLowerCase().trim();
                // "all" or empty both mean all categories
                const srcIsAll = !srcCat || srcCat === 'all' || srcCat === '-' || srcCat.includes('all categories');
                const tgtIsAll = !tgtCat || tgtCat === 'all' || tgtCat === '-' || tgtCat === 'n/a' || tgtCat === 'nan';
                if (srcIsAll !== tgtIsAll) {
                    result.mismatches.push('Categories');
                } else if (!srcIsAll && !tgtIsAll && srcCat !== tgtCat) {
                    result.mismatches.push('Categories');
                }
                
                // Determine eligibility
                // Can only determine Continue eligibility if we could parse the tab date
                if (result.mismatches.length === 0 && !result.cannotDetermineDate) {
                    result.isContinue = true;
                    
                    // Check if end date needs manual review
                    const parsedEnd = parseDate(misEndDate);
                    if (parsedEnd) {
                        const endDateObj = new Date(parsedEnd.year, parsedEnd.month, parsedEnd.day);
                        const targetMonthStart = new Date(tabInfo.year, tabInfo.month, 1);
                        if (endDateObj >= targetMonthStart) {
                            result.needsManualReview = true;
                            result.isPartialContinue = true;
                        }
                    }
                }
                
                return result;
            };

            // Helper: Build More Info popup content
            const buildMoreInfoHtml = (data, title) => {
                if (!data || Object.keys(data).length === 0) return '<em>No additional data</em>';
                let html = '<table class="table table-sm table-bordered" style="font-size:0.8em; margin:0;">';
                html += '<thead><tr><th style="width:40%;">Field</th><th>Value</th></tr></thead><tbody>';
                Object.entries(data).forEach(([key, val]) => {
                    html += '<tr><td><strong>' + key + '</strong></td><td>' + val + '</td></tr>';
                });
                html += '</tbody></table>';
                return html;
            };

            // Escape for JSON embedding
            const escapeForAttr = (str) => {
                if (!str) return '';
                return String(str).replace(/'/g, "\\'").replace(/"/g, "&quot;");
            };

            // --- HEADER ---
            let html = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:2px solid #007bff; padding-bottom:10px;">
                    <h5 style="margin:0; color:#007bff;">Suggestion Details for Row ${match.google_row}</h5>
                    <button class="btn btn-sm btn-outline-danger" onclick="document.getElementById('suggestion-modal-overlay').remove()">Close</button>
                </div>
            `;

            // --- SEARCHING FOR SECTION ---
            const linkedBrandDisplay = match.linked_brand ? `<br><small style="color:#6c757d;">${match.linked_brand}</small>` : '';
            const rawRowDataJson = match.raw_row_data ? escapeForAttr(JSON.stringify(match.raw_row_data)) : '{}';
            
            // v12.1: Format weekdays vertically for display and tooltip
            let searchingWeekdays = match.weekday || '-';
            let searchingWeekdaysTooltip = match.weekday || '-';
            if (match.multi_day_group && match.multi_day_group.weekdays) {
                const weekdaysList = match.multi_day_group.weekdays.filter(w => w && !w.toLowerCase().includes('missing'));
                searchingWeekdays = weekdaysList.join('<br>');
                searchingWeekdaysTooltip = weekdaysList.join('&#10;');
            }
            
            // v12.1: Format categories vertically
            const formatCategoriesVertical = (catStr) => {
                if (!catStr || catStr === '-') return { display: '-', tooltip: '-' };
                const cats = catStr.split(',').map(c => c.trim()).filter(c => c);
                return { 
                    display: cats.slice(0, 3).join('<br>') + (cats.length > 3 ? '<br>...' : ''),
                    tooltip: cats.join('&#10;')
                };
            };
            const searchingCategories = formatCategoriesVertical(match.categories);
            
            html += `
                <div style="margin-bottom:20px;">
                    <h6 style="color:#495057; margin-bottom:10px; border-bottom:1px solid #dee2e6; padding-bottom:5px;">
                        Searching For (Google Sheet Data)
                    </h6>
                    <div style="overflow-x:auto;">
                        <table class="table table-sm table-bordered" style="font-size:0.85em; white-space:nowrap;">
                            <thead class="table-primary">
                                <tr>
                                    <th>Row</th>
                                    <th>Weekday</th>
                                    <th>Brand / Linked</th>
                                    <th>Category</th>
                                    <th>Discount</th>
                                    <th>Vendor %</th>
                                    <th>Deal Info</th>
                                    <th>Notes</th>
                                    <th>Locations</th>
                                    <th>More Info</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background:#e7f1ff;">
                                    <td>
                                        <button class="btn btn-sm btn-outline-primary py-0 px-2" 
                                                onclick="openSheetRow(${match.google_row})" 
                                                title="Go to row in Google Sheet">
                                            ${match.google_row}
                                        </button>
                                    </td>
                                    <td title="${searchingWeekdaysTooltip}" style="white-space:normal;"><strong>${searchingWeekdays}</strong></td>
                                    <td><strong>${match.brand}</strong>${linkedBrandDisplay}</td>
                                    <td title="${searchingCategories.tooltip}" style="white-space:normal;">${searchingCategories.display}</td>
                                    <td><strong>${match.discount !== null && match.discount !== '' ? match.discount + '%' : '-'}</strong></td>
                                    <td>${match.vendor_contrib !== null && match.vendor_contrib !== '' ? match.vendor_contrib + '%' : '-'}</td>
                                    <td title="${match.deal_info || ''}">${(match.deal_info || '-').substring(0, 20)}${(match.deal_info || '').length > 20 ? '...' : ''}</td>
                                    <td title="${match.special_notes || ''}">${(match.special_notes || '-').substring(0, 20)}${(match.special_notes || '').length > 20 ? '...' : ''}</td>
                                    <td title="${formatLocationsVertical(match.locations)}">${(match.locations || '-').substring(0, 25)}${(match.locations || '').length > 25 ? '...' : ''}</td>
                                    <td>
                                        <div class="more-info-container" style="position:relative; display:inline-block;">
                                            <button class="btn btn-sm btn-outline-info py-0 px-2" 
                                                    onclick="showMoreInfoPopup(this, 'sheet', ${rowIdx})"
                                                    onmouseenter="showMoreInfoPopup(this, 'sheet', ${rowIdx})"
                                                    title="View all Google Sheet fields">
                                                Info
                                            </button>
                                        </div>
                                        <button class="btn btn-sm btn-success py-0 px-2 ms-1" 
                                            onclick="showCreateDealPopup(${rowIdx})"
                                            title="Create new deal in MIS based on this Google Sheet data">
                                            Create
                                        </button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            `;

            // --- SUGGESTIONS SECTION ---
            html += `
                <div>
                    <h6 style="color:#495057; margin-bottom:10px; border-bottom:1px solid #dee2e6; padding-bottom:5px;">
                        Suggested Matches from MIS CSV <small class="text-muted">(${match.suggestions.length} found)</small>
                    </h6>
                    <div style="overflow-x:auto;">
                        <table class="table table-sm table-bordered table-hover" style="font-size:0.85em; white-space:nowrap;">
                            <thead class="table-light">
                                <tr>
                                    <th>Conf.</th>
                                    <th>MIS ID</th>
                                    <th>Weekday</th>
                                    <th>Brand / Linked</th>
                                    <th>Category</th>
                                    <th>Discount</th>
                                    <th>Vendor %</th>
                                    <th>Locations</th>
                                    <th>Start Date</th>
                                    <th>End Date</th>
                                    <th>More Info</th>
                                    <th>Action</th>
                                </tr>
                            </thead>
                            <tbody>
            `;

            match.suggestions.forEach((s, sIdx) => {
                // Confidence color
                const confColor = s.confidence >= 90 ? '#28a745' : (s.confidence >= 70 ? '#ffc107' : '#dc3545');
                const confBg = s.confidence >= 90 ? '#d4edda' : (s.confidence >= 70 ? '#fff3cd' : '#f8d7da');
                
                // Get values from suggestion
                const sLinkedBrand = s.mis_data.linked_brand && s.mis_data.linked_brand !== 'N/A' ? s.mis_data.linked_brand : '';
                const sWeekday = s.mis_data.weekdays && s.mis_data.weekdays !== 'N/A' ? s.mis_data.weekdays : '-';
                const sCategory = s.mis_data.category && s.mis_data.category !== 'N/A' && s.mis_data.category !== '-' && s.mis_data.category !== 'nan' ? s.mis_data.category : 'All Categories';
                const sDiscount = s.mis_data.discount !== null && s.mis_data.discount !== undefined ? s.mis_data.discount : '-';
                const sVendor = s.mis_data.vendor_contribution !== null && s.mis_data.vendor_contribution !== undefined ? s.mis_data.vendor_contribution : '-';
                const sLocations = s.mis_data.locations || '-';
                const sLocationsVertical = formatLocationsVertical(sLocations);
                const sStartDate = s.mis_data.start_date && s.mis_data.start_date !== 'N/A' ? s.mis_data.start_date : '-';
                const sEndDate = s.mis_data.end_date && s.mis_data.end_date !== 'N/A' ? s.mis_data.end_date : '-';
                
                // v12.1: Format weekday vertically with tooltip
                const sWeekdayParts = sWeekday.split(',').map(w => w.trim()).filter(w => w && w !== '-');
                const sWeekdayDisplay = sWeekdayParts.length > 0 ? sWeekdayParts.join('<br>') : '-';
                const sWeekdayTooltip = sWeekdayParts.length > 0 ? sWeekdayParts.join('&#10;') : '-';
                
                // v12.1: Format category vertically with tooltip
                const sCategoryParts = sCategory === 'All Categories' ? ['All Categories'] : sCategory.split(',').map(c => c.trim()).filter(c => c);
                const sCategoryDisplay = sCategoryParts.slice(0, 3).join('<br>') + (sCategoryParts.length > 3 ? '<br>...' : '');
                const sCategoryTooltip = sCategoryParts.join('&#10;');
                
                // Color coding for comparison
                const brandStyle = getBrandMatchStyle(match.brand, s.mis_data.brand);
                const discountStyle = getMatchStyle(match.discount, sDiscount, true);
                const vendorStyle = getMatchStyle(match.vendor_contrib, sVendor, true);
                
                // v12.1: Check Continue/Recycle eligibility
                const continueCheck = checkContinueEligibility(match, s, match.section || 'weekly');
                
                // v12.1: Build Continue/New Entry indicator
                let continueIndicator = '';
                let endDateStyle = '';
                let endDateTooltip = sEndDate;
                
                if (continueCheck.isContinue) {
                    if (continueCheck.needsManualReview) {
                        continueIndicator = '<br><span style="color:#856404; font-size:0.75em; font-weight:bold;">CONTINUE*</span>';
                        endDateStyle = 'background:#fff3cd; font-weight:bold;';
                        endDateTooltip = 'MANUAL REVIEW NEEDED: End date (' + sEndDate + ') is already within target month. Verify if extension to ' + continueCheck.newEndDate + ' is needed.';
                    } else {
                        continueIndicator = '<br><span style="color:#155724; font-size:0.75em; font-weight:bold;">CONTINUE</span>';
                        endDateStyle = 'background:#fff3cd; font-weight:bold;';
                        endDateTooltip = 'UPDATE END DATE: Change from ' + sEndDate + ' to ' + continueCheck.newEndDate + ' (last day of ' + currentTabName + ')';
                    }
                    // v12.1: Add warning if MIS needs linked brand
                    if (continueCheck.needsLinkedBrand) {
                        continueIndicator += '<br><span style="color:#856404; font-size:0.65em; background:#fff3cd; padding:1px 3px; border-radius:2px;" title="Google Sheet has Linked Brand but MIS entry does not">√¢≈°¬† Needs Linked Brand</span>';
                    }
                } else {
                    // Not a Continue - show as NEW ENTRY
                    if (continueCheck.cannotDetermineDate) {
                        // Can't determine Continue status due to unparseable tab name
                        continueIndicator = '<br><span style="color:#856404; font-size:0.75em; font-weight:bold; background:#fff3cd; padding:1px 3px; border-radius:2px;" title="Cannot determine Continue eligibility - tab name could not be parsed for date">? UNDETERMINED</span>';
                        if (continueCheck.mismatches.length > 0) {
                            continueIndicator += '<br><span style="color:#dc3545; font-size:0.65em;">Diff: ' + continueCheck.mismatches.join(', ') + '</span>';
                        }
                    } else {
                        continueIndicator = '<br><span style="color:#721c24; font-size:0.75em; font-weight:bold;">NEW ENTRY</span>';
                        if (continueCheck.mismatches.length > 0) {
                            continueIndicator += '<br><span style="color:#dc3545; font-size:0.65em;">Diff: ' + continueCheck.mismatches.join(', ') + '</span>';
                        }
                    }
                    // v12.1: Also show needs linked brand warning for NEW ENTRY
                    if (continueCheck.needsLinkedBrand) {
                        continueIndicator += '<br><span style="color:#856404; font-size:0.65em; background:#fff3cd; padding:1px 3px; border-radius:2px;" title="Google Sheet has Linked Brand but MIS entry does not">√¢≈°¬† Needs Linked Brand</span>';
                    }
                }
                
                const rawCsvDataJson = s.mis_data.raw_csv_data ? escapeForAttr(JSON.stringify(s.mis_data.raw_csv_data)) : '{}';
                
                html += `
                    <tr>
                        <td style="background:${confBg}; text-align:center;">
                            <span style="color:${confColor}; font-weight:bold;">${s.confidence}%</span>
                            ${continueIndicator}
                        </td>
                        <td>
                            <button class="btn btn-sm btn-outline-secondary py-0 px-2" 
                                    onclick="lookupMisId('${s.mis_id}')" 
                                    style="font-weight:bold;" 
                                    title="Click to lookup in MIS">
                                ${s.mis_id}
                            </button>
                        </td>
                        <td title="${sWeekdayTooltip}" style="white-space:normal;">${sWeekdayDisplay}</td>
                        <td style="${brandStyle}">
                            <strong>${s.mis_data.brand}</strong>
                            ${sLinkedBrand ? '<br><small style="color:#6c757d;">' + sLinkedBrand + '</small>' : ''}
                        </td>
                        <td title="${sCategoryTooltip}" style="white-space:normal;">${sCategoryDisplay}</td>
                        <td style="${discountStyle}"><strong>${sDiscount}%</strong></td>
                        <td style="${vendorStyle}">${sVendor}%</td>
                        <td title="${sLocationsVertical}">${sLocations.substring(0, 20)}${sLocations.length > 20 ? '...' : ''}</td>
                        <td>${sStartDate}</td>
                        <td style="${endDateStyle}" title="${endDateTooltip}">
                            <div id="end-date-display-${rowIdx}-${sIdx}">
                                <button class="btn btn-sm btn-outline-warning py-0 px-1" 
                                        onclick="showEndDateEditor(${rowIdx}, ${sIdx}, '${s.mis_id}', '${sEndDate}')"
                                        title="Click to update end date in MIS">
                                    ${sEndDate}
                                </button>
                            </div>
                            <div id="end-date-editor-${rowIdx}-${sIdx}" style="display:none;">
                                <div style="display:flex; gap:2px; align-items:center; flex-wrap:wrap;">
                                    <select id="end-month-${rowIdx}-${sIdx}" class="form-select form-select-sm" style="width:60px; padding:2px;">
                                        <option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>
                                        <option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>
                                        <option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>
                                        <option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>
                                    </select>
                                    <select id="end-day-${rowIdx}-${sIdx}" class="form-select form-select-sm" style="width:55px; padding:2px;"></select>
                                    <select id="end-year-${rowIdx}-${sIdx}" class="form-select form-select-sm" style="width:70px; padding:2px;"></select>
                                    <button class="btn btn-sm btn-success py-0 px-2" onclick="updateMisEndDate(${rowIdx}, ${sIdx}, '${s.mis_id}')">Update</button>
                                    <button class="btn btn-sm btn-secondary py-0 px-1" onclick="cancelEndDateEditor(${rowIdx}, ${sIdx})">√¢≈ì‚Ä¢</button>
                                </div>
                            </div>
                        </td>
                        <td>
                            <div class="more-info-container" style="position:relative; display:inline-block;">
                                <button class="btn btn-sm btn-outline-info py-0 px-2" 
                                        onclick="showMoreInfoPopup(this, 'csv', ${rowIdx}, ${sIdx})"
                                        onmouseenter="showMoreInfoPopup(this, 'csv', ${rowIdx}, ${sIdx})"
                                        title="View all MIS CSV fields">
                                    Info
                                </button>
                            </div>
                        </td>
                        <td>
                            <button class="btn btn-sm btn-primary" 
                                onclick="applySuggestionFromModal(${rowIdx}, '${s.mis_id}')">
                                Select
                            </button>
                        </td>
                    </tr>
                `;
            });

            html += `
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div style="margin-top:15px; padding-top:10px; border-top:1px solid #dee2e6; text-align:right;">
                    <small class="text-muted">Color Legend: </small>
                    <span class="badge" style="background:#d4edda; color:#155724;">Match</span>
                    <span class="badge" style="background:#fff3cd; color:#856404;">Partial/Missing</span>
                    <span class="badge" style="background:#f8d7da; color:#721c24;">Mismatch</span>
                </div>
            `;
            
            modal.innerHTML = html;
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }
        
        // v12.2: End Date Editor functions for updating MIS end dates
        function showEndDateEditor(rowIdx, sIdx, misId, currentEndDate) {
            // Hide display, show editor
            const displayEl = document.getElementById(`end-date-display-${rowIdx}-${sIdx}`);
            const editorEl = document.getElementById(`end-date-editor-${rowIdx}-${sIdx}`);
            if (displayEl) displayEl.style.display = 'none';
            if (editorEl) editorEl.style.display = 'block';
            
            // Calculate default end date (last day of month from tab name)
            const defaultDate = calculateDefaultEndDate();
            
            // Populate dropdowns
            const monthSelect = document.getElementById(`end-month-${rowIdx}-${sIdx}`);
            const daySelect = document.getElementById(`end-day-${rowIdx}-${sIdx}`);
            const yearSelect = document.getElementById(`end-year-${rowIdx}-${sIdx}`);
            
            // Populate year dropdown (current year and next 2 years)
            const currentYear = new Date().getFullYear();
            yearSelect.innerHTML = '';
            for (let y = currentYear; y <= currentYear + 2; y++) {
                const opt = document.createElement('option');
                opt.value = y;
                opt.textContent = y;
                yearSelect.appendChild(opt);
            }
            
            // Set default values
            if (defaultDate) {
                monthSelect.value = defaultDate.month;
                yearSelect.value = defaultDate.year;
                updateDayDropdown(rowIdx, sIdx);
                daySelect.value = defaultDate.day;
            } else {
                // Fallback: try to parse current end date
                const parsed = parseEndDateString(currentEndDate);
                if (parsed) {
                    monthSelect.value = parsed.month;
                    yearSelect.value = parsed.year;
                    updateDayDropdown(rowIdx, sIdx);
                    daySelect.value = parsed.day;
                } else {
                    updateDayDropdown(rowIdx, sIdx);
                }
            }
            
            // Add change listeners to update day dropdown when month/year changes
            monthSelect.onchange = () => updateDayDropdown(rowIdx, sIdx);
            yearSelect.onchange = () => updateDayDropdown(rowIdx, sIdx);
        }
        
        function cancelEndDateEditor(rowIdx, sIdx) {
            const displayEl = document.getElementById(`end-date-display-${rowIdx}-${sIdx}`);
            const editorEl = document.getElementById(`end-date-editor-${rowIdx}-${sIdx}`);
            if (displayEl) displayEl.style.display = 'block';
            if (editorEl) editorEl.style.display = 'none';
        }
        
        function updateDayDropdown(rowIdx, sIdx) {
            const monthSelect = document.getElementById(`end-month-${rowIdx}-${sIdx}`);
            const daySelect = document.getElementById(`end-day-${rowIdx}-${sIdx}`);
            const yearSelect = document.getElementById(`end-year-${rowIdx}-${sIdx}`);
            
            if (!monthSelect || !daySelect || !yearSelect) return;
            
            const month = parseInt(monthSelect.value);
            const year = parseInt(yearSelect.value);
            const daysInMonth = new Date(year, month, 0).getDate();
            
            const currentDay = daySelect.value;
            daySelect.innerHTML = '';
            
            for (let d = 1; d <= daysInMonth; d++) {
                const opt = document.createElement('option');
                opt.value = String(d).padStart(2, '0');
                opt.textContent = d;
                daySelect.appendChild(opt);
            }
            
            // Try to restore previous selection or default to last day
            if (currentDay && parseInt(currentDay) <= daysInMonth) {
                daySelect.value = currentDay;
            } else {
                daySelect.value = String(daysInMonth).padStart(2, '0');
            }
        }
        
        function calculateDefaultEndDate() {
            // Get tab name and calculate last day of that month
            const currentTabName = document.getElementById('mis-tab')?.value || '';
            if (!currentTabName) return null;
            
            // Parse tab name for month/year (reuse logic from checkContinueEligibility)
            const tabInfo = parseTabMonthYear(currentTabName);
            if (tabInfo.month < 0 || tabInfo.year < 0) return null;
            
            // Calculate last day of month
            const lastDay = getLastDayOfMonth(tabInfo.year, tabInfo.month);
            
            return {
                month: String(tabInfo.month + 1).padStart(2, '0'), // Convert 0-indexed to 1-indexed
                day: String(lastDay).padStart(2, '0'),
                year: String(tabInfo.year)
            };
        }
        
        function parseEndDateString(dateStr) {
            if (!dateStr || dateStr === '-' || dateStr === 'N/A') return null;
            
            // Try MM/DD/YYYY or MM/DD/YY format
            const parts = dateStr.split('/');
            if (parts.length === 3) {
                let year = parts[2];
                if (year.length === 2) {
                    year = '20' + year;
                }
                return {
                    month: parts[0].padStart(2, '0'),
                    day: parts[1].padStart(2, '0'),
                    year: year
                };
            }
            return null;
        }
        
        async function updateMisEndDate(rowIdx, sIdx, misId) {
            const monthSelect = document.getElementById(`end-month-${rowIdx}-${sIdx}`);
            const daySelect = document.getElementById(`end-day-${rowIdx}-${sIdx}`);
            const yearSelect = document.getElementById(`end-year-${rowIdx}-${sIdx}`);
            
            if (!monthSelect || !daySelect || !yearSelect) {
                alert('Date selectors not found');
                return;
            }
            
            const month = monthSelect.value;
            const day = daySelect.value;
            const year = yearSelect.value.slice(-2); // Get last 2 digits of year
            
            // Format as MM/DD/YY for MIS
            const newDate = `${month}/${day}/${year}`;
            
            // Show loading state
            const editorEl = document.getElementById(`end-date-editor-${rowIdx}-${sIdx}`);
            const originalHtml = editorEl.innerHTML;
            editorEl.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Updating MIS...';
            
            try {
                const response = await fetch('/api/mis/update-end-date', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ mis_id: misId, new_date: newDate })
                });
                const data = await response.json();
                
                if (data.success) {
                    // Update the display
                    const displayEl = document.getElementById(`end-date-display-${rowIdx}-${sIdx}`);
                    if (displayEl) {
                        const savedIcon = data.saved ? '√¢≈ì‚Äú√¢≈ì‚Äú' : '√¢≈ì‚Äú';
                        const savedColor = data.saved ? '#155724' : '#856404';
                        displayEl.innerHTML = `<span style="color:${savedColor}; font-weight:bold;">${savedIcon} ${newDate}</span>`;
                        displayEl.style.display = 'block';
                    }
                    editorEl.style.display = 'none';
                    editorEl.innerHTML = originalHtml;
                    
                    if (data.saved) {
                        alert('√¢≈ì‚Äú End date updated to ' + newDate + ' and SAVED successfully!');
                    } else {
                        alert('√¢≈ì‚Äú End date updated to ' + newDate + '\\n\\n' + (data.message || 'Please verify in MIS.'));
                    }
                } else {
                    editorEl.innerHTML = originalHtml;
                    alert('Error: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                editorEl.innerHTML = originalHtml;
                alert('Error: ' + error.message);
            }
        }
        
        // ============================================
        // v12.3: CREATE DEAL IN MIS - Functions
        // ============================================
        
        function showCreateDealPopup(rowIdx) {
            // Get the Google Sheet data for this row
            const match = matchesData[rowIdx];
            if (!match) {
                alert('Error: Could not find row data');
                return;
            }
            
            // Remove any existing popup
            const existingPopup = document.getElementById('create-deal-popup-overlay');
            if (existingPopup) existingPopup.remove();
            
            // Calculate default dates (last day of month from tab name)
            const defaultDate = calculateDefaultEndDate();
            const today = new Date();
            const todayStr = {
                month: String(today.getMonth() + 1).padStart(2, '0'),
                day: String(today.getDate()).padStart(2, '0'),
                year: String(today.getFullYear())
            };
            
            // Build popup HTML
            const overlay = document.createElement('div');
            overlay.id = 'create-deal-popup-overlay';
            overlay.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.6); z-index:10002; display:flex; justify-content:center; align-items:center;';
            
            const popup = document.createElement('div');
            popup.style.cssText = 'background:white; border-radius:10px; padding:25px; max-width:500px; width:90%; box-shadow:0 10px 40px rgba(0,0,0,0.3);';
            
            popup.innerHTML = `
                <h5 style="margin-bottom:20px; color:#28a745; border-bottom:2px solid #28a745; padding-bottom:10px;">
                    <i class="bi bi-plus-circle"></i> Create New Deal in MIS
                </h5>
                
                <div class="alert alert-info" style="font-size:0.9em;">
                    <strong>Creating deal for:</strong><br>
                    <strong>Brand:</strong> ${match.brand || '-'}<br>
                    <strong>Weekday:</strong> ${match.weekday || '-'}<br>
                    <strong>Discount:</strong> ${match.discount || '-'}%<br>
                    <strong>Row:</strong> ${match.google_row}
                </div>
                
                <div class="mb-3">
                    <label class="form-label fw-bold">Start Date:</label>
                    <div style="display:flex; gap:5px;">
                        <select id="create-start-month" class="form-select form-select-sm" style="width:80px;">
                            <option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>
                            <option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>
                            <option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>
                            <option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>
                        </select>
                        <select id="create-start-day" class="form-select form-select-sm" style="width:70px;"></select>
                        <select id="create-start-year" class="form-select form-select-sm" style="width:90px;"></select>
                    </div>
                </div>
                
                <div class="mb-4">
                    <label class="form-label fw-bold">End Date:</label>
                    <div style="display:flex; gap:5px;">
                        <select id="create-end-month" class="form-select form-select-sm" style="width:80px;">
                            <option value="01">Jan</option><option value="02">Feb</option><option value="03">Mar</option>
                            <option value="04">Apr</option><option value="05">May</option><option value="06">Jun</option>
                            <option value="07">Jul</option><option value="08">Aug</option><option value="09">Sep</option>
                            <option value="10">Oct</option><option value="11">Nov</option><option value="12">Dec</option>
                        </select>
                        <select id="create-end-day" class="form-select form-select-sm" style="width:70px;"></select>
                        <select id="create-end-year" class="form-select form-select-sm" style="width:90px;"></select>
                    </div>
                </div>
                
                <div style="display:flex; gap:10px; justify-content:flex-end;">
                    <button class="btn btn-secondary" onclick="closeCreateDealPopup()">Cancel</button>
                    <button class="btn btn-success" onclick="executeCreateDeal(${rowIdx})">
                        <i class="bi bi-check-lg"></i> Confirm & Create
                    </button>
                </div>
            `;
            
            overlay.appendChild(popup);
            document.body.appendChild(overlay);
            
            // Populate year dropdowns
            const currentYear = new Date().getFullYear();
            ['create-start-year', 'create-end-year'].forEach(id => {
                const select = document.getElementById(id);
                select.innerHTML = '';
                for (let y = currentYear; y <= currentYear + 2; y++) {
                    const opt = document.createElement('option');
                    opt.value = y;
                    opt.textContent = y;
                    select.appendChild(opt);
                }
            });
            
            // Set default values - Start: today, End: last day of tab month
            document.getElementById('create-start-month').value = todayStr.month;
            document.getElementById('create-start-year').value = todayStr.year;
            updateCreateDayDropdown('start');
            document.getElementById('create-start-day').value = todayStr.day;
            
            if (defaultDate) {
                document.getElementById('create-end-month').value = defaultDate.month;
                document.getElementById('create-end-year').value = defaultDate.year;
                updateCreateDayDropdown('end');
                document.getElementById('create-end-day').value = defaultDate.day;
            } else {
                updateCreateDayDropdown('end');
            }
            
            // Add change listeners
            document.getElementById('create-start-month').onchange = () => updateCreateDayDropdown('start');
            document.getElementById('create-start-year').onchange = () => updateCreateDayDropdown('start');
            document.getElementById('create-end-month').onchange = () => updateCreateDayDropdown('end');
            document.getElementById('create-end-year').onchange = () => updateCreateDayDropdown('end');
            
            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) closeCreateDealPopup();
            };
        }
        
        function closeCreateDealPopup() {
            const popup = document.getElementById('create-deal-popup-overlay');
            if (popup) popup.remove();
        }
        
        function updateCreateDayDropdown(type) {
            const monthSelect = document.getElementById(`create-${type}-month`);
            const daySelect = document.getElementById(`create-${type}-day`);
            const yearSelect = document.getElementById(`create-${type}-year`);
            
            if (!monthSelect || !daySelect || !yearSelect) return;
            
            const month = parseInt(monthSelect.value);
            const year = parseInt(yearSelect.value);
            const daysInMonth = new Date(year, month, 0).getDate();
            
            const currentDay = daySelect.value;
            daySelect.innerHTML = '';
            
            for (let d = 1; d <= daysInMonth; d++) {
                const opt = document.createElement('option');
                opt.value = String(d).padStart(2, '0');
                opt.textContent = d;
                daySelect.appendChild(opt);
            }
            
            // Restore or default to last day
            if (currentDay && parseInt(currentDay) <= daysInMonth) {
                daySelect.value = currentDay;
            } else if (type === 'end') {
                daySelect.value = String(daysInMonth).padStart(2, '0');
            }
        }
        
        async function executeCreateDeal(rowIdx) {
            const match = matchesData[rowIdx];
            if (!match) {
                alert('Error: Could not find row data');
                return;
            }
            
            // Get dates from popup
            const startMonth = document.getElementById('create-start-month').value;
            const startDay = document.getElementById('create-start-day').value;
            const startYear = document.getElementById('create-start-year').value.slice(-2);
            const endMonth = document.getElementById('create-end-month').value;
            const endDay = document.getElementById('create-end-day').value;
            const endYear = document.getElementById('create-end-year').value.slice(-2);
            
            const startDate = `${startMonth}/${startDay}/${startYear}`;
            const endDate = `${endMonth}/${endDay}/${endYear}`;
            
            // Close popup and show loading
            closeCreateDealPopup();
            
            // Show loading indicator
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'create-deal-loading';
            loadingOverlay.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:10003; display:flex; justify-content:center; align-items:center; flex-direction:column;';
            loadingOverlay.innerHTML = `
                <div class="spinner-border text-light" style="width:3rem; height:3rem;"></div>
                <div style="color:white; margin-top:15px; font-size:1.2em;">Creating deal in MIS...</div>
                <div id="create-deal-status" style="color:#aaa; margin-top:10px; font-size:0.9em;">Initializing...</div>
            `;
            document.body.appendChild(loadingOverlay);
            
            try {
                const response = await fetch('/api/mis/create-deal', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        row_idx: rowIdx,
                        google_row: match.google_row,
                        start_date: startDate,
                        end_date: endDate,
                        // Pass all Google Sheet data
                        sheet_data: {
                            brand: match.brand,
                            linked_brand: match.linked_brand || '',
                            weekday: match.weekday,
                            discount: match.discount,
                            vendor_contrib: match.vendor_contrib,
                            locations: match.locations,
                            categories: match.categories,
                            raw_row_data: match.raw_row_data
                        }
                    })
                });
                
                const data = await response.json();
                
                // Remove loading
                document.getElementById('create-deal-loading')?.remove();
                
                if (data.success) {
                    let message = '√¢≈ì‚Äú Deal created in MIS!\\n\\n';
                    if (data.warnings && data.warnings.length > 0) {
                        message += '√¢≈°¬† Warnings:\\n' + data.warnings.join('\\n') + '\\n\\n';
                    }
                    message += 'Please review and click Save in MIS if everything looks correct.';
                    alert(message);
                } else {
                    alert('Error creating deal: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                document.getElementById('create-deal-loading')?.remove();
                alert('Error: ' + error.message);
            }
        }
        
        // v12.1: More Info popup for detailed field view - CENTERED on screen
        function showMoreInfoPopup(btn, type, rowIdx, suggestionIdx = null) {
            // Remove any existing more-info popups
            const existingPopup = document.getElementById('more-info-popup');
            if (existingPopup) existingPopup.remove();
            
            const match = matchesData[rowIdx];
            if (!match) return;
            
            let data = {};
            let title = '';
            
            if (type === 'sheet') {
                data = match.raw_row_data || {};
                title = 'Google Sheet - All Fields';
            } else if (type === 'csv' && suggestionIdx !== null && match.suggestions[suggestionIdx]) {
                data = match.suggestions[suggestionIdx].mis_data.raw_csv_data || {};
                title = 'MIS CSV - All Fields';
            }
            
            if (Object.keys(data).length === 0) {
                return;
            }
            
            // Create popup - CENTERED on screen
            const popup = document.createElement('div');
            popup.id = 'more-info-popup';
            popup.style.cssText = `
                position: fixed; z-index: 10001;
                background: #fff; border: 1px solid #ccc; border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                padding: 15px; max-width: 500px; max-height: 500px;
                overflow-y: auto;
                left: 50%; top: 50%;
                transform: translate(-50%, -50%);
            `;
            
            // Build content
            let html = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; border-bottom:1px solid #eee; padding-bottom:5px;">
                    <strong style="color:#007bff;">${title}</strong>
                    <button class="btn btn-sm btn-outline-danger py-0 px-1" onclick="document.getElementById('more-info-popup').remove()">X</button>
                </div>
                <table class="table table-sm table-bordered" style="font-size:0.8em; margin:0;">
                    <thead><tr><th style="width:40%;">Field</th><th>Value</th></tr></thead>
                    <tbody>
            `;
            
            Object.entries(data).forEach(([key, val]) => {
                const displayVal = String(val).length > 100 ? String(val).substring(0, 100) + '...' : val;
                html += `<tr><td><strong>${key}</strong></td><td title="${String(val).replace(/"/g, '&quot;')}">${displayVal}</td></tr>`;
            });
            
            html += '</tbody></table>';
            popup.innerHTML = html;
            
            document.body.appendChild(popup);
            
            // Close on mouse leave after delay
            let closeTimeout = null;
            popup.onmouseenter = () => { if (closeTimeout) clearTimeout(closeTimeout); };
            popup.onmouseleave = () => { closeTimeout = setTimeout(() => popup.remove(), 300); };
            btn.onmouseleave = () => { closeTimeout = setTimeout(() => popup.remove(), 300); };
        }

        // Helper function to apply ID from the modal and close it
        function applySuggestionFromModal(rowIdx, misId) {
            const input = document.getElementById(`input-mis-${rowIdx}`);
            if (input) {
                input.value = misId;
                // Highlight the input to show it changed
                input.style.backgroundColor = '#d4edda';
                setTimeout(() => { input.style.backgroundColor = ''; }, 1000);
            }
            // Close modal
            const overlay = document.getElementById('suggestion-modal-overlay');
            if (overlay) overlay.remove();
        }

        // v12.5: Enhanced applyMatches with mode parameter (mis, blaze, all)
        async function applyMatches(mode = 'all') {
            // Check if there's anything to apply based on mode
            const hasMisIds = Object.keys(approvedMatches).some(row => {
                const data = approvedMatches[row];
                return data.mis_ids && data.mis_ids.length > 0;
            });
            const hasBlazeTitles = Object.keys(approvedMatches).some(row => {
                const data = approvedMatches[row];
                return data.blaze_titles && data.blaze_titles.length > 0;
            });
            
            if (mode === 'mis' && !hasMisIds) {
                alert('No MIS IDs approved yet');
                return;
            }
            if (mode === 'blaze' && !hasBlazeTitles) {
                alert('No Blaze Titles selected yet');
                return;
            }
            if (mode === 'all' && !hasMisIds && !hasBlazeTitles) {
                alert('No matches approved yet');
                return;
            }
            
            const btn = event.target;
            btn.disabled = true;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="bi bi-hourglass-split"></i> Applying...';
            
            try {
                let misUpdated = 0, blazeUpdated = 0;
                
                // Apply MIS IDs if mode is 'mis' or 'all'
                if ((mode === 'mis' || mode === 'all') && hasMisIds) {
                    const response = await fetch('/api/mis/apply-matches', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({matches: approvedMatches})
                    });
                    const data = await response.json();
                    if (data.success) {
                        misUpdated = data.updated || 0;
                    } else {
                        throw new Error('MIS ID Apply Error: ' + data.error);
                    }
                }
                
                // Apply Blaze Titles if mode is 'blaze' or 'all'
                if ((mode === 'blaze' || mode === 'all') && hasBlazeTitles) {
                    const blazeResponse = await fetch('/api/mis/apply-blaze-titles', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({matches: approvedMatches})
                    });
                    const blazeData = await blazeResponse.json();
                    if (blazeData.success) {
                        blazeUpdated = blazeData.updated || 0;
                    } else {
                        throw new Error('Blaze Title Apply Error: ' + blazeData.error);
                    }
                }
                
                // Update table visually
                const rowToIndices = {};
                matchesData.forEach((m, idx) => {
                    if (!rowToIndices[m.google_row]) {
                        rowToIndices[m.google_row] = [];
                    }
                    rowToIndices[m.google_row].push(idx);
                });
                
                Object.keys(approvedMatches).forEach(googleRow => {
                    const approvedData = approvedMatches[googleRow];
                    const indices = rowToIndices[googleRow] || [];
                    
                    // Get applied IDs
                    let appliedIds = [];
                    if (approvedData.mis_ids && Array.isArray(approvedData.mis_ids)) {
                        appliedIds = approvedData.mis_ids;
                    } else if (approvedData.mis_id) {
                        appliedIds = [approvedData.mis_id];
                    }
                    
                    const appliedIdDisplay = appliedIds.join(', ');
                    
                    indices.forEach((idx, i) => {
                        const specificId = appliedIds[i] || appliedIdDisplay;
                        
                        if (matchesData[idx]) {
                            if (mode === 'mis' || mode === 'all') {
                                matchesData[idx].current_sheet_id = specificId;
                                matchesData[idx].matched_mis_id = specificId;
                            }
                            if (mode === 'blaze' || mode === 'all') {
                                matchesData[idx].blaze_titles = approvedData.blaze_titles || [];
                            }
                        }
                        
                        const row = document.getElementById('match-row-' + idx);
                        if (row) {
                            row.style.backgroundColor = '#d4edda';
                            row.style.borderLeft = '4px solid #28a745';
                            row.classList.add('row-applied');
                            
                            // Update Current ID column if MIS was applied
                            if ((mode === 'mis' || mode === 'all') && specificId) {
                                const cells = row.getElementsByTagName('td');
                                if (cells.length >= 12) {
                                    const currentIdCell = cells[11];
                                    currentIdCell.innerHTML = `<span style="cursor:pointer; font-weight:bold; padding:2px 6px; border-radius:4px; 
                                        background:#d4edda; color:#155724; border:1px solid #28a745;
                                        text-decoration:underline; display:inline-block; margin:2px;"
                                        onclick="lookupMisId('${specificId}')">${specificId}</span>
                                        <span class="badge bg-success ms-1">Applied</span>`;
                                }
                            }
                            
                            // Update Blaze button indicator if Blaze was applied
                            if ((mode === 'blaze' || mode === 'all') && approvedData.blaze_titles && approvedData.blaze_titles.length > 0) {
                                const blazeBtn = row.querySelector('.btn-blaze');
                                if (blazeBtn) {
                                    blazeBtn.classList.remove('btn-outline-primary');
                                    blazeBtn.classList.add('btn-success');
                                    blazeBtn.innerHTML = '<i class="bi bi-lightning-charge-fill"></i> ' + approvedData.blaze_titles.length;
                                }
                            }
                            
                            // Disable action buttons
                            const approveBtn = row.querySelector('.btn-approve');
                            const rejectBtn = row.querySelector('.btn-reject');
                            if (approveBtn) {
                                approveBtn.disabled = true;
                                approveBtn.style.opacity = '0.5';
                            }
                            if (rejectBtn) {
                                rejectBtn.disabled = true;
                                rejectBtn.style.opacity = '0.5';
                            }
                        }
                    });
                });
                
                // Build result message
                let resultMsg = '[OK] Applied successfully!\n';
                if (mode === 'mis') resultMsg += 'MIS IDs updated: ' + misUpdated + ' rows';
                else if (mode === 'blaze') resultMsg += 'Blaze Titles updated: ' + blazeUpdated + ' rows';
                else resultMsg += 'MIS IDs: ' + misUpdated + ' rows\nBlaze Titles: ' + blazeUpdated + ' rows';
                
                alert(resultMsg);
                
                // Clear applied entries from approvedMatches based on mode
                if (mode === 'all') {
                    approvedMatches = {};
                } else {
                    // Only clear the part that was applied
                    Object.keys(approvedMatches).forEach(row => {
                        if (mode === 'mis') {
                            approvedMatches[row].mis_ids = [];
                            approvedMatches[row].brands = [];
                        } else if (mode === 'blaze') {
                            approvedMatches[row].blaze_titles = [];
                        }
                        // If both are empty, remove the entry
                        const d = approvedMatches[row];
                        if ((!d.mis_ids || d.mis_ids.length === 0) && (!d.blaze_titles || d.blaze_titles.length === 0)) {
                            delete approvedMatches[row];
                        }
                    });
                }
                
                updateApplyButtonsVisibility();
                
            } catch (error) {
                alert('Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }
        
        // v12.5: Update visibility of apply buttons based on approved data
        function updateApplyButtonsVisibility() {
            const container = document.getElementById('apply-btns-container');
            if (!container) return;
            
            const hasMisIds = Object.keys(approvedMatches).some(row => {
                const data = approvedMatches[row];
                return data.mis_ids && data.mis_ids.length > 0;
            });
            const hasBlazeTitles = Object.keys(approvedMatches).some(row => {
                const data = approvedMatches[row];
                return data.blaze_titles && data.blaze_titles.length > 0;
            });
            
            container.style.display = (hasMisIds || hasBlazeTitles) ? 'flex' : 'none';
            container.style.gap = '5px';
            
            // Enable/disable individual buttons
            const misBtn = document.getElementById('apply-mis-btn');
            const blazeBtn = document.getElementById('apply-blaze-btn');
            const allBtn = document.getElementById('apply-all-btn');
            
            if (misBtn) {
                misBtn.disabled = !hasMisIds;
                misBtn.style.opacity = hasMisIds ? '1' : '0.5';
            }
            if (blazeBtn) {
                blazeBtn.disabled = !hasBlazeTitles;
                blazeBtn.style.opacity = hasBlazeTitles ? '1' : '0.5';
            }
            if (allBtn) {
                allBtn.disabled = !(hasMisIds || hasBlazeTitles);
            }
        }

        // ============================================================================
        // v12.5: BLAZE DISCOUNT SELECTION MODAL
        // ============================================================================
        
        // Global state for Blaze modal
        let blazeModalData = {
            rowIdx: null,
            selectedTitles: [],
            allPromotions: [],
            filterType: 'NONE',        // v12.5: NONE, BOGO, B2G1, BULK
            alternateBrands: [],       // v12.5: List of alternate brand names
            libraryStatusFilter: 'All' // v12.5: All, Active, Inactive
        };
        
        async function openBlazeModal(rowIdx) {
            const match = matchesData[rowIdx];
            if (!match) return;
            
            // Initialize modal data
            blazeModalData.rowIdx = rowIdx;
            blazeModalData.filterType = 'NONE';        // v12.5: Reset filter
            blazeModalData.alternateBrands = [];       // v12.5: Reset alternate brands
            blazeModalData.libraryStatusFilter = 'All'; // v12.5: Reset status filter
            
            // Get existing selections from approvedMatches
            const existingData = approvedMatches[match.google_row];
            blazeModalData.selectedTitles = existingData?.blaze_titles ? [...existingData.blaze_titles] : [];
            
            // v12.7: Auto-load existing titles from Google Sheet column
            // Track which titles exist in Blaze and which don't
            blazeModalData.notFoundTitles = [];  // Titles that don't exist in Blaze yet
            
            // Get all Blaze promotions - check if already loaded
            blazeModalData.allPromotions = blazeData.currentRows || [];
            
            // If no Blaze data loaded, try to fetch it
            if (blazeModalData.allPromotions.length === 0) {
                // Show loading indicator
                const loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'blaze-loading-overlay';
                loadingOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    background-color: rgba(0, 0, 0, 0.6); z-index: 9998;
                    display: flex; justify-content: center; align-items: center;
                `;
                loadingOverlay.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 8px; text-align: center;">
                        <div class="spinner-border text-primary" role="status"></div>
                        <p style="margin-top: 15px; margin-bottom: 0;">Loading Blaze Promotions...</p>
                    </div>
                `;
                document.body.appendChild(loadingOverlay);
                
                try {
                    const response = await fetch('/api/blaze/refresh');
                    const data = await response.json();
                    if (data.success && data.promotions) {
                        // Store globally so Blaze tab also has it
                        blazeData.currentRows = data.promotions;
                        blazeModalData.allPromotions = data.promotions;
                        console.log('[BLAZE-MODAL] Fetched ' + data.promotions.length + ' promotions');
                    } else {
                        throw new Error(data.error || 'Failed to fetch Blaze data');
                    }
                } catch (e) {
                    console.error('[BLAZE-MODAL] Error fetching Blaze data:', e);
                    loadingOverlay.remove();
                    alert('Could not load Blaze promotions.\n\nPlease go to the Blaze tab and click "Refresh / Sync Data" first, then try again.\n\nError: ' + e.message);
                    return;
                }
                
                loadingOverlay.remove();
            }
            
            // v12.7: Auto-load existing Blaze titles from Google Sheet column "Blaze Discount Title"
            // Parse the current sheet value (may have newline-separated titles)
            const sheetBlazeTitle = match.blaze_discount_title || '';  // Assuming this field exists
            if (sheetBlazeTitle && sheetBlazeTitle.trim() !== '') {
                const titleLines = sheetBlazeTitle.split('\n').map(t => t.trim()).filter(t => t.length > 0);
                
                titleLines.forEach(title => {
                    // Check if this title exists in Blaze promotions
                    const foundPromo = blazeModalData.allPromotions.find(p => 
                        (p.Name || '').toLowerCase() === title.toLowerCase()
                    );
                    
                    if (foundPromo) {
                        // Title exists in Blaze - add to selected titles if not already there
                        if (!blazeModalData.selectedTitles.includes(title)) {
                            blazeModalData.selectedTitles.push(title);
                        }
                    } else {
                        // Title NOT found in Blaze - track it separately
                        if (!blazeModalData.notFoundTitles.includes(title)) {
                            blazeModalData.notFoundTitles.push(title);
                        }
                        // Also add to selectedTitles so it appears in queue with warning
                        if (!blazeModalData.selectedTitles.includes(title)) {
                            blazeModalData.selectedTitles.push(title);
                        }
                    }
                });
                
                console.log('[BLAZE-MODAL] Auto-loaded from sheet:', titleLines.length, 'titles');
                console.log('[BLAZE-MODAL] Not found in Blaze:', blazeModalData.notFoundTitles.length);
            }
            
            // Generate suggestions based on brand name
            const suggestions = generateBlazeSuggestions(match, blazeModalData.allPromotions);
            
            // Create modal overlay
            const existing = document.getElementById('blaze-modal-overlay');
            if (existing) existing.remove();
            
            const overlay = document.createElement('div');
            overlay.id = 'blaze-modal-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.6); z-index: 9998;
                display: flex; justify-content: center; align-items: center;
            `;
            overlay.onclick = function(e) {
                if(e.target === overlay) overlay.remove();
            };
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #fff; padding: 20px; border-radius: 12px;
                box-shadow: 0 8px 30px rgba(0,0,0,0.3);
                width: 900px; max-width: 95%; max-height: 90vh;
                overflow-y: auto; z-index: 9999; position: relative;
            `;
            
            // Build modal HTML
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 2px solid #0d6efd; padding-bottom: 10px;">
                    <h4 style="margin: 0; color: #0d6efd;"><i class="bi bi-lightning-charge-fill"></i> Select Blaze Discounts</h4>
                    <button class="btn btn-outline-secondary btn-sm" onclick="document.getElementById('blaze-modal-overlay').remove()">
                        <i class="bi bi-x-lg"></i> Close
                    </button>
                </div>
                
                <!-- Current Row Details -->
                <div style="background: #e7f1ff; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <h6 style="margin: 0 0 8px 0; color: #0d6efd;"><i class="bi bi-info-circle"></i> Google Sheet Row ${match.google_row}</h6>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; font-size: 0.9em;">
                        <div><strong>Brand:</strong> ${match.brand || '-'}</div>
                        <div><strong>Discount:</strong> ${match.discount !== null ? match.discount + '%' : '-'}</div>
                        <div><strong>Weekday:</strong> ${match.weekday || '-'}</div>
                        <div style="grid-column: span 2;">
                            <strong>Locations:</strong> ${(match.locations || '-').substring(0, 50)}${(match.locations || '').length > 50 ? '...' : ''}
                            <button class="btn btn-success btn-sm" style="margin-left: 10px; padding: 2px 8px; font-size: 0.85em;" 
                                    onclick="openCreateBlazeModal(${rowIdx})" title="Create new Blaze discount">
                                <i class="bi bi-plus-circle"></i> Create
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Selection Queue (v12.6: Scrollable with counter) -->
                <div style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                    <h6 style="margin: 0 0 8px 0; color: #856404;">
                        <i class="bi bi-list-ol"></i> Selected Queue (<span id="queue-counter">0</span> items) - drag to reorder
                    </h6>
                    <div id="blaze-queue-container" style="display: flex; flex-wrap: wrap; gap: 5px; min-height: 60px; max-height: 120px; overflow-y: auto;">
                        ${blazeModalData.selectedTitles.length === 0 ? '<span style="color: #999; font-style: italic;">No discounts selected</span>' : ''}
                    </div>
                </div>
                
                <!-- Suggested Matches -->
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #198754; padding-bottom: 5px; margin-bottom: 10px;">
                        <h6 style="color: #198754; margin: 0;">
                            <i class="bi bi-stars"></i> Suggested Matches (<span id="suggestion-count">${suggestions.length}</span>)
                        </h6>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <label style="font-size: 0.85em; margin: 0;">Filter:</label>
                            <select id="blaze-suggestion-filter" class="form-select form-select-sm" style="width: auto;" onchange="updateBlazeSuggestions()">
                                <option value="NONE" selected>NONE</option>
                                <option value="BOGO">BOGO</option>
                                <option value="B2G1">B2G1</option>
                                <option value="BULK">BULK</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- Alternate Brand Names -->
                    <div style="margin-bottom: 10px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                            <label style="font-size: 0.85em; margin: 0; white-space: nowrap;">Alt Brand Names:</label>
                            <input type="text" id="blaze-alt-brand-input" class="form-control form-control-sm" 
                                   placeholder="e.g., Stizzy, Stizy" style="flex: 1;"
                                   onkeypress="if(event.key==='Enter'){addAlternateBrand(); event.preventDefault();}">
                            <button class="btn btn-outline-success btn-sm" onclick="addAlternateBrand()" title="Add alternate brand">
                                <i class="bi bi-plus"></i> Add
                            </button>
                        </div>
                        <div id="blaze-alt-brands-container" style="display: flex; flex-wrap: wrap; gap: 5px; min-height: 20px;">
                            <span style="color: #999; font-size: 0.85em; font-style: italic;">No alternate brands added</span>
                        </div>
                    </div>
                    
                    <div id="blaze-suggestions-container" style="max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px;">
                        ${renderBlazePromoList(suggestions, 'suggestion')}
                    </div>
                </div>
                
                <!-- Full Library (v12.6: Collapsible) -->
                <div style="margin-bottom: 15px;">
                    <h6 style="color: #6c757d; border-bottom: 1px solid #6c757d; padding-bottom: 5px; cursor: pointer; display: flex; align-items: center; gap: 8px;" 
                        onclick="toggleFullLibrary()">
                        <span id="library-toggle-icon">‚ñ∂</span>
                        <i class="bi bi-collection"></i> Full Library (${blazeModalData.allPromotions.length})
                    </h6>
                    <div id="full-library-content" style="display: none;">
                        <div style="display: flex; gap: 8px; margin-bottom: 8px; margin-top: 8px; align-items: center;">
                            <input type="text" id="blaze-library-search" class="form-control form-control-sm" 
                                   placeholder="Search by name..." style="flex: 1;" oninput="filterBlazeLibrary()">
                            <label style="font-size: 0.85em; margin: 0; white-space: nowrap;">Status:</label>
                            <select id="blaze-library-status" class="form-select form-select-sm" style="width: auto;" onchange="filterBlazeLibrary()">
                                <option value="All" selected>All</option>
                                <option value="Active">Active</option>
                                <option value="Inactive">Inactive</option>
                            </select>
                        </div>
                        <div id="blaze-library-container" style="max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px;">
                            ${renderBlazePromoList(blazeModalData.allPromotions.slice(0, 50), 'library')}
                        </div>
                        ${blazeModalData.allPromotions.length > 50 ? '<small class="text-muted">Showing first 50. Use search to narrow results.</small>' : ''}
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: flex; justify-content: flex-end; gap: 10px; border-top: 1px solid #dee2e6; padding-top: 15px;">
                    <button class="btn btn-outline-secondary" onclick="document.getElementById('blaze-modal-overlay').remove()">Cancel</button>
                    <button class="btn btn-primary" onclick="confirmBlazeSelection()">
                        <i class="bi bi-check-lg"></i> Confirm Selection
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Render initial queue
            renderBlazeQueue();
        }
        
        function generateBlazeSuggestions(match, allPromos, filterType = 'NONE', alternateBrands = []) {
            if (!allPromos || allPromos.length === 0) return [];
            
            const brand = (match.brand || '').toLowerCase();
            // Combine primary brand words with alternate brands
            let brandWords = brand.split(/[\s,]+/).filter(w => w.length > 2);
            alternateBrands.forEach(alt => {
                const altWords = alt.toLowerCase().split(/[\s,]+/).filter(w => w.length > 2);
                brandWords = brandWords.concat(altWords);
            });
            brandWords = [...new Set(brandWords)]; // Remove duplicates
            
            // Filter type patterns
            const bulkPatterns = [
                /bulk/i,
                /mix\s*&\s*match/i,
                /mix\s+and\s+match/i,
                /\d+\s*for\s*\$?\d+/i,  // "2 for $40", "3 for 60"
                /\d+\/\$?\d+/i           // "2/$40", "4/100"
            ];
            
            // Score each promotion
            const scored = allPromos.map(promo => {
                const name = (promo.Name || '').toLowerCase();
                let score = 0;
                let matchesFilter = true;
                let hasBrandMatch = false;  // v12.6: Track if brand matches
                
                // v12.6 FIX: Check for brand match FIRST
                // Check for brand word matches in title
                brandWords.forEach(word => {
                    if (name.includes(word)) {
                        score += 30;
                        hasBrandMatch = true;
                    }
                });
                
                // Exact brand name match
                if (name.includes(brand)) {
                    score += 50;
                    hasBrandMatch = true;
                }
                
                // Check alternate brands for exact match too
                alternateBrands.forEach(alt => {
                    if (name.includes(alt.toLowerCase())) {
                        score += 50;
                        hasBrandMatch = true;
                    }
                });
                
                // v12.6 FIX: If no brand match at all, return score 0 immediately
                if (!hasBrandMatch) {
                    return { promo, score: 0 };
                }
                
                // Apply filter type (ONLY after confirming brand match)
                if (filterType === 'BOGO') {
                    matchesFilter = name.includes('bogo');
                } else if (filterType === 'B2G1') {
                    matchesFilter = name.includes('b2g1');
                } else if (filterType === 'BULK') {
                    matchesFilter = bulkPatterns.some(pattern => pattern.test(promo.Name || ''));
                }
                // NONE = no additional filter (but still requires brand match)
                
                if (!matchesFilter) {
                    return { promo, score: 0 };
                }
                
                // Active status bonus
                if (promo.Status === 'Active') {
                    score += 10;
                }
                
                return { promo, score };
            });
            
            // Filter (require brand match) and sort by score - NO LIMIT
            return scored
                .filter(s => s.score > 0)
                .sort((a, b) => b.score - a.score)
                .map(s => s.promo);
        }
        
        function renderBlazePromoList(promos, type) {
            if (!promos || promos.length === 0) {
                return '<div style="padding: 10px; text-align: center; color: #999;">No promotions found</div>';
            }
            
            return promos.map(promo => {
                const isSelected = blazeModalData.selectedTitles.includes(promo.Name);
                const statusColor = promo.Status === 'Active' ? '#198754' : '#dc3545';
                const bgColor = isSelected ? '#d4edda' : '#fff';
                
                // v12.7: Add View button for each promo
                return `
                    <div style="padding: 8px 12px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 10px; background: ${bgColor};"
                         onmouseover="this.style.background='${isSelected ? '#c3e6cb' : '#f8f9fa'}'"
                         onmouseout="this.style.background='${bgColor}'">
                        <input type="checkbox" ${isSelected ? 'checked' : ''} style="cursor: pointer;" 
                               onclick="toggleBlazeSelection('${escapeHtml(promo.Name)}')">
                        <div style="flex: 1; min-width: 0; cursor: pointer;" onclick="toggleBlazeSelection('${escapeHtml(promo.Name)}')">
                            <div style="font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${escapeHtml(promo.Name)}">
                                ${escapeHtml(promo.Name)}
                            </div>
                            <div style="font-size: 0.8em; color: #6c757d;">
                                <span style="color: ${statusColor};">${promo.Status}</span>
                                ${promo['Discount Value'] ? ' | ' + promo['Discount Value'] + ' ' + (promo['Discount Value Type'] || '') : ''}
                                ${promo['Start Date'] ? ' | ' + promo['Start Date'] : ''}
                            </div>
                        </div>
                        <button class="btn btn-info btn-sm" style="padding: 2px 6px; font-size: 0.75em; white-space: nowrap;" 
                                onclick="event.stopPropagation(); showDetailModal(${JSON.stringify(promo).replace(/"/g, '&quot;')}, true)">
                            <i class="bi bi-eye"></i> View
                        </button>
                    </div>
                `;
            }).join('');
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }
        
        function toggleBlazeSelection(promoName) {
            const idx = blazeModalData.selectedTitles.indexOf(promoName);
            if (idx >= 0) {
                blazeModalData.selectedTitles.splice(idx, 1);
            } else {
                blazeModalData.selectedTitles.push(promoName);
            }
            
            // Re-render lists
            renderBlazeQueue();
            
            // v12.5: Use current filter settings for suggestions
            const match = matchesData[blazeModalData.rowIdx];
            const suggestions = generateBlazeSuggestions(
                match, 
                blazeModalData.allPromotions,
                blazeModalData.filterType,
                blazeModalData.alternateBrands
            );
            document.getElementById('blaze-suggestions-container').innerHTML = renderBlazePromoList(suggestions, 'suggestion');
            
            // Update count
            const countEl = document.getElementById('suggestion-count');
            if (countEl) countEl.textContent = suggestions.length;
            
            // Re-render library with current search and status filter
            filterBlazeLibrary();
        }
        
        function renderBlazeQueue() {
            const container = document.getElementById('blaze-queue-container');
            if (!container) return;
            
            // v12.6: Update counter
            const counterSpan = document.getElementById('queue-counter');
            if (counterSpan) {
                counterSpan.textContent = blazeModalData.selectedTitles.length;
            }
            
            if (blazeModalData.selectedTitles.length === 0) {
                container.innerHTML = '<span style="color: #999; font-style: italic;">No discounts selected</span>';
                return;
            }
            
            // v12.7: Render items with different styling for not-found titles
            container.innerHTML = blazeModalData.selectedTitles.map((title, idx) => {
                const isNotFound = blazeModalData.notFoundTitles.includes(title);
                
                // Find promo to get View button
                const promo = blazeModalData.allPromotions.find(p => 
                    (p.Name || '').toLowerCase() === title.toLowerCase()
                );
                
                if (isNotFound) {
                    // Not found in Blaze - show warning with Create button
                    return `
                        <div class="blaze-queue-item" data-idx="${idx}" data-not-found="true"
                             style="background: #f8f9fa; border: 1px solid #6c757d; border-radius: 4px; padding: 4px 8px; 
                                    display: flex; align-items: center; gap: 5px; opacity: 0.7;">
                            <span style="font-weight: bold; color: #6c757d;">${idx + 1}.</span>
                            <i class="bi bi-exclamation-triangle" style="color: #ffc107;" title="Not found in Blaze"></i>
                            <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; color: #6c757d;" title="${escapeHtml(title)}">
                                ${escapeHtml(title)}
                            </span>
                            <button class="btn btn-success btn-sm" style="padding: 1px 4px; font-size: 0.75em;" 
                                    onclick="event.stopPropagation(); createBlazeDiscountFromQueue('${escapeHtml(title)}')">
                                <i class="bi bi-plus-circle"></i> Create
                            </button>
                            <button class="btn btn-sm" style="padding: 0 4px; color: #dc3545;" onclick="event.stopPropagation(); removeFromBlazeQueue(${idx})">
                                <i class="bi bi-x"></i>
                            </button>
                        </div>
                    `;
                } else {
                    // Found in Blaze - normal item with drag and View button
                    return `
                        <div class="blaze-queue-item" draggable="true" data-idx="${idx}"
                             style="background: #fff; border: 1px solid #ffc107; border-radius: 4px; padding: 4px 8px; 
                                    display: flex; align-items: center; gap: 5px; cursor: move;">
                            <span style="font-weight: bold; color: #856404;">${idx + 1}.</span>
                            <span style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 120px;" title="${escapeHtml(title)}">
                                ${escapeHtml(title)}
                            </span>
                            ${promo ? `
                                <button class="btn btn-info btn-sm" style="padding: 1px 4px; font-size: 0.75em;" 
                                        onclick="event.stopPropagation(); showDetailModal(${JSON.stringify(promo).replace(/"/g, '&quot;')}, true)">
                                    <i class="bi bi-eye"></i> View
                                </button>
                            ` : ''}
                            <button class="btn btn-sm" style="padding: 0 4px; color: #dc3545;" onclick="event.stopPropagation(); removeFromBlazeQueue(${idx})">
                                <i class="bi bi-x"></i>
                            </button>
                        </div>
                    `;
                }
            }).join('');
            
            // Add drag-and-drop handlers only to items that are found (draggable)
            const items = container.querySelectorAll('.blaze-queue-item[draggable="true"]');
            items.forEach(item => {
                item.addEventListener('dragstart', handleQueueDragStart);
                item.addEventListener('dragover', handleQueueDragOver);
                item.addEventListener('drop', handleQueueDrop);
                item.addEventListener('dragend', handleQueueDragEnd);
            });
        }
        
        let queueDraggedItem = null;
        
        function handleQueueDragStart(e) {
            queueDraggedItem = this;
            this.style.opacity = '0.5';
        }
        
        function handleQueueDragOver(e) {
            e.preventDefault();
            this.style.borderLeft = '3px solid #0d6efd';
        }
        
        function handleQueueDrop(e) {
            e.preventDefault();
            this.style.borderLeft = '';
            
            if (queueDraggedItem === this) return;
            
            const fromIdx = parseInt(queueDraggedItem.dataset.idx);
            const toIdx = parseInt(this.dataset.idx);
            
            // Reorder array
            const [removed] = blazeModalData.selectedTitles.splice(fromIdx, 1);
            blazeModalData.selectedTitles.splice(toIdx, 0, removed);
            
            renderBlazeQueue();
        }
        
        function handleQueueDragEnd(e) {
            this.style.opacity = '1';
            document.querySelectorAll('.blaze-queue-item').forEach(item => {
                item.style.borderLeft = '';
            });
        }
        
        function removeFromBlazeQueue(idx) {
            blazeModalData.selectedTitles.splice(idx, 1);
            renderBlazeQueue();
            
            // v12.5: Use current filter settings for suggestions
            const match = matchesData[blazeModalData.rowIdx];
            const suggestions = generateBlazeSuggestions(
                match, 
                blazeModalData.allPromotions,
                blazeModalData.filterType,
                blazeModalData.alternateBrands
            );
            document.getElementById('blaze-suggestions-container').innerHTML = renderBlazePromoList(suggestions, 'suggestion');
            
            // Update count
            const countEl = document.getElementById('suggestion-count');
            if (countEl) countEl.textContent = suggestions.length;
            
            filterBlazeLibrary();
        }
        
        function filterBlazeLibrary() {
            const container = document.getElementById('blaze-library-container');
            if (!container) return;
            
            const searchTerm = (document.getElementById('blaze-library-search')?.value || '').toLowerCase();
            const statusFilter = document.getElementById('blaze-library-status')?.value || 'All';
            
            blazeModalData.libraryStatusFilter = statusFilter;
            
            let filtered = blazeModalData.allPromotions;
            
            // Apply search term filter
            if (searchTerm) {
                filtered = filtered.filter(p => 
                    (p.Name || '').toLowerCase().includes(searchTerm)
                );
            }
            
            // Apply status filter
            if (statusFilter !== 'All') {
                filtered = filtered.filter(p => p.Status === statusFilter);
            }
            
            container.innerHTML = renderBlazePromoList(filtered.slice(0, 50), 'library');
        }
        
        // v12.5: Add alternate brand name
        function addAlternateBrand() {
            const input = document.getElementById('blaze-alt-brand-input');
            if (!input) return;
            
            const value = input.value.trim();
            if (!value) return;
            
            // Check for duplicates
            if (blazeModalData.alternateBrands.includes(value)) {
                input.value = '';
                return;
            }
            
            blazeModalData.alternateBrands.push(value);
            input.value = '';
            
            renderAlternateBrands();
            updateBlazeSuggestions();
        }
        
        // v12.5: Remove alternate brand name
        function removeAlternateBrand(idx) {
            blazeModalData.alternateBrands.splice(idx, 1);
            renderAlternateBrands();
            updateBlazeSuggestions();
        }
        
        // v12.5: Render alternate brands list
        function renderAlternateBrands() {
            const container = document.getElementById('blaze-alt-brands-container');
            if (!container) return;
            
            if (blazeModalData.alternateBrands.length === 0) {
                container.innerHTML = '<span style="color: #999; font-size: 0.85em; font-style: italic;">No alternate brands added</span>';
                return;
            }
            
            container.innerHTML = blazeModalData.alternateBrands.map((brand, idx) => `
                <span style="background: #e7f1ff; border: 1px solid #0d6efd; border-radius: 15px; padding: 2px 10px; 
                             font-size: 0.85em; display: inline-flex; align-items: center; gap: 5px;">
                    ${escapeHtml(brand)}
                    <button class="btn btn-sm" style="padding: 0 2px; color: #dc3545; line-height: 1;" 
                            onclick="removeAlternateBrand(${idx})" title="Remove">
                        <i class="bi bi-x"></i>
                    </button>
                </span>
            `).join('');
        }
        
        // v12.5: Update suggestions based on filter and alternate brands
        function updateBlazeSuggestions() {
            const filterSelect = document.getElementById('blaze-suggestion-filter');
            const filterType = filterSelect?.value || 'NONE';
            blazeModalData.filterType = filterType;
            
            const match = matchesData[blazeModalData.rowIdx];
            if (!match) return;
            
            const suggestions = generateBlazeSuggestions(
                match, 
                blazeModalData.allPromotions, 
                filterType, 
                blazeModalData.alternateBrands
            );
            
            // Update count
            const countEl = document.getElementById('suggestion-count');
            if (countEl) countEl.textContent = suggestions.length;
            
            // Update list
            document.getElementById('blaze-suggestions-container').innerHTML = renderBlazePromoList(suggestions, 'suggestion');
        }
        
        function confirmBlazeSelection() {
            const match = matchesData[blazeModalData.rowIdx];
            if (!match) return;
            
            // Update approvedMatches
            if (!approvedMatches[match.google_row]) {
                approvedMatches[match.google_row] = {
                    mis_ids: [],
                    brands: [],
                    section: match.section || 'weekly',
                    blaze_titles: [],
                    blaze_titles_not_found: []  // v12.7: Track not-found titles
                };
            }
            
            approvedMatches[match.google_row].blaze_titles = [...blazeModalData.selectedTitles];
            approvedMatches[match.google_row].blaze_titles_not_found = [...blazeModalData.notFoundTitles];  // v12.7
            
            // Update the Blaze button in the table
            const row = document.getElementById('match-row-' + blazeModalData.rowIdx);
            if (row) {
                const blazeBtn = row.querySelector('.btn-blaze');
                if (blazeBtn) {
                    if (blazeModalData.selectedTitles.length > 0) {
                        blazeBtn.classList.remove('btn-outline-primary');
                        blazeBtn.classList.add('btn-primary');
                        blazeBtn.innerHTML = '<i class="bi bi-lightning-charge-fill"></i> ' + blazeModalData.selectedTitles.length;
                        blazeBtn.title = blazeModalData.selectedTitles.join('\\n');
                    } else {
                        blazeBtn.classList.remove('btn-primary');
                        blazeBtn.classList.add('btn-outline-primary');
                        blazeBtn.innerHTML = '<i class="bi bi-lightning-charge"></i>';
                        blazeBtn.title = 'Select Blaze Discount';
                    }
                }
            }
            
            // Update visibility of apply buttons
            updateApplyButtonsVisibility();
            
            // Close modal
            document.getElementById('blaze-modal-overlay').remove();
        }
        
        // v12.6: Toggle Full Library section visibility
        function toggleFullLibrary() {
            const content = document.getElementById('full-library-content');
            const icon = document.getElementById('library-toggle-icon');
            
            if (!content || !icon) return;
            
            const isCurrentlyVisible = content.style.display !== 'none';
            content.style.display = isCurrentlyVisible ? 'none' : 'block';
            icon.textContent = isCurrentlyVisible ? '‚ñ∂' : '‚ñº';
        }
        
        // v12.7: Create Blaze Discount Modal and Automation
        let createBlazeModalData = {
            rowIdx: null,
            suggestedTitle: '',
            typedTitle: '',
            canUndo: false
        };
        
        function openCreateBlazeModal(rowIdx) {
            const match = matchesData[rowIdx];
            if (!match) return;
            
            // Store for later use
            createBlazeModalData.rowIdx = rowIdx;
            createBlazeModalData.suggestedTitle = '';
            createBlazeModalData.typedTitle = '';
            createBlazeModalData.canUndo = false;
            
            // Generate suggested title variations
            const brand = match.brand || '';
            const discount = match.discount !== null ? match.discount + '%' : '';
            const weekday = match.weekday || '';
            
            const suggestions = [
                `${brand} ${discount} ${weekday}`.trim(),
                `${brand} ${discount} Off ${weekday}`.trim(),
                `${weekday} ${brand} ${discount}`.trim(),
                `${discount} Off ${brand} - ${weekday}`.trim()
            ].filter(s => s.length > 0);
            
            // Auto-detect discount type from pattern
            const dealInfo = (match.deal_info || '').toLowerCase();
            let detectedType = '';
            if (dealInfo.includes('bogo') || dealInfo.includes('buy') && dealInfo.includes('get')) {
                detectedType = 'BOGO';
            } else if (dealInfo.includes('bundle')) {
                detectedType = 'Bundle';
            } else if (dealInfo.includes('bulk') || dealInfo.includes('mix')) {
                detectedType = 'BULK (likely Global Product Discount)';
            } else {
                detectedType = 'Unknown (manual selection required)';
            }
            
            // Create modal
            const existing = document.getElementById('create-blaze-overlay');
            if (existing) existing.remove();
            
            const overlay = document.createElement('div');
            overlay.id = 'create-blaze-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background-color: rgba(0, 0, 0, 0.7); z-index: 10000;
                display: flex; justify-content: center; align-items: center;
            `;
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: #fff; padding: 25px; border-radius: 12px;
                box-shadow: 0 8px 30px rgba(0,0,0,0.4);
                width: 600px; max-width: 95%;
            `;
            
            const currentDate = new Date().toLocaleString();
            
            modal.innerHTML = `
                <h4 style="margin: 0 0 15px 0; color: #198754;">
                    <i class="bi bi-plus-circle-fill"></i> Create Blaze Discount
                </h4>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">Title:</label>
                    <div style="position: relative;">
                        <input type="text" id="create-blaze-title" class="form-control" placeholder="Enter discount title..."
                               onfocus="showTitleSuggestions()"
                               oninput="handleTitleInput(event)"
                               onblur="setTimeout(() => hideTitleSuggestions(), 150)">
                        <div id="title-suggestions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; 
                                background: white; border: 1px solid #ccc; border-top: none; max-height: 150px; overflow-y: auto; z-index: 1000;">
                            ${suggestions.map(s => `
                                <div style="padding: 8px; cursor: pointer; border-bottom: 1px solid #eee;"
                                     onmouseover="this.style.background='#f8f9fa'"
                                     onmouseout="this.style.background='white'"
                                     onclick="selectTitleSuggestion('${escapeHtml(s)}')">
                                    ${escapeHtml(s)}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <button id="title-undo-btn" class="btn btn-sm btn-outline-warning mt-1" style="display: none;" onclick="undoTitleSelection()">
                        <i class="bi bi-arrow-counterclockwise"></i> Undo
                    </button>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">Discount Type:</label>
                    <select id="create-blaze-type" class="form-select">
                        <option value="">-- Select Type --</option>
                        <option value="Bundle">Bundle</option>
                        <option value="BOGO">BOGO</option>
                        <option value="Global Product Discount">Global Product Discount</option>
                        <option value="Collection Discount">Collection Discount</option>
                    </select>
                    <small style="color: #6c757d; font-style: italic;">Suggested: ${detectedType}</small>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">Description:</label>
                    <textarea id="create-blaze-description" class="form-control" rows="4" placeholder="Enter description..."></textarea>
                    <button class="btn btn-sm btn-outline-secondary mt-1" onclick="autofillDescription()">
                        <i class="bi bi-magic"></i> Autofill
                    </button>
                </div>
                
                <div style="display: flex; justify-content: flex-end; gap: 10px; border-top: 1px solid #dee2e6; padding-top: 15px;">
                    <button class="btn btn-outline-secondary" onclick="document.getElementById('create-blaze-overlay').remove()">Cancel</button>
                    <button class="btn btn-success" onclick="executeCreateBlazeAutomation()">
                        <i class="bi bi-check-lg"></i> Create in Blaze
                    </button>
                </div>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            // Close on outside click
            overlay.onclick = function(e) {
                if (e.target === overlay) overlay.remove();
            };
        }
        
        function createBlazeDiscountFromQueue(title) {
            // Find the row index and open create modal with pre-filled title
            const rowIdx = createBlazeModalData.rowIdx || blazeModalData.rowIdx;
            if (rowIdx === null) return;
            
            openCreateBlazeModal(rowIdx);
            
            // Pre-fill title after modal opens
            setTimeout(() => {
                const titleInput = document.getElementById('create-blaze-title');
                if (titleInput) {
                    titleInput.value = title;
                    createBlazeModalData.typedTitle = title;
                }
            }, 100);
        }
        
        function showTitleSuggestions() {
            const dropdown = document.getElementById('title-suggestions');
            if (dropdown) dropdown.style.display = 'block';
        }
        
        function hideTitleSuggestions() {
            const dropdown = document.getElementById('title-suggestions');
            if (dropdown) dropdown.style.display = 'none';
        }
        
        function handleTitleInput(event) {
            createBlazeModalData.typedTitle = event.target.value;
            // Hide undo button if user types new text
            if (createBlazeModalData.canUndo && event.target.value !== createBlazeModalData.suggestedTitle) {
                createBlazeModalData.canUndo = false;
                const undoBtn = document.getElementById('title-undo-btn');
                if (undoBtn) undoBtn.style.display = 'none';
            }
        }
        
        function selectTitleSuggestion(suggestion) {
            const titleInput = document.getElementById('create-blaze-title');
            const undoBtn = document.getElementById('title-undo-btn');
            const dropdown = document.getElementById('title-suggestions');
            
            if (titleInput) {
                titleInput.value = suggestion;
                createBlazeModalData.suggestedTitle = suggestion;
                createBlazeModalData.canUndo = true;
                
                if (undoBtn) undoBtn.style.display = 'inline-block';
            }
            
            if (dropdown) dropdown.style.display = 'none';
        }
        
        function undoTitleSelection() {
            const titleInput = document.getElementById('create-blaze-title');
            const undoBtn = document.getElementById('title-undo-btn');
            
            if (titleInput) {
                titleInput.value = createBlazeModalData.typedTitle;
                createBlazeModalData.canUndo = false;
                
                if (undoBtn) undoBtn.style.display = 'none';
            }
        }
        
        function autofillDescription() {
            const match = matchesData[createBlazeModalData.rowIdx];
            if (!match) return;
            
            const descArea = document.getElementById('create-blaze-description');
            if (!descArea) return;
            
            const brand = match.brand || '-';
            const discountType = document.getElementById('create-blaze-type')?.value || 'Not Selected';
            const discountValue = match.discount !== null ? match.discount + '%' : '-';
            const locations = match.locations || '-';
            const creationDate = new Date().toLocaleString();
            
            descArea.value = `Brand: ${brand}\nDiscount Type: ${discountType}\nDiscount Value: ${discountValue}\nLocations: ${locations}\nCreation Date + Time: ${creationDate}`;
        }
        
        async function executeCreateBlazeAutomation() {
            const title = document.getElementById('create-blaze-title')?.value.trim();
            const type = document.getElementById('create-blaze-type')?.value;
            const description = document.getElementById('create-blaze-description')?.value.trim();
            
            if (!title) {
                alert('Please enter a title');
                return;
            }
            
            if (!type) {
                alert('Please select a discount type');
                return;
            }
            
            // Check for duplicate names in Blaze
            const existingPromo = blazeModalData.allPromotions.find(p => 
                (p.Name || '').toLowerCase() === title.toLowerCase()
            );
            
            if (existingPromo) {
                const userChoice = confirm(
                    `A discount with the name "${title}" already exists in Blaze.\n\n` +
                    `Do you want to:\n` +
                    `- OK: Select the existing discount\n` +
                    `- Cancel: Continue creating with a modified name`
                );
                
                if (userChoice) {
                    // User chose to use existing - add it to queue
                    if (!blazeModalData.selectedTitles.includes(title)) {
                        blazeModalData.selectedTitles.push(title);
                        renderBlazeQueue();
                    }
                    document.getElementById('create-blaze-overlay').remove();
                    return;
                } else {
                    // User wants to create anyway - ask for note
                    const note = prompt('Enter a note to append to the title (e.g., "v2", "2025"):', 'v2');
                    if (note) {
                        document.getElementById('create-blaze-title').value = `${title} ${note}`;
                        return; // Don't proceed, let user review and click Create again
                    } else {
                        return; // User cancelled
                    }
                }
            }
            
            // Proceed with automation
            console.log('[CREATE-BLAZE] Starting automation...');
            console.log('[CREATE-BLAZE] Title:', title);
            console.log('[CREATE-BLAZE] Type:', type);
            console.log('[CREATE-BLAZE] Description:', description);
            
            try {
                // Call backend to execute Blaze automation
                const response = await fetch('/api/blaze/create-discount', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ title, type, description })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert('Discount creation started in Blaze!\n\nThe title has been filled in. Please complete the remaining fields manually.');
                    document.getElementById('create-blaze-overlay').remove();
                } else {
                    alert('Error starting automation: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('[CREATE-BLAZE] Error:', error);
                alert('Error communicating with server: ' + error.message);
            }
        }

        function displayAuditResults(resultsObj) {
            const containerId = 'audit-results';
            const titles = {'weekly': ' WEEKLY DEALS', 'monthly': ' MONTHLY DEALS', 'sale': ' SALE DEALS'};
            
            // Count items per section
            const counts = {
                weekly: (resultsObj.weekly || []).length,
                monthly: (resultsObj.monthly || []).length,
                sale: (resultsObj.sale || []).length
            };
            
            // Header
            let headerHtml = '<h3>Audit Results</h3>';
            headerHtml += generateDealTypeTabsHTML(containerId, counts);
            
            // Build content for each section
            const sectionContents = {};
            
            ['weekly', 'monthly', 'sale'].forEach(key => {
                const results = resultsObj[key] || [];
                let sectionHtml = '';
                
                sectionHtml += `<h5 class="mt-2 border-bottom pb-2">${titles[key]} (${results.length} Items)</h5>`;
                
                if (results.length === 0) {
                    sectionHtml += '<p class="text-muted">No data.</p>';
                } else {
                    sectionHtml += '<div class="scrollable-table-container" style="max-height:500px;">';
                    sectionHtml += '<table class="table table-sm"><thead>';
                    sectionHtml += '<tr><th>Row</th><th>MIS ID</th><th>Brand</th><th>Weekday</th><th>Notes</th><th>Deal Info</th><th>Discount</th><th>Vendor %</th><th>Locations</th><th>Categories</th><th>Status</th><th>Issues</th><th>Action</th></tr>';
                    sectionHtml += '</thead><tbody>';
                    
                    const renderedGroups = new Set();
                    
                    results.forEach((r, idx) => {
                        const isGrouped = r.multi_day_group !== null && r.multi_day_group !== undefined;
                        const isFirstInGroup = isGrouped && r.multi_day_group.is_first;
                        const groupId = isGrouped ? r.multi_day_group.group_id : null;
                        
                        if (isGrouped && !isFirstInGroup) return;
                        
                        if (isGrouped && isFirstInGroup) {
                            renderedGroups.add(groupId);
                            const groupData = r.multi_day_group;
                            const hasMissingWeekday = groupData.has_missing_weekday;
                            const warningIcon = hasMissingWeekday ? '<span class="weekday-missing-icon">[!] [EMOJI]√É‚Äö√Ç¬è </span>' : '';
                            
                            sectionHtml += `<tr class="group-header-row" onclick="toggleGroup('${groupId}')" title="Click to collapse/expand">`;
                            sectionHtml += `<td colspan="13">`;
                            sectionHtml += `<span class="group-toggle-icon" id="toggle-${groupId}">->[EMOJI]</span>`;
                            sectionHtml += `${warningIcon}<strong>${r.brand}</strong>`;
                            sectionHtml += `<span class="multi-day-badge">&#x3030;[EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è ${groupData.total_days}-Day Deal</span>`;
                            sectionHtml += ` (Rows: ${groupData.row_numbers.join(', ')})`;
                            sectionHtml += `</td></tr>`;
                            
                            const groupResults = results.filter(gr => 
                                gr.multi_day_group && gr.multi_day_group.group_id === groupId
                            );
                            
                            groupResults.forEach((gr) => {
                                const grIdx = results.indexOf(gr);
                                sectionHtml += renderAuditRow(gr, grIdx + key, groupId, hasMissingWeekday);
                            });
                            
                        } else {
                            sectionHtml += renderAuditRow(r, idx + key, null, false);
                        }
                    });
                    
                    sectionHtml += '</tbody></table></div>';
                }
                
                sectionContents[key] = sectionHtml;
            });
            
            // Build the "All Deals" view (stacked)
            let allHtml = sectionContents.weekly + sectionContents.monthly + sectionContents.sale;
            
            // Build final HTML with containers
            let finalHtml = headerHtml;
            finalHtml += `<div id="${containerId}-weekly" class="deal-type-content">${sectionContents.weekly}</div>`;
            finalHtml += `<div id="${containerId}-monthly" class="deal-type-content">${sectionContents.monthly}</div>`;
            finalHtml += `<div id="${containerId}-sale" class="deal-type-content">${sectionContents.sale}</div>`;
            finalHtml += `<div id="${containerId}-all" class="deal-type-content active" style="display:block;">${allHtml}</div>`;
            
            document.getElementById('audit-results').innerHTML = finalHtml;
        }

// ============================================
// SEARCH ENHANCEMENT: Click-to-Search
// ============================================
function setupSearchEnhancements() {
    // Find all search inputs
    document.querySelectorAll('input[type="search"]').forEach(searchInput => {
        // Check if there's a button/icon next to it
        const parent = searchInput.parentElement;
        
        // Look for magnifying glass icon (common patterns)
        const searchIcon = parent.querySelector('.bi-search, .fa-search, [class*="search-icon"]');
        
        if (searchIcon) {
            searchIcon.style.cursor = 'pointer';
            searchIcon.addEventListener('click', function() {
                // Trigger ENTER key on the search input
                const enterEvent = new KeyboardEvent('keypress', {
                    key: 'Enter',
                    code: 'Enter',
                    keyCode: 13,
                    which: 13,
                    bubbles: true
                });
                searchInput.dispatchEvent(enterEvent);
                
                // Also trigger change event for DataTables
                searchInput.dispatchEvent(new Event('input', { bubbles: true }));
            });
        }
        
        // Add ENTER key handler if not already present
        if (!searchInput.dataset.enterHandlerAdded) {
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // Trigger search
                    this.dispatchEvent(new Event('input', { bubbles: true }));
                }
            });
            searchInput.dataset.enterHandlerAdded = 'true';
        }
    });
    
    // Find all buttons near search inputs
    document.querySelectorAll('button').forEach(btn => {
        const btnText = btn.textContent.trim().toLowerCase();
        if (btnText.includes('search') || btnText.includes('filter')) {
            const nearbySearch = btn.parentElement?.querySelector('input[type="search"]') ||
                                btn.closest('.filter-group')?.querySelector('input[type="search"]');
            
            if (nearbySearch) {
                btn.style.cursor = 'pointer';
                btn.addEventListener('click', function() {
                    const enterEvent = new KeyboardEvent('keypress', {
                        key: 'Enter',
                        code: 'Enter',
                        keyCode: 13,
                        which: 13,
                        bubbles: true
                    });
                    nearbySearch.dispatchEvent(enterEvent);
                    nearbySearch.dispatchEvent(new Event('input', { bubbles: true }));
                });
            }
}
    });
}

// ============================================
        // AUTO-LOAD CREDENTIALS
        // ============================================
        async function autoLoadCredentials() {
            try {
                const response = await fetch('/api/get-credentials');
                const data = await response.json();
                
                if (data.success && data.credentials) {
                    const creds = data.credentials;
                    
                    // Auto-fill MIS credentials
                    if (creds.mis) {
                        document.getElementById('mis-username').value = creds.mis.username || '';
                        document.getElementById('mis-password').value = creds.mis.password || '';
                        console.log('[AUTO-FILL] MIS credentials loaded');
                    }
                    
                    // Auto-fill Blaze credentials
                    if (creds.blaze) {
                        document.getElementById('blaze-email').value = creds.blaze.email || '';
                        document.getElementById('blaze-password').value = creds.blaze.password || '';
                        console.log('[AUTO-FILL] Blaze credentials loaded');
                    }
                    
                    // Auto-fill and load Google Sheet
                    if (creds.google_sheet && creds.google_sheet.default_url) {
                        const urlInput = document.getElementById('mis-sheet-url');
                        urlInput.value = creds.google_sheet.default_url;
                        console.log('[AUTO-FILL] Google Sheet URL loaded');
                        
                        // Auto-trigger load tabs
                        setTimeout(function() {
                            autoLoadSheetTabs();
                        }, 2000); // Wait 2 seconds after auth
                    }
                }
            } catch (error) {
                console.log('[INFO] No credentials config found (this is optional)');
            }
        }
        
        async function autoLoadSheetTabs() {
            const urlInput = document.getElementById('mis-sheet-url');
            const url = urlInput.value;
            
            if (!url) return;
            
            console.log('[AUTO-LOAD] Loading sheet tabs...');
            
            try {
                const response = await fetch('/api/mis/load-sheet', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({url: url})
                });
                const data = await response.json();
                
                if (data.success) {
                    misData.allLoadedTabs = data.tabs;
                    // v12.1: Store spreadsheet ID globally for goToSheetRow
                    window.globalSpreadsheetId = data.spreadsheet_id || '';
                    renderTabOptions();
                    if (document.getElementById('mis-tab').options.length > 0) {
                        misData.tabName = document.getElementById('mis-tab').value;
                    }
                    console.log('[AUTO-LOAD] Sheet tabs loaded successfully');
                } else {
                    console.log('[AUTO-LOAD] Failed to load sheet tabs:', data.error);
                }
            } catch (error) {
                console.log('[AUTO-LOAD] Error loading sheet tabs:', error.message);
            }
        }

async function autoAuthenticateGoogle() {
            console.log('[AUTO-AUTH] Attempting Google Sheets authentication...');
            
            try {
                // Wait for browser to be ready
                let attempts = 0;
                while (!document.getElementById('browser-ready-text').textContent.includes('Ready') && attempts < 10) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    attempts++;
                }
                
                const response = await fetch('/api/auth', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('auth-status').innerHTML = '<p class="alert alert-success">[OK] Auto-authenticated successfully!</p>';
                    console.log('[AUTO-AUTH] Google Sheets authenticated');
                } else {
                    document.getElementById('auth-status').innerHTML = '<p class="alert alert-warning">[!] [EMOJI]√É‚Äö√Ç¬è  Auto-auth failed. Please authenticate manually.</p>';
                    console.log('[AUTO-AUTH] Failed:', data.error);
                }
            } catch (error) {
                console.log('[AUTO-AUTH] Error:', error.message);
            }
        }

        // ============================================
        // DATATABLE SEARCH: Add Search Button
        // ============================================
        function enhanceDataTableSearch() {
            // Wait for DataTable to exist
            if ($.fn.DataTable && $.fn.DataTable.isDataTable('#promotionsTable')) {
                const table = $('#promotionsTable').DataTable();
                
                // Find the DataTables search input (auto-generated)
                const dtSearch = $('.dataTables_filter input[type="search"]');
                
                if (dtSearch.length > 0) {
                    // Check if button already exists
                    if (!dtSearch.next('.search-trigger-btn').length) {
                        // Create search button
                        const searchBtn = $('<button>')
                            .addClass('btn btn-sm btn-primary search-trigger-btn')
                            .html('<i class="bi bi-search"></i>')
                            .css({
                                'marginLeft': '5px',
                                'padding': '4px 12px'
                            })
                            .on('click', function() {
                                const searchValue = dtSearch.val();
                                table.search(searchValue).draw();
                            });
                        
                        // Insert button after search input
                        dtSearch.after(searchBtn);
                        
                        console.log('[SEARCH] DataTable search button added');
                    }
                }
            }
        }

        function renderAuditRow(r, idx, groupId, hasMissingWeekday) {
            const statusClass = r.status.includes('MATCH') ? 'status-match' : 
                               r.status.includes('NOT FOUND') ? 'status-error' : 'status-warning';
            
            const rowBtn = renderRowButton(r.google_row);
            const brandCell = renderBrandCell(r.brand, idx, 'audit');
            const misIdCell = renderMisIdCell(r.mis_id, r);  // Pass full row data for validation
            
            let weekdayDisplay = r.weekday || '-';
            if (!r.weekday || r.weekday.trim() === '') {
                weekdayDisplay = '<span class="weekday-missing-icon">[!] [EMOJI]√É‚Äö√Ç¬è </span><span style="color:#dc3545; font-style:italic;">MISSING</span>';
            }
            
            const hasDiscrepancies = r.discrepancies && r.discrepancies.length > 0;
            let reviewBtn = '-';
            if (hasDiscrepancies && !(hasMissingWeekday && (!r.weekday || r.weekday.trim() === ''))) {
                reviewBtn = `<button class="btn-review" onclick="reviewDiscrepancy('${r.mis_id}', ${r.google_row})">Review</button>`;
            }
            
            const truncate = (text, len) => {
                if (!text) return '-';
                text = String(text);
                return text.length > len ? text.substring(0, len) + '...' : text;
            };
            
            // v12.1: Format locations with numbered list for tooltip
            const formatLocationsNumbered = (locStr) => {
                if (!locStr || locStr === '-') return '-';
                const locs = locStr.split(',').map(l => l.trim()).filter(l => l);
                return locs.map((loc, i) => (i + 1) + '. ' + loc).join('&#10;');
            };
            const locationsTooltip = formatLocationsNumbered(r.locations);
            
            const rowClass = groupId ? `group-member-row group-${groupId}` : '';
            const warningClass = (hasMissingWeekday && (!r.weekday || r.weekday.trim() === '')) ? 'missing-weekday-warning' : '';
            
            // --- YELLOW BACKGROUND LOGIC ---
            // If this row is part of a group, force the background color to yellow
            const bgStyle = groupId ? 'style="background-color: #fff3cd !important;"' : '';
            
            return `<tr id="audit-row-${idx}" class="${rowClass} ${warningClass}" ${bgStyle}>
                <td>${rowBtn}</td>
                <td>${misIdCell}</td>
                <td>${brandCell}</td>
                <td>${weekdayDisplay}</td>
                <td title="${r.special_notes}">${truncate(r.special_notes, 15)}</td>
                <td title="${r.deal_info}">${truncate(r.deal_info, 15)}</td>
                <td>${r.discount}%</td>
                <td>${r.vendor_contrib}%</td>
                <td title="${locationsTooltip}">${truncate(r.locations, 25)}</td>
                <td title="${r.categories}">${truncate(r.categories, 15)}</td>
                <td><span class="status-badge ${statusClass}">${r.status}</span></td>
                <td>${r.discrepancies.join('<br>') || '-'}</td>
                <td>${reviewBtn}</td>
            </tr>`;
        }

        async function reviewDiscrepancy(misId, googleRow) {
            const btn = event.target;
            const originalText = btn.innerText;
            btn.innerText = '...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/mis/review-discrepancy', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ mis_id: misId, google_row: googleRow })
                });
                const data = await response.json();
                if (!data.success) {
                    alert('Error: ' + data.error);
                }
            } catch (e) {
                alert('Error: ' + e.message);
            } finally {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }

        async function authenticateGoogle() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Authenticating...';
            
            try {
                const response = await fetch('/api/auth', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('auth-status').innerHTML = '<p class="alert alert-success">[OK] Success!</p>';
                } else {
                    document.getElementById('auth-status').innerHTML = '<p class="alert alert-error">Error: ' + data.error + '</p>';
                }
            } catch (error) {
                document.getElementById('auth-status').innerHTML = '<p class="alert alert-error">Error: ' + error.message + '</p>';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Authenticate Google Sheets';
            }
        }

        async function loadMISSheetTabs() {
            const url = document.getElementById('mis-sheet-url').value;
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Loading...';
            
            try {
                const response = await fetch('/api/mis/load-sheet', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({url: url})
                });
                const data = await response.json();
                
                if (data.success) {
                    misData.allLoadedTabs = data.tabs;
                    // v12.1: Store spreadsheet ID globally for goToSheetRow
                    window.globalSpreadsheetId = data.spreadsheet_id || '';
                    renderTabOptions();
                    if (document.getElementById('mis-tab').options.length > 0) {
                        misData.tabName = document.getElementById('mis-tab').value;
                    }
                } else {
                    alert('Error: ' + data.error);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Load Tabs';
            }
        }

        function renderTabOptions() {
            const select = document.getElementById('mis-tab');
            const showAll = document.getElementById('mis-show-all-tabs').checked;
            const currentSelection = select.value;
            
            const filteredTabs = showAll ? misData.allLoadedTabs : misData.allLoadedTabs.filter(tab => {
                const parts = tab.trim().split(' ');
                if (parts.length !== 2) return false;
                const month = parts[0].toLowerCase();
                const year = parts[1];
                return VALID_MONTHS.includes(month) && /^\d{4}$/.test(year);
            });
            
            if (filteredTabs.length === 0) {
                select.innerHTML = '<option value="">-- No matching tabs --</option>';
            } else {
                select.innerHTML = filteredTabs.map(t => `<option value="${t}">${t}</option>`).join('');
            }
            
            if (currentSelection && filteredTabs.includes(currentSelection)) {
                select.value = currentSelection;
            } else if (filteredTabs.length > 0) {
                select.value = filteredTabs[0];
            }
        }

        async function initializeSheetPage(btnElement) {
            const tab = document.getElementById('mis-tab').value;
            if (!tab) {
                alert('Select a tab first');
                return;
            }
            
            // Use the passed element
            const btn = btnElement;
            
            btn.disabled = true;
            btn.textContent = 'Opening...';
            
            try {
                const response = await fetch('/api/mis/init-sheet-page', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({tab: tab})
                });
                const data = await response.json();
                
                // Alert result
                if (data.success) {
                    // Optional: auto-close alert after 2s or just show it
                    alert('[OK] ' + data.message);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Network/Server Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Open Sheet';
            }
        }

function handleMISCSV(input) {
    if (input.files.length > 0) {
        // Manual upload overrides pulled CSV
        misData.csvFile = input.files[0];
        misData.csvFilename = input.files[0].name;
        misData.pulledCSVPath = null; // Clear pulled path
        
        // Re-enable the input
        input.disabled = false;
        input.style.opacity = '1';
        
        document.getElementById('mis-csv-status').innerHTML = `
            <div class="alert alert-info p-2 mb-0" style="font-size: 0.9rem;">
                <strong> Manual Upload:</strong> ${misData.csvFilename}
            </div>
        `;
        
        console.log('[MANUAL-CSV] User uploaded:', misData.csvFilename);
    }
}

        // v10.7: Open MIS Reports folder in file explorer
        async function openMisReportsFolder() {
            try {
                const response = await fetch('/api/open-mis-reports-folder');
                const data = await response.json();
                if (!data.success) {
                    alert('Could not open folder: ' + (data.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }
        
        // v10.7: Load MIS Reports folder path on page load
        async function loadMisReportsFolderPath() {
            try {
                const response = await fetch('/api/get-mis-reports-folder');
                const data = await response.json();
                if (data.success) {
                    document.getElementById('mis-csv-folder-path').innerHTML = 
                        '<i class="bi bi-folder"></i> ' + data.path;
                }
            } catch (e) {
                console.log('Could not load MIS folder path');
            }
        }

        async function pullMisCsv(btn) {
            btn.disabled = true;
            const originalHtml = btn.innerHTML;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
            
            try {
                // Get credentials from Setup tab
                const misUsername = document.getElementById('mis-username').value;
                const misPassword = document.getElementById('mis-password').value;
                
                const response = await fetch('/api/mis/pull-csv', { 
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mis_username: misUsername,
                        mis_password: misPassword
                    })
                });
                const data = await response.json();
                
                if (data.success) {
                    misData.localPath = data.path;
                    misData.csvFile = null; // Auto-pull overrides manual file
                    
                    // Store globally so Matcher and Audit can use it
                    misData.csvFilename = data.filename;
                    misData.pulledCSVPath = data.path;
                    
                    // Clear the file input visually so user knows automation took over
                    // Can't set file input value (security), but create a visual "Active CSV" indicator
                    document.getElementById('mis-csv').value = ''; 
                    document.getElementById('mis-csv-status').innerHTML = `
                        <div class="alert alert-success p-2 mb-0" style="font-size: 0.9rem;">
                            <strong>[OK][EMOJI]√É‚Äö√Ç¬ù[EMOJI]√É‚Äö√Ç¬è Active CSV:</strong> ${data.filename}
                            <br><small class="text-muted">This CSV will be automatically used by ID Matcher and Audit tabs</small>
                        </div>
                    `;

                    // Also disable the file input to show automation is active
                    document.getElementById('mis-csv').disabled = true;
                    document.getElementById('mis-csv').style.opacity = '0.5';
                    
                    console.log('[CSV-PULL] CSV stored and ready for Matcher/Audit tabs');
                    console.log('[CSV-PULL] Filename:', data.filename);
                    console.log('[CSV-PULL] Path:', data.path);
                } else {
                    alert("Pull Failed: " + data.error);
                }
            } catch (e) {
                alert("Network Error: " + e.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalHtml;
            }
        }

        async function initializeAllSystems() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Initializing...';
            
            try {
                const response = await fetch('/api/init-all', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mis: {
                            username: document.getElementById('mis-username').value,
                            password: document.getElementById('mis-password').value
                        },
                        blaze: {
                            email: document.getElementById('blaze-email').value,
                            password: document.getElementById('blaze-password').value
                        }
                    })
                });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('init-status').innerHTML = '<p class="alert alert-success">' + data.message + '</p>';
                    
                    if (data.message.includes("Blaze login successful")) {
                        console.log("Triggering ONE-TIME auto-fetch for Blaze...");
                        const blazeBtn = document.querySelector("button[onclick='fetchBlazeData()']");
                        if (blazeBtn) blazeBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Auto-Syncing...';
                        setTimeout(() => { fetchBlazeData(true); }, 5000);
                    }
                } else {
                    document.getElementById('init-status').innerHTML = '<p class="alert alert-error">Error: ' + data.error + '</p>';
                }
            } catch (error) {
                document.getElementById('init-status').innerHTML = '<p class="alert alert-error">Network Error: ' + error.message + '</p>';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Initialize Browser & Login to Both Systems';
            }
        }

            function displayGeneratedCSV(data) {
            const containerId = 'gen-results';
            const sections = data.sections;
            
            const sectionTitles = {
                'weekly': ' WEEKLY DEALS',
                'monthly': ' MONTHLY DEALS',
                'sale': ' SALE DEALS'
            };
            
            // Count items per section
            const counts = {
                weekly: (sections.weekly?.rows || []).length,
                monthly: (sections.monthly?.rows || []).length,
                sale: (sections.sale?.rows || []).length
            };
            
            // Header and download buttons
            let headerHtml = '<h3>Generated MIS CSV (Multi-Section)</h3>';
            headerHtml += '<div style="margin-bottom:20px; display:flex; gap:10px; flex-wrap:wrap;">';
            headerHtml += '<button class="btn btn-success" onclick="downloadCSV(\'all\')"> Download ALL</button>';
            headerHtml += '<button class="btn btn-outline-primary" onclick="downloadCSV(\'weekly\')"> Weekly Only</button>';
            headerHtml += '<button class="btn btn-outline-info" onclick="downloadCSV(\'monthly\')"> Monthly Only</button>';
            headerHtml += '<button class="btn btn-outline-warning" onclick="downloadCSV(\'sale\')"> Sale Only</button>';
            headerHtml += '<button class="btn btn-secondary" onclick="generateCSV()"> Regenerate</button>';
            headerHtml += '<button class="btn btn-purple" style="background:#6f42c1; color:white; border:none;" onclick="generateNewsletterTable()"> Generate Newsletter Table</button>';
            headerHtml += '</div>';
            
            // Generate deal type tabs
            headerHtml += generateDealTypeTabsHTML(containerId, counts);
            
            // Helper function to build a section's HTML
            function buildSectionHTML(secKey) {
                const secData = sections[secKey];
                const rows = secData?.rows || [];
                const title = sectionTitles[secKey];
                let sectionHtml = '';
                
                sectionHtml += `<div class="card mb-4 shadow-sm">`;
                sectionHtml += `<div class="card-header bg-light"><strong>${title}</strong> (${rows.length} rows)</div>`;
                sectionHtml += `<div class="card-body p-0">`;
                
                if (rows.length === 0) {
                    sectionHtml += '<div class="p-3 text-muted">No data in this section.</div>';
                } else {
                    sectionHtml += '<div class="scrollable-table-container" style="max-height:500px;">';
                    sectionHtml += '<table class="table table-sm table-striped mb-0" style="font-size:0.85em; border-collapse: separate; border-spacing: 0;">';
                    sectionHtml += '<thead style="position:sticky; top:0; z-index:5; background:white;"><tr>';
                    sectionHtml += '<th style="width:40px;">[OK]</th><th>Weekday</th><th>Brand</th><th>Linked</th><th>Notes</th><th>Info</th><th>Disc</th><th>Vend%</th><th>Store</th><th>Cat</th><th>Type</th><th>Flag</th>';
                    sectionHtml += '</tr></thead><tbody>';
                    
                    rows.forEach(r => {
                        const isMultiDay = r.MULTI_DAY_FLAG !== 'NO';
                        const isSplit = r.SPLIT_GROUP_ID && r.SPLIT_GROUP_ID !== "";
                        
                        let bgStyle = '';
                        if (isMultiDay) bgStyle = 'background:#fff3cd;'; 
                        if (isSplit) bgStyle = 'background:#e2e3e5;';    
                        
                        let borderStyle = 'border-bottom: 1px solid #dee2e6;';
                        if (isSplit) {
                            const borderColor = '#6c757d'; 
                            const borderWidth = '2px';
                            borderStyle = `border-left: ${borderWidth} solid ${borderColor}; border-right: ${borderWidth} solid ${borderColor};`;
                            if (r.ROW_UI_CLASS === 'split-group-start') {
                                borderStyle += `border-top: ${borderWidth} solid ${borderColor}; border-bottom: 1px dotted #ccc;`;
                            } else if (r.ROW_UI_CLASS === 'split-group-end') {
                                borderStyle += `border-bottom: ${borderWidth} solid ${borderColor};`;
                            } else {
                                borderStyle += `border-bottom: 1px dotted #ccc;`;
                            }
                        }

                        const checkboxCellStyle = 'border-bottom: 1px solid #dee2e6; background: #fff; text-align: center; vertical-align: middle;';

                        let weekdayHtml = r.Weekday;
                        const days = r.Weekday.split(', ');
                        if (days.length > 4) {
                            const chunks = [];
                            for (let i = 0; i < days.length; i += 4) {
                                chunks.push(days.slice(i, i + 4).join(', '));
                            }
                            weekdayHtml = chunks.join(',<br>');
                        }

                        const buildCellContent = (dataArray, keyName) => {
                            if (!dataArray || dataArray.length === 0) return { display: '<span style="color:#ccc;">-</span>', tooltip: '' };
                            const firstVal = dataArray[0][keyName]; 
                            const truncated = firstVal.length > 25 ? firstVal.substring(0, 22) + '...' : firstVal;
                            let display = dataArray.length > 1 ? `<span style="font-weight:500;">${truncated} <span style="color:#667eea; font-weight:bold;">(...)</span></span>` : `<span>${truncated}</span>`;
                            const lines = dataArray.map(item => `<strong>Row ${item.row} (${item.day}):</strong> ${item[keyName]}`);
                            const tooltip = lines.join('<br>').replace(/"/g, '&quot;');
                            return { display: display, tooltip: tooltip };
                        };

                        const notesObj = buildCellContent(r.UI_SPECIAL_NOTES, 'note');
                        const infoObj = buildCellContent(r.UI_DEAL_INFO, 'info');

                        let rebateDisplay = r.UI_REBATE_DISPLAY;
                        let rebateStyle = borderStyle;
                        if (rebateDisplay === 'Retail') rebateStyle += ' color:#dc3545; font-weight:bold;';
                        else if (rebateDisplay === 'Wholesale') rebateStyle += ' color:#198754; font-weight:500;';

                        const locRaw = r.DISPLAY_STORE || r.Store || '-';
                        let locHtml = locRaw;
                        let locStyle = '';
                        if (locRaw === 'All Locations') {
                            locStyle = 'color: #28a745; font-weight: bold;';
                        } else if (String(locRaw).startsWith('All Locations Except')) {
                            locStyle = 'color: #dc3545; font-weight: bold;';
                            const match = locRaw.match(/: (.*)/);
                            if (match) {
                                const parts = match[1].split(',').map(s => s.trim());
                                if (parts.length > 2) locHtml = `All Locations Except: ${parts[0]}, ${parts[1]}...`;
                            }
                        } else {
                            const parts = String(locRaw).split(',').map(s => s.trim());
                            if (parts.length > 2) locHtml = `${parts[0]}, ${parts[1]}...`;
                        }

                        let flagContent = r.MULTI_DAY_FLAG;
                        if (isMultiDay && flagContent.includes('YES')) {
                            flagContent = flagContent.replace('YES (', 'YES<br>(');
                        }

                        const flagBadge = isMultiDay 
                            ? `<span style="background:#ffc107; padding:4px 8px; border-radius:12px; font-size:0.75em; font-weight:bold; display:inline-block; text-align:center; line-height:1.1;">&#x3030;[EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è ${flagContent}</span>`
                            : '<span style="color:#999;">-</span>';
                        
                        const displayCat = r.DISPLAY_CATEGORY || r.Category || '-';

                        let warningEmoji = '';
                        const rebateType = r.UI_REBATE_DISPLAY || r['Rebate type'] || '';
                        if (rebateType === 'Retail') {
                            warningEmoji = '<span style="font-size:1.2em; margin-right:5px;" title="Retail Rebate Reporting">[EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è</span>';
                        } else if (!rebateType || rebateType.trim() === '') {
                            warningEmoji = '<span style="font-size:1.2em; margin-right:5px;" title="Wholesale/Retail Value = BLANK">[!] [EMOJI]√É‚Äö√Ç¬è </span>';
                        }

                        sectionHtml += `<tr style="${bgStyle}">`;
                        sectionHtml += `<td style="${checkboxCellStyle}">${warningEmoji}<input type="checkbox" style="cursor: pointer; width: 18px; height: 18px;"></td>`;
                        sectionHtml += `<td style="${borderStyle} white-space:nowrap;"><strong>${weekdayHtml}</strong></td>`;
                        sectionHtml += `<td style="${borderStyle} font-weight:bold;">${r.Brand}</td>`;
                        sectionHtml += `<td style="${borderStyle} color:#666;">${r['Linked Brand (if applicable)'] || '-'}</td>`;
                        sectionHtml += `<td style="${borderStyle} cursor:help;" data-bs-toggle="tooltip" data-bs-html="true" title="${notesObj.tooltip}">${notesObj.display}</td>`;
                        sectionHtml += `<td style="${borderStyle} cursor:help;" data-bs-toggle="tooltip" data-bs-html="true" title="${infoObj.tooltip}">${infoObj.display}</td>`;
                        sectionHtml += `<td style="${borderStyle}">${r['Daily Deal Discount']}%</td>`;
                        sectionHtml += `<td style="${borderStyle}">${r['Discount paid by vendor']}%</td>`;
                        sectionHtml += `<td style="${borderStyle} ${locStyle}" title="${locRaw}">${locHtml}</td>`;
                        sectionHtml += `<td style="${borderStyle}">${displayCat}</td>`;
                        sectionHtml += `<td style="${rebateStyle}">${rebateDisplay}</td>`;
                        sectionHtml += `<td style="${borderStyle}">${flagBadge}</td>`;
                        sectionHtml += `</tr>`;
                    });
                    
                    sectionHtml += '</tbody></table></div>';
                }
                sectionHtml += '</div></div>';
                return sectionHtml;
            }
            
            // Build content for each section
            const sectionContents = {
                weekly: buildSectionHTML('weekly'),
                monthly: buildSectionHTML('monthly'),
                sale: buildSectionHTML('sale')
            };
            
            // Build the "All Deals" view (stacked)
            let allHtml = sectionContents.weekly + sectionContents.monthly + sectionContents.sale;
            
            // Build final HTML with containers
            let finalHtml = headerHtml;
            finalHtml += `<div id="${containerId}-weekly" class="deal-type-content">${sectionContents.weekly}</div>`;
            finalHtml += `<div id="${containerId}-monthly" class="deal-type-content">${sectionContents.monthly}</div>`;
            finalHtml += `<div id="${containerId}-sale" class="deal-type-content">${sectionContents.sale}</div>`;
            finalHtml += `<div id="${containerId}-all" class="deal-type-content active" style="display:block;">${allHtml}</div>`;
            
            document.getElementById('gen-results').innerHTML = finalHtml;
            
            setTimeout(function() {
                const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
                tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl);
                });
            }, 500);
        }

        async function generateCSV() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Generating...';
            
            try {
                const tab = document.getElementById('mis-tab').value;
                const response = await fetch('/api/mis/generate-csv', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({tab: tab})
                });
                const data = await response.json();
                
                if (data.success) {
                    displayGeneratedCSV(data);
                } else {
                    alert('Error: ' + data.error);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = 'Generate CSV';
            }
        }

        async function downloadCSV(type = 'all') {
            window.location.href = `/api/mis/download-csv?type=${type}`;
        }

        async function generateNewsletterTable() {
            // Generate Newsletter files (Excel + DOCX) and save to REPORTS/Newsletter folder
            const btn = event.target;
            const originalText = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Generating...';
            
            try {
                const response = await fetch('/api/mis/generate-newsletter', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'}
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Show success message with folder path
                    const folderPath = data.folder;
                    const counts = data.counts;
                    
                    let message = '[OK][EMOJI] Newsletter files generated successfully!\\n\\n';
                    message += ' Saved to:\\n' + folderPath + '\\n\\n';
                    message += ' Files created:\\n';
                    if (data.files.excel) message += '  &#x2022; Excel (6 tabs)\\n';
                    if (data.files.club420_docx) message += '  &#x2022; CLUB420_Newsletter.docx\\n';
                    if (data.files.tat_legacy_docx) message += '  &#x2022; TAT_LEGACY_Newsletter.docx\\n';
                    message += '\\n[EMOJI] Deal counts:\\n';
                    message += '  CLUB420: Weekly=' + counts.club420.weekly + ', Monthly=' + counts.club420.monthly + ', Sale=' + counts.club420.sale + '\\n';
                    message += '  TAT LEGACY: Weekly=' + counts.tat_legacy.weekly + ', Monthly=' + counts.tat_legacy.monthly + ', Sale=' + counts.tat_legacy.sale;
                    
                    alert(message);
                } else {
                    alert('Error: ' + (data.error || 'Failed to generate newsletter'));
                }
            } catch (error) {
                alert('Network Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalText;
            }
        }

    async function runMatcher() {
    const tab = document.getElementById('mis-tab').value;
    if (!tab) {
        alert('Please select a sheet tab in Setup first');
        return;
    }
    // Note: Removed csvFile check - backend will handle both uploaded and pulled CSV
            
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'Running...';
            
            const focusEnabled = document.getElementById('matcher-focus-enable').checked;
            const focusDate = document.getElementById('matcher-focus-date').value;
            const expandMonth = document.getElementById('matcher-focus-expand').checked;

            if (focusEnabled && !focusDate) {
                alert("Please select a date for Focus mode.");
                btn.disabled = false; btn.textContent = 'Run Matcher';
                return;
            }

            const formData = new FormData();
            formData.append('tab', tab);
            
            // ATTACH FILE OR PATH (Updated logic)
            if (misData.csvFile) {
                formData.append('csv', misData.csvFile);
            } else if (misData.localPath) {
                formData.append('local_csv_path', misData.localPath);
            }

            formData.append('focus_enabled', focusEnabled);
            formData.append('focus_date', focusDate);
            formData.append('expand_month', expandMonth);
            
            try {
                const response = await fetch('/api/mis/match', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (data.success) {
                    matchesData = data.matches; 
                    displayMatchResults(data.matches);
                    // v12.5: Reset apply buttons visibility after new matcher run
                    approvedMatches = {};
                    updateApplyButtonsVisibility();
                } else {
                    alert('Error: ' + data.error);
                }
            } catch(e) { alert(e); } 
            finally {
                btn.disabled = false;
                btn.textContent = 'Run Matcher';
            }
        }

        // ============================================
        // v12.1: ID Matcher Subtab Switching
        // ============================================
        function switchIdMatcherSubTab(tabName, clickedElement) {
            // Hide all subtab content
            document.querySelectorAll('.id-matcher-subtab-content').forEach(el => {
                el.style.display = 'none';
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('#idMatcherSubTabs .nav-link').forEach(el => {
                el.classList.remove('active');
            });
            
            // Show selected subtab
            const targetEl = document.getElementById('id-matcher-subtab-' + tabName);
            if (targetEl) {
                targetEl.style.display = 'block';
            }
            
            // Add active class to clicked tab
            if (clickedElement) {
                clickedElement.classList.add('active');
            }
        }

        // ============================================
        // v12.1: MAudit - Google Sheet vs MIS CSV Verification
        // ============================================
        async function runMAudit() {
            const statusEl = document.getElementById('maudit-status');
            const resultsEl = document.getElementById('maudit-results');
            
            statusEl.textContent = 'Running verification...';
            resultsEl.innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary"></div><div class="mt-2">Verifying deals against MIS CSV...</div></div>';
            
            try {
                const tab = document.getElementById('mis-tab').value;
                if (!tab) {
                    alert('Please select a sheet tab in Setup first');
                    statusEl.textContent = '';
                    resultsEl.innerHTML = '<p class="text-muted">Select a sheet tab first.</p>';
                    return;
                }
                
                const formData = new FormData();
                formData.append('tab', tab);
                
                if (misData.csvFile) {
                    formData.append('csv', misData.csvFile);
                } else if (misData.localPath) {
                    formData.append('local_csv_path', misData.localPath);
                }
                
                const response = await fetch('/api/mis/maudit', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (data.success) {
                    statusEl.textContent = 'Verification complete';
                    renderMAuditResults(data.results);
                } else {
                    statusEl.textContent = 'Error';
                    resultsEl.innerHTML = `<div class="alert alert-danger">Error: ${data.error}</div>`;
                }
            } catch (error) {
                statusEl.textContent = 'Error';
                resultsEl.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        }
        
        function renderMAuditResults(results) {
            const container = document.getElementById('maudit-results');
            
            if (!results || (results.verified.length === 0 && results.mismatches.length === 0 && 
                results.not_found.length === 0 && results.missing_id.length === 0)) {
                container.innerHTML = '<div class="alert alert-info">No results to display. Make sure the sheet has data and MIS CSV is loaded.</div>';
                return;
            }
            
            let html = '';
            
            // Summary stats
            const totalVerified = results.verified?.length || 0;
            const totalMismatches = results.mismatches?.length || 0;
            const totalNotFound = results.not_found?.length || 0;
            const totalMissingId = results.missing_id?.length || 0;
            const total = totalVerified + totalMismatches + totalNotFound + totalMissingId;
            
            html += `<div class="d-flex gap-3 mb-3 flex-wrap">
                <span class="badge bg-success fs-6">Verified: ${totalVerified}</span>
                <span class="badge bg-warning text-dark fs-6">Mismatches: ${totalMismatches}</span>
                <span class="badge bg-danger fs-6">Not Found: ${totalNotFound}</span>
                <span class="badge bg-secondary fs-6">Missing MIS ID: ${totalMissingId}</span>
                <span class="badge bg-dark fs-6">Total: ${total}</span>
            </div>`;
            
            // Missing MIS ID section
            if (results.missing_id && results.missing_id.length > 0) {
                html += `<div class="card mb-3 border-secondary">
                    <div class="card-header bg-secondary text-white">
                        <strong>Missing MIS ID (${results.missing_id.length})</strong>
                        <small class="ms-2">- Deals without MIS IDs in Google Sheet</small>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered mb-0">
                                <thead class="table-light">
                                    <tr><th style="width:60px;">Row</th><th>Section</th><th>Brand</th><th>Day/Dates</th><th>Discount</th><th>Locations</th></tr>
                                </thead>
                                <tbody>`;
                
                results.missing_id.forEach(item => {
                    const sectionBadge = getSectionBadge(item.section);
                    const rowBtn = window.globalSpreadsheetId ? 
                        `<button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${item.row})" title="Go to row ${item.row}">${item.row}</button>` : 
                        item.row;
                    html += `<tr>
                        <td>${rowBtn}</td>
                        <td>${sectionBadge}</td>
                        <td>${item.brand || '-'}</td>
                        <td>${item.weekday || item.start_date || '-'}</td>
                        <td>${item.discount || '-'}</td>
                        <td><small>${item.locations || '-'}</small></td>
                    </tr>`;
                });
                
                html += `</tbody></table></div></div></div>`;
            }
            
            // Not Found in CSV section
            if (results.not_found && results.not_found.length > 0) {
                html += `<div class="card mb-3 border-danger">
                    <div class="card-header bg-danger text-white">
                        <strong>Not Found in CSV (${results.not_found.length})</strong>
                        <small class="ms-2">- MIS IDs not found in uploaded CSV</small>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered mb-0">
                                <thead class="table-light">
                                    <tr><th style="width:60px;">Row</th><th>Section</th><th>Brand</th><th>MIS ID</th><th>Day/Dates</th><th>Discount</th></tr>
                                </thead>
                                <tbody>`;
                
                results.not_found.forEach(item => {
                    const sectionBadge = getSectionBadge(item.section);
                    const rowBtn = window.globalSpreadsheetId ? 
                        `<button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${item.row})" title="Go to row ${item.row}">${item.row}</button>` : 
                        item.row;
                    
                    // Enhanced MIS ID button with row data for validation
                    const rowDataJson = JSON.stringify({
                        brand: item.brand || '',
                        linked_brand: item.linked_brand || '',
                        weekday: item.weekday || '',
                        categories: item.categories || '',
                        discount: item.discount || '',
                        vendor_contrib: item.vendor_contrib || '',
                        locations: item.locations || 'All Locations',
                        rebate_type: item.rebate_type || '',
                        after_wholesale: item.after_wholesale || false
                    }).replace(/"/g, '&quot;');
                    
                    const misIdBtn = item.mis_id ? 
                        `<button class="btn btn-outline-secondary btn-sm py-0 px-2" 
                                 data-row='${rowDataJson}' 
                                 onclick="lookupMisIdWithValidation(this, '${item.mis_id}')"
                                 title="Click to lookup and validate">${item.mis_id}</button>` : '-';
                    html += `<tr>
                        <td>${rowBtn}</td>
                        <td>${sectionBadge}</td>
                        <td>${item.brand || '-'}</td>
                        <td>${misIdBtn}</td>
                        <td>${item.weekday || item.start_date || '-'}</td>
                        <td>${item.discount || '-'}</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div></div></div>`;
            }
            
            // Mismatches section
            if (results.mismatches && results.mismatches.length > 0) {
                html += `<div class="card mb-3 border-warning">
                    <div class="card-header bg-warning text-dark">
                        <strong>Field Mismatches (${results.mismatches.length})</strong>
                        <small class="ms-2">- Deals with field differences between Sheet and CSV</small>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered mb-0">
                                <thead class="table-light">
                                    <tr><th style="width:60px;">Row</th><th>Section</th><th>Brand</th><th>MIS ID</th><th>Match %</th><th>Issues</th></tr>
                                </thead>
                                <tbody>`;
                
                results.mismatches.forEach(item => {
                    const sectionBadge = getSectionBadge(item.section);
                    const rowBtn = window.globalSpreadsheetId ? 
                        `<button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${item.row})" title="Go to row ${item.row}">${item.row}</button>` : 
                        item.row;
                    
                    // Enhanced MIS ID button with row data for validation
                    const rowDataJson = JSON.stringify({
                        brand: item.brand || '',
                        linked_brand: item.linked_brand || '',
                        weekday: item.weekday || '',
                        categories: item.categories || '',
                        discount: item.discount || '',
                        vendor_contrib: item.vendor_contrib || '',
                        locations: item.locations || 'All Locations',
                        rebate_type: item.rebate_type || '',
                        after_wholesale: item.after_wholesale || false
                    }).replace(/"/g, '&quot;');
                    
                    const misIdBtn = item.mis_id ? 
                        `<button class="btn btn-outline-secondary btn-sm py-0 px-2" 
                                 data-row='${rowDataJson}' 
                                 onclick="lookupMisIdWithValidation(this, '${item.mis_id}')"
                                 title="Click to lookup and validate">${item.mis_id}</button>` : '-';
                    const pct = item.match_percent || 0;
                    const pctClass = pct >= 80 ? 'text-success' : pct >= 50 ? 'text-warning' : 'text-danger';
                    const issues = item.issues ? item.issues.join(', ') : '-';
                    html += `<tr>
                        <td>${rowBtn}</td>
                        <td>${sectionBadge}</td>
                        <td>${item.brand || '-'}</td>
                        <td>${misIdBtn}</td>
                        <td class="${pctClass} fw-bold">${pct}%</td>
                        <td><small class="text-danger">${issues}</small></td>
                    </tr>`;
                });
                
                html += `</tbody></table></div></div></div>`;
            }
            
            // Verified section
            if (results.verified && results.verified.length > 0) {
                html += `<div class="card mb-3 border-success">
                    <div class="card-header bg-success text-white">
                        <strong>Verified (${results.verified.length})</strong>
                        <small class="ms-2">- All fields match between Sheet and CSV</small>
                    </div>
                    <div class="card-body p-0">
                        <div class="table-responsive">
                            <table class="table table-sm table-bordered mb-0">
                                <thead class="table-light">
                                    <tr><th style="width:60px;">Row</th><th>Section</th><th>Brand</th><th>MIS ID</th><th>Day/Dates</th><th>Discount</th></tr>
                                </thead>
                                <tbody>`;
                
                results.verified.forEach(item => {
                    const sectionBadge = getSectionBadge(item.section);
                    const rowBtn = window.globalSpreadsheetId ? 
                        `<button class="btn btn-outline-primary btn-sm py-0 px-2" onclick="openSheetRow(${item.row})" title="Go to row ${item.row}">${item.row}</button>` : 
                        item.row;
                    
                    // Enhanced MIS ID button with row data for validation
                    const rowDataJson = JSON.stringify({
                        brand: item.brand || '',
                        linked_brand: item.linked_brand || '',
                        weekday: item.weekday || '',
                        categories: item.categories || '',
                        discount: item.discount || '',
                        vendor_contrib: item.vendor_contrib || '',
                        locations: item.locations || 'All Locations',
                        rebate_type: item.rebate_type || '',
                        after_wholesale: item.after_wholesale || false
                    }).replace(/"/g, '&quot;');
                    
                    const misIdBtn = item.mis_id ? 
                        `<button class="btn btn-outline-success btn-sm py-0 px-2" 
                                 data-row='${rowDataJson}' 
                                 onclick="lookupMisIdWithValidation(this, '${item.mis_id}')"
                                 title="Click to lookup and validate">${item.mis_id}</button>` : '-';
                    html += `<tr>
                        <td>${rowBtn}</td>
                        <td>${sectionBadge}</td>
                        <td>${item.brand || '-'}</td>
                        <td>${misIdBtn}</td>
                        <td>${item.weekday || item.start_date || '-'}</td>
                        <td>${item.discount || '-'}</td>
                    </tr>`;
                });
                
                html += `</tbody></table></div></div></div>`;
            }
            
            container.innerHTML = html;
        }
        
        function getSectionBadge(section) {
            if (!section) return '';
            const s = section.toLowerCase();
            if (s.includes('week')) return '<span class="badge bg-primary">Weekly</span>';
            if (s.includes('month')) return '<span class="badge bg-success">Monthly</span>';
            if (s.includes('sale')) return '<span class="badge bg-warning text-dark">Sale</span>';
            return `<span class="badge bg-secondary">${section}</span>`;
        }

async function runAudit() {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Running...';

        document.getElementById('audit-results').innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary"></div><div class="mt-2">Auditing Data...</div></div>';

        try {
            // Get current tab selection from dropdown (not stale misData.tabName)
            const currentTab = document.getElementById('mis-tab').value;
            
            if (!currentTab) {
                document.getElementById('audit-results').innerHTML = 
                    '<div class="alert alert-warning">Please select a Google Sheet tab in the Setup section first.</div>';
                return;
            }
            
            const formData = new FormData();
            formData.append('tab', currentTab);

            // Attach CSV if available (same logic as Matcher/Conflict)
            if (misData.csvFile) {
                formData.append('csv', misData.csvFile);
            }

            const response = await fetch('/api/mis/audit', {
                method: 'POST',
                body: formData
            });

            const data = await response.json();

            if (data.success) {
                displayAuditResults(data.results);
            } else {
                document.getElementById('audit-results').innerHTML = 
                    `<div class="alert alert-danger">[X] Error: ${data.error}</div>`;
            }
        } catch (e) {
            document.getElementById('audit-results').innerHTML = 
                `<div class="alert alert-danger">[X] Network Error: ${e.message}</div>`;
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

// ============================================
// GOOGLE SHEET CONFLICT AUDIT (Pre-Flight Check)
// ============================================
async function runGSheetConflictAudit() {
    const btn = event.target;
    const originalText = btn.innerHTML;
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Scanning Google Sheet...';
    
    document.getElementById('gsheet-audit-results').innerHTML = '';
    document.getElementById('gsheet-audit-stats').innerText = 'Scanning...';
    document.getElementById('gsheet-audit-stats').className = 'badge bg-info fs-6 me-2';

    try {
        const tab = document.getElementById('mis-tab').value;
        
        if (!tab) {
            alert('Please select a Google Sheet tab in the Setup section first.');
            document.getElementById('gsheet-audit-stats').innerText = 'No Tab Selected';
            document.getElementById('gsheet-audit-stats').className = 'badge bg-danger fs-6 me-2';
            return;
        }
        
        const response = await fetch('/api/mis/gsheet-conflict-audit', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ tab: tab })
        });
        const data = await response.json();

        if (data.success) {
            displayGSheetConflictResults(data);
            
            const conflictCount = data.conflicts ? data.conflicts.length : 0;
            if (conflictCount > 0) {
                document.getElementById('gsheet-audit-stats').innerText = 
                    `[!] [EMOJI]√É‚Äö√Ç¬è ${conflictCount} Cross-Section Conflicts Found`;
                document.getElementById('gsheet-audit-stats').className = 'badge bg-warning text-dark fs-6 me-2';
            } else {
                document.getElementById('gsheet-audit-stats').innerText = 
                    `[OK][EMOJI] No Cross-Section Conflicts`;
                document.getElementById('gsheet-audit-stats').className = 'badge bg-success fs-6 me-2';
            }
        } else {
            document.getElementById('gsheet-audit-results').innerHTML = 
                `<div class="alert alert-danger">[X] Error: ${data.error}</div>`;
            document.getElementById('gsheet-audit-stats').innerText = 'Error';
            document.getElementById('gsheet-audit-stats').className = 'badge bg-danger fs-6 me-2';
        }
    } catch (e) {
        document.getElementById('gsheet-audit-results').innerHTML = 
            `<div class="alert alert-danger">[X] Network Error: ${e.message}</div>`;
        document.getElementById('gsheet-audit-stats').innerText = 'Error';
        document.getElementById('gsheet-audit-stats').className = 'badge bg-danger fs-6 me-2';
    } finally {
        btn.disabled = false;
        btn.innerHTML = originalText;
    }
}

function displayGSheetConflictResults(data) {
            const container = document.getElementById('gsheet-audit-results');
            const dateConflicts = data.date_conflicts || [];
            const brandConflicts = data.brand_conflicts || [];
            const summary = data.summary || {};
            const dateContext = data.date_context || 'Unknown';
            
            // --- 1. Summary Header ---
            let html = `
                <div class="card mb-4 shadow-sm">
                    <div class="card-header bg-light d-flex justify-content-between align-items-center">
                        <strong> Sheet Analysis Summary</strong>
                        <span class="badge bg-dark fs-6">[EMOJI] Context: ${dateContext}</span>
                    </div>
                    <div class="card-body">
                        <div class="row text-center">
                            <div class="col-md-3">
                                <div class="border rounded p-3">
                                    <h4 class="text-primary mb-0">${summary.weekly_count || 0}</h4>
                                    <small class="text-muted">&#x1F4C5; Weekly Deals</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="border rounded p-3">
                                    <h4 class="text-info mb-0">${summary.monthly_count || 0}</h4>
                                    <small class="text-muted"> Monthly Deals</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="border rounded p-3">
                                    <h4 class="text-warning mb-0">${summary.sale_count || 0}</h4>
                                    <small class="text-muted"> Sale Deals</small>
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="border rounded p-3">
                                    <h4 class="text-secondary mb-0">${summary.unique_brands || 0}</h4>
                                    <small class="text-muted"> Unique Brands</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // --- 2. Tab Navigation ---
            html += `
                <ul class="nav nav-tabs mb-3" id="auditSubTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active fw-bold" id="tab-date-conflicts" data-bs-toggle="tab" data-bs-target="#pane-date-conflicts" type="button" role="tab">
                             Conflictions by Date 
                            <span class="badge bg-danger ms-2">${dateConflicts.length}</span>
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link fw-bold" id="tab-brand-conflicts" data-bs-toggle="tab" data-bs-target="#pane-brand-conflicts" type="button" role="tab">
                             Conflictions by Brand
                            <span class="badge bg-secondary ms-2">${brandConflicts.length}</span>
                        </button>
                    </li>
                </ul>
                
                <div class="tab-content" id="auditSubTabsContent">
            `;

            // --- 3. Pane A: Date Conflicts ---
            html += `<div class="tab-pane fade show active" id="pane-date-conflicts" role="tabpanel">`;
            
            if (dateConflicts.length === 0) {
                html += `
                    <div class="text-center p-4 border rounded bg-light text-success">
                        <h4><i class="bi bi-check-circle-fill"></i> No Date-Based Conflicts</h4>
                        <p class="mb-0">No brands overlap on the exact same dates.</p>
                    </div>`;
            } else {
                html += `
                    <div class="alert alert-warning">
                        <h6 class="mb-1"><i class="bi bi-exclamation-triangle-fill"></i> STRICT OVERLAP</h6>
                        These brands have deals scheduled on the <strong>exact same date</strong> in different sections.
                    </div>
                    <div class="accordion" id="accDateConflicts">`;
                
                dateConflicts.forEach((conflict, idx) => {
                    const groupID = `dc${idx}`;
                    const sectionBadges = conflict.sections.map(s => `<span class="badge bg-secondary me-1">${s.toUpperCase()}</span>`).join('');
                    const datesBadges = conflict.conflicting_dates.map(d => `<span class="badge bg-danger me-1">${d.date}</span>`).join('');
                    
                    html += `
                        <div class="card mb-3 shadow-sm" style="border-left: 5px solid #dc3545;">
                            <div class="card-header bg-white collapsed" data-bs-toggle="collapse" data-bs-target="#${groupID}" style="cursor:pointer;">
                                <div class="d-flex justify-content-between">
                                    <div><span class="fw-bold fs-5"> ${conflict.brand}</span> <span class="ms-2">${sectionBadges}</span></div>
                                    <span class="badge bg-danger">${conflict.total_conflict_dates} dates</span>
                                </div>
                                <div class="mt-1 small text-muted">Overlapping: ${datesBadges}</div>
                            </div>
                            <div id="${groupID}" class="collapse" data-bs-parent="#accDateConflicts">
                                <div class="card-body p-0 table-responsive">
                                    ${renderAuditTable(conflict.rows, true)}
                                </div>
                            </div>
                        </div>`;
                });
                html += `</div>`; // End Accordion
            }
            html += `</div>`; // End Pane A

            // --- 4. Pane B: Brand Conflicts ---
            html += `<div class="tab-pane fade" id="pane-brand-conflicts" role="tabpanel">`;
            
            if (brandConflicts.length === 0) {
                html += `
                    <div class="text-center p-4 border rounded bg-light text-success">
                        <h4><i class="bi bi-check-circle-fill"></i> No Brand Overlaps</h4>
                        <p class="mb-0">Every brand appears in only one section type.</p>
                    </div>`;
            } else {
                html += `
                    <div class="alert alert-secondary" style="border-left: 5px solid #6c757d;">
                        <h6 class="mb-1"><i class="bi bi-info-circle-fill"></i> BROAD OVERLAP</h6>
                        These brands appear in multiple sections (e.g., Weekly AND Sale) but <strong>do not necessarily overlap dates</strong>.
                    </div>
                    <div class="accordion" id="accBrandConflicts">`;

                brandConflicts.forEach((conflict, idx) => {
                    const groupID = `bc${idx}`;
                    const sectionBadges = conflict.sections.map(s => `<span class="badge bg-secondary me-1">${s.toUpperCase()}</span>`).join('');
                    
                    html += `
                        <div class="card mb-3 shadow-sm" style="border-left: 5px solid #6c757d;">
                            <div class="card-header bg-white collapsed" data-bs-toggle="collapse" data-bs-target="#${groupID}" style="cursor:pointer;">
                                <div class="d-flex justify-content-between">
                                    <div><span class="fw-bold fs-5"> ${conflict.brand}</span> <span class="ms-2">${sectionBadges}</span></div>
                                    <span class="badge bg-secondary">${conflict.rows.length} rows</span>
                                </div>
                            </div>
                            <div id="${groupID}" class="collapse" data-bs-parent="#accBrandConflicts">
                                <div class="card-body p-0 table-responsive">
                                    ${renderAuditTable(conflict.rows, false)}
                                </div>
                            </div>
                        </div>`;
                });
                html += `</div>`; // End Accordion
            }
            html += `</div>`; // End Pane B
            
            html += `</div>`; // End Tab Content
            
            container.innerHTML = html;
            initTooltips();
        }

// Helper to render table rows (reused for both tabs)
        // UPDATED: Tight padding, recalculated widths to prevent scrolling
        function renderAuditTable(rows, showConflictDate) {
            // Added explicit padding style to th/td to reduce gaps
            const cellStyle = 'padding: 2px 4px; vertical-align: middle; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
            const wrapStyle = 'padding: 2px 4px; vertical-align: middle; white-space: normal; word-break: break-word;'; // For Notes/Locations
            
            let table = `<table class="table table-sm table-hover mb-0" style="font-size:0.85em; table-layout: fixed; width: 100%;">
                <thead class="table-light">
                    <tr>`;
            
            // Total width must equal 100% to avoid scrollbars
            if (showConflictDate) {
                // Scenario A: WITH Conflict Date (Total 100%)
                table += `<th style="width: 9%; ${cellStyle}">Conflict Date</th>`;
                table += `
                    <th style="width: 7%; ${cellStyle}">Section</th>
                    <th style="width: 4%; ${cellStyle}">Row</th>
                    <th style="width: 9%; ${wrapStyle}">Date/Day</th>
                    <th style="width: 6%; ${cellStyle}">Discount</th>
                    <th style="width: 6%; ${cellStyle}">Vendor %</th>
                    <th style="width: 20%; ${wrapStyle}">Locations</th>
                    <th style="width: 28%; ${wrapStyle}">Notes</th>
                    <th style="width: 6%; ${cellStyle}">MIS ID</th>
                    <th style="width: 5%; ${cellStyle}">Action</th>`;
            } else {
                // Scenario B: Brand View (No Conflict Date) (Total 100%)
                // Distributed extra space to Notes & Locations
                table += `
                    <th style="width: 7%; ${cellStyle}">Section</th>
                    <th style="width: 4%; ${cellStyle}">Row</th>
                    <th style="width: 9%; ${wrapStyle}">Date/Day</th>
                    <th style="width: 6%; ${cellStyle}">Discount</th>
                    <th style="width: 6%; ${cellStyle}">Vendor %</th>
                    <th style="width: 22%; ${wrapStyle}">Locations</th>
                    <th style="width: 35%; ${wrapStyle}">Notes</th>
                    <th style="width: 6%; ${cellStyle}">MIS ID</th>
                    <th style="width: 5%; ${cellStyle}">Action</th>`;
            }
            
            table += `</tr></thead><tbody>`;

            rows.forEach(row => {
                const sectionColors = { 'weekly': 'primary', 'monthly': 'info', 'sale': 'warning' };
                const badge = `<span class="badge bg-${sectionColors[row.section] || 'secondary'}">${row.section.charAt(0).toUpperCase()}</span>`; // Abbreviated Badge
                
                // Stack Date/Weekday Values
                let dateDisplay = row.weekday_raw || '-';
                if (dateDisplay.includes(',')) {
                    dateDisplay = dateDisplay.replace(/,\s*/g, '<br>');
                }

                // Color Code Locations
                let locText = row.locations || '-';
                let locStyle = 'color: #fd7e14;'; 
                if (locText.includes('All Locations Except')) {
                    locStyle = 'color: #dc3545; font-weight: bold;'; 
                } else if (locText.trim() === 'All Locations') {
                    locStyle = 'color: #198754; font-weight: bold;'; 
                }

                const truncate = (t, l) => t && t.length > l ? t.substring(0, l) + '...' : (t || '-');
                
                // Truncate based on width
                const notes = row.notes ? `<span title="${row.notes.replace(/"/g, '&quot;')}">${truncate(row.notes, 45)}</span>` : '-';
                const locDisplay = `<span style="${locStyle}" title="${locText.replace(/"/g, '&quot;')}">${truncate(locText, 35)}</span>`;
                
                let misLink = '-';
                if(row.mis_id && row.mis_id !== '-') {
                    misLink = row.mis_id.split(',').map(id => 
                        `<a href="#" onclick="lookupMisId('${id.trim()}'); return false;" style="font-weight:bold; text-decoration:underline;">${id.trim()}</a>`
                    ).join(', ');
                }

                table += `<tr>`;
                if (showConflictDate) table += `<td style="${cellStyle}"><span class="badge bg-danger">${row.conflict_date}</span></td>`;
                table += `
                    <td style="${cellStyle}">${badge}</td>
                    <td style="${cellStyle} text-align:center; font-weight:bold;">${row.row_num}</td>
                    <td style="${wrapStyle} line-height: 1.1;">${dateDisplay}</td>
                    <td style="${cellStyle}">${row.discount}</td>
                    <td style="${cellStyle}">${row.vendor_contrib}</td>
                    <td style="${wrapStyle}">${locDisplay}</td>
                    <td style="${wrapStyle}">${notes}</td>
                    <td style="${cellStyle}">${misLink}</td>
                    <td style="${cellStyle}"><button class="btn btn-sm btn-outline-primary py-0 px-1" style="font-size: 0.8em;" onclick="openSheetRow(${row.row_num})">Row ->[EMOJI][EMOJI]√É‚Äö√Ç¬ù</button></td>
                </tr>`;
            });
            table += `</tbody></table>`;
            return table;
        }

        function initTooltips() {
            setTimeout(function() {
                var tooltipTriggerList = [].slice.call(document.querySelectorAll('[title]'));
                tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl);
                });
            }, 500);
        }

        // ============================================
        // CLEANUP AUDIT - Find stale MIS entries
        // ============================================
        let cleanupAuditData = { fullMatch: [], idOnly: [] };
        
        function switchCleanupMethod(method, btnElement) {
            // Hide all method contents
            document.querySelectorAll('.cleanup-method-content').forEach(el => {
                el.style.display = 'none';
            });
            
            // Deactivate all tabs
            document.querySelectorAll('#cleanupMethodTabs .nav-link').forEach(el => {
                el.classList.remove('active');
            });
            
            // Show selected method
            const targetEl = document.getElementById('cleanup-method-' + method);
            if (targetEl) {
                targetEl.style.display = 'block';
            }
            
            // Activate button
            if (btnElement) {
                btnElement.classList.add('active');
            }
        }
        
        function filterCleanupSection(method, section, btnElement) {
            const containerId = method === 'full-match' ? 'cleanup-full-match-results' : 'cleanup-id-only-results';
            const tabsId = method === 'full-match' ? 'cleanupFullMatchSectionTabs' : 'cleanupIdOnlySectionTabs';
            
            // Update active state on pills
            document.querySelectorAll(`#${tabsId} .nav-link`).forEach(el => {
                el.classList.remove('active');
            });
            if (btnElement) {
                btnElement.classList.add('active');
            }
            
            // Filter rows in the table
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const rows = container.querySelectorAll('tbody tr[data-section]');
            rows.forEach(row => {
                const rowSection = row.getAttribute('data-section');
                if (section === 'all' || rowSection === section) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Update visible count
            const visibleCount = container.querySelectorAll('tbody tr[data-section]:not([style*="display: none"])').length;
            const countBadge = container.querySelector('.cleanup-count-badge');
            if (countBadge) {
                countBadge.textContent = visibleCount + ' entries';
            }
        }
        
        async function runCleanupAudit() {
            const statsEl = document.getElementById('cleanup-audit-stats');
            const fullMatchResultsEl = document.getElementById('cleanup-full-match-results');
            const idOnlyResultsEl = document.getElementById('cleanup-id-only-results');
            
            statsEl.textContent = 'Scanning...';
            statsEl.className = 'badge bg-warning fs-6 me-2';
            fullMatchResultsEl.innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary"></div><div class="mt-2">Scanning MIS CSV for stale entries...</div></div>';
            idOnlyResultsEl.innerHTML = '<div class="text-center p-4"><div class="spinner-border text-primary"></div><div class="mt-2">Scanning MIS CSV for stale entries...</div></div>';
            
            try {
                const tab = document.getElementById('mis-tab').value;
                if (!tab) {
                    alert('Please select a sheet tab in Setup first');
                    statsEl.textContent = 'Ready';
                    statsEl.className = 'badge bg-secondary fs-6 me-2';
                    fullMatchResultsEl.innerHTML = '<p class="text-muted">Select a sheet tab first.</p>';
                    idOnlyResultsEl.innerHTML = '<p class="text-muted">Select a sheet tab first.</p>';
                    return;
                }
                
                const formData = new FormData();
                formData.append('tab', tab);
                
                if (misData.csvFile) {
                    formData.append('csv', misData.csvFile);
                } else if (misData.localPath) {
                    formData.append('local_csv_path', misData.localPath);
                }
                
                const response = await fetch('/api/mis/cleanup-audit', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();
                
                if (data.success) {
                    cleanupAuditData = data.results;
                    const totalIssues = (data.results.fullMatch?.length || 0) + (data.results.idOnly?.length || 0);
                    statsEl.textContent = totalIssues + ' potential issues';
                    statsEl.className = totalIssues > 0 ? 'badge bg-danger fs-6 me-2' : 'badge bg-success fs-6 me-2';
                    renderCleanupResults('full-match', data.results.fullMatch || []);
                    renderCleanupResults('id-only', data.results.idOnly || []);
                } else {
                    statsEl.textContent = 'Error';
                    statsEl.className = 'badge bg-danger fs-6 me-2';
                    fullMatchResultsEl.innerHTML = `<div class="alert alert-danger">Error: ${data.error}</div>`;
                    idOnlyResultsEl.innerHTML = `<div class="alert alert-danger">Error: ${data.error}</div>`;
                }
            } catch (error) {
                statsEl.textContent = 'Error';
                statsEl.className = 'badge bg-danger fs-6 me-2';
                fullMatchResultsEl.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
                idOnlyResultsEl.innerHTML = `<div class="alert alert-danger">Error: ${error.message}</div>`;
            }
        }
        
        function renderCleanupResults(method, results) {
            const containerId = method === 'full-match' ? 'cleanup-full-match-results' : 'cleanup-id-only-results';
            const container = document.getElementById(containerId);
            
            if (!results || results.length === 0) {
                container.innerHTML = `<div class="alert alert-success"><i class="bi bi-check-circle"></i> No stale entries found using ${method === 'full-match' ? 'Full Field Match' : 'MIS ID Only'} detection.</div>`;
                return;
            }
            
            // Count by section
            const sectionCounts = { weekly: 0, monthly: 0, sale: 0 };
            results.forEach(r => {
                const section = (r.section || 'weekly').toLowerCase();
                if (sectionCounts.hasOwnProperty(section)) {
                    sectionCounts[section]++;
                }
            });
            
            let html = `<div class="d-flex justify-content-between align-items-center mb-2">
                <span class="cleanup-count-badge badge bg-danger">${results.length} entries</span>
                <small class="text-muted">Weekly: ${sectionCounts.weekly} | Monthly: ${sectionCounts.monthly} | Sale: ${sectionCounts.sale}</small>
            </div>`;
            
            html += `<div class="table-responsive"><table class="table table-sm table-bordered table-hover">
                <thead class="table-dark">
                    <tr>
                        <th style="width:80px;">MIS ID</th>
                        <th style="width:150px;">Brand</th>
                        <th style="width:80px;">Weekday</th>
                        <th style="width:70px;">Discount</th>
                        <th style="width:70px;">Vendor %</th>
                        <th style="width:150px;">Locations</th>
                        <th style="width:90px;">Start Date</th>
                        <th style="width:90px;">End Date</th>
                        <th style="width:80px;">Section</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>`;
            
            results.forEach((r, idx) => {
                const section = (r.section || 'weekly').toLowerCase();
                const sectionBadgeClass = section === 'weekly' ? 'bg-primary' : (section === 'monthly' ? 'bg-success' : 'bg-warning text-dark');
                
                // Format locations with numbered tooltip
                const locs = r.locations || 'All Locations';
                const locParts = locs.split(',').map(l => l.trim()).filter(l => l);
                const locDisplay = locParts.slice(0, 2).join('<br>') + (locParts.length > 2 ? '<br>...' : '');
                const locTooltip = locParts.map((l, i) => (i + 1) + '. ' + l).join('&#10;');
                
                // Format weekday vertically
                const weekday = r.weekday || '-';
                const weekdayParts = weekday.split(',').map(w => w.trim()).filter(w => w);
                const weekdayDisplay = weekdayParts.slice(0, 3).join('<br>') + (weekdayParts.length > 3 ? '<br>...' : '');
                const weekdayTooltip = weekdayParts.join('&#10;');
                
                // Status styling
                let statusHtml = '';
                if (r.status === 'NOT_IN_SHEET') {
                    statusHtml = '<span class="badge bg-danger">NOT IN SHEET</span>';
                } else if (r.status === 'PARTIAL_MATCH') {
                    statusHtml = `<span class="badge bg-warning text-dark" title="${r.partial_match_details || ''}">PARTIAL MATCH</span>`;
                    if (r.partial_match_details) {
                        statusHtml += `<br><small class="text-muted">${r.partial_match_details}</small>`;
                    }
                } else if (r.status === 'ID_NOT_TRACKED') {
                    statusHtml = '<span class="badge bg-info">ID NOT TRACKED</span>';
                } else {
                    statusHtml = `<span class="badge bg-secondary">${r.status || 'UNKNOWN'}</span>`;
                }
                
                html += `<tr data-section="${section}">
                    <td>
                        <button class="btn btn-sm btn-outline-secondary py-0 px-2" 
                                onclick="lookupMisId('${r.mis_id}')" 
                                style="font-weight:bold;" 
                                title="Click to lookup in MIS">
                            ${r.mis_id}
                        </button>
                    </td>
                    <td>${r.brand || '-'}</td>
                    <td title="${weekdayTooltip}" style="font-size:0.85em;">${weekdayDisplay}</td>
                    <td>${r.discount || '-'}%</td>
                    <td>${r.vendor_pct || '-'}%</td>
                    <td title="${locTooltip}" style="font-size:0.85em;">${locDisplay}</td>
                    <td>${r.start_date || '-'}</td>
                    <td>${r.end_date || '-'}</td>
                    <td><span class="badge ${sectionBadgeClass}">${section.toUpperCase()}</span></td>
                    <td>${statusHtml}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

async function runConflictAudit() {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Scanning...';
        
        document.getElementById('conflict-results').innerHTML = '';
        document.getElementById('conflict-stats').innerText = 'Scanning...';

        try {
            const formData = new FormData();
            // Attach active CSV if available
            if (misData.csvFile) {
                formData.append('csv', misData.csvFile);
            } else if (misData.localPath) {
                formData.append('local_csv_path', misData.localPath);
            } else if (misData.mis_csv_filename) {
                 // Fallback if we stored filename but logic needs path
                 formData.append('local_csv_path', misData.pulledCSVPath);
            }

            const response = await fetch('/api/mis/conflict-audit', {
                method: 'POST',
                body: formData
            });
            const data = await response.json();

            if (data.success) {
                renderConflictResults(data.conflicts);
                document.getElementById('conflict-stats').innerText = 
                    `${data.conflict_groups} Conflict Groups Found (${data.total_active} Active Deals Scanned)`;
            } else {
                alert('Error: ' + data.error);
                document.getElementById('conflict-stats').innerText = 'Error';
            }
        } catch (e) {
            alert('Network Error: ' + e.message);
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

    function renderConflictResults(conflicts) {
        const containerId = 'conflict-results';
        const container = document.getElementById(containerId);
        
        // Note: Conflict audit doesn't categorize by deal type (weekly/monthly/sale)
        // It groups by Brand/Weekday conflicts across all deal types
        const conflictCount = conflicts ? conflicts.length : 0;
        
        // Header with sub-tabs
        let headerHtml = '<h3>Conflict Analysis Results</h3>';
        
        // Generate deal type tabs with informational counts
        // Since conflicts aren't categorized by type, we show N/A for individual types
        headerHtml += `
            <div class="deal-type-tabs">
                <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'weekly', this)">
                    &#x1F4C5; Weekly Deals <span class="badge bg-secondary">N/A</span>
                </button>
                <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'monthly', this)">
                     Monthly Deals <span class="badge bg-secondary">N/A</span>
                </button>
                <button class="deal-type-btn" onclick="switchDealTypeTab('${containerId}', 'sale', this)">
                     Sale Deals <span class="badge bg-secondary">N/A</span>
                </button>
                <button class="deal-type-btn active" onclick="switchDealTypeTab('${containerId}', 'all', this)">
                     All Conflicts <span class="badge bg-warning text-dark">${conflictCount} groups</span>
                </button>
            </div>
        `;
        
        // Info message for individual deal type tabs
        const infoMessage = `
            <div class="alert alert-info">
                <i class="bi bi-info-circle"></i> 
                <strong>Note:</strong> Conflict detection works across all deal types. Conflicts are grouped by 
                <strong>Brand + Weekday</strong> regardless of whether they are Weekly, Monthly, or Sale deals.
                <br><br>
                View the <strong>"All Conflicts"</strong> tab to see all detected conflicts.
            </div>
        `;
        
        // Build content for "All" tab
        let allContent = '';
        
        if (!conflicts || conflicts.length === 0) {
            allContent = `
                <div class="text-center p-5 text-muted" style="background:#f8f9fa; border-radius:10px;">
                    <h3 style="color:#28a745;"><i class="bi bi-check-circle-fill"></i> No Conflicts Found!</h3>
                    <p>All active deals appear unique based on Brand/Discount/Category/Weekday.</p>
                </div>`;
        } else {
            allContent = '<div class="accordion" id="conflictAccordion">';
            
            conflicts.forEach((group, idx) => {
                const groupID = `conflictGroup${idx}`;
                
                allContent += `
                <div class="card mb-3 shadow-sm" style="border-left: 5px solid #ffc107;">
                    <div class="card-header bg-white" id="heading${idx}">
                        <div class="d-flex justify-content-between align-items-center" 
                             style="cursor:pointer;" 
                             data-bs-toggle="collapse" 
                             data-bs-target="#${groupID}">
                            
                            <div>
                                <span class="badge bg-warning text-dark me-2">${group.count} Conflicts</span>
                                <span class="fw-bold" style="font-size:1.1em;">${group.title}</span>
                            </div>
                            <i class="bi bi-chevron-down text-muted"></i>
                        </div>
                    </div>

                    <div id="${groupID}" class="collapse show" data-bs-parent="#conflictAccordion">
                        <div class="card-body p-0">
                            <table class="table table-sm table-hover mb-0" style="font-size:0.9em;">
                                <thead class="table-light">
                                    <tr>
                                        <th>MIS ID</th>
                                        <th>Start Date</th>
                                        <th>End Date</th>
                                        <th>Locations</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                
                group.rows.forEach(row => {
                    const actionBtn = `<button class="btn btn-sm btn-outline-primary py-0" onclick="lookupMisId('${row.mis_id}')">View ${row.mis_id}</button>`;

                    allContent += `
                                    <tr>
                                        <td class="fw-bold text-primary">${row.mis_id}</td>
                                        <td>${row.start}</td>
                                        <td>${row.end}</td>
                                        <td>${row.locations}</td>
                                        <td>${actionBtn}</td>
                                    </tr>`;
                });

                allContent += `       </tbody>
                            </table>
                        </div>
                    </div>
                </div>`;
            });

            allContent += '</div>';
        }
        
        // Build final HTML with containers
        let finalHtml = headerHtml;
        finalHtml += `<div id="${containerId}-weekly" class="deal-type-content">${infoMessage}</div>`;
        finalHtml += `<div id="${containerId}-monthly" class="deal-type-content">${infoMessage}</div>`;
        finalHtml += `<div id="${containerId}-sale" class="deal-type-content">${infoMessage}</div>`;
        finalHtml += `<div id="${containerId}-all" class="deal-type-content active" style="display:block;">${allContent}</div>`;
        
        container.innerHTML = finalHtml;
    }

async function navBlaze(type, id) {
            let url = "";
            // Use the specific Setup Anchor
            if (type === 'promo') url = `https://retail.blaze.me/company-promotions/promotions/${id}#setup`;
            if (type === 'coll') url = `https://retail.blaze.me/company-promotions/smart-collections/${id}`;
            
            await fetch('/api/blaze/navigate', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ url: url })
            });
        }

// --- OTD Price Modal Logic (With Marketing Audit) ---
function showOtdModal(rowIndex) {
    // 1. Get row data from global storage
    const row = blazeData.currentRows[rowIndex];
    if (!row) return;

    // 2. Parse Base Price
    const discountValueStr = String(row['Discount Value']).replace(/[^0-9.-]/g, '');
    const discValue = parseFloat(discountValueStr);
    
    if (isNaN(discValue)) {
        alert("Invalid price value");
        return;
    }

    // 3. Prepare Modal Elements
    const modal = document.getElementById('detailModal');
    const backdrop = document.getElementById('detailModalBackdrop');
    
    document.getElementById('detailModalTitle').textContent = "OTD Price Breakdown";
    document.getElementById('detailModalId').textContent = `Base Price: $${discValue.toFixed(2)}`;
    document.getElementById('detailModalType').textContent = row.Name;

    // 4. Determine Applicable Stores
    let applicableStores = [];
    const locRaw = row.Locations || '';
    
    const ALL_LOCATIONS_LIST = [
        "Beverly Hills", "Davis", "Dixon", "El Sobrante", "Fresno (Palm)",
        "Fresno Shaw", "Hawthorne", "Koreatown", "Laguna Woods", 
        "Oxnard", "Riverside", "West Hollywood"
    ];

    if (locRaw === 'All Locations') {
        applicableStores = ALL_LOCATIONS_LIST;
    } else {
        applicableStores = locRaw.split(',').map(l => l.trim()).filter(l => l);
    }

// --- MARKETING AUDIT SETUP ---
    let targetOtd = null;
    let skipAudit = false;
    
    // Check for Exclusion Verbiage
    if (/BOGO|B2G1/i.test(row.Name)) {
        skipAudit = true;
    } else {
        // Regex for "4 for $20", "2 for 30", etc.
        const bulkMatch = row.Name.match(/(\d+)\s+for\s+\$([0-9.]+)/i);
        if (bulkMatch) {
            // FIX: Use total price directly (Group 2)
            targetOtd = parseFloat(bulkMatch[2]);
        }
    }

    // 5. Build Content HTML
    let bodyHTML = '<div class="section-header" style="color: #28a745;"> OUT THE DOOR PRICES</div>';
    
    if (typeof TAX_RATES === 'undefined' || Object.keys(TAX_RATES).length === 0) {
        bodyHTML += '<div class="alert alert-warning">Tax rates not loaded yet. Please wait or check Setup tab.</div>';
    } else {
        const sortedStores = Object.keys(TAX_RATES).sort();
        let foundAny = false;

        sortedStores.forEach(store => {
            const isApplicable = applicableStores.some(loc => 
                loc.includes(store) || store.includes(loc)
            );

            if (isApplicable) {
                foundAny = true;
                const rate = TAX_RATES[store];
                const otdPrice = (discValue * rate); 
                const otdDisplay = otdPrice.toFixed(2);
                
                // AUDIT LOGIC
                let rowColor = "color:#198754;"; // Default Green
                let auditInfo = "";
                let fixAction = "";

                if (!skipAudit && targetOtd !== null && STRICT_OTD_STORES.includes(store)) {
                    // FIX: Round to 2 decimals BEFORE comparing to catch visual penny variances
                    const otdRounded = parseFloat(otdDisplay);
                    const diff = Math.abs(otdRounded - targetOtd);
                    
                    // Match Logic
                    if (diff < 0.009) {
                        // Exact Match (Green)
                        auditInfo = ` <span style="color:#198754; font-size:0.8em;">([OK][EMOJI] Target: $${targetOtd.toFixed(2)})</span>`;
                    } else if (diff <= 0.019) {
                        // Penny Variance (Orange)
                        rowColor = "color:#fd7e14;";
                        auditInfo = ` <span style="color:#fd7e14; font-size:0.8em;">([!] [EMOJI]√É‚Äö√Ç¬è Target: $${targetOtd.toFixed(2)})</span>`;
                    } else {
                        // Mismatch (Red)
                        rowColor = "color:#dc3545; font-weight:bold;";
                        auditInfo = ` <span style="color:#dc3545; font-size:0.8em;">([X] Target: $${targetOtd.toFixed(2)})</span>`;
                        
                        // Calculate Fix
                        const correctPreTax = (targetOtd / rate).toFixed(2);
                        fixAction = `
                            <button class="btn btn-sm btn-outline-danger" 
                                style="padding: 0px 6px; font-size: 0.75em; margin-left: 10px;" 
                                onclick="copyToClipboard('${correctPreTax}'); this.innerText='Copied!';">
                                Copy Fix: $${correctPreTax}
                            </button>
                        `;
                    }
                }

                bodyHTML += `
                    <div class="data-row" style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #eee; padding:6px 0;">
                        <div>
                            <span class="data-label" style="font-size:1.1em;">${store}</span>
                            ${auditInfo}
                        </div>
                        <div style="display:flex; align-items:center;">
                            <span class="data-value" style="${rowColor} font-size:1.1em;">$${otdDisplay}</span>
                            ${fixAction}
                        </div>
                    </div>`;
            }
        });

        if (!foundAny) {
            bodyHTML += '<div class="data-row">No matching stores found for this promotion configuration.</div>';
        }
    }

    document.getElementById('detailModalBody').innerHTML = bodyHTML;
    modal.style.display = 'block';
    backdrop.style.display = 'block';
}

// --- SHARED RENDER HELPER ---
    async function renderBlazeTable(rows) {
        // [CRITICAL] Store rows globally so buttons can access data by index
        blazeData.currentRows = rows || [];

        // 0. PRE-FETCH TAX RATES (Blocking) - Ensures Audit Logic has data
        let TAX_RATES = {};
        try {
            const response = await fetch('/api/tax-rates');
            const data = await response.json();
            if (data.success) {
                TAX_RATES = data.rates;
            }
        } catch (e) {
            console.error("Failed to pre-fetch tax rates:", e);
        }

// 1. CALCULATE GLOBAL TOTALS
        let totActive = 0;
        let totInactive = 0;
        let totZombie = 0;
        
        if (rows && Array.isArray(rows)) {
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Midnight Local Time
            
            rows.forEach(r => {
                const status = (r.Status || '').trim();
                if (status === 'Active') totActive++;
                else if (status === 'Inactive') totInactive++;
                
                if (status === 'Active') {
                    const endDateStr = (r['End Date'] || '').trim();
                    if (endDateStr) {
                        try {
                            // FIX: Parse strictly as Local Time to avoid UTC shift errors
                            const parts = endDateStr.split('-'); // Assumes YYYY-MM-DD
                            if (parts.length === 3) {
                                const endDate = new Date(parts[0], parts[1] - 1, parts[2]);
                                endDate.setHours(0, 0, 0, 0);
                                
                                // LOGIC: If End Date is STRICTLY LESS than Today, it's a Zombie.
                                // If End Date == Today, it is still running (Active).
                                if (endDate.getTime() < today.getTime()) {
                                    totZombie++;
                                }
                            }
                        } catch (e) {}
                    }
                }
            });
        }

        // Update DOM - Group 1 (Totals)
        document.getElementById('totalCount').innerText = (rows ? rows.length : 0) + " Total Promotions";
        document.getElementById('totalActive').innerText = totActive + " Active";
        document.getElementById('totalInactive').innerText = totInactive + " Inactive";
        document.getElementById('totalZombie').innerText = " " + totZombie + " Zombie";

        // Cleanup old table
        if ($.fn.DataTable.isDataTable('#promotionsTable')) {
            $('#promotionsTable').DataTable().destroy();
        }
        
        const tbody = document.querySelector('#promotionsTable tbody');
        tbody.innerHTML = '';
        
        // Helper: Get ALL location names for comparison
        const ALL_LOCATIONS_LIST = [
            "Beverly Hills", "Davis", "Dixon", "El Sobrante", "Fresno (Palm)", 
            "Fresno Shaw", "Hawthorne", "Koreatown", "Laguna Woods", 
            "Oxnard", "Riverside", "West Hollywood"
        ].sort();
        
        if (rows && Array.isArray(rows)) {
            rows.forEach((row, index) => {
                const tr = document.createElement('tr');
                
                // --- STATUS BADGE LOGIC ---
                const status = (row.Status || '').trim();
                const statusBadge = status === 'Active' 
                    ? '<span class="badge bg-success">Active</span>' 
                    : '<span class="badge bg-danger">Inactive</span>';
                
// --- DAYS UNTIL END CALCULATION ---
                const startDateStr = row['Start Date'] || '';
                const endDateStr = row['End Date'] || '';
                let daysDisplay = '-';
                let isExpired = false;
                
                if (endDateStr && endDateStr !== '') {
                    try {
                        // 1. Setup Dates (Local Time 00:00:00)
                        const today = new Date();
                        today.setHours(0, 0, 0, 0); 
                        
                        // Helper to parse YYYY-MM-DD cleanly to local time
                        const parseLocal = (dateStr) => {
                            if (!dateStr) return null;
                            const parts = dateStr.split('-');
                            if (parts.length === 3) {
                                const d = new Date(parts[0], parts[1] - 1, parts[2]);
                                d.setHours(0, 0, 0, 0);
                                return d;
                            }
                            // Fallback
                            const d = new Date(dateStr);
                            d.setHours(0,0,0,0);
                            return d;
                        };

                        const endDate = parseLocal(endDateStr);
                        const startDate = parseLocal(startDateStr);

                        if (endDate) {
                            // --- NEW: CHECK FOR FUTURE START ---
                            if (startDate && startDate.getTime() > today.getTime()) {
                                // Calculate "Starts in X Days"
                                const startDiff = startDate.getTime() - today.getTime();
                                const daysToStart = Math.round(startDiff / (1000 * 3600 * 24));
                                
                                // Calculate "Runs for X Days"
                                const durationDiff = endDate.getTime() - startDate.getTime();
                                const durationDays = Math.round(durationDiff / (1000 * 3600 * 24));
                                
                                daysDisplay = `<div style="line-height:1.2;">
                                    <span style="color:#0d6efd; font-weight:bold;">Starts in ${daysToStart} Day${daysToStart===1?'':'s'}</span><br>
                                    <span style="color:#6c757d; font-size:0.85em;">Runs for ${durationDays} Day${durationDays===1?'':'s'}</span>
                                </div>`;
                            } 
                            // --- EXISTING LOGIC (Active or Ended) ---
                            else {
                                const diffTime = endDate.getTime() - today.getTime();
                                const diffDays = Math.round(diffTime / (1000 * 3600 * 24));
                                
                                if (diffDays === 0) {
                                    daysDisplay = '<span style="color:#d63384; font-weight:bold;">Ends Today!</span>';
                                } else if (diffDays > 0) {
                                    daysDisplay = `Ends in ${diffDays} Day${diffDays === 1 ? '' : 's'}`;
                                } else {
                                    const absDays = Math.abs(diffDays);
                                    daysDisplay = `Ended ${absDays} Day${absDays === 1 ? '' : 's'} ago`;
                                    isExpired = true;
                                }
                            }
                        }
                    } catch (e) {
                        console.error(e);
                        daysDisplay = 'Invalid Date';
                    }
                }
                
                // --- ROW HIGHLIGHTING ---
                const isExpiredAlt = daysDisplay.includes('Ended') && daysDisplay.includes('ago');

                if (status === 'Active' && (isExpired || isExpiredAlt)) {
                    tr.style.backgroundColor = '#dc3545'; // Bootstrap danger red
                    tr.style.color = '#ffffff'; // White text
                    tr.style.fontWeight = 'bold';
                    tr.style.border = '3px solid #a02030';
                } else if (status === 'Inactive') {
                    tr.style.backgroundColor = '#f4cccc'; // Light pink
                }

                if (isExpiredAlt && !isExpired && status === 'Active') {
                    tr.style.color = '#dc3545'; 
                    tr.style.fontWeight = 'bold';
                }
                
                // --- ID COLUMN ---
                const idButton = `
                    <button onclick="navBlaze('promo', '${row.ID}'); return false;" 
                            class="btn btn-sm btn-primary" 
                            style="font-size: 0.75rem; padding: 2px 8px;"
                            title="ID: ${row.ID}">
                        View Discount
                    </button>
                `;
                
                // --- LOCATIONS SIMPLIFICATION ---
                let locationsRaw = row.Locations || '';
                let locationsDisplay = '';
                let applicableStores = [];

                if (locationsRaw === 'All Locations') {
                    applicableStores = ALL_LOCATIONS_LIST;
                    const tooltipHTML = ALL_LOCATIONS_LIST.join('<br>');
                    locationsDisplay = `<span class="badge bg-info text-white" 
                                              style="cursor: help;" 
                                              data-bs-toggle="tooltip" 
                                              data-bs-html="true" 
                                              data-bs-placement="right"
                                              title="${tooltipHTML}">All Locations</span>`;
                } else {
                    applicableStores = locationsRaw.split(',').map(l => l.trim()).filter(l => l);
                    let displayText = locationsRaw;
                    if (displayText.length > 50) {
                        displayText = displayText.substring(0, 47) + '...';
                    }
                    const locationsList = locationsRaw.split(',').map(l => l.trim()).filter(l => l).sort();
                    const tooltipHTML = locationsList.join('<br>');
                    
                    locationsDisplay = `<span style="cursor: help; text-decoration: underline dotted;" 
                                              data-bs-toggle="tooltip" 
                                              data-bs-html="true" 
                                              data-bs-placement="right"
                                              title="${tooltipHTML}">${displayText}</span>`;
                }
                
                // --- DETAIL COLUMN ---
                const detailCell = `<button 
                    class="btn btn-sm btn-outline-secondary py-0 px-2"
                    style="font-size: 0.75rem; font-weight: bold;" 
                    onmouseenter="showDetailModal(blazeData.currentRows[${index}], false)"
                    onmouseleave="hideDetailModal()"
                    onclick="toggleDetailPin(blazeData.currentRows[${index}]); event.stopPropagation();">
                    DETAIL
                </button>`;
                
                // --- AUTO/MANUAL COLUMN ---
                const autoManualText = row.auto_apply ? 'Automatic' : 'Manual';
                const autoManualColor = row.auto_apply ? '#0066ff' : '#ff8800';
                const autoManualCell = `<span style="color: ${autoManualColor}; font-weight: bold;">${autoManualText}</span>`;
                
                // --- GROUP LINKS ---
                const makeGroupLinks = (groups) => {
                    if (!groups || groups.length === 0) return '-';
                    const list = Array.isArray(groups) ? groups : []; 
                    return list.map(g => {
                        const displayName = g.name.length > 20 ? g.name.substring(0, 20) + '...' : g.name;
                        const fullName = g.name; 
                        return `<a href="#" onclick="navBlaze('coll', '${g.id}'); return false;" 
                           class="badge bg-light text-dark border" 
                           style="margin:1px; text-decoration:none; display:block; width:fit-content; margin-bottom:2px;"
                           title="${fullName}">
                           ${displayName}
                         </a>`;
                    }).join(''); 
                };

// --- DISCOUNT VALUE (BUTTON & AUDIT LOGIC) ---
                let discountValueContent = row['Discount Value'];
                const discType = row['Discount Value Type'] || '';
                const isFinalPrice = discType.toLowerCase().includes('final');
                
                // IF FINAL PRICE: RENDER BUTTON WITH AUDIT
                if (isFinalPrice && discountValueContent && discountValueContent !== '-') {
                    
                    // --- AUDIT LOGIC START ---
                    // Default Style: Blue Text, Blue Border, Tag Emoji
                    let btnStyle = "color:#0d6efd; border:1px solid #0d6efd;"; 
                    let btnEmoji = "";
                    
                    // 1. Check for bulk deal pattern in Name (e.g. "4 for $20")
                    const bulkMatch = row.Name.match(/(\d+)\s+for\s+\$([0-9.]+)/i);
                    const isBogo = /BOGO|B2G1/i.test(row.Name);
                    
                    if (!isBogo && bulkMatch && Object.keys(TAX_RATES).length > 0) {
                        // FIX: Use total price directly from Regex Group 2
                        const targetOtd = parseFloat(bulkMatch[2]);
                        const discValue = parseFloat(String(discountValueContent).replace(/[^0-9.-]/g, ''));
                        
                        let maxDiff = 0;
                        
                        // Check applicable STRICT stores
                        STRICT_OTD_STORES.forEach(strictStore => {
                            // Check if this strict store is in the applicable list for this row
                            const isApplicable = applicableStores.some(loc => 
                                loc.includes(strictStore) || strictStore.includes(loc)
                            );
                            
                            if (isApplicable && TAX_RATES[strictStore]) {
                                const rate = TAX_RATES[strictStore];
                                const calculatedOtd = discValue * rate;
                                // FIX: Round to 2 decimals before comparing
                                const calculatedRounded = parseFloat(calculatedOtd.toFixed(2));
                                const diff = Math.abs(calculatedRounded - targetOtd);
                                if (diff > maxDiff) maxDiff = diff;
                            }
                        });
                        
                        // Determine Style based on worst variance found
                        if (maxDiff >= 0.02) {
                            // Mismatch (> 2 cents): RED TEXT + CAUTION
                            btnStyle = "color:#dc3545; border:1px solid #dc3545;"; 
                            btnEmoji = "[!] [EMOJI]√É‚Äö√Ç¬è";
                        } else if (maxDiff > 0.009) {
                            // Penny Variance: ORANGE TEXT + CAUTION
                            btnStyle = "color:#fd7e14; border:1px solid #fd7e14;"; 
                            btnEmoji = "[!] [EMOJI]√É‚Äö√Ç¬è";
                        }
                    }
                    // --- AUDIT LOGIC END ---

                    // RENDER BUTTON (Using inline styles to force color)
                    discountValueContent = `
                        <button class="btn btn-sm" 
                                style="font-weight:bold; padding:0px 6px; background:white; ${btnStyle}"
                                onclick="showOtdModal(${index})">
                            ${discountValueContent} ${btnEmoji}
                        </button>`;
                }

                tr.innerHTML = `
                    <td>${detailCell}</td>
                    <td>${idButton}</td>
                    <td>${row.Name}</td>
                    <td>${statusBadge}</td>
                    <td>${autoManualCell}</td>
                    <td>${locationsDisplay}</td>
                    <td>${makeGroupLinks(row.buy_groups)}</td>
                    <td>${makeGroupLinks(row.get_groups)}</td>
                    <td>${row['Discount Value Type']}</td>
                    <td>${discountValueContent}</td>
                    <td>${row['Start Date']}</td>
                    <td>${row['End Date']}</td>
                    <td><span style="font-size: 0.85rem; font-style: italic;">${daysDisplay}</span></td>
                `;
                tbody.appendChild(tr);
                
                // Attach row data to detail cell span for event handlers
                const detailSpan = tr.querySelector('td:first-child span');
                if (detailSpan) {
                    detailSpan.rowData = row;
                }
            });
        }
        
        // Initialize DataTable
        const table = $('#promotionsTable').DataTable({ 
            paging: false, 
            scrollY: '60vh', 
            scrollCollapse: false,  // Don't collapse - maintain scroll area
            dom: 't',
            autoWidth: true,
            deferRender: true
        });
        
        // Force redraw if container was hidden during initialization
        const promoContent = document.getElementById('blaze-promo-content');
        if (promoContent && promoContent.style.display !== 'none') {
            setTimeout(function() {
                table.columns.adjust().draw(false);
            }, 50);
        }
        
        // Initialize Bootstrap tooltips
        setTimeout(function() {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        }, 300);

        // 2. SETUP DYNAMIC FILTER COUNTER
        table.on('draw', function () {
            const filteredData = table.rows({ search: 'applied' }).data();
            let filtActive = 0;
            let filtInactive = 0;
            let filtZombie = 0;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            filteredData.each(function (value, index) {
                const statusHTML = String(value[3] || ''); // Index 3 is Status
                const endDateHTML = String(value[11] || ''); // Index 11 is End Date
                
                if (statusHTML.includes('Active')) {
                    filtActive++;
                    const dateMatch = endDateHTML.match(/\d{4}-\d{2}-\d{2}/);
                    if (dateMatch) {
                        try {
                            const endDate = new Date(dateMatch[0]);
                            endDate.setHours(0, 0, 0, 0);
                            // UPDATE: Strict inequality for Zombie count
                            if (endDate < today) {
                                filtZombie++;
                            }
                        } catch (e) {}
                    }
                } else if (statusHTML.includes('Inactive')) {
                    filtInactive++;
                }
            });

            document.getElementById('filteredCount').innerText = filteredData.length + " Total";
            document.getElementById('filteredActive').innerText = filtActive + " Active";
            document.getElementById('filteredInactive').innerText = filtInactive + " Inactive";
            document.getElementById('filteredZombie').innerText = " " + filtZombie + " Zombie";

            const nameFilter = document.getElementById('blazeNameSearch').value;
            const subFilter = document.getElementById('blazeSubSearch').value;
            const filteredGroup = document.getElementById('filteredStatsGroup');
            const downloadFilteredBtn = document.getElementById('downloadFilteredBtn');
            
            // Check if any filter is active (including zombie filter)
            const hasActiveFilter = nameFilter.trim().length > 0 || subFilter.trim().length > 0 || $.fn.dataTable.ext.search.length > 0;
            
            if (hasActiveFilter) {
                filteredGroup.style.display = 'block';
                downloadFilteredBtn.style.display = 'block';
            } else {
                filteredGroup.style.display = 'none';
                downloadFilteredBtn.style.display = 'none';
            }
        });

        table.draw();

        // PERSISTENCE
        const primaryVal = document.getElementById('blazeNameSearch').value;
        const subVal = document.getElementById('blazeSubSearch').value;
        const subContainer = document.getElementById('subSearchContainer');
        
        if (primaryVal.trim().length > 0) {
            subContainer.style.display = 'flex';
            table.column(2).search(primaryVal);  
            table.search(subVal);                 
            table.draw();
        } else if (subVal.trim().length > 0) {
            document.getElementById('blazeSubSearch').value = '';
            subContainer.style.display = 'none';
        }
    }

// 3. FULL REPORT EXPORT FUNCTION
        async function exportData(mode) {
            if (mode === 'full') {
                window.location.href = '/api/blaze/export-csv';
            } else {
                console.log('Export mode not implemented:', mode);
            }
        }

// ============================================
// DOWNLOAD FILTERED - Export visible rows only
// ============================================
async function exportFilteredData() {
    if (!$.fn.DataTable.isDataTable('#promotionsTable')) {
        alert('Table not initialized');
        return;
    }
    
    const table = $('#promotionsTable').DataTable();
    const filteredData = table.rows({ search: 'applied' }).data();
    
    if (filteredData.length === 0) {
        alert('No filtered data to export');
        return;
    }
    
    // Collect visible row IDs
    const visibleIds = [];
    filteredData.each(function(rowData) {
        // Extract ID from the button HTML in column 0 (Detail column has the View Discount button)
        // The ID is in column 1 which contains just the ID text
        const idCell = rowData[1]; // ID column
        // Extract numeric ID from potential HTML or text
        const idMatch = String(idCell).match(/(\d+)/);
        if (idMatch) {
            visibleIds.push(idMatch[1]);
        }
    });
    
    if (visibleIds.length === 0) {
        alert('Could not extract IDs from filtered data');
        return;
    }
    
    // Send to backend for CSV generation
    try {
        const response = await fetch('/api/blaze/export-filtered-csv', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ids: visibleIds })
        });
        
        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `blaze_filtered_report_${new Date().toISOString().slice(0,19).replace(/[:-]/g, '')}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        } else {
            const errorText = await response.text();
            alert('Export failed: ' + errorText);
        }
    } catch (e) {
        alert('Export error: ' + e.message);
    }
}

// ============================================
// ZOMBIE CLEANUP - State Management
// ============================================
let zombieCleanupState = {
    isActive: false,
    isManualMode: false,
    zombieIds: [],
    currentIndex: 0,
    originalFilters: {
        nameFilter: '',
        subFilter: ''
    }
};

function toggleZombieCleanupMode() {
    const toggle = document.getElementById('zombieCleanupToggle');
    const btn = document.getElementById('zombieCleanupBtn');
    
    if (toggle.checked) {
        btn.style.display = 'inline-block';
    } else {
        btn.style.display = 'none';
        // If cleanup was active, reset everything
        if (zombieCleanupState.isActive) {
            finishZombieCleanup();
        }
    }
}

function startZombieCleanup() {
    // Save current filter state
    zombieCleanupState.originalFilters.nameFilter = document.getElementById('blazeNameSearch').value;
    zombieCleanupState.originalFilters.subFilter = document.getElementById('blazeSubSearch').value;
    
    // Find all zombie IDs from the current data
    const zombieIds = findZombieIds();
    
    if (zombieIds.length === 0) {
        alert('No zombie deals found! All active deals have valid end dates.');
        return;
    }
    
    zombieCleanupState.zombieIds = zombieIds;
    zombieCleanupState.currentIndex = 0;
    
    // Update modal count
    document.getElementById('zombieCountDisplay').textContent = zombieIds.length;
    
    // Show modal
    document.getElementById('zombieModalBackdrop').style.display = 'block';
    document.getElementById('zombieModal').style.display = 'block';
    document.getElementById('zombieActionButtons').style.display = 'flex';
    document.getElementById('zombieProgressContainer').style.display = 'none';
}

function findZombieIds() {
            const zombieIds = [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (blazeData.currentRows && Array.isArray(blazeData.currentRows)) {
                blazeData.currentRows.forEach(row => {
                    const status = (row.Status || '').trim();
                    const endDateStr = (row['End Date'] || '').trim();

                    if (status === 'Active' && endDateStr) {
                        try {
                            // FIX: Parse strictly as Local Time
                            const parts = endDateStr.split('-');
                            if (parts.length === 3) {
                                const endDate = new Date(parts[0], parts[1] - 1, parts[2]);
                                endDate.setHours(0, 0, 0, 0);
                                
                                // LOGIC: Only kill if End Date is BEFORE today (Yesterday or older)
                                if (endDate.getTime() < today.getTime()) {
                                    zombieIds.push(row.ID);
                                }
                            }
                        } catch (e) {
                            console.error("Date parse error", e);
                        }
                    }
                });
            }
            return zombieIds;
        }

function applyZombieFilter() {
    if (!$.fn.DataTable.isDataTable('#promotionsTable')) return;
    
    const table = $('#promotionsTable').DataTable();
    
    // Clear existing filters
    document.getElementById('blazeNameSearch').value = '';
    document.getElementById('blazeSubSearch').value = '';
    table.column(2).search('');
    table.search('');
    
    // Apply custom filter for zombies only
    $.fn.dataTable.ext.search.push(function(settings, data, dataIndex) {
        if (settings.nTable.id !== 'promotionsTable') return true;
        
        const statusHTML = data[3] || '';
        const endDateHTML = data[11] || '';
        
        // Must be Active
        if (!statusHTML.includes('Active')) return false;
        
        // Must have end date in past
        const dateMatch = endDateHTML.match(/\d{4}-\d{2}-\d{2}/);
        if (!dateMatch) return false;
        
        try {
            const endDate = new Date(dateMatch[0]);
            const today = new Date();
            endDate.setHours(0, 0, 0, 0);
            today.setHours(0, 0, 0, 0);
            
            return endDate < today;
        } catch (e) {
            return false;
        }
    });
    
    table.draw();
}

function clearZombieFilter() {
    // Remove custom zombie filter
    $.fn.dataTable.ext.search.pop();
    
    if (!$.fn.DataTable.isDataTable('#promotionsTable')) return;
    
    const table = $('#promotionsTable').DataTable();
    table.draw();
}

function runManualCleanup() {
    zombieCleanupState.isActive = true;
    zombieCleanupState.isManualMode = true;
    
    // Hide modal
    document.getElementById('zombieModalBackdrop').style.display = 'none';
    document.getElementById('zombieModal').style.display = 'none';
    
    // Apply zombie filter
    applyZombieFilter();
    
    // Change button to "Finish Cleanup"
    const btn = document.getElementById('zombieCleanupBtn');
    btn.innerHTML = '[OK][EMOJI] Finish Cleanup';
    btn.classList.add('cleanup-mode');
    btn.onclick = finishZombieCleanup;
}

async function runAutoCleanup() {
    zombieCleanupState.isActive = true;
    zombieCleanupState.isManualMode = false;
    zombieCleanupState.currentIndex = 0;
    
    // Show progress, hide buttons
    document.getElementById('zombieActionButtons').style.display = 'none';
    document.getElementById('zombieProgressContainer').style.display = 'block';
    
    // Apply zombie filter to table
    applyZombieFilter();
    
    // Change main button to show in-progress
    const btn = document.getElementById('zombieCleanupBtn');
    btn.innerHTML = '<span class="spin"></span> Processing...';
    btn.disabled = true;
    
    // Process each zombie
    const total = zombieCleanupState.zombieIds.length;
    
    for (let i = 0; i < total; i++) {
        zombieCleanupState.currentIndex = i;
        const promoId = zombieCleanupState.zombieIds[i];
        
        // Update progress
        const percent = Math.round(((i + 1) / total) * 100);
        document.getElementById('zombieProgressFill').style.width = percent + '%';
        document.getElementById('zombieProgressText').textContent = 
            `Processing ${i + 1} of ${total}: ID ${promoId}`;
        
        try {
            const response = await fetch('/api/blaze/zombie-disable', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ promo_id: promoId })
            });
            
            const result = await response.json();
            
            if (!result.success) {
                console.error(`Failed to disable ${promoId}: ${result.error}`);
                document.getElementById('zombieProgressText').textContent = 
                    `[!] [EMOJI]√É‚Äö√Ç¬è Error on ID ${promoId}: ${result.error}. Continuing...`;
                await new Promise(r => setTimeout(r, 2000));
            }
        } catch (e) {
            console.error(`Error disabling ${promoId}:`, e);
            document.getElementById('zombieProgressText').textContent = 
                `[!] [EMOJI]√É‚Äö√Ç¬è Network error on ID ${promoId}. Continuing...`;
            await new Promise(r => setTimeout(r, 2000));
        }
        
        // Small delay between operations
        await new Promise(r => setTimeout(r, 500));
    }
    
    // Complete
    document.getElementById('zombieProgressText').textContent = 
        `[OK][EMOJI] Completed! Disabled ${total} zombie deal(s).`;
    document.getElementById('zombieProgressFill').style.width = '100%';
    document.getElementById('zombieProgressFill').style.background = '#28a745';
    
    // Wait 2 seconds then finish
    await new Promise(r => setTimeout(r, 2000));
    finishZombieCleanup();
    
    // Refresh data
    fetchBlazeData();
}

function cancelZombieCleanup() {
    // Hide modal
    document.getElementById('zombieModalBackdrop').style.display = 'none';
    document.getElementById('zombieModal').style.display = 'none';
    
    // Reset state
    zombieCleanupState.isActive = false;
    zombieCleanupState.zombieIds = [];
}

function finishZombieCleanup() {
    // Clear zombie filter
    clearZombieFilter();
    
    // Hide modal if visible
    document.getElementById('zombieModalBackdrop').style.display = 'none';
    document.getElementById('zombieModal').style.display = 'none';
    
    // Reset progress UI
    document.getElementById('zombieActionButtons').style.display = 'flex';
    document.getElementById('zombieProgressContainer').style.display = 'none';
    document.getElementById('zombieProgressFill').style.width = '0%';
    document.getElementById('zombieProgressFill').style.background = 'linear-gradient(90deg, #dc3545, #fd7e14)';
    
    // Reset button
    const btn = document.getElementById('zombieCleanupBtn');
    btn.innerHTML = ' Zombie Cleanup';
    btn.classList.remove('cleanup-mode');
    btn.onclick = startZombieCleanup;
    btn.disabled = false;
    
    // Restore original filters
    document.getElementById('blazeNameSearch').value = zombieCleanupState.originalFilters.nameFilter;
    document.getElementById('blazeSubSearch').value = zombieCleanupState.originalFilters.subFilter;
    
    // Re-apply original filters
    applyBlazeFilters();
    
    // Reset state
    zombieCleanupState.isActive = false;
    zombieCleanupState.isManualMode = false;
    zombieCleanupState.zombieIds = [];
    zombieCleanupState.currentIndex = 0;
}

        document.addEventListener('click', function(event) {
            const tooltip = document.getElementById('suggestion-tooltip');
            if (!event.target.closest('.suggestion-indicator') && !event.target.closest('.tooltip-container')) {
                tooltip.style.display = 'none';
            }
            
            const brandPopup = document.getElementById('brand-sticky-popup');
            if (!event.target.closest('.brand-multi') && !event.target.closest('.brand-popup')) {
                brandPopup.style.display = 'none';
            }
        });

        let hasAutoSynced = false; // Flag to prevent looping

        async function checkBrowserStatus() {
            try {
                const response = await fetch('/api/browser-status');
                const data = await response.json();
                
                const statusDiv = document.getElementById('browser-ready-status');
                const statusText = document.getElementById('browser-ready-text');
                
                if (data.ready) {
                    statusDiv.className = 'alert alert-success';
                    statusDiv.style.display = 'block';
                    statusText.textContent = 'Ready!';
                    
                    // v10.7: REMOVED AUTO-SYNC - was causing browser crash by opening Blaze tabs
                    // User should manually click "Initialize Browser" or "Refresh / Sync Data"
                    // when they're ready to connect to Blaze
                    console.log("[STARTUP] Browser Ready. Auto-sync disabled - use manual sync.");
                } else {
                    statusDiv.className = 'alert alert-info';
                    statusDiv.style.display = 'block';
                    statusText.textContent = 'Initializing...';
                    setTimeout(checkBrowserStatus, 1000);
                }
            } catch (error) {
                setTimeout(checkBrowserStatus, 2000);
            }
        }
        
// --- BLAZE FILTER LOGIC ---
        function handlePrimaryInput() {
            const primaryVal = document.getElementById('blazeNameSearch').value;
            const subContainer = document.getElementById('subSearchContainer');
            const subInput = document.getElementById('blazeSubSearch');

            if (primaryVal.trim().length > 0) {
                subContainer.style.display = 'flex';
            } else {
                subContainer.style.display = 'none';
                subInput.value = ''; 
            }
            applyBlazeFilters();
        }

// 2. Applies both filters to the DataTable
        function applyBlazeFilters() {
            if (!$.fn.DataTable.isDataTable('#promotionsTable')) return;
            
            const table = $('#promotionsTable').DataTable();
            const primaryVal = document.getElementById('blazeNameSearch').value;
            const subVal = document.getElementById('blazeSubSearch').value;
            
            // Step 1: Apply Name Filter (Column 2) - v63 FIX: Column index changed after adding Detail column
            // Column 0 = Detail, Column 1 = ID, Column 2 = Name
            table.column(2).search(primaryVal);
            
            // Step 2: Apply Global "Sub" Search
            // This searches WITHIN the results remaining from Step 1
            table.search(subVal);
            
            // Step 3: Draw once to show the final result
            table.draw();
        }


        async function fetchBlazeData(isAuto = false) {
            const btn = document.querySelector("button[onclick='fetchBlazeData()']");
            const statusDiv = document.getElementById('blaze-sync-status');
            
            // UI Feedback
            if (btn) { 
                btn.disabled = true; 
                btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> ' + (isAuto ? 'Auto-Syncing...' : 'Syncing...'); 
            }
            if (isAuto && statusDiv) {
                statusDiv.innerHTML = '<span class="text-muted">Checking Blaze Token...</span>';
            }
            
            try {
                const response = await fetch('/api/blaze/refresh');
                if (!response.ok) throw new Error("Server Error");
                const data = await response.json();
                
                if (data.success) {
                    renderBlazeTable(data.data);
                    lastUpdateTS = Date.now() / 1000; 
                    if (isAuto) {
                        console.log("[AUTO] Sync successful.");
                        if(statusDiv) statusDiv.innerHTML = '<span class="text-success fw-bold">[OK] Connected</span>';
                    }
                } else {
                    // ERROR HANDLING
                    const errorMsg = data.message || "Unknown Error";
                    
                    if (isAuto) {
                        console.log("[AUTO] Sync failed: " + errorMsg);
                        // Notify user in the setup tab without popup
                        if(statusDiv) {
                            statusDiv.innerHTML = `<span class="text-danger fw-bold">[!] [EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è ${errorMsg}</span>`;
                        }
                    } else {
                        alert("Sync Failed: " + errorMsg);
                    }
                }
            } catch (e) {
                if (!isAuto) alert('Sync Error: ' + e.message);
                if (isAuto && statusDiv) statusDiv.innerHTML = `<span class="text-danger">Error: ${e.message}</span>`;
            } finally {
                if (btn) { 
                    btn.disabled = false; 
                    btn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Refresh / Sync Data'; 
                }
            }
        }

        // --- BACKGROUND UPDATE (THE POLL) ---
        async function loadTableFromCache() {
            try {
                const response = await fetch('/api/blaze/get-cache');
                if (!response.ok) return;
                const data = await response.json();
                if (data.success) {
                    console.log("Background update applied.");
                    renderBlazeTable(data.data);
                    lastUpdateTS = data.ts; 
                }
            } catch (e) { console.log("Background load error:", e); }
        }

        // --- AUTO REFRESH POLLING ---
        let lastUpdateTS = Date.now() / 1000;
        setInterval(() => {
            // Only poll promotions if we're on Blaze tab AND not viewing Inventory
            // AND not running zombie cleanup automation
            const invContent = document.getElementById('blaze-inv-content');
            const isInventoryVisible = invContent && invContent.style.display !== 'none';
            const isZombieCleanupActive = zombieCleanupState && zombieCleanupState.isActive && !zombieCleanupState.isManualMode;
            
            if (currentMainTab === 'blaze' && !isInventoryVisible && !isZombieCleanupActive) {
                fetch(`/api/blaze/poll-update?ts=${lastUpdateTS}`)
                    .then(r => r.json())
                    .then(data => {
                        if (data.update) loadTableFromCache(); 
                    })
                    .catch(e => console.log("Poll error:", e));
            }
        }, 2000);
// Initialize
        window.addEventListener('load', function() {
            checkBrowserStatus();
            setupSearchEnhancements();
            autoLoadCredentials(); // Auto-fill credentials from config file
            autoAuthenticateGoogle(); // Auto-authenticate Google Sheets
            loadMisReportsFolderPath(); // v10.7: Show MIS reports folder path
            autoSyncBlazeData(); // v12.1: Auto-sync Company Promotions if token exists
        });
        
        // v12.1: Auto-sync Blaze data if token is available
        async function autoSyncBlazeData() {
            console.log('[AUTO-SYNC] Checking for Blaze token...');
            try {
                // Wait a bit for page to fully load
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // Check if we have Blaze credentials/token by calling the refresh endpoint
                const response = await fetch('/api/blaze/refresh');
                const data = await response.json();
                
                if (data.success) {
                    console.log('[AUTO-SYNC] Blaze data synced successfully on startup');
                    renderBlazeTable(data.data);
                    
                    // Update status in Setup tab
                    const statusDiv = document.getElementById('blaze-sync-status');
                    if (statusDiv) {
                        statusDiv.innerHTML = '<span class="text-success fw-bold">[OK] Auto-synced on startup</span>';
                    }
                } else {
                    console.log('[AUTO-SYNC] Blaze sync skipped:', data.message || 'No token or error');
                }
            } catch (error) {
                console.log('[AUTO-SYNC] Blaze auto-sync not available:', error.message);
            }
        }

// --- NEW FOCUS LOGIC ---
        function toggleFocus(type) {
            const isEnabled = document.getElementById(`${type}-focus-enable`).checked;
            const controls = document.getElementById(`${type}-focus-controls`);
            const panel = document.getElementById(`${type}-focus-panel`);
            
            if (isEnabled) {
                controls.style.opacity = '1';
                controls.style.pointerEvents = 'auto';
                panel.classList.add('active');
            } else {
                controls.style.opacity = '0.5';
                controls.style.pointerEvents = 'none';
                panel.classList.remove('active');
            }
        }



/* ==================================================================
   BLAZE DETAIL MODAL - Dual-State JavaScript (Hover + Pin)
   ================================================================== */
let detailModalState = {
    isPinned: false,
    currentPromoId: null,
    hoverTimeout: null
};

function showDetailModal(row, isPinned = false) {
    const modal = document.getElementById('detailModal');
    const backdrop = document.getElementById('detailModalBackdrop');
    
    if (!modal || !backdrop) {
        console.error('[DETAIL] Modal elements not found');
        return;
    }
    
    // Update modal content
    document.getElementById('detailModalTitle').textContent = row.Name || 'N/A';
    document.getElementById('detailModalId').textContent = `ID: ${row.ID || 'N/A'}`;
    document.getElementById('detailModalType').textContent = `Type: ${row['Discount Value Type'] || 'N/A'}`;
    
    // Build body content
    let bodyHTML = '';
    
    // SETUP SECTION
    bodyHTML += '<div class="section-header" style="color: #0066cc;"> SETUP</div>';
    bodyHTML += `<div class="data-row"><span class="data-label">Description:</span> ${row.description || 'None'}</div>`;
    
    // Buy Requirements
    if (row.buy_requirements && row.buy_requirements.length > 0) {
        bodyHTML += '<div class="data-row"><span class="data-label">Buy Requirements:</span></div>';
        row.buy_requirements.forEach(req => {
            bodyHTML += `<div class="data-row" style="padding-left: 30px;">&#x2022; Qty: ${req.quantity} | Items: ${req.items.join(', ')}</div>`;
        });
    } else {
        bodyHTML += '<div class="data-row"><span class="data-label">Buy Requirements:</span> None</div>';
    }
    
    bodyHTML += `<div class="data-row"><span class="data-label">Get/Target:</span> ${row.target_type || 'N/A'} - ${row.target_value || 'N/A'}</div>`;
    
    // ADVANCED SECTION
    bodyHTML += '<div class="section-header" style="color: #cc6600;">&#x2699;[EMOJI]√É‚Äö√Ç¬è ADVANCED</div>';
    bodyHTML += `<div class="data-row"><span class="data-label">Auto Apply:</span> ${row.auto_apply ? 'Yes' : 'No'}</div>`;
    bodyHTML += `<div class="data-row"><span class="data-label">Stackable:</span> ${row.stackable ? 'Yes' : 'No'}</div>`;
    bodyHTML += `<div class="data-row"><span class="data-label">Lowest Price First:</span> ${row.apply_lowest_price_first ? 'Yes' : 'No'}</div>`;
    bodyHTML += `<div class="data-row"><span class="data-label">Priority:</span> ${row.priority || '5 - Lowest'}</div>`;
    
    if (row.enable_promo_code) {
        bodyHTML += `<div class="data-row"><span class="data-label">Promo Code:</span> ${row.promo_code || 'N/A'}</div>`;
    }
    
    bodyHTML += `<div class="data-row"><span class="data-label">Max Uses (Total):</span> ${row.max_uses || 'Unlimited'}</div>`;
    bodyHTML += `<div class="data-row"><span class="data-label">Max Uses (Per Member):</span> ${row.max_uses_per_consumer || 'Unlimited'}</div>`;
    
    // Restrictions
    if (row.restrictions) {
        const hasRestrictions = row.restrictions.member_groups.length > 0 || 
                              row.restrictions.consumer_types.length > 0 || 
                              row.restrictions.sales_channels.length > 0;
        if (hasRestrictions) {
            bodyHTML += '<div class="data-row"><span class="data-label">Restrictions:</span></div>';
            if (row.restrictions.member_groups.length > 0) {
                bodyHTML += `<div class="data-row" style="padding-left: 30px;">&#x2022; Member Groups: ${row.restrictions.member_groups.join(', ')}</div>`;
            }
            if (row.restrictions.consumer_types.length > 0) {
                bodyHTML += `<div class="data-row" style="padding-left: 30px;">&#x2022; Consumer Types: ${row.restrictions.consumer_types.join(', ')}</div>`;
            }
            if (row.restrictions.sales_channels.length > 0) {
                bodyHTML += `<div class="data-row" style="padding-left: 30px;">&#x2022; Sales Channels: ${row.restrictions.sales_channels.join(', ')}</div>`;
            }
        }
    }
    
    // SCHEDULE SECTION
    bodyHTML += '<div class="section-header" style="color: #009933;"> SCHEDULE</div>';
    bodyHTML += `<div class="data-row"><span class="data-label">Date Range:</span> ${row['Start Date']} to ${row['End Date']}</div>`;
    
    if (row.time_constraint) {
        if (row.time_constraint.days && row.time_constraint.days.length > 0) {
            bodyHTML += `<div class="data-row"><span class="data-label">Days:</span> ${row.time_constraint.days.join(', ')}</div>`;
        }
        if (row.time_constraint.start_time && row.time_constraint.end_time) {
            bodyHTML += `<div class="data-row"><span class="data-label">Time:</span> ${row.time_constraint.start_time} - ${row.time_constraint.end_time}</div>`;
        }
    }
    
    document.getElementById('detailModalBody').innerHTML = bodyHTML;
    
    // Update state
    detailModalState.isPinned = isPinned;
    detailModalState.currentPromoId = row.ID;
    
    // Show modal
    modal.style.display = 'block';
    if (isPinned) {
        backdrop.style.display = 'block';
    }
}

function hideDetailModal() {
    if (detailModalState.isPinned) {
        return; // Don't hide if pinned
    }
    
    const modal = document.getElementById('detailModal');
    const backdrop = document.getElementById('detailModalBackdrop');
    
    if (modal) modal.style.display = 'none';
    if (backdrop) backdrop.style.display = 'none';
    
    detailModalState.currentPromoId = null;
}

function closeDetailModal() {
    const modal = document.getElementById('detailModal');
    const backdrop = document.getElementById('detailModalBackdrop');
    
    if (modal) modal.style.display = 'none';
    if (backdrop) backdrop.style.display = 'none';
    
    detailModalState.isPinned = false;
    detailModalState.currentPromoId = null;
}

function toggleDetailPin(row) {
    if (detailModalState.isPinned && detailModalState.currentPromoId === row.ID) {
        // Unpin and close
        closeDetailModal();
    } else {
        // Pin or switch to new promo
        if (detailModalState.currentPromoId && detailModalState.currentPromoId !== row.ID) {
            closeDetailModal(); // Close old one
        }
        showDetailModal(row, true); // Open and pin new one
    }
}

// Setup backdrop click handler
document.addEventListener('DOMContentLoaded', function() {
    const backdrop = document.getElementById('detailModalBackdrop');
    if (backdrop) {
        backdrop.addEventListener('click', function() {
            closeDetailModal();
        });
    }
});


    </script>
    
    <!-- BLAZE DETAIL MODAL -->
    <div id="detailModalBackdrop"></div>
    <div id="detailModal">
        <div class="modal-header">
            <button class="close-btn" onclick="closeDetailModal()">X[EMOJI]√É‚Äö√Ç¬ù</button>
            <div class="modal-title" id="detailModalTitle"></div>
            <div class="modal-id" id="detailModalId"></div>
            <div class="modal-type" id="detailModalType"></div>
        </div>
        <div class="modal-body" id="detailModalBody"></div>
    </div>

    <!-- ZOMBIE CLEANUP MODAL -->
    <div id="zombieModalBackdrop" class="zombie-modal-backdrop"></div>
    <div id="zombieModal" class="zombie-modal">
        <h3> Zombie Cleanup Mode</h3>
        <p>
            <strong>Zombie Deals</strong> are promotions that are still <span style="color: #28a745; font-weight: bold;">Active</span> 
            but have an <span style="color: #dc3545; font-weight: bold;">End Date in the past</span>. 
            These should be disabled to prevent confusion.
        </p>
        <p>
            <strong>Found: <span id="zombieCountDisplay">0</span> Zombie Deal(s)</strong>
        </p>
        <div id="zombieActionButtons" class="btn-group-vertical">
            <button onclick="runManualCleanup()" class="btn btn-outline-primary">
                 Run Manual <small style="display:block; font-weight:normal;">(Disable zombies yourself, click "Finish" when done)</small>
            </button>
            <button onclick="runAutoCleanup()" class="btn btn-danger">
                 Run Auto <small style="display:block; font-weight:normal;">(Automatically disable all zombies one-by-one)</small>
            </button>
            <button onclick="cancelZombieCleanup()" class="btn btn-secondary">
                [X] Cancel
            </button>
        </div>
        <div id="zombieProgressContainer" class="zombie-progress-container">
            <div class="zombie-progress-bar">
                <div id="zombieProgressFill" class="zombie-progress-fill"></div>
            </div>
            <div id="zombieProgressText" class="zombie-progress-text">Initializing...</div>
        </div>
    </div>
    
    <!-- v63: TAX CALCULATOR MODAL -->
<div id="calcModal">
        <div class="calc-content">
            <div class="calc-header">
                <h2> Tax Calculator</h2>
                <button class="calc-close" onclick="toggleCalcModal()">X[EMOJI]√É‚Äö√Ç¬ù</button>
            </div>
            
            <div class="store-selector">
                <label for="calcStoreSelect">Select Store (for Tax Calcs):</label>
                <select id="calcStoreSelect" onchange="updateTaxRateDisplay(); runAllCalculations();">
                    <option value="">-- Loading Stores --</option>
                </select>
                <div class="tax-rate-display" id="calcTaxDisplay">Tax Rate: Not selected</div>
            </div>

            <div style="background: #e9ecef; padding: 10px; border-radius: 8px; margin-bottom: 20px;">
                <label for="calcTypeSelect" style="font-weight:bold; display:block; margin-bottom:5px; color:#495057;">Select Tool:</label>
                <select id="calcTypeSelect" class="form-select" onchange="switchCalculator()" style="width:100%; padding:8px; border-radius:4px; border:1px solid #ced4da;">
                    <option value="postTax"> Post-Tax Calculator</option>
                    <option value="preTax"> Pre-Tax Calculator</option>
                    <option value="percent"> Percentage Calculator</option>
                    <option value="rebate"> Vendor Rebate Calculator</option>
                    <option value="reprice"> Correct Percent Off Discount (Pre-Tax)</option>
                </select>
            </div>
            
            <div id="calc-postTax" class="calc-section">
                <h3> Post-Tax Calculator</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">Calculate after-tax price from discount value</p>
                <div class="calc-row">
                    <label>Discount Value:</label>
                    <input type="number" id="postTaxInput" step="0.01" placeholder="e.g., 10.00" oninput="calculatePostTax()">
                </div>
                <div class="calc-row">
                    <label>After Tax:</label>
                    <div class="result" id="postTaxResult">--</div>
                </div>
            </div>
            
            <div id="calc-preTax" class="calc-section" style="display:none;">
                <h3> Pre-Tax Calculator</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">Calculate discount value from after-tax price</p>
                <div class="calc-row">
                    <label>After-Tax Price:</label>
                    <input type="number" id="preTaxInput" step="0.01" placeholder="e.g., 10.98" oninput="calculatePreTax()">
                </div>
                <div class="calc-row">
                    <label>Discount Value:</label>
                    <div class="result" id="preTaxResult">--</div>
                </div>
            </div>
            
            <div id="calc-percent" class="calc-section" style="display:none;">
                <h3> Percentage Calculator</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">Calculate percentage from base and result</p>
                <div class="calc-row">
                    <label>Base Amount:</label>
                    <input type="number" id="percBaseInput" step="0.01" placeholder="e.g., 50.00" oninput="calculatePercentage()">
                </div>
                <div class="calc-row">
                    <label>Result Amount:</label>
                    <input type="number" id="percResultInput" step="0.01" placeholder="e.g., 45.00" oninput="calculatePercentage()">
                </div>
                <div class="calc-row">
                    <label>Percentage Off:</label>
                    <div class="result" id="percResult">--</div>
                </div>
            </div>
            
            <div id="calc-rebate" class="calc-section" style="display:none;">
                <h3> Vendor Rebate Calculator</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">Calculate vendor contribution from discount and rebate percentage</p>
                <div class="calc-row">
                    <label>Discount Value:</label>
                    <input type="number" id="vendorDiscountInput" step="0.01" placeholder="e.g., 10.00" oninput="calculateVendorRebate()">
                </div>
                <div class="calc-row">
                    <label>Rebate %:</label>
                    <input type="number" id="vendorRebateInput" step="0.01" placeholder="e.g., 50" oninput="calculateVendorRebate()">
                </div>
                <div class="calc-row">
                    <label>Vendor Contribution:</label>
                    <div class="result" id="vendorResult">--</div>
                </div>
            </div>

            <div id="calc-reprice" class="calc-section" style="display:none;">
                <h3>[!][EMOJI]√É‚Äö√Ç¬è Reprice / Stack Fixer</h3>
                <p style="color: #6c757d; font-size: 0.9em; margin-bottom: 10px;">
                    Calculate required flat discount to bridge the gap between current price and desired % off. (Example: Is 45% Off but needs to be 50% Off)<br>
                    <strong>(PRE-TAX VALUES ONLY)</strong>
                </p>
                <div class="calc-row">
                    <label>Original Price:</label>
                    <input type="number" id="repriceOriginal" step="0.01" placeholder="Slash-out Price (e.g. 95.51)" oninput="calculateReprice()">
                </div>
                <div class="calc-row">
                    <label>Current Price:</label>
                    <input type="number" id="repriceCurrent" step="0.01" placeholder="Current Price (e.g. 57.31)" oninput="calculateReprice()">
                </div>
                <div class="calc-row">
                    <label>Desired % Off:</label>
                    <input type="number" id="repriceTargetPerc" step="0.1" placeholder="Target % (e.g. 50)" oninput="calculateReprice()">
                </div>
                <div class="calc-row" style="background:#e7f5ff; padding:10px; border-radius:5px; margin-top:10px;">
                    <label style="color:#000;">Flat Discount to Enter:</label>
                    <div class="result" id="repriceResult" style="background:white; border:2px solid #667eea; font-size:1.2em;">--</div>
                </div>
            </div>
        </div>
    </div>

<!-- Register Profile Modal -->
<div class="modal fade" id="registerProfileModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header" style="background: linear-gradient(135deg, #4285F4 0%, #34A853 50%, #FBBC05 75%, #EA4335 100%);">
                <h5 class="modal-title text-white"><i class="bi bi-person-plus"></i> Register New Google Profile</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Step Indicator -->
                <div class="d-flex justify-content-center mb-4">
                    <div id="step-indicator" class="d-flex align-items-center gap-2">
                        <span id="step1-badge" class="badge bg-primary rounded-pill px-3 py-2">1. Enter Handle</span>
                        <i class="bi bi-arrow-right text-muted"></i>
                        <span id="step2-badge" class="badge bg-secondary rounded-pill px-3 py-2">2. Add Credentials</span>
                        <i class="bi bi-arrow-right text-muted"></i>
                        <span id="step3-badge" class="badge bg-secondary rounded-pill px-3 py-2">3. Complete</span>
                    </div>
                </div>

                <!-- Step 1: Enter Handle -->
                <div id="register-step1">
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle"></i> 
                        Enter your <strong>email handle</strong> - the part before the @ symbol.
                        <br><span class="text-muted">Example: For john.doe@company.com, enter <code>john.doe</code></span>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label fw-bold">Email Handle</label>
                        <div class="input-group">
                            <input type="text" id="new-profile-handle" class="form-control form-control-lg" 
                                   placeholder="john.doe" pattern="[a-z0-9._-]+"
                                   oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9._-]/g, '')">
                            <span class="input-group-text text-muted">@email.com</span>
                        </div>
                        <div id="handle-error" class="text-danger mt-2" style="display: none;"></div>
                    </div>
                    
                    <div class="text-center">
                        <button class="btn btn-primary btn-lg px-5" onclick="registerStep1Next()">
                            Next <i class="bi bi-arrow-right"></i>
                        </button>
                    </div>
                </div>

                <!-- Step 2: Add Credentials File -->
                <div id="register-step2" style="display: none;">
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle"></i> 
                        <strong>Credentials file not found!</strong>
                    </div>
                    
                    <div class="card mb-3">
                        <div class="card-header bg-light">
                            <strong>Required File:</strong>
                        </div>
                        <div class="card-body">
                            <code id="expected-creds-path" class="d-block p-2 bg-dark text-light rounded">config/google_credentials/credentials_[handle].json</code>
                        </div>
                    </div>
                    
                    <div class="card mb-3">
                        <div class="card-header bg-light">
                            <strong>How to get this file:</strong>
                        </div>
                        <div class="card-body small">
                            <ol class="mb-0">
                                <li>Go to <a href="https://console.cloud.google.com/" target="_blank">Google Cloud Console</a></li>
                                <li>Create a project and enable <strong>Google Sheets API</strong></li>
                                <li>Go to <strong>OAuth Consent Screen</strong> √É¬¢√¢‚Ç¨¬†√¢‚Ç¨‚Ñ¢ Add your email as a Test User</li>
                                <li>Go to <strong>Credentials</strong> √É¬¢√¢‚Ç¨¬†√¢‚Ç¨‚Ñ¢ Create <strong>OAuth Client ID</strong> (Desktop App)</li>
                                <li>Download the JSON and rename it as shown above</li>
                                <li>Place it in the <code>config/google_credentials/</code> folder</li>
                            </ol>
                        </div>
                    </div>
                    
                    <div class="text-center">
                        <button class="btn btn-outline-secondary me-2" onclick="registerGoBack()">
                            <i class="bi bi-arrow-left"></i> Back
                        </button>
                        <button class="btn btn-success btn-lg px-4" onclick="registerCheckCredentials()">
                            <i class="bi bi-arrow-clockwise"></i> Check Again
                        </button>
                    </div>
                </div>

                <!-- Step 3: Success -->
                <div id="register-step3" style="display: none;">
                    <div class="text-center py-4">
                        <div style="font-size: 4em; color: #34A853;"><i class="bi bi-check-circle-fill"></i></div>
                        <h4 class="text-success mt-3">Profile Registered Successfully!</h4>
                        <p class="text-muted" id="register-success-msg">Profile "john.doe" has been created.</p>
                        <p class="text-muted">The application will restart to load your new profile.</p>
                    </div>
                    
                    <div class="text-center">
                        <button class="btn btn-primary btn-lg px-5" onclick="restartAfterRegister()">
                            <i class="bi bi-power"></i> Restart Now
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- First Run Modal (shown when no profiles exist) -->
<div class="modal fade" id="firstRunModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header" style="background: linear-gradient(135deg, #4285F4 0%, #34A853 50%, #FBBC05 75%, #EA4335 100%);">
                <h5 class="modal-title text-white"><i class="bi bi-stars"></i> Welcome to BLAZE MIS Audit Pro!</h5>
            </div>
            <div class="modal-body text-center py-4">
                <div style="font-size: 3em; color: #4285F4;"><i class="bi bi-person-badge"></i></div>
                <h5 class="mt-3">No Google Profiles Found</h5>
                <p class="text-muted">To get started, you'll need to register a Google account profile.</p>
                <p class="text-muted small">This connects your Google Sheets for deal management.</p>
            </div>
            <div class="modal-footer justify-content-center">
                <button class="btn btn-lg px-5" onclick="openRegisterFromFirstRun()" 
                        style="background: linear-gradient(135deg, #34A853 0%, #4285F4 100%); color: white; font-weight: 600;">
                    <i class="bi bi-plus-lg"></i> Register Profile
                </button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="helpModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header bg-danger text-white">
                    <h5 class="modal-title"><i class="bi bi-life-preserver"></i> System Help & Account Setup</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <!-- Tab Navigation -->
                    <ul class="nav nav-tabs mb-3" id="helpTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="help-troubleshoot-tab" data-bs-toggle="tab" data-bs-target="#help-troubleshoot" type="button" role="tab">
                                <i class="bi bi-wrench"></i> Troubleshooting
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="help-newaccount-tab" data-bs-toggle="tab" data-bs-target="#help-newaccount" type="button" role="tab">
                                <i class="bi bi-person-plus"></i> New Account Setup
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="help-structure-tab" data-bs-toggle="tab" data-bs-target="#help-structure" type="button" role="tab">
                                <i class="bi bi-folder"></i> Folder Structure
                            </button>
                        </li>
                    </ul>

                    <!-- Tab Content -->
                    <div class="tab-content" id="helpTabContent">
                        
                        <!-- TROUBLESHOOTING TAB -->
                        <div class="tab-pane fade show active" id="help-troubleshoot" role="tabpanel">
                            <div class="alert alert-warning">
                                <strong><i class="bi bi-exclamation-triangle"></i> Moving to a new computer?</strong><br>
                                If the script crashes or fails to login on a new machine, delete your profile's <code>chrome_profiles/chrome_[handle]/</code> folder and <code>config/tokens/token_[handle].json</code> file.
                            </div>

                            <h5 class="text-danger mt-4 border-bottom pb-2">Common Fixes</h5>
                            <div class="accordion" id="helpAccordion">
                                <div class="accordion-item">
                                    <h2 class="accordion-header">
                                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#fix1">
                                            Script crashes immediately on startup
                                        </button>
                                    </h2>
                                    <div id="fix1" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                                        <div class="accordion-body">
                                            This usually means the <strong>Chrome Profile</strong> is corrupted. 
                                            <br><strong>Fix:</strong> Delete your profile folder in <code>chrome_profiles/</code> and restart.
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item">
                                    <h2 class="accordion-header">
                                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#fix2">
                                            "Google Login Failed" or 400 Error
                                        </button>
                                    </h2>
                                    <div id="fix2" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                                        <div class="accordion-body">
                                            Your Google session token is invalid.
                                            <br><strong>Fix:</strong> Delete <code>config/tokens/token_[handle].json</code>. Restart the script and re-authorize with Google.
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item">
                                    <h2 class="accordion-header">
                                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#fix3">
                                            "Profile not found" on startup
                                        </button>
                                    </h2>
                                    <div id="fix3" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                                        <div class="accordion-body">
                                            The system scans <code>config/tokens/</code> for existing profiles.
                                            <br><strong>Fix:</strong> Select "Register New Profile" to set up a new account.
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- NEW ACCOUNT SETUP TAB -->
                        <div class="tab-pane fade" id="help-newaccount" role="tabpanel">
                            <div class="alert alert-info">
                                <strong><i class="bi bi-info-circle"></i> Multi-Account System</strong><br>
                                This tool supports multiple Google accounts. Each account uses an "email handle" (the part before @) as its identifier.
                                <br>Example: For <code>john.doe@company.com</code>, the handle is <code>john.doe</code>
                            </div>

                            <h5 class="text-primary mt-4 border-bottom pb-2"><i class="bi bi-cloud"></i> Step 1: Google Cloud Console Setup</h5>
                            <div class="card mb-3">
                                <div class="card-body small">
                                    <ol>
                                        <li>Log into <a href="https://console.cloud.google.com/" target="_blank">Google Cloud Console</a> with your <strong>NEW email</strong>.</li>
                                        <li>Create a <strong>New Project</strong> (e.g., "MIS Audit Tool").</li>
                                        <li>Go to <strong>APIs &amp; Services &gt; Library</strong> and Enable:
                                            <ul>
                                                <li><strong>Google Sheets API</strong></li>
                                                <li><strong>Google Drive API</strong></li>
                                            </ul>
                                        </li>
                                        <li>Go to <strong>OAuth Consent Screen</strong>:
                                            <ul>
                                                <li>Select <strong>External</strong>.</li>
                                                <li>Fill in App Name and Support Email.</li>
                                                <li class="text-danger"><strong>CRITICAL:</strong> Add your email to "Test Users"!</li>
                                            </ul>
                                        </li>
                                        <li>Go to <strong>Credentials</strong>:
                                            <ul>
                                                <li>Click <strong>+ CREATE CREDENTIALS</strong> &gt; <strong>OAuth client ID</strong>.</li>
                                                <li>Application Type: <strong>Desktop App</strong>.</li>
                                                <li>Download the JSON file.</li>
                                            </ul>
                                        </li>
                                    </ol>
                                </div>
                            </div>

                            <h5 class="text-success mt-4 border-bottom pb-2"><i class="bi bi-file-earmark-arrow-down"></i> Step 2: File Setup</h5>
                            <div class="card mb-3">
                                <div class="card-body small">
                                    <ol>
                                        <li>Rename the downloaded JSON to: <code>credentials_[your_email_prefix].json</code>
                                            <br><span class="text-muted">Example: <code>credentials_john.doe.json</code></span>
                                        </li>
                                        <li>Place it in: <code>config/google_credentials/</code></li>
                                    </ol>
                                    <div class="alert alert-secondary mt-2 mb-0 py-2">
                                        <strong>Expected path:</strong> <code>config/google_credentials/credentials_john.doe.json</code>
                                    </div>
                                </div>
                            </div>

                            <h5 class="text-warning mt-4 border-bottom pb-2"><i class="bi bi-play-circle"></i> Step 3: Registration</h5>
                            <div class="card mb-3">
                                <div class="card-body small">
                                    <ol>
                                        <li>Restart this script.</li>
                                        <li>Select <strong>"Register New Profile"</strong> from the menu.</li>
                                        <li>Enter your email handle when prompted.</li>
                                        <li>Complete the Google sign-in in the browser popup.</li>
                                        <li>Done! Your profile is now saved.</li>
                                    </ol>
                                </div>
                            </div>

                            <h5 class="text-info mt-4 border-bottom pb-2"><i class="bi bi-gear"></i> Step 4: Configure MIS/Blaze Credentials (Optional)</h5>
                            <div class="card mb-3">
                                <div class="card-body small">
                                    <p>To auto-fill MIS and Blaze login credentials, edit:</p>
                                    <code>config/blaze_configs/blaze_config_[handle].json</code>
                                    <pre class="bg-dark text-light p-2 mt-2 rounded" style="font-size: 0.8em;">{
    "mis_username": "your_mis_username",
    "mis_password": "your_mis_password",
    "blaze_email": "your_blaze_email",
    "blaze_password": "your_blaze_password",
    "default_spreadsheet_id": "your_google_sheet_id"
}</pre>
                                </div>
                            </div>
                        </div>

                        <!-- FOLDER STRUCTURE TAB -->
                        <div class="tab-pane fade" id="help-structure" role="tabpanel">
                            <h5 class="text-primary border-bottom pb-2"><i class="bi bi-folder2-open"></i> Directory Structure</h5>
                            <p class="text-muted">The script automatically creates this structure on first run:</p>
                            <pre class="bg-dark text-light p-3 rounded" style="font-size: 0.85em;">project_folder/
√É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ DASHBOARD.py                    # Main script
√É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ config/
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ google_credentials/         # OAuth JSON files
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ credentials_john.doe.json
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨¬ù√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ credentials_jane.smith.json
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ tokens/                     # Google auth tokens (auto-generated)
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ token_john.doe.json
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨¬ù√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ token_jane.smith.json
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨¬ù√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ blaze_configs/              # MIS/Blaze credentials per profile
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°       √É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ blaze_config_john.doe.json
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°       √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨¬ù√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ blaze_config_jane.smith.json
√É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ chrome_profiles/                # Isolated browser profiles
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ chrome_john.doe/
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨≈°   √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨¬ù√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ chrome_jane.smith/
√É¬¢√¢‚Ç¨¬ù√¢‚Ç¨¬ù√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ reports/
    √É¬¢√¢‚Ç¨¬ù√Ö‚Äú√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ MIS_CSV_REPORTS/            # Downloaded MIS exports
    √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨¬ù√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ BLAZE_CSV_REPORTS/
        √É¬¢√¢‚Ç¨¬ù√¢‚Ç¨¬ù√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨√É¬¢√¢‚Ç¨¬ù√¢‚Äö¬¨ INVENTORY/              # Inventory scan results</pre>

                            <h5 class="text-success mt-4 border-bottom pb-2">Files You Provide</h5>
                            <table class="table table-sm table-bordered">
                                <thead class="table-light">
                                    <tr><th>File</th><th>Description</th></tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>credentials_[handle].json</code></td>
                                        <td>OAuth JSON from Google Cloud Console</td>
                                    </tr>
                                    <tr>
                                        <td><code>blaze_config_[handle].json</code></td>
                                        <td>MIS/Blaze login credentials (optional)</td>
                                    </tr>
                                </tbody>
                            </table>

                            <h5 class="text-warning mt-4 border-bottom pb-2">Auto-Generated Files (Safe to Delete)</h5>
                            <table class="table table-sm table-bordered">
                                <thead class="table-light">
                                    <tr><th>File/Folder</th><th>Description</th><th>When to Delete</th></tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>chrome_profiles/chrome_[handle]/</code></td>
                                        <td>Browser cookies/state</td>
                                        <td>Browser crashes or moving computers</td>
                                    </tr>
                                    <tr>
                                        <td><code>config/tokens/token_[handle].json</code></td>
                                        <td>Google session token</td>
                                        <td>Google login fails or token expired</td>
                                    </tr>
                                    <tr>
                                        <td><code>blaze_groups.json</code></td>
                                        <td>Promotion group cache</td>
                                        <td>Missing group names in dashboard</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>    
    <script>
    // ============================================================================
    // PROFILE MANAGEMENT FUNCTIONS
    // ============================================================================
    
    let currentProfileHandle = null;
    let pendingProfileHandle = null;
    
    // Load profiles on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadProfiles();
    });
    
    async function loadProfiles() {
        try {
            const response = await fetch('/api/profiles');
            const data = await response.json();
            
            if (!data.success) {
                console.error('Failed to load profiles:', data.error);
                return;
            }
            
            const selector = document.getElementById('profile-selector');
            selector.innerHTML = '';
            
            if (data.profiles.length === 0) {
                // No profiles - show first run modal
                selector.innerHTML = '<option value="">No Profiles</option>';
                setTimeout(() => {
                    const firstRunModal = new bootstrap.Modal(document.getElementById('firstRunModal'));
                    firstRunModal.show();
                }, 500);
                return;
            }
            
            // Populate dropdown
            data.profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.handle;
                option.textContent = profile.handle;
                if (profile.is_active) {
                    option.selected = true;
                    currentProfileHandle = profile.handle;
                }
                if (!profile.has_credentials) {
                    option.textContent += ' (!)';
                    option.style.color = '#dc3545';
                }
                selector.appendChild(option);
            });
            
            // Update current profile display
            if (data.active_profile) {
                currentProfileHandle = data.active_profile;
            }
            
        } catch (error) {
            console.error('Error loading profiles:', error);
        }
    }
    
    function onProfileChange(newHandle) {
        if (!newHandle || newHandle === currentProfileHandle) return;
        
        // Show confirmation
        if (!confirm(`Switch to profile "${newHandle}"?\n\nThis will require a restart.`)) {
            // Revert selection
            document.getElementById('profile-selector').value = currentProfileHandle;
            return;
        }
        
        switchProfile(newHandle);
    }
    
    async function switchProfile(handle) {
        try {
            const response = await fetch('/api/profile/switch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ handle: handle })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Show restart banner
                showRestartBanner(`Switched to "${handle}".`);
            } else {
                alert('Failed to switch profile: ' + data.error);
                document.getElementById('profile-selector').value = currentProfileHandle;
            }
        } catch (error) {
            alert('Error switching profile: ' + error.message);
            document.getElementById('profile-selector').value = currentProfileHandle;
        }
    }
    
    function showRestartBanner(message) {
        const banner = document.getElementById('restart-banner');
        const text = document.getElementById('restart-banner-text');
        text.textContent = message + ' Restart required to apply changes.';
        banner.style.display = 'block';
    }
    
    function hideRestartBanner() {
        document.getElementById('restart-banner').style.display = 'none';
    }
    
    async function restartApplication() {
        if (!confirm('Restart the application now?')) return;
        
        try {
            document.getElementById('restart-banner').innerHTML = 
                '<strong><i class="bi bi-hourglass-split"></i> Restarting...</strong> Please wait...';
            
            await fetch('/api/restart', { method: 'POST' });
            
            // The page will become unresponsive, show message
            setTimeout(() => {
                document.body.innerHTML = `
                    <div style="display: flex; justify-content: center; align-items: center; height: 100vh; flex-direction: column; font-family: sans-serif;">
                        <div style="font-size: 3em; margin-bottom: 20px;"><i class="bi bi-arrow-repeat" style="animation: spin 1s linear infinite;"></i></div>
                        <h2>Application Restarting...</h2>
                        <p>This page will automatically reload when ready.</p>
                        <p style="color: #666;">If it doesn't reload, <a href="/" onclick="location.reload()">click here</a></p>
                    </div>
                    <style>@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }</style>
                `;
                
                // Try to reload every 2 seconds
                const reloadInterval = setInterval(() => {
                    fetch('/api/browser-status')
                        .then(r => r.json())
                        .then(() => {
                            clearInterval(reloadInterval);
                            location.reload();
                        })
                        .catch(() => {});
                }, 2000);
            }, 500);
            
        } catch (error) {
            console.log('Restart initiated');
        }
    }
    
    // ============================================================================
    // REGISTER PROFILE MODAL FUNCTIONS
    // ============================================================================
    
    function openRegisterModal() {
        // Reset state
        document.getElementById('new-profile-handle').value = '';
        document.getElementById('handle-error').style.display = 'none';
        document.getElementById('register-step1').style.display = 'block';
        document.getElementById('register-step2').style.display = 'none';
        document.getElementById('register-step3').style.display = 'none';
        updateStepBadges(1);
        
        const modal = new bootstrap.Modal(document.getElementById('registerProfileModal'));
        modal.show();
    }
    
    function openRegisterFromFirstRun() {
        // Close first run modal
        const firstRunModal = bootstrap.Modal.getInstance(document.getElementById('firstRunModal'));
        if (firstRunModal) firstRunModal.hide();
        
        // Open register modal
        setTimeout(() => openRegisterModal(), 300);
    }
    
    function updateStepBadges(currentStep) {
        const badges = ['step1-badge', 'step2-badge', 'step3-badge'];
        badges.forEach((id, idx) => {
            const badge = document.getElementById(id);
            if (idx + 1 < currentStep) {
                badge.className = 'badge bg-success rounded-pill px-3 py-2';
            } else if (idx + 1 === currentStep) {
                badge.className = 'badge bg-primary rounded-pill px-3 py-2';
            } else {
                badge.className = 'badge bg-secondary rounded-pill px-3 py-2';
            }
        });
    }
    
    async function registerStep1Next() {
        const handle = document.getElementById('new-profile-handle').value.trim().toLowerCase();
        const errorDiv = document.getElementById('handle-error');
        
        // Validate
        if (!handle) {
            errorDiv.textContent = 'Please enter an email handle.';
            errorDiv.style.display = 'block';
            return;
        }
        
        if (!/^[a-z0-9._-]+$/.test(handle)) {
            errorDiv.textContent = 'Handle can only contain: letters, numbers, dots, underscores, hyphens';
            errorDiv.style.display = 'block';
            return;
        }
        
        errorDiv.style.display = 'none';
        pendingProfileHandle = handle;
        
        // Check if credentials exist
        try {
            const response = await fetch(`/api/profile/check-credentials/${handle}`);
            const data = await response.json();
            
            if (data.exists) {
                // Credentials found - try to register
                await registerCompleteProfile(handle);
            } else {
                // Show step 2 - need credentials
                document.getElementById('expected-creds-path').textContent = data.expected_path;
                document.getElementById('register-step1').style.display = 'none';
                document.getElementById('register-step2').style.display = 'block';
                updateStepBadges(2);
            }
        } catch (error) {
            errorDiv.textContent = 'Error checking credentials: ' + error.message;
            errorDiv.style.display = 'block';
        }
    }
    
    function registerGoBack() {
        document.getElementById('register-step1').style.display = 'block';
        document.getElementById('register-step2').style.display = 'none';
        updateStepBadges(1);
    }
    
    async function registerCheckCredentials() {
        try {
            const response = await fetch(`/api/profile/check-credentials/${pendingProfileHandle}`);
            const data = await response.json();
            
            if (data.exists) {
                await registerCompleteProfile(pendingProfileHandle);
            } else {
                alert('Credentials file still not found.\n\nPlease place the file at:\n' + data.expected_path);
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }
    
    async function registerCompleteProfile(handle) {
        try {
            const response = await fetch('/api/profile/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ handle: handle })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Show success step
                document.getElementById('register-step1').style.display = 'none';
                document.getElementById('register-step2').style.display = 'none';
                document.getElementById('register-step3').style.display = 'block';
                document.getElementById('register-success-msg').textContent = 
                    `Profile "${handle}" has been created.`;
                updateStepBadges(3);
            } else if (data.error === 'credentials_not_found') {
                // Show step 2
                document.getElementById('expected-creds-path').textContent = data.expected_path;
                document.getElementById('register-step1').style.display = 'none';
                document.getElementById('register-step2').style.display = 'block';
                updateStepBadges(2);
            } else {
                alert('Error: ' + data.error);
            }
        } catch (error) {
            alert('Error registering profile: ' + error.message);
        }
    }
    
    function restartAfterRegister() {
        // Close modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('registerProfileModal'));
        if (modal) modal.hide();
        
        // Restart
        restartApplication();
    }

    // ============================================================================
    // TAX RATES EDITING FUNCTIONS (Setup Tab)
    async function loadTaxRatesForEdit() {
        try {
            const resp = await fetch('/api/tax-rates');
            const data = await resp.json();
            
            if (!data.success) {
                alert('Failed to load tax rates: ' + data.error);
                return;
            }
            
            const rates = data.rates;
            const container = document.getElementById('tax-rates-container');
            container.innerHTML = '';
            
            // Sort stores alphabetically
            const stores = Object.keys(rates).sort();
            
            stores.forEach(store => {
                const rate = rates[store];
                const col = document.createElement('div');
                col.className = 'col-md-6 col-lg-4';
                
                col.innerHTML = `
                    <div class="input-group input-group-sm mb-2">
                        <span class="input-group-text" style="width: 140px; font-size: 0.85em;">${store}</span>
                        <input type="number" 
                               class="form-control tax-rate-input" 
                               data-store="${store}" 
                               value="${rate}" 
                               step="0.000001"
                               style="font-size: 0.85em;">
                    </div>
                `;
                
                container.appendChild(col);
            });
            
            document.getElementById('tax-save-status').innerHTML = '';
            
        } catch (err) {
            console.error('Error loading tax rates:', err);
            alert('Error loading tax rates: ' + err.message);
        }
    }
    
    async function saveTaxRates() {
        try {
            const inputs = document.querySelectorAll('.tax-rate-input');
            const rates = {};
            
            inputs.forEach(input => {
                const store = input.dataset.store;
                const value = parseFloat(input.value);
                
                if (isNaN(value)) {
                    throw new Error(`Invalid rate for ${store}: ${input.value}`);
                }
                
                rates[store] = value;
            });
            
            const resp = await fetch('/api/save-tax-rates', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({rates: rates})
            });
            
            const data = await resp.json();
            const statusDiv = document.getElementById('tax-save-status');
            
            if (data.success) {
                statusDiv.innerHTML = '<span class="text-success">[SUCCESS] ' + data.message + '</span>';
                // Reload calculator rates
                await loadTaxRates();
            } else {
                statusDiv.innerHTML = '<span class="text-danger">[X] ' + data.error + '</span>';
            }
            
        } catch (err) {
            console.error('Error saving tax rates:', err);
            document.getElementById('tax-save-status').innerHTML = 
                '<span class="text-danger">[X] Error: ' + err.message + '</span>';
        }
    }
    
    // Load tax rates on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadTaxRatesForEdit();
    });
    
    // v63: Tax Calculator JavaScript
    let TAX_RATES = {};
    let currentStore = '';
    
    // Load tax rates on page load
    async function loadTaxRates() {
        try {
            const resp = await fetch('/api/tax-rates');
            const data = await resp.json();
            
            if (data.success) {
                TAX_RATES = data.rates;
                populateStoreDropdown();
            } else {
                console.error('Failed to load tax rates:', data.error);
                document.getElementById('calcStoreSelect').innerHTML = '<option value="">-- No tax rates found --</option>';
            }
        } catch (err) {
            console.error('Error loading tax rates:', err);
            document.getElementById('calcStoreSelect').innerHTML = '<option value="">-- Error loading rates --</option>';
        }
    }
    
    // Populate store dropdown (alphabetically)
    function populateStoreDropdown() {
        const select = document.getElementById('calcStoreSelect');
        const stores = Object.keys(TAX_RATES).sort();
        
        select.innerHTML = '<option value="">-- Select Store --</option>';
        stores.forEach(store => {
            const option = document.createElement('option');
            option.value = store;
            option.textContent = store;
            select.appendChild(option);
        });
        
        // Set default to first store
        if (stores.length > 0) {
            select.value = stores[0];
            currentStore = stores[0];
            updateTaxRateDisplay();
        }
    }
    
    // Update tax rate display when store changes
    function updateTaxRateDisplay() {
        const select = document.getElementById('calcStoreSelect');
        currentStore = select.value;
        const display = document.getElementById('calcTaxDisplay');
        
        if (currentStore && TAX_RATES[currentStore]) {
            const rate = TAX_RATES[currentStore];
            const percentage = ((rate - 1) * 100).toFixed(2);
            display.textContent = `Tax Rate: ${rate.toFixed(4)} (${percentage}% tax)`;
        } else {
            display.textContent = 'Tax Rate: Not selected';
        }
    }
    
    // Simple toggle function for calculator modal
    function toggleCalcModal() {
        const modal = document.getElementById('calcModal');
        if (modal.classList.contains('show')) {
            modal.classList.remove('show');
        } else {
            modal.classList.add('show');
        }
    }
    
    // Close on backdrop click
    document.getElementById('calcModal').addEventListener('click', function(e) {
        if (e.target === this) {
            toggleCalcModal();
        }
    });
    
    // Close with Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            const modal = document.getElementById('calcModal');
            if (modal.classList.contains('show')) {
                toggleCalcModal();
            }
        }
    });
    
    // Calculator Functions
// Helper to trigger all calcs if store changes
    function runAllCalculations() {
        calculatePostTax();
        calculatePreTax();
        calculatePercentage();
        calculateVendorRebate();
        calculateReprice();
    }

    // Toggle Visibility based on Dropdown
    function switchCalculator() {
        const selected = document.getElementById('calcTypeSelect').value;
        const sections = ['calc-postTax', 'calc-preTax', 'calc-percent', 'calc-rebate', 'calc-reprice'];
        
        sections.forEach(id => {
            const el = document.getElementById(id);
            if (id === 'calc-' + selected) {
                el.style.display = 'block';
            } else {
                el.style.display = 'none';
            }
        });
    }

    // 1. Post-Tax
    function calculatePostTax() {
        if (!currentStore || !TAX_RATES[currentStore]) {
            document.getElementById('postTaxResult').textContent = '-- (Select Store)';
            return;
        }
        const inputVal = document.getElementById('postTaxInput').value;
        if (inputVal === '') {
            document.getElementById('postTaxResult').textContent = '--';
            return;
        }
        const discountValue = parseFloat(inputVal);
        const taxRate = TAX_RATES[currentStore];
        const afterTax = discountValue * taxRate;
        document.getElementById('postTaxResult').textContent = '$' + afterTax.toFixed(2);
    }
    
    // 2. Pre-Tax
    function calculatePreTax() {
        if (!currentStore || !TAX_RATES[currentStore]) {
            document.getElementById('preTaxResult').textContent = '-- (Select Store)';
            return;
        }
        const inputVal = document.getElementById('preTaxInput').value;
        if (inputVal === '') {
            document.getElementById('preTaxResult').textContent = '--';
            return;
        }
        const afterTaxPrice = parseFloat(inputVal);
        const taxRate = TAX_RATES[currentStore];
        const discountValue = afterTaxPrice / taxRate;
        document.getElementById('preTaxResult').textContent = '$' + discountValue.toFixed(2);
    }
    
    // 3. Percentage
    function calculatePercentage() {
        const baseVal = document.getElementById('percBaseInput').value;
        const resVal = document.getElementById('percResultInput').value;
        
        if (baseVal === '' || resVal === '') {
            document.getElementById('percResult').textContent = '--';
            return;
        }
        const base = parseFloat(baseVal);
        const result = parseFloat(resVal);
        
        if (base === 0) {
            document.getElementById('percResult').textContent = 'Error';
            return;
        }
        const percentage = ((base - result) / base) * 100;
        document.getElementById('percResult').textContent = percentage.toFixed(2) + '%';
    }
    
    // 4. Vendor Rebate
    function calculateVendorRebate() {
        const discVal = document.getElementById('vendorDiscountInput').value;
        const rebateVal = document.getElementById('vendorRebateInput').value;
        
        if (discVal === '' || rebateVal === '') {
            document.getElementById('vendorResult').textContent = '--';
            return;
        }
        const discountValue = parseFloat(discVal);
        const rebatePercentage = parseFloat(rebateVal);
        
        const vendorContribution = (discountValue * rebatePercentage) / 100;
        document.getElementById('vendorResult').textContent = '$' + vendorContribution.toFixed(2);
    }

    // 5. NEW: Reprice Calculator
    function calculateReprice() {
        const origVal = document.getElementById('repriceOriginal').value;
        const currVal = document.getElementById('repriceCurrent').value;
        const targetVal = document.getElementById('repriceTargetPerc').value;

        if (origVal === '' || currVal === '' || targetVal === '') {
            document.getElementById('repriceResult').textContent = '--';
            return;
        }

        const originalPrice = parseFloat(origVal);
        const currentPrice = parseFloat(currVal);
        const targetPercent = parseFloat(targetVal);

        if (originalPrice === 0) return;

        // Step 1: Calculate what the price SHOULD be at the target %
        // e.g. 95.51 * (1 - 0.50) = 47.755
        const desiredFinalPrice = originalPrice * (1 - (targetPercent / 100));

        // Step 2: Calculate the difference needed to reach that price from current
        // e.g. 57.31 - 47.755 = 9.555
        const differenceNeeded = currentPrice - desiredFinalPrice;

        // Display with 3 decimal places as requested for precision
        document.getElementById('repriceResult').textContent = '$' + differenceNeeded.toFixed(3);
    }

async function runTierUpdate(btn) {
        if (!confirm("[!] [EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è This will take control of the browser to update 'Bag Day' tags across all valid stores.\n\nEnsure you are not actively using the browser.\n\nProceed?")) return;
        
        btn.disabled = true;
        const originalHtml = btn.innerHTML;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Running...';
        
        try {
            // Pass credentials just in case auto-login is needed
            const misUsername = document.getElementById('mis-username').value;
            const misPassword = document.getElementById('mis-password').value;

            const response = await fetch('/api/blaze/update-tags', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    mis_username: misUsername,
                    mis_password: misPassword
                })
            });
            const data = await response.json();
            
            if (data.success) {
                alert("[SUCCESS] " + data.message + "\n\nWatch the terminal console for progress.");
            } else {
                alert("[X] Error: " + data.error);
            }
        } catch (e) {
            alert("[X] Network Error: " + e.message);
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalHtml;
        }
    }

    // Initialize tax rates on page load (Restored)
    document.addEventListener('DOMContentLoaded', function() {
        loadTaxRates();
    });
        // --- BLAZE TAB SWITCHING ---
        function switchBlazeTab(mode) {
            const promoContent = document.getElementById('blaze-promo-content');
            const invContent = document.getElementById('blaze-inv-content');
            const promoBtn = document.getElementById('btn-blaze-promo');
            const invBtn = document.getElementById('btn-blaze-inv');

            if (mode === 'promo') {
                promoContent.style.display = 'block';
                invContent.style.display = 'none';
                promoBtn.classList.add('active');
                invBtn.classList.remove('active');
                // Recalculate DataTable after tab becomes visible
                setTimeout(function() {
                    if ($.fn.DataTable.isDataTable('#promotionsTable')) {
                        const table = $('#promotionsTable').DataTable();
                        table.columns.adjust();
                        table.draw(false);
                        $(window).trigger('resize');
                    }
                }, 100);
            } else {
                promoContent.style.display = 'none';
                invContent.style.display = 'block';
                promoBtn.classList.remove('active');
                invBtn.classList.add('active');
            }
        }

// --- INVENTORY REPORTER LOGIC ---
// Simplified single-table storage
let currentInventoryData = [];  // Full unfiltered dataset
let currentStoreName = '';       // Current store name  
let currentDataSource = '';      // 'fresh' or 'file'
let currentDataTimestamp = '';   // When loaded
let searchDebounceTimer = null;  // For debouncing  // For debouncing search input

// Debug Log Variables
let debugTimer = null;
let debugStartTime = null;
let debugPollInterval = null;
let debugLogMessages = [];

// Debug Log Helper Functions
function showDebugLog() {
    const panel = document.getElementById('debugLogPanel');
    const messages = document.getElementById('debugMessages');
    panel.style.display = 'block';
    messages.innerHTML = '';
    debugLogMessages = [];
    debugStartTime = Date.now();
    updateDebugTimer();
    debugTimer = setInterval(updateDebugTimer, 1000);
}

function hideDebugLog() {
    const panel = document.getElementById('debugLogPanel');
    panel.style.display = 'none';
    if (debugTimer) clearInterval(debugTimer);
    if (debugPollInterval) clearInterval(debugPollInterval);
    debugTimer = null;
    debugPollInterval = null;
}

function addDebugLog(message, type = 'info') {
    const messages = document.getElementById('debugMessages');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `> ${message}`;
    messages.appendChild(entry);
    messages.scrollTop = messages.scrollHeight;
    debugLogMessages.push({ message, type, time: Date.now() });
}

function updateDebugTimer() {
    if (!debugStartTime) return;
    const elapsed = Math.floor((Date.now() - debugStartTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    document.getElementById('debugTimer').textContent = 
        `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

function updateDebugProgress(current, total, currentAction = '') {
    const percent = total > 0 ? Math.round((current / total) * 100) : 0;
    const progressBar = document.getElementById('debugProgress');
    progressBar.style.width = percent + '%';
    progressBar.textContent = percent + '%';
    
    // Calculate ETA
    if (debugStartTime && current > 0) {
        const elapsed = (Date.now() - debugStartTime) / 1000;
        const avgTimePerItem = elapsed / current;
        const remaining = (total - current) * avgTimePerItem;
        const etaMinutes = Math.floor(remaining / 60);
        const etaSeconds = Math.floor(remaining % 60);
        
        if (etaMinutes > 0) {
            document.getElementById('debugETA').textContent = `${etaMinutes}m ${etaSeconds}s`;
        } else {
            document.getElementById('debugETA').textContent = `${etaSeconds}s`;
        }
    }
    
    if (currentAction) {
        addDebugLog(currentAction);
    }
}

// Poll status endpoint for real-time updates
function startDebugPolling() {
    debugPollInterval = setInterval(async () => {
        try {
            const response = await fetch('/api/blaze/inventory/status');
            const data = await response.json();
            
            if (data.running) {
                // Parse logs for progress info
                const logs = data.logs || [];
                const lastLog = logs[logs.length - 1] || '';
                
                // Look for page info (e.g., "Fetching Page 3 (Items 2000-3000)...")
                const pageMatch = lastLog.match(/Page (\d+)/);
                if (pageMatch) {
                    const currentPage = parseInt(pageMatch[1]);
                    // Estimate total pages (we'll update this dynamically)
                    const estimatedTotal = Math.max(currentPage + 2, 5); // Rough estimate
                    updateDebugProgress(currentPage, estimatedTotal, lastLog);
                }
            } else {
                // Operation completed
                if (debugPollInterval) {
                    clearInterval(debugPollInterval);
                    debugPollInterval = null;
                }
            }
        } catch (err) {
            console.error('Debug poll error:', err);
        }
    }, 1000); // Poll every second
}

// Initialize: Load available saved reports on page load
async function loadSavedReportsList() {
    try {
        const response = await fetch('/api/blaze/inventory/list-reports');
        const data = await response.json();
        
        const dropdown = document.getElementById('savedReportsDropdown');
        dropdown.innerHTML = '<option value="">-- Select Report --</option>';
        
        if (data.success && data.reports.length > 0) {
            data.reports.forEach(filename => {
                dropdown.innerHTML += `<option value="${filename}">${filename}</option>`;
            });
        }
    } catch (err) {
        console.error('Failed to load saved reports list:', err);
    }
}

// Load saved report from file
async function loadSavedReport() {
    const dropdown = document.getElementById('savedReportsDropdown');
    const filename = dropdown.value;
    
    if (!filename) {
        alert('Please select a report file first.');
        return;
    }

    // Extract store name from filename (e.g., "Koreatown_BLAZE_INVENTORY_2024_12_09.csv")
    const storeName = filename.split('_BLAZE_INVENTORY_')[0].replace(/_/g, ' ');

    try {
        const response = await fetch('/api/blaze/inventory/load-report', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ filename: filename })
        });

        const data = await response.json();

        if (data.success && data.data) {
            // Store data globally for single-table view
            currentInventoryData = data.data;
            currentStoreName = storeName;
            currentDataSource = 'file';
            currentDataTimestamp = filename;  // Use filename as timestamp for loaded files
            
            // Populate filters and render table
            populateFilters(currentInventoryData);
            clearInventoryFilters();  // Reset filters
            renderInventoryTable(currentInventoryData);
            
            // Show status bar
            showInventoryStatus();
        } else {
            alert(`Failed to load report: ${data.error || 'Unknown error'}`);
        }
    } catch (err) {
        alert(`Network error: ${err.message}`);
    }
}

// Fetch fresh data from Blaze
async function fetchInventoryData() {
    const storeSelect = document.getElementById('invStoreSelect');
    const store = storeSelect.value;
    
    const btn = document.getElementById('btnFetchFresh');
    const originalText = btn ? btn.innerHTML : 'Fetch';

    if (!store) {
        alert('Please select a store first.');
        return;
    }

    const storeName = storeSelect.options[storeSelect.selectedIndex].text;

    // SHOW DEBUG LOG & START TIMER
    showDebugLog();
    addDebugLog(`Starting fetch for: ${storeName}`, 'info');
    addDebugLog('Initializing connection to Blaze API...', 'info');

    // LOCK UI
    if (btn) {
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span> Fetching...';
    }

    // START STATUS POLLING
    startDebugPolling();

    try {
        addDebugLog('Sending fetch request...', 'info');
        
        // STEP 1: Fetch and cache data
        const fetchResponse = await fetch('/api/blaze/inventory/fetch', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ 
                store: store, 
                fresh: true,
                force_reset: true
            })
        });

        const fetchData = await fetchResponse.json();

        if (!fetchData.success) {
            addDebugLog(`[OK][EMOJI]√É‚Äö√Ç¬ù Error: ${fetchData.error || 'Unknown error'}`, 'error');
            alert(`Failed to fetch data: ${fetchData.error || 'Unknown error'}`);
            setTimeout(() => hideDebugLog(), 5000);
            return;
        }

        addDebugLog(`[OK] Data cached successfully (${fetchData.row_count} rows)`, 'success');
        updateDebugProgress(100, 100, 'Loading data from cache...');
        
        // STEP 2: Load data from cache
        const loadResponse = await fetch('/api/blaze/inventory/get-tab-data', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ store: store })
        });

        const loadData = await loadResponse.json();

        if (loadData.success && loadData.data) {
            addDebugLog(`[OK] Loaded ${loadData.data.length} items from cache`, 'success');
            
            // Store data globally for single-table view
            currentInventoryData = loadData.data;
            currentStoreName = storeName;
            currentDataSource = 'fresh';
            currentDataTimestamp = new Date().toLocaleString();
            
            // Populate filters and render table
            populateFilters(currentInventoryData);
            clearInventoryFilters();  // Reset filters
            renderInventoryTable(currentInventoryData);
            
            // Show status bar
            showInventoryStatus();
            
            addDebugLog('[OK] All done!', 'success');
            setTimeout(() => hideDebugLog(), 3000);
        } else {
            addDebugLog(`[OK][EMOJI]√É‚Äö√Ç¬ù Error loading from cache: ${loadData.error}`, 'error');
            alert(`Failed to load data: ${loadData.error || 'Unknown error'}`);
            setTimeout(() => hideDebugLog(), 5000);
        }
    } catch (err) {
        addDebugLog(`[OK][EMOJI]√É‚Äö√Ç¬ù Network error: ${err.message}`, 'error');
        alert(`Network error: ${err.message}`);
        setTimeout(() => hideDebugLog(), 5000);
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }
}

// Show inventory status bar with current data info
function showInventoryStatus() {
    const statusCard = document.getElementById('inventoryStatusCard');
    const statusText = document.getElementById('inventoryStatusText');
    
    if (statusCard && statusText) {
        let statusMsg = `<strong>${currentStoreName}</strong> - `;
        if (currentDataSource === 'fresh') {
            statusMsg += `Fresh Fetch - ${currentDataTimestamp}`;
        } else {
            statusMsg += `Loaded File: ${currentDataTimestamp}`;
        }
        statusMsg += ` (${currentInventoryData.length} items)`;
        
        statusText.innerHTML = statusMsg;
        statusCard.style.display = 'block';
    }
}

// Render tab navigation (DEPRECATED - tabs removed for performance)
function renderInventoryTabs() {
    // No-op: tabs removed in v7.6 for performance
}

// Switch to inventory tab (DEPRECATED - tabs removed for performance)
async function switchInventoryTab(tabId) {
    // No-op: tabs removed in v7.6 for performance
}


// Save current UI filter state to active tab
function saveCurrentFilters() {
    // No-op: filter persistence removed with tabs in v7.6
}


// Restore tab's saved filters to UI
function restoreTabFilters(tabId) {
    // No-op: filter persistence removed with tabs in v7.6
}


// Debounced search (300ms delay)
function debouncedInventorySearch() {
    if (searchDebounceTimer) {
        clearTimeout(searchDebounceTimer);
    }
    searchDebounceTimer = setTimeout(() => {
        applyInventoryFilters();
    }, 300);
}

// Clear individual search field
function clearSearchField(fieldId) {
    document.getElementById(fieldId).value = '';
    applyInventoryFilters();
}

// Show status bar with tab info (DEPRECATED - replaced by showInventoryStatus)
function showInventoryStatusBar(tabId) {
    // No-op: replaced by showInventoryStatus() in v7.6
}

// Close current tab
function closeCurrentInventoryTab() {
    // No-op: tabs removed in v7.6 for performance
}


// Populate brand and category filters
function populateFilters(data) {
    const brands = [...new Set(data.map(row => row.Brand))].filter(Boolean).sort();
    const categories = [...new Set(data.map(row => row.Category))].filter(Boolean).sort();

    const brandSelect = document.getElementById('invFilterBrand');
    const catSelect = document.getElementById('invFilterCategory');

    brandSelect.innerHTML = '<option value="">All Brands</option>' + 
        brands.map(b => `<option value="${b}">${b}</option>`).join('');
    
    catSelect.innerHTML = '<option value="">All Categories</option>' + 
        categories.map(c => `<option value="${c}">${c}</option>`).join('');
}

// Apply filters with waterfall logic
function applyInventoryFilters() {
    if (!currentInventoryData || currentInventoryData.length === 0) return;
    
    // Get filter values
    const search1 = document.getElementById('invSearchName').value.toLowerCase();
    const search2 = document.getElementById('invSearchName2').value.toLowerCase();
    const selectedBrand = document.getElementById('invFilterBrand').value;
    const selectedCategory = document.getElementById('invFilterCategory').value;
    const hideZeroQty = document.getElementById('invHideZeroQty').checked;
    
    // Start with full data
    let filtered = [...currentInventoryData];
    
    // STEP 1: Apply Primary Search (Product Name only)
    if (search1) {
        filtered = filtered.filter(row => 
            (row['Product Name'] || '').toLowerCase().includes(search1)
        );
    }
    
    // STEP 2: Apply Secondary Search (filters results of Step 1 - Product Name only)
    if (search2) {
        filtered = filtered.filter(row =>
            (row['Product Name'] || '').toLowerCase().includes(search2)
        );
    }
    
    // STEP 3: Apply Brand filter
    if (selectedBrand) {
        filtered = filtered.filter(row => row.Brand === selectedBrand);
    }
    
    // STEP 4: Apply Category filter
    if (selectedCategory) {
        filtered = filtered.filter(row => row.Category === selectedCategory);
    }
    
    // STEP 5: Apply Hide Zero Quantity filter
    if (hideZeroQty) {
        filtered = filtered.filter(row => {
            const qty = row['Total Quantity'];
            // Keep rows with null/undefined, only hide rows that are exactly 0
            return qty !== 0;
        });
    }
    
    // Re-render table with filtered data
    renderInventoryTable(filtered);
    
    // Save current filters to tab
    saveCurrentFilters();
}

// Clear all filters
function clearInventoryFilters() {
    // Clear UI fields
    document.getElementById('invSearchName').value = '';
    document.getElementById('invSearchName2').value = '';
    document.getElementById('invFilterBrand').value = '';
    document.getElementById('invFilterCategory').value = '';
    document.getElementById('invHideZeroQty').checked = false;
    
    // Reapply filters (will show all data)
    applyInventoryFilters();
}

// Render table with data
function renderInventoryTable(data) {
    const rowCount = document.getElementById('invRowCount');
    rowCount.textContent = `${data.length} Items`;

    // Check if DataTable already exists
    if ($.fn.DataTable.isDataTable('#inventoryTable')) {
        // Destroy existing DataTable
        $('#inventoryTable').DataTable().destroy();
    }

    // Clear table body
    const tbody = document.getElementById('inventoryTableBody');
    
    if (!data || data.length === 0) {
        tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted py-4">No data available</td></tr>';
        return;
    }

    // Build rows
    tbody.innerHTML = data.map((row, index) => {
        const blazeId = row['BLAZE ID'] || '';
        const sku = row.SKU || 'N/A';
        const name = row['Product Name'] || '';
        const brand = row.Brand || 'N/A';
        const category = row.Category || 'N/A';
        const price = parseFloat(row['Unit Price ($)'] || 0).toFixed(2);
        const qty = parseFloat(row['Total Quantity'] || 0).toFixed(2);
        const weight = row['Weight / Unit'] || 'N/A';

        return `
            <tr>
                <td>
                    <button class="btn btn-sm btn-outline-primary sku-button" 
                            onclick="handleSkuClick('${sku}', '${blazeId}')">
                        ${sku}
                    </button>
                </td>
                <td>
                    <div class="name-cell-wrapper">
                        <span class="product-name clickable-name" 
                              id="product-name-${index}"
                              data-blaze-id="${blazeId}"
                              data-sku="${sku}"
                              onclick="handleProductNameClick(this, '${blazeId}', '${sku}')">
                            ${name}
                        </span>
                    </div>
                </td>
                <td>${brand}</td>
                <td>${category}</td>
                <td class="text-end">$${price}</td>
                <td class="text-end">${qty}</td>
                <td class="text-end">${weight}</td>
            </tr>
        `;
    }).join('');

    // Initialize DataTable with no pagination (scrolling list)
    $('#inventoryTable').DataTable({
        paging: false,           // Disable pagination
        searching: false,        // We handle search manually
        info: false,             // Hide "Showing X of Y entries"
        ordering: true,          // Allow column sorting
        scrollY: '60vh',         // Enable vertical scrolling
        scrollCollapse: true,    // Allow table to be smaller than scrollY
        order: [[1, 'asc']]      // Default sort by Product Name
    });

    // Setup persistent tooltips for product names (will be triggered by click)
    setupPersistentTooltips();
}

// ============================================================================
// PERSISTENT TOOLTIP SYSTEM FOR PRODUCT NAMES
// ============================================================================
let activeTooltip = null;  // Track currently visible tooltip
let activeTooltipElement = null;  // Track element with active tooltip

function setupPersistentTooltips() {
    // Initialize tooltips for all product names (but don't trigger them yet)
    const productNames = document.querySelectorAll('.product-name');
    
    productNames.forEach(element => {
        const blazeId = element.getAttribute('data-blaze-id');
        const sku = element.getAttribute('data-sku');
        
        // Create tooltip content
        const tooltipContent = `
            <div class='text-start'>
                <strong>BLAZE ID:</strong> ${blazeId} 
                <i class='bi bi-paperclip' style='cursor:pointer' onclick='copyToClipboard("${blazeId}")'></i>
                <br>
                <strong>SKU:</strong> ${sku} 
                <i class='bi bi-paperclip' style='cursor:pointer' onclick='copyToClipboard("${sku}")'></i>
            </div>
        `;
        
        // Initialize Bootstrap tooltip (manual trigger)
        const tooltip = new bootstrap.Tooltip(element, {
            html: true,
            title: tooltipContent,
            trigger: 'manual',  // We'll control show/hide manually
            placement: 'right'
        });
        
        // Store tooltip instance on element
        element._tooltipInstance = tooltip;
    });
    
    // Add click-outside listener to dismiss active tooltip
    document.addEventListener('click', function(e) {
        // If clicking outside any product name and outside tooltip
        if (!e.target.closest('.product-name') && !e.target.closest('.tooltip')) {
            dismissActiveTooltip();
        }
    });
}

function handleProductNameClick(element, blazeId, sku) {
    // If clicking the same element that already has tooltip open, do nothing
    if (activeTooltipElement === element) {
        return;
    }
    
    // Dismiss any currently active tooltip
    dismissActiveTooltip();
    
    // Show tooltip for clicked element
    if (element._tooltipInstance) {
        element._tooltipInstance.show();
        activeTooltip = element._tooltipInstance;
        activeTooltipElement = element;
    }
}

function dismissActiveTooltip() {
    if (activeTooltip) {
        activeTooltip.hide();
        activeTooltip = null;
        activeTooltipElement = null;
    }
}

// ============================================================================
// SKU BUTTON CLICK HANDLER (PLACEHOLDER FOR FUTURE FUNCTIONALITY)
// ============================================================================
async function handleSkuClick(sku, blazeId) {
    // Get current store name from global state
    if (!currentStoreName) {
        alert('Error: No inventory data loaded');
        return;
    }
    
    console.log(`[SKU CLICK] Navigating to product ${blazeId} in store ${currentStoreName}`);
    
    // Show status message
    const statusText = document.getElementById('inventoryStatusText');
    const originalStatus = statusText.innerHTML;
    statusText.innerHTML = '<span class="text-primary"><i class="bi bi-arrow-repeat spin"></i> Navigating to product page...</span>';
    
    try {
        const response = await fetch('/api/blaze/inventory/navigate-to-product', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                store_name: currentStoreName,
                blaze_id: blazeId
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            // Success message
            statusText.innerHTML = '<span class="text-success"><i class="bi bi-check-circle"></i> [OK] Navigated to product page!</span>';
            console.log(`[SKU CLICK] Success: ${result.message}`);
            
            // Restore original status after 3 seconds
            setTimeout(() => {
                statusText.innerHTML = originalStatus;
            }, 3000);
        } else {
            // Error message
            statusText.innerHTML = `<span class="text-danger"><i class="bi bi-x-circle"></i> Error: ${result.error}</span>`;
            console.error(`[SKU CLICK] Error: ${result.error}`);
            
            // Restore after 5 seconds
            setTimeout(() => {
                statusText.innerHTML = originalStatus;
            }, 5000);
        }
    } catch (err) {
        statusText.innerHTML = `<span class="text-danger"><i class="bi bi-x-circle"></i> Network error: ${err.message}</span>`;
        console.error(`[SKU CLICK] Network error: ${err}`);
        
        // Restore after 5 seconds
        setTimeout(() => {
            statusText.innerHTML = originalStatus;
        }, 5000);
    }
}

// Copy to clipboard utility
function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        const statusText = document.getElementById('inventoryStatusText');
        const original = statusText.innerHTML;
        statusText.innerHTML = '<span class="text-success">[OK] Copied to clipboard</span>';
        setTimeout(() => {
            statusText.innerHTML = original;
        }, 1500);
    });
}

// Open export modal
function openInventoryExportModal() {
    // Check if data is loaded
    if (!currentInventoryData || currentInventoryData.length === 0) {
        alert('No data loaded. Please fetch or load data first.');
        return;
    }
    
    const exportTabsList = document.getElementById('exportTabsList');
    const exportNoTabs = document.getElementById('exportNoTabs');
    const exportTabsSection = document.getElementById('exportTabsSection');
    const exportDownloadBtn = document.getElementById('exportDownloadBtn');
    
    exportNoTabs.style.display = 'none';
    exportTabsSection.style.display = 'block';
    exportDownloadBtn.disabled = false;
    
    // Show current data info
    exportTabsList.innerHTML = `
        <div class="alert alert-info">
            <strong>Current Data:</strong> ${currentStoreName}<br>
            <strong>Items:</strong> ${currentInventoryData.length}<br>
            <strong>Source:</strong> ${currentDataSource === 'fresh' ? 'Fresh Fetch' : 'Loaded File'}
        </div>
    `;
    
    const modal = new bootstrap.Modal(document.getElementById('inventoryExportModal'));
    modal.show();
}

// Toggle all tabs selection (deprecated)
function toggleAllTabsExport(checkbox) {
    // No-op: tabs removed in v7.6
}

// Update export button state (deprecated)
function updateExportButton() {
    // No-op: tabs removed in v7.6
}

// Generate inventory report
async function generateInventoryReport() {
    if (!currentInventoryData || currentInventoryData.length === 0) {
        alert('No data to export.');
        return;
    }

    // Prepare single-store export data
    const exportData = {};
    exportData[currentStoreName] = currentInventoryData;

    try {
        const response = await fetch('/api/blaze/inventory/export-tabs', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ tabs: exportData })
        });

        if (response.ok) {
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // Single store always exports as CSV
            const timestamp = new Date().toISOString().slice(0,10).replace(/-/g, '');
            const safeName = currentStoreName.replace(/[^a-zA-Z0-9]/g, '_');
            a.download = `${safeName}_Inventory_${timestamp}.csv`;
            
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            // Close modal
            bootstrap.Modal.getInstance(document.getElementById('inventoryExportModal')).hide();
        } else {
            const error = await response.json();
            alert(`Export failed: ${error.error || 'Unknown error'}`);
        }
    } catch (err) {
        alert(`Network error: ${err.message}`);
    }
}

// Auto-load saved reports list on page load
document.addEventListener('DOMContentLoaded', () => {
    loadSavedReportsList();
});

    </script>
</body>
</html>
"""

# ============================================================================
# FLASK ROUTES (CONTINUED FROM PREVIOUS SECTION)
# ============================================================================

@app.route('/')
def index():
    return render_template_string(HTML_TEMPLATE)

# ============================================================================
# PROFILE MANAGEMENT API ENDPOINTS
# ============================================================================

@app.route('/api/profiles')
def api_get_profiles():
    """Get list of all available profiles."""
    try:
        profiles = get_available_profiles()
        profile_list = []
        for p in profiles:
            profile_list.append({
                'handle': p,
                'has_credentials': check_credentials_for_handle(p),
                'is_active': ACTIVE_PROFILE.get('handle') == p
            })
        return jsonify({
            'success': True,
            'profiles': profile_list,
            'active_profile': ACTIVE_PROFILE.get('handle')
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/current')
def api_get_current_profile():
    """Get current active profile info."""
    try:
        return jsonify({
            'success': True,
            'handle': ACTIVE_PROFILE.get('handle'),
            'has_credentials': check_credentials_for_handle(ACTIVE_PROFILE.get('handle')) if ACTIVE_PROFILE.get('handle') else False
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/switch', methods=['POST'])
def api_switch_profile():
    """Switch to a different profile (requires restart)."""
    try:
        data = request.get_json() or {}
        handle = data.get('handle', '').strip().lower()
        
        if not handle:
            return jsonify({'success': False, 'error': 'No handle provided'})
        
        profiles = get_available_profiles()
        if handle not in profiles:
            return jsonify({'success': False, 'error': f'Profile "{handle}" not found'})
        
        if not check_credentials_for_handle(handle):
            return jsonify({'success': False, 'error': f'Credentials missing for "{handle}"'})
        
        # Save as last used profile
        save_last_used_profile(handle)
        
        return jsonify({
            'success': True,
            'message': f'Profile switched to "{handle}". Restart required.',
            'restart_required': True
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/register', methods=['POST'])
def api_register_profile():
    """Register a new profile."""
    try:
        data = request.get_json() or {}
        handle = data.get('handle', '')
        
        result = register_profile_api(handle)
        
        if result['success']:
            # Save as last used profile
            save_last_used_profile(handle.strip().lower())
        
        return jsonify(result)
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/check-credentials/<handle>')
def api_check_credentials(handle):
    """Check if credentials file exists for a handle."""
    try:
        handle = handle.strip().lower()
        exists = check_credentials_for_handle(handle)
        expected_path = str(GOOGLE_CREDS_DIR / f'credentials_{handle}.json')
        return jsonify({
            'success': True,
            'exists': exists,
            'expected_path': expected_path
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/restart', methods=['POST'])
def api_restart():
    """Restart the application."""
    try:
        import os
        import sys
        
        print("\n" + "="*70)
        print("[RESTART] Restarting application...")
        print("="*70 + "\n")
        
        # Use os.execv to restart the script
        os.execv(sys.executable, [sys.executable] + sys.argv)
        
        # This line won't be reached, but included for completeness
        return jsonify({'success': True})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/profile/delete', methods=['POST'])
def api_delete_profile():
    """Delete a profile (removes token file only, keeps credentials)."""
    try:
        data = request.get_json() or {}
        handle = data.get('handle', '').strip().lower()
        
        if not handle:
            return jsonify({'success': False, 'error': 'No handle provided'})
        
        if handle == ACTIVE_PROFILE.get('handle'):
            return jsonify({'success': False, 'error': 'Cannot delete active profile'})
        
        # Remove token file (this "unregisters" the profile)
        token_file = TOKENS_DIR / f'token_{handle}.json'
        if token_file.exists():
            token_file.unlink()
        
        return jsonify({'success': True, 'message': f'Profile "{handle}" deleted'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# ============================================================================
# EXISTING API ROUTES
# ============================================================================

@app.route('/api/auth', methods=['POST'])
def api_auth():
    try:
        service = authenticate_google_sheets()
        if service:
            GLOBAL_DATA['sheets_service'] = service
            return jsonify({'success': True})
        return jsonify({'success': False, 'error': 'Authentication failed'})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/browser-status')
def api_browser_status():
    return jsonify({
        'ready': GLOBAL_DATA['browser_ready'],
        'instance': GLOBAL_DATA['browser_instance'] is not None
    })

@app.route('/api/get-mis-reports-folder')
def api_get_mis_reports_folder():
    """v10.7: Return the MIS Reports folder path."""
    return jsonify({
        'success': True,
        'path': str(MIS_REPORTS_DIR)
    })

@app.route('/api/open-mis-reports-folder')
def api_open_mis_reports_folder():
    """v10.7: Open the MIS Reports folder in the system file explorer."""
    try:
        import subprocess
        import platform
        
        folder_path = str(MIS_REPORTS_DIR)
        
        if platform.system() == 'Windows':
            subprocess.Popen(['explorer', folder_path])
        elif platform.system() == 'Darwin':  # macOS
            subprocess.Popen(['open', folder_path])
        else:  # Linux
            subprocess.Popen(['xdg-open', folder_path])
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/get-credentials')
def api_get_credentials():
    """Get credentials from config file for auto-fill."""
    try:
        config = load_credentials_config()
        return jsonify({
            'success': True,
            'credentials': config
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        })

@app.route('/api/init-all', methods=['POST'])
def api_init_all():
    try:
        data = request.get_json()
        mis_creds = data.get('mis', {})
        blaze_creds = data.get('blaze', {})
        
        GLOBAL_DATA['mis']['credentials'] = mis_creds
        GLOBAL_DATA['blaze']['credentials'] = blaze_creds
        
        # SILENT OPERATION: Save original tab to return to it at the end
        driver = GLOBAL_DATA.get('browser_instance')
        original_tab = None
        if driver:
            try:
                original_tab = driver.current_window_handle
            except:
                pass
        
        # 1. Initialize Browser
        if not GLOBAL_DATA['browser_ready']:
            driver = init_browser()
            if not driver:
                return jsonify({'success': False, 'error': 'Failed to initialize browser'})
            driver.get("http://127.0.0.1:5100")
            time.sleep(1)
            # Update original tab after browser init
            try:
                original_tab = driver.current_window_handle
            except:
                pass
        else:
            driver = GLOBAL_DATA['browser_instance']
        
        # 2. MIS Login
        mis_success = False
        if mis_creds.get('username') and mis_creds.get('password'):
            mis_success = mis_login(driver, mis_creds['username'], mis_creds['password'], new_tab=True)
        
        # 3. Blaze Login Logic (Smart)
        blaze_success = False
        if blaze_creds.get('email') and blaze_creds.get('password'):
            
            # A. CHECK TOKEN VALIDITY FIRST
            stored_token = load_stored_token()
            is_token_valid = validate_token(stored_token)
            
            if is_token_valid:
                print("[INIT] Existing token is VALID. Skipping sniffer.")
                # Just perform the visual login/navigation
                robust_login(blaze_creds['email'], blaze_creds['password'])
                GLOBAL_DATA['blaze']['token'] = stored_token
                blaze_success = True
                
            else:
                print("[INIT] Token invalid or missing. Running full capture sequence...")
                # Run full logic: Login -> Navigate -> Sniff
                login_status = robust_login(blaze_creds['email'], blaze_creds['password'])
                
                if login_status:
                    blaze_success = True
                    print("[INIT] Blaze Login successful. Searching for Blaze Tab...")
                    
                    # Find Blaze Tab
                    blaze_handle = None
                    for h in driver.window_handles:
                        driver.switch_to.window(h)
                        if "blaze.me" in driver.current_url:
                            blaze_handle = h
                            break
                    
                    if blaze_handle:
                        print(f"[INIT] Found Blaze Tab! Switching focus to handle: {blaze_handle}")
                        driver.switch_to.window(blaze_handle)
                        
                        # Force Navigation to PROMOTIONS (Master Token Source)
                        print("[INIT] Navigating to Main Promotions Page to force Master Token generation...")
                        driver.get("https://retail.blaze.me/company-promotions/promotions?page=0&pageSize=100")
                        time.sleep(5) # Wait for full load
                        
                        # Sniff Logs
                        logs = driver.get_log('performance')
                        found_token = None
                        
                        for entry in logs:
                            try:
                                msg = json.loads(entry['message'])['message']
                                if msg['method'] == 'Network.requestWillBeSent':
                                    req = msg['params']['request']
                                    if 'company/promotions' in req['url']:
                                        headers = req.get('headers', {})
                                        auth = next((v for k, v in headers.items() if k.lower() == 'authorization'), None)
                                        if auth and 'Token' in auth:
                                            found_token = auth.replace('Token ', '').strip()
                                            break
                            except: continue
                        
                        if found_token:
                            print(f"[INIT] SUCCESS: Captured Master Token: {found_token[:10]}...")
                            GLOBAL_DATA['blaze']['token'] = found_token
                            save_stored_token(found_token)
                        else:
                            print("[INIT] WARN: Could not sniff Master Token. Check manual login.")
                    else:
                        print("[INIT] ERROR: Could not find Blaze tab.")

        messages = []
        if mis_success: messages.append("MIS login successful")
        if blaze_success: messages.append("Blaze login & Sync successful")
        
        # SILENT OPERATION: Return to original tab
        if original_tab and driver:
            try:
                driver.switch_to.window(original_tab)
                print("[INIT] Returned to original tab silently")
            except:
                print("[INIT] Could not return to original tab (may have been closed)")
        
        return jsonify({'success': True, 'message': ' | '.join(messages)})

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/load-sheet', methods=['POST'])
def api_mis_load_sheet():
    try:
        data = request.get_json()
        url = data.get('url', '')
        spreadsheet_id = extract_spreadsheet_id(url)
        if not spreadsheet_id:
            return jsonify({'success': False, 'error': 'Invalid URL'})
        GLOBAL_DATA['mis']['spreadsheet_id'] = spreadsheet_id
        tabs = get_available_tabs(spreadsheet_id)
        if not tabs:
            return jsonify({'success': False, 'error': 'No tabs found'})
        # v12.1: Return spreadsheet_id for goToSheetRow functionality
        return jsonify({'success': True, 'tabs': tabs, 'spreadsheet_id': spreadsheet_id})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/init-sheet-page', methods=['POST'])
def api_mis_init_sheet_page():
    try:
        data = request.get_json()
        tab_name = data.get('tab')
        spreadsheet_id = GLOBAL_DATA['mis'].get('spreadsheet_id')
        if not spreadsheet_id:
            return jsonify({'success': False, 'error': 'No spreadsheet loaded'})
        if not GLOBAL_DATA.get('browser_ready'):
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        GLOBAL_DATA['mis']['current_sheet'] = tab_name
        if open_google_sheet_in_browser(spreadsheet_id, tab_name):
            return jsonify({'success': True, 'message': f'Opened tab "{tab_name}"'})
        return jsonify({'success': False, 'error': 'Failed to open sheet'})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/generate-csv', methods=['POST'])
def api_mis_generate_csv():
    try:
        data = request.get_json()
        tab_name = data.get('tab')
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab selected'})
        
        # 1. Fetch Sections (Returns Dict)
        sections_data = fetch_google_sheet_data(tab_name)
        
        # 2. Process Each Section
        results = {}
        total_count = 0
        
        for section_name in ['weekly', 'monthly', 'sale']:
            df = sections_data.get(section_name, pd.DataFrame())
            
            if df.empty:
                results[section_name] = {'rows': [], 'summary': {}}
            else:
                # PASS section_name HERE
                rows, summary = generate_mis_csv_with_multiday(df, section_type=section_name)
                results[section_name] = {'rows': rows, 'summary': summary}
                total_count += len(rows)
            
        # Store structured results globally
        GLOBAL_DATA['mis']['generated_sections'] = results
        
        return jsonify({
            'success': True, 
            'sections': results,
            'total_rows': total_count
        })
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/download-csv')
def api_mis_download_csv():
    try:
        export_type = request.args.get('type', 'all') # all, weekly, monthly, sale
        sections = GLOBAL_DATA['mis'].get('generated_sections', {})
        
        if not sections:
            return "No CSV generated. Please click 'Generate CSV' first.", 400
        
        # Gather rows based on type
        final_rows = []
        
        if export_type == 'all':
            for key in ['weekly', 'monthly', 'sale']:
                if key in sections:
                    final_rows.extend(sections[key]['rows'])
        elif export_type in sections:
            final_rows = sections[export_type]['rows']
        else:
            return f"Invalid export type: {export_type}", 400
            
        if not final_rows:
            return "No data found for selected section.", 400
            
        df = pd.DataFrame(final_rows)
        
        # Drop internal tracking columns
        df = df.drop(columns=['GOOGLE_ROWS', 'MULTI_DAY_FLAG', 'WEEKDAY_SORT_KEY', 'NOTES', 
                              'SPLIT_GROUP_ID', 'ROW_UI_CLASS', 'DISPLAY_CATEGORY', 
                              'DISPLAY_STORE', 'UI_SPECIAL_NOTES', 'UI_DEAL_INFO', 'UI_REBATE_DISPLAY'], 
                     errors='ignore')
        
        # Column Ordering
        column_order = [
            'ID', 'Weekday', 'Store', 'Brand', 'Linked Brand (if applicable)',
            'Category', 'Daily Deal Discount', 'Rebate type', 
            'Discount paid by vendor', 'Rebate After Wholesale Discount?',
            'Include clearance items?', 'Specialty Discount (non-daily deal)?',
            'Start date', 'End date', 'Minimum Weight', 'Maximum Weight', 'Actions'
        ]
        
        for col in column_order:
            if col not in df.columns: df[col] = ''
        
        df = df[column_order]
        
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'MIS_Deals_{export_type.upper()}_{timestamp}.csv'
        filepath = BASE_DIR / filename
        df.to_csv(filepath, index=False)
        
        return send_file(filepath, as_attachment=True, download_name=filename)
    except Exception as e:
        traceback.print_exc()
        return str(e), 500


@app.route('/api/mis/generate-newsletter', methods=['POST'])
def api_mis_generate_newsletter():
    """
    Generate Newsletter files:
    1. Excel file with 6 tabs (CLUB420 and TAT LEGACY x Weekly/Monthly/Sale)
    2. Two DOCX files (CLUB420_Newsletter.docx and TAT_LEGACY_Newsletter.docx)
    
    Each DOCX contains 3 tables (Weekly, Monthly, Sale) with day-of-week columns.
    """
    try:
        sections = GLOBAL_DATA['mis'].get('generated_sections', {})
        
        if not sections:
            return jsonify({'success': False, 'error': "No CSV generated. Please click 'Generate CSV' first."}), 400
        
        # Define CLUB420 locations (Davis and Dixon)
        CLUB420_LOCATIONS = ['Davis', 'Dixon']
        
        # Define patterns that indicate ONLY Davis/Dixon (should be excluded from TAT LEGACY)
        DAVIS_DIXON_ONLY_PATTERNS = [
            'Davis',
            'Dixon',
            'Davis, Dixon',
            'Dixon, Davis',
            'All Locations Except: Davis, Dixon',
            'All Locations Except: Dixon, Davis',
            'All Locations Except: Davis',
            'All Locations Except: Dixon'
        ]
        
        def is_club420_deal(store_value: str) -> bool:
            """Check if deal is available at CLUB420 locations (Davis/Dixon)"""
            if not store_value:
                return False
            store = str(store_value).strip()
            
            if store == 'All Locations':
                return True
            
            for loc in CLUB420_LOCATIONS:
                if loc in store:
                    if store.startswith('All Locations Except:'):
                        continue
                    return True
            
            return False
        
        def is_tat_legacy_deal(store_value: str) -> bool:
            """Check if deal is available at TAT Legacy locations (not just Davis/Dixon)"""
            if not store_value:
                return False
            store = str(store_value).strip()
            
            if store == 'All Locations':
                return True
            
            store_normalized = store.strip()
            
            for pattern in DAVIS_DIXON_ONLY_PATTERNS:
                if store_normalized == pattern:
                    return False
            
            store_parts = [s.strip() for s in store.split(',')]
            if all(part in CLUB420_LOCATIONS for part in store_parts):
                return False
            
            if store.startswith('All Locations Except:'):
                return True
            
            return True
        
        def format_discount(row) -> str:
            """Format discount value for newsletter"""
            deal_info = ''
            
            ui_deal_info = row.get('UI_DEAL_INFO', [])
            if ui_deal_info and isinstance(ui_deal_info, list) and len(ui_deal_info) > 0:
                first_info = ui_deal_info[0].get('info', '') if isinstance(ui_deal_info[0], dict) else ''
                deal_info = str(first_info).strip()
            
            if not deal_info:
                deal_info = str(row.get('Deal Information', '') or row.get('Deal Info', '')).strip()
            
            deal_info_upper = deal_info.upper()
            if 'BOGO FOR $1' in deal_info_upper or 'B2G1 FOR $1' in deal_info_upper:
                bogo_match = re.search(r'(BOGO\s+for\s+\$\d+|B2G1\s+for\s+\$\d+)', deal_info, re.IGNORECASE)
                if bogo_match:
                    return bogo_match.group(0)
                if 'BOGO' in deal_info_upper:
                    return 'BOGO for $1'
                if 'B2G1' in deal_info_upper:
                    return 'B2G1 for $1'
            
            discount_val = row.get('Daily Deal Discount', '')
            if discount_val:
                discount_str = str(discount_val).strip().replace('%', '').strip()
                try:
                    discount_num = float(discount_str)
                    if discount_num == int(discount_num):
                        return f"{int(discount_num)}% Off"
                    else:
                        return f"{discount_num}% Off"
                except (ValueError, TypeError):
                    if discount_str:
                        return f"{discount_str}% Off"
            
            return discount_val or ''
        
        def format_deal_info(discount: str, categories: str) -> str:
            """Format the Deal Info column for DOCX table"""
            if not discount:
                return ''
            
            # If it's a BOGO deal, return as-is with " - Like-Products" suffix if not already present
            if 'BOGO' in discount.upper() or 'B2G1' in discount.upper():
                if 'Like-Products' not in discount and 'like-products' not in discount.lower():
                    return f"{discount} - Like-Products"
                return discount
            
            # Format as "X% Off [category]"
            if not categories or categories.strip().lower() == 'all categories':
                return f"{discount} all Products"
            else:
                return f"{discount} {categories}"
        
        def parse_weekdays_weekly(weekday_str: str) -> dict:
            """Parse weekday string for WEEKLY deals - puts day abbreviation in column"""
            days = {
                'Mon.': '', 'Tues.': '', 'Wed.': '', 
                'Thurs.': '', 'Fri.': '', 'Sat.': '', 'Sun.': ''
            }
            
            if not weekday_str:
                return days
            
            weekday_lower = weekday_str.lower()
            
            # Map full day name to column key and display abbreviation
            day_mapping = {
                'monday': ('Mon.', 'Mon'),
                'tuesday': ('Tues.', 'Tues'),
                'wednesday': ('Wed.', 'Wed'),
                'thursday': ('Thurs.', 'Thurs'),
                'friday': ('Fri.', 'Fri'),
                'saturday': ('Sat.', 'Sat'),
                'sunday': ('Sun.', 'Sun')
            }
            
            for full_day, (col_key, display_abbrev) in day_mapping.items():
                if full_day in weekday_lower:
                    days[col_key] = display_abbrev
            
            return days
        
        def parse_weekdays_monthly(weekday_str: str) -> dict:
            """Parse weekday for MONTHLY deals - puts the weekday value in Mon. column"""
            days = {
                'Mon.': '', 'Tues.': '', 'Wed.': '', 
                'Thurs.': '', 'Fri.': '', 'Sat.': '', 'Sun.': ''
            }
            
            if weekday_str:
                # Put the raw weekday value in the Mon. column
                days['Mon.'] = str(weekday_str).strip()
            
            return days
        
        def process_row(row, section_type: str = 'weekly') -> dict:
            """Process a single row into newsletter format"""
            store = row.get('Store', '') or row.get('DISPLAY_STORE', '') or ''
            formatted_discount = format_discount(row)
            categories = row.get('Category', '') or row.get('DISPLAY_CATEGORY', '')
            weekday = row.get('Weekday', '')
            brand = row.get('Brand', '')
            
            # Use different day parsing based on section type
            if section_type == 'monthly':
                days = parse_weekdays_monthly(weekday)
            else:
                # Weekly and Sale both use the weekly format (day abbreviations)
                days = parse_weekdays_weekly(weekday)
            
            return {
                'Weekday': weekday,
                'Brand': brand,
                'Discount': formatted_discount,
                'Categories': categories,
                'Deal_Info': format_deal_info(formatted_discount, categories),
                'Days': days,
                'Store': store
            }
        
        # Process each section separately
        section_data = {
            'weekly': {'club420': [], 'tat_legacy': []},
            'monthly': {'club420': [], 'tat_legacy': []},
            'sale': {'club420': [], 'tat_legacy': []}
        }
        
        for section_key in ['weekly', 'monthly', 'sale']:
            section_rows = sections.get(section_key, {}).get('rows', [])
            
            for row in section_rows:
                processed = process_row(row, section_key)
                store = processed['Store']
                
                if is_club420_deal(store):
                    section_data[section_key]['club420'].append(processed)
                
                if is_tat_legacy_deal(store):
                    section_data[section_key]['tat_legacy'].append(processed)
        
        # ===== CREATE OUTPUT FOLDER =====
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        current_month = datetime.now().strftime('%B')
        
        # Create Newsletter folder structure: REPORTS/Newsletter/NEWSLETTER_YYYYMMDD_HHMMSS/
        newsletter_base_dir = BASE_DIR / 'REPORTS' / 'Newsletter'
        newsletter_base_dir.mkdir(parents=True, exist_ok=True)
        
        newsletter_folder = newsletter_base_dir / f'NEWSLETTER_{timestamp}'
        newsletter_folder.mkdir(parents=True, exist_ok=True)
        
        print(f"[NEWSLETTER] Output folder: {newsletter_folder}")
        
        # ===== GENERATE EXCEL FILE (6 tabs) =====
        excel_filename = f'Newsletter_Table_{timestamp}.xlsx'
        excel_filepath = newsletter_folder / excel_filename
        
        column_order = ['Weekday', 'Brand', 'Discount', 'Categories']
        
        with pd.ExcelWriter(excel_filepath, engine='openpyxl') as writer:
            for section_key, section_title in [('weekly', 'Weekly Deals'), ('monthly', 'Monthly Deals'), ('sale', 'Sale Deals')]:
                # CLUB420 tab
                club420_rows = section_data[section_key]['club420']
                df_club420 = pd.DataFrame([{k: r[k] for k in column_order} for r in club420_rows]) if club420_rows else pd.DataFrame(columns=column_order)
                for col in column_order:
                    if col not in df_club420.columns:
                        df_club420[col] = ''
                df_club420 = df_club420[column_order]
                df_club420.to_excel(writer, sheet_name=f'CLUB420 - {section_title}', index=False)
                
                # TAT LEGACY tab
                tat_legacy_rows = section_data[section_key]['tat_legacy']
                df_tat_legacy = pd.DataFrame([{k: r[k] for k in column_order} for r in tat_legacy_rows]) if tat_legacy_rows else pd.DataFrame(columns=column_order)
                for col in column_order:
                    if col not in df_tat_legacy.columns:
                        df_tat_legacy[col] = ''
                df_tat_legacy = df_tat_legacy[column_order]
                df_tat_legacy.to_excel(writer, sheet_name=f'TAT LEGACY - {section_title}', index=False)
        
        print(f"[NEWSLETTER] Excel generated: {excel_filepath}")
        
        # ===== GENERATE DOCX FILES (using python-docx) =====
        from docx import Document as DocxDocument
        from docx.shared import Inches, Pt, RGBColor
        from docx.enum.text import WD_ALIGN_PARAGRAPH
        from docx.enum.table import WD_TABLE_ALIGNMENT
        from docx.oxml.ns import nsdecls
        from docx.oxml import parse_xml
        
        def create_newsletter_docx(location_name: str, location_data: dict, output_path: Path):
            """Create a newsletter DOCX file with tables for each section"""
            doc = DocxDocument()
            
            # Set narrow margins
            for section in doc.sections:
                section.top_margin = Inches(0.5)
                section.bottom_margin = Inches(0.5)
                section.left_margin = Inches(0.5)
                section.right_margin = Inches(0.5)
            
            # Title
            title = doc.add_paragraph()
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            title_run = title.add_run(location_name)
            title_run.bold = True
            title_run.font.size = Pt(18)
            title_run.font.name = 'Arial'
            
            # Subtitle with month
            subtitle = doc.add_paragraph()
            subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
            subtitle_run = subtitle.add_run(f"{current_month} Daily Deal Schedule Notes:")
            subtitle_run.bold = True
            subtitle_run.font.size = Pt(14)
            subtitle_run.font.name = 'Arial'
            
            # Add spacing after subtitle
            doc.add_paragraph()
            
            def add_section_table(section_title: str, section_rows: list):
                """Add a section with title and table"""
                # Section title
                sec_title = doc.add_paragraph()
                sec_title_run = sec_title.add_run(section_title)
                sec_title_run.bold = True
                sec_title_run.font.size = Pt(12)
                sec_title_run.font.name = 'Arial'
                
                if not section_rows:
                    no_data = doc.add_paragraph()
                    no_data_run = no_data.add_run("No deals in this section.")
                    no_data_run.italic = True
                    no_data_run.font.size = Pt(10)
                    no_data_run.font.name = 'Arial'
                    no_data_run.font.color.rgb = RGBColor(102, 102, 102)
                    doc.add_paragraph()  # Spacer
                    return
                
                # Create table: Brand, Deal Info, Mon, Tues, Wed, Thurs, Fri, Sat, Sun
                table = doc.add_table(rows=1 + len(section_rows), cols=9)
                table.style = 'Table Grid'
                table.alignment = WD_TABLE_ALIGNMENT.CENTER
                
                # Set column widths
                widths = [Inches(1.2), Inches(2.3), Inches(0.5), Inches(0.5), Inches(0.5), Inches(0.5), Inches(0.5), Inches(0.5), Inches(0.5)]
                for row in table.rows:
                    for idx, cell in enumerate(row.cells):
                        cell.width = widths[idx]
                
                # Header row
                headers = ['Brand', 'Deal Info', 'Mon.', 'Tues.', 'Wed.', 'Thurs.', 'Fri.', 'Sat.', 'Sun.']
                header_row = table.rows[0]
                for idx, header_text in enumerate(headers):
                    cell = header_row.cells[idx]
                    cell.text = ''
                    para = cell.paragraphs[0]
                    para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                    run = para.add_run(header_text)
                    run.bold = True
                    run.font.size = Pt(9)
                    run.font.name = 'Arial'
                    # Light blue background for header
                    shading = parse_xml(f'<w:shd {nsdecls("w")} w:fill="D9E2F3"/>')
                    cell._tc.get_or_add_tcPr().append(shading)
                
                # Data rows
                for row_idx, row_data in enumerate(section_rows):
                    data_row = table.rows[row_idx + 1]
                    days = row_data.get('Days', {})
                    
                    cell_values = [
                        row_data.get('Brand', ''),
                        row_data.get('Deal_Info', ''),
                        days.get('Mon.', ''),
                        days.get('Tues.', ''),
                        days.get('Wed.', ''),
                        days.get('Thurs.', ''),
                        days.get('Fri.', ''),
                        days.get('Sat.', ''),
                        days.get('Sun.', '')
                    ]
                    
                    for col_idx, cell_value in enumerate(cell_values):
                        cell = data_row.cells[col_idx]
                        cell.text = ''
                        para = cell.paragraphs[0]
                        # Center align day columns (index 2-8)
                        if col_idx >= 2:
                            para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                        run = para.add_run(str(cell_value))
                        run.font.size = Pt(9)
                        run.font.name = 'Arial'
                
                # Add spacer after table
                doc.add_paragraph()
            
            # Add each section
            add_section_table("Weekly Deals", location_data.get('weekly', []))
            add_section_table("Monthly Deals", location_data.get('monthly', []))
            add_section_table("Sale Deals", location_data.get('sale', []))
            
            # Save document
            doc.save(str(output_path))
            print(f"[NEWSLETTER] DOCX saved: {output_path}")
        
        # Generate CLUB420 document - save directly to newsletter folder
        club420_docx = newsletter_folder / f'CLUB420_Newsletter_{timestamp}.docx'
        try:
            club420_data = {
                'weekly': section_data['weekly']['club420'],
                'monthly': section_data['monthly']['club420'],
                'sale': section_data['sale']['club420']
            }
            create_newsletter_docx("CLUB420", club420_data, club420_docx)
        except Exception as e:
            print(f"[NEWSLETTER] Error creating CLUB420 DOCX: {e}")
            traceback.print_exc()
        
        # Generate TAT LEGACY document - save directly to newsletter folder
        tat_legacy_docx = newsletter_folder / f'TAT_LEGACY_Newsletter_{timestamp}.docx'
        try:
            tat_legacy_data = {
                'weekly': section_data['weekly']['tat_legacy'],
                'monthly': section_data['monthly']['tat_legacy'],
                'sale': section_data['sale']['tat_legacy']
            }
            create_newsletter_docx("TAT LEGACY", tat_legacy_data, tat_legacy_docx)
        except Exception as e:
            print(f"[NEWSLETTER] Error creating TAT LEGACY DOCX: {e}")
            traceback.print_exc()
        
        # Check what was created
        excel_created = excel_filepath.exists()
        club420_created = club420_docx.exists()
        tat_legacy_created = tat_legacy_docx.exists()
        
        # Log summary
        print(f"[NEWSLETTER] ========== GENERATION COMPLETE ==========")
        print(f"[NEWSLETTER] Output folder: {newsletter_folder}")
        print(f"[NEWSLETTER] Excel created: {excel_created}")
        print(f"[NEWSLETTER] CLUB420 DOCX created: {club420_created}")
        print(f"[NEWSLETTER] TAT LEGACY DOCX created: {tat_legacy_created}")
        print(f"[NEWSLETTER] CLUB420 - Weekly: {len(section_data['weekly']['club420'])}, Monthly: {len(section_data['monthly']['club420'])}, Sale: {len(section_data['sale']['club420'])}")
        print(f"[NEWSLETTER] TAT LEGACY - Weekly: {len(section_data['weekly']['tat_legacy'])}, Monthly: {len(section_data['monthly']['tat_legacy'])}, Sale: {len(section_data['sale']['tat_legacy'])}")
        print(f"[NEWSLETTER] ==========================================")
        
        # Return success with folder path
        return jsonify({
            'success': True,
            'folder': str(newsletter_folder),
            'files': {
                'excel': str(excel_filepath) if excel_created else None,
                'club420_docx': str(club420_docx) if club420_created else None,
                'tat_legacy_docx': str(tat_legacy_docx) if tat_legacy_created else None
            },
            'counts': {
                'club420': {
                    'weekly': len(section_data['weekly']['club420']),
                    'monthly': len(section_data['monthly']['club420']),
                    'sale': len(section_data['sale']['club420'])
                },
                'tat_legacy': {
                    'weekly': len(section_data['weekly']['tat_legacy']),
                    'monthly': len(section_data['monthly']['tat_legacy']),
                    'sale': len(section_data['sale']['tat_legacy'])
                }
            }
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================================
# FIXED MIS AUTOMATION: PULL CSV WITH SMART VALIDATION & RETRY
# ============================================================================
def pull_mis_csv_report_background(driver) -> Tuple[bool, str, str]:
    """
    Background version of pull_mis_csv_report that uses provided driver.
    Navigates to MIS, clears search, ensures 'ALL' rows visible, downloads CSV.
    
    NEW: Smart Validation & Retry Logic
    - Verifies table is fully populated before clicking CSV button
    - Validates downloaded file size (< 1KB = misfire/empty)
    - Retries up to 3 times if misfire detected
    
    Returns: (Success, Full Path or Error Message, Filename)
    """
    if not driver:
        return False, "Browser not ready", ""
    
    target_url = "https://mis.theartisttree.com/daily-discount"
    MAX_RETRY_ATTEMPTS = 3
    MIN_VALID_FILE_SIZE = 1024  # 1KB minimum for valid CSV
    
    try:
        # Already on MIS tab from execute_in_background
        # Wait for page to be ready
        time.sleep(2)
            
        # 1. Clear Search Bar
        print("[MIS CSV] Clearing Search Bar...")
        search_input = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
        )
        search_input.clear()
        search_input.send_keys(Keys.CONTROL + "a")
        search_input.send_keys(Keys.DELETE)

        # 2. Set table to show ALL entries
        print("[MIS CSV] Verifying table length setting...")
        try:
            dropdown_element = WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.NAME, "daily-discount_length"))
            )
            
            select = Select(dropdown_element)
            current_val = select.first_selected_option.get_attribute("value")
            
            if current_val != "-1":
                print("[MIS CSV] Switching view to 'All' entries...")
                select.select_by_value("-1")
                
                # Wait for loading to complete
                print("[MIS CSV] Waiting for loading spinner to disappear...")
                try:
                    WebDriverWait(driver, 30).until_not(
                        EC.presence_of_element_located((By.CSS_SELECTOR, "td.dataTables_empty"))
                    )
                    print("[MIS CSV] [OK] Loading spinner disappeared")
                except TimeoutException:
                    print("[WARN] Spinner timeout, proceeding...")
                
        except Exception as e:
            print(f"[WARN] Table setup error: {e}")
        
        # ================================================================
        # SMART VALIDATION: Ensure table is FULLY POPULATED before download
        # ================================================================
        def verify_table_populated():
            """
            Returns True if table has actual data rows (not loading/empty).
            Checks for:
            - No "Loading..." text
            - No "No data available" message
            - At least one real data row with content
            """
            try:
                # Check for empty/loading states
                empty_cells = driver.find_elements(By.CSS_SELECTOR, "td.dataTables_empty")
                for cell in empty_cells:
                    if cell.is_displayed():
                        cell_text = cell.text.lower()
                        if 'loading' in cell_text or 'no data' in cell_text or 'processing' in cell_text:
                            return False
                
                # Check for actual data rows
                data_rows = driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.dataTables_empty)")
                if len(data_rows) == 0:
                    return False
                
                # Verify at least one row has actual content (not empty)
                for row in data_rows[:3]:  # Check first 3 rows
                    try:
                        cells = row.find_elements(By.CSS_SELECTOR, "td")
                        if len(cells) > 0 and any(cell.text.strip() for cell in cells):
                            return True
                    except:
                        continue
                
                return False
            except:
                return False
        
        # Wait for table to be fully populated
        print("[MIS CSV] Waiting for table to be fully populated...")
        for wait_attempt in range(15):  # Up to 15 seconds
            if verify_table_populated():
                row_count = len(driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.dataTables_empty)"))
                print(f"[MIS CSV] [OK] Table populated with {row_count} rows")
                break
            time.sleep(1)
            if wait_attempt == 14:
                print("[WARN] Table population timeout, proceeding anyway...")
        
        # Extra stability wait
        time.sleep(1)
        
        # ================================================================
        # RETRY LOOP: Download CSV with validation and retry on misfire
        # ================================================================
        for attempt in range(1, MAX_RETRY_ATTEMPTS + 1):
            print(f"[MIS CSV] Download attempt {attempt}/{MAX_RETRY_ATTEMPTS}...")
            
            # Snapshot files before download
            existing_files = set(os.listdir(MIS_REPORTS_DIR))
            
            # Click CSV Button
            print("[MIS CSV] Clicking CSV Button...")
            csv_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.buttons-csv"))
            )
            driver.execute_script("arguments[0].click();", csv_btn)
            
            # Wait for new file to appear
            print("[MIS CSV] Waiting for download...")
            new_file_path = None
            for _ in range(30):  # 30 second timeout
                time.sleep(1)
                current_files = set(os.listdir(MIS_REPORTS_DIR))
                new_files = current_files - existing_files
                for f in new_files:
                    if (f.endswith('.csv') or f.endswith('.xlsx')) and not f.endswith('.crdownload'):
                        new_file_path = MIS_REPORTS_DIR / f
                        break
                if new_file_path:
                    break
            
            if not new_file_path:
                print(f"[MIS CSV] [WARN] Download timed out on attempt {attempt}")
                if attempt < MAX_RETRY_ATTEMPTS:
                    print("[MIS CSV] Refreshing and retrying...")
                    driver.refresh()
                    time.sleep(3)
                    continue
                else:
                    return False, "Download timed out after all retry attempts", ""
            
            # ================================================================
            # SIZE VALIDATION: Check if file is a misfire (< 1KB)
            # ================================================================
            time.sleep(0.5)  # Let file finish writing
            file_size = os.path.getsize(new_file_path)
            print(f"[MIS CSV] Downloaded file size: {file_size} bytes")
            
            if file_size < MIN_VALID_FILE_SIZE:
                print(f"[MIS CSV] [MISFIRE] File too small ({file_size} bytes < {MIN_VALID_FILE_SIZE} bytes) - likely empty!")
                
                # Delete the empty/broken file
                try:
                    os.remove(new_file_path)
                    print(f"[MIS CSV] Deleted misfire file: {new_file_path}")
                except Exception as del_err:
                    print(f"[WARN] Could not delete misfire file: {del_err}")
                
                if attempt < MAX_RETRY_ATTEMPTS:
                    print(f"[MIS CSV] Waiting 3 seconds before retry {attempt + 1}...")
                    time.sleep(3)
                    
                    # Refresh table to ensure data is loaded
                    print("[MIS CSV] Refreshing page before retry...")
                    driver.refresh()
                    time.sleep(3)
                    
                    # Re-verify table is populated
                    for wait_attempt in range(10):
                        if verify_table_populated():
                            print("[MIS CSV] Table re-populated, retrying download...")
                            break
                        time.sleep(1)
                    
                    continue  # Try again
                else:
                    return False, f"Download misfire (empty file) after {MAX_RETRY_ATTEMPTS} attempts", ""
            
            # ================================================================
            # SUCCESS: Valid file downloaded
            # ================================================================
            print(f"[MIS CSV] [OK] Valid file downloaded ({file_size} bytes)")
            
            # Rename to standard format
            now = datetime.now()
            final_name = f"MIS_CSV_REPORT_{now.strftime('%Y-%m-%d')}_{now.strftime('%I-%M-%S-%p')}.csv"
            final_path = MIS_REPORTS_DIR / final_name
            
            if final_path.exists():
                os.remove(final_path)
            time.sleep(0.5)
            os.rename(new_file_path, final_path)
            
            print(f"[MIS CSV] [OK] Report Ready: {final_name} ({file_size} bytes)")
            return True, str(final_path), final_name
        
        # Should not reach here, but just in case
        return False, "Unknown error during CSV download", ""

    except Exception as e:
        print(f"[ERROR] MIS CSV Pull failed: {e}")
        traceback.print_exc()
        return False, f"Error: {str(e)}", ""

def pull_mis_csv_report() -> Tuple[bool, str, str]:
    """
    Navigates to MIS, clears search, ENSURES 'ALL' ROWS VISIBLE with validation,
    clicks CSV, downloads, and renames.
    
    NEW: Smart Validation & Retry Logic
    - Verifies table is fully populated before clicking CSV button
    - Validates downloaded file size (< 1KB = misfire/empty)
    - Retries up to 3 times if misfire detected
    
    Returns: (Success, Full Path, Filename)
    """
    driver = GLOBAL_DATA['browser_instance']
    if not driver: return False, "Browser not ready", ""
    
    target_url = "https://mis.theartisttree.com/daily-discount"
    MAX_RETRY_ATTEMPTS = 3
    MIN_VALID_FILE_SIZE = 1024  # 1KB minimum for valid CSV
    
    try:
        # 1. Navigate / Switch Tab
        found = False
        for h in driver.window_handles:
            driver.switch_to.window(h)
            if "daily-discount" in driver.current_url:
                found = True
                break
        
        if not found:
            driver.execute_script(f"window.open('{target_url}', '_blank');")
            driver.switch_to.window(driver.window_handles[-1])
        else:
            driver.get(target_url)  # Refresh to clear state
            
        # 2. Clear Search Bar
        print("[MIS CSV] Clearing Search Bar...")
        search_input = WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
        )
        search_input.clear()
        search_input.send_keys(Keys.CONTROL + "a")
        search_input.send_keys(Keys.DELETE)

        # 3. Set table to show ALL entries
        print("[MIS CSV] Verifying table length setting...")
        try:
            dropdown_element = WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.NAME, "daily-discount_length"))
            )
            
            select = Select(dropdown_element)
            current_val = select.first_selected_option.get_attribute("value")
            
            if current_val != "-1":
                print("[MIS CSV] Switching view to 'All' entries...")
                select.select_by_value("-1")
                
                # Wait for loading to complete
                print("[MIS CSV] Waiting for loading spinner to disappear...")
                try:
                    WebDriverWait(driver, 30).until_not(
                        EC.presence_of_element_located((By.CSS_SELECTOR, "td.dataTables_empty"))
                    )
                    print("[MIS CSV] [OK] Loading spinner disappeared")
                except TimeoutException:
                    print("[WARN] Spinner timeout, proceeding...")
                    
        except Exception as e:
            print(f"[WARN] Table setup error: {e}")
        
        # ================================================================
        # SMART VALIDATION: Ensure table is FULLY POPULATED before download
        # ================================================================
        def verify_table_populated():
            """
            Returns True if table has actual data rows (not loading/empty).
            """
            try:
                # Check for empty/loading states
                empty_cells = driver.find_elements(By.CSS_SELECTOR, "td.dataTables_empty")
                for cell in empty_cells:
                    if cell.is_displayed():
                        cell_text = cell.text.lower()
                        if 'loading' in cell_text or 'no data' in cell_text or 'processing' in cell_text:
                            return False
                
                # Check for actual data rows
                data_rows = driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.dataTables_empty)")
                if len(data_rows) == 0:
                    return False
                
                # Verify at least one row has actual content
                for row in data_rows[:3]:
                    try:
                        cells = row.find_elements(By.CSS_SELECTOR, "td")
                        if len(cells) > 0 and any(cell.text.strip() for cell in cells):
                            return True
                    except:
                        continue
                
                return False
            except:
                return False
        
        # Wait for table to be fully populated
        print("[MIS CSV] Waiting for table to be fully populated...")
        for wait_attempt in range(15):
            if verify_table_populated():
                row_count = len(driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.dataTables_empty)"))
                print(f"[MIS CSV] [OK] Table populated with {row_count} rows")
                break
            time.sleep(1)
            if wait_attempt == 14:
                print("[WARN] Table population timeout, proceeding anyway...")
        
        # Extra stability wait
        time.sleep(1)
        
        # ================================================================
        # RETRY LOOP: Download CSV with validation and retry on misfire
        # ================================================================
        for attempt in range(1, MAX_RETRY_ATTEMPTS + 1):
            print(f"[MIS CSV] Download attempt {attempt}/{MAX_RETRY_ATTEMPTS}...")
            
            # Snapshot files before download
            existing_files = set(os.listdir(MIS_REPORTS_DIR))
            
            # Click CSV Button
            print("[MIS CSV] Clicking CSV Button...")
            csv_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.buttons-csv"))
            )
            driver.execute_script("arguments[0].click();", csv_btn)
            
            # Wait for new file to appear
            print("[MIS CSV] Waiting for download...")
            new_file_path = None
            for _ in range(30):
                time.sleep(1)
                current_files = set(os.listdir(MIS_REPORTS_DIR))
                new_files = current_files - existing_files
                for f in new_files:
                    if (f.endswith('.csv') or f.endswith('.xlsx')) and not f.endswith('.crdownload'):
                        new_file_path = MIS_REPORTS_DIR / f
                        break
                if new_file_path:
                    break
            
            if not new_file_path:
                print(f"[MIS CSV] [WARN] Download timed out on attempt {attempt}")
                if attempt < MAX_RETRY_ATTEMPTS:
                    print("[MIS CSV] Refreshing and retrying...")
                    driver.refresh()
                    time.sleep(3)
                    continue
                else:
                    return False, "Download timed out after all retry attempts", ""
            
            # ================================================================
            # SIZE VALIDATION: Check if file is a misfire (< 1KB)
            # ================================================================
            time.sleep(0.5)
            file_size = os.path.getsize(new_file_path)
            print(f"[MIS CSV] Downloaded file size: {file_size} bytes")
            
            if file_size < MIN_VALID_FILE_SIZE:
                print(f"[MIS CSV] [MISFIRE] File too small ({file_size} bytes < {MIN_VALID_FILE_SIZE} bytes) - likely empty!")
                
                # Delete the empty/broken file
                try:
                    os.remove(new_file_path)
                    print(f"[MIS CSV] Deleted misfire file: {new_file_path}")
                except Exception as del_err:
                    print(f"[WARN] Could not delete misfire file: {del_err}")
                
                if attempt < MAX_RETRY_ATTEMPTS:
                    print(f"[MIS CSV] Waiting 3 seconds before retry {attempt + 1}...")
                    time.sleep(3)
                    
                    # Refresh table to ensure data is loaded
                    print("[MIS CSV] Refreshing page before retry...")
                    driver.refresh()
                    time.sleep(3)
                    
                    # Re-verify table is populated
                    for wait_attempt in range(10):
                        if verify_table_populated():
                            print("[MIS CSV] Table re-populated, retrying download...")
                            break
                        time.sleep(1)
                    
                    continue
                else:
                    return False, f"Download misfire (empty file) after {MAX_RETRY_ATTEMPTS} attempts", ""
            
            # ================================================================
            # SUCCESS: Valid file downloaded
            # ================================================================
            print(f"[MIS CSV] [OK] Valid file downloaded ({file_size} bytes)")
            
            # Rename to standard format
            now = datetime.now()
            final_name = f"MIS_CSV_REPORT_{now.strftime('%Y-%m-%d')}_{now.strftime('%I-%M-%S-%p')}.csv"
            final_path = MIS_REPORTS_DIR / final_name
            
            if final_path.exists():
                os.remove(final_path)
            time.sleep(0.5)
            os.rename(new_file_path, final_path)
            
            print(f"[MIS CSV] [OK] Report Ready: {final_name} ({file_size} bytes)")
            return True, str(final_path), final_name
        
        # Should not reach here
        return False, "Unknown error during CSV download", ""

    except Exception as e:
        print(f"[ERROR] MIS CSV Pull failed: {e}")
        traceback.print_exc()
        return False, str(e), ""

@app.route('/api/mis/pull-csv', methods=['POST'])
def api_mis_pull_csv():
    """Pull MIS CSV in background without switching user's visible tab."""
    # Get credentials from request (GUI fields)
    data = request.get_json() or {}
    gui_username = data.get('mis_username', '').strip()
    gui_password = data.get('mis_password', '').strip()
    
    def pull_operation(driver):
        """Inner function for background execution."""
        return pull_mis_csv_report_background(driver)
    
    # Pass credentials to background executor
    result = execute_in_background('mis', pull_operation, gui_username=gui_username, gui_password=gui_password)
    
    if result['success']:
        success, path, filename = result['result']
        if success:
            # Store the filepath globally
            GLOBAL_DATA['mis']['mis_csv_filepath'] = path
            GLOBAL_DATA['mis']['mis_csv_filename'] = filename
            print(f"[CSV-PULL] Stored in GLOBAL_DATA: {filename}")
            return jsonify({'success': True, 'path': path, 'filename': filename})
        else:
            return jsonify({'success': False, 'error': path})  # path contains error message
    else:
        return jsonify({'success': False, 'error': result['error']})

@app.route('/api/debug/token-test', methods=['GET'])
def api_debug_token_test():
    """
    DIAGNOSTIC ROUTE: Tests current token against all Blaze endpoints.
    Access: http://127.0.0.1:5100/api/debug/token-test
    """
    try:
        # 1. Load current token
        token = GLOBAL_DATA['blaze'].get('token') or load_stored_token()
        
        if not token:
            return jsonify({
                'error': 'No token available',
                'action': 'Please login to Blaze first'
            })
        
        # Handle both dict and string formats
        if isinstance(token, dict):
            test_token = token.get('promo_token') or token.get('group_token') or ''
        else:
            test_token = str(token)
        
        headers = {"Authorization": f"Token {test_token}"}
        results = {}
        
        # 2. Test Shops Endpoint
        print("\n[DIAGNOSTIC] Testing Shops endpoint...")
        try:
            r = requests.get("https://api.blaze.me/api/v1/mgmt/shops?start=0&limit=5", 
                           headers=headers, timeout=10)
            results['shops'] = {
                'status_code': r.status_code,
                'success': r.ok,
                'count': len(r.json().get('values', [])) if r.ok else 0,
                'sample': r.json().get('values', [])[:2] if r.ok else None,
                'error': r.text[:200] if not r.ok else None
            }
        except Exception as e:
            results['shops'] = {'error': str(e)}
        
        # 3. Test Collections Endpoint (CRITICAL)
        print("[DIAGNOSTIC] Testing SmartCollections endpoint...")
        try:
            r = requests.get("https://api.blaze.me/api/v1/mgmt/smartcollections?start=0&limit=5",
                           headers=headers, timeout=10)
            results['collections'] = {
                'status_code': r.status_code,
                'success': r.ok,
                'raw_response_type': type(r.json()).__name__ if r.ok else 'N/A',
                'count': len(r.json().get('values', [])) if r.ok and isinstance(r.json(), dict) else (len(r.json()) if r.ok else 0),
                'sample': (r.json().get('values', [])[:2] if isinstance(r.json(), dict) else r.json()[:2]) if r.ok else None,
                'error': r.text[:200] if not r.ok else None
            }
        except Exception as e:
            results['collections'] = {'error': str(e)}
        
        # 4. Test Promotions Endpoint
        print("[DIAGNOSTIC] Testing Promotions endpoint...")
        try:
            r = requests.get("https://api.blaze.me/api/v1/mgmt/company/promotions?start=0&limit=5",
                           headers=headers, timeout=10)
            results['promotions'] = {
                'status_code': r.status_code,
                'success': r.ok,
                'count': len(r.json().get('values', [])) if r.ok else 0,
                'sample': r.json().get('values', [])[:1] if r.ok else None,
                'error': r.text[:200] if not r.ok else None
            }
        except Exception as e:
            results['promotions'] = {'error': str(e)}
        
        # 5. Summary
        summary = {
            'token_preview': test_token[:15] + '...' if test_token else 'MISSING',
            'shops_working': results.get('shops', {}).get('success', False),
            'collections_working': results.get('collections', {}).get('success', False),
            'promotions_working': results.get('promotions', {}).get('success', False)
        }
        
        print("\n[DIAGNOSTIC] Results:")
        print(f"  Shops: {'[OK]' if summary['shops_working'] else '[ERROR]'}")
        print(f"  Collections: {'[OK]' if summary['collections_working'] else '[ERROR]'}")
        print(f"  Promotions: {'[OK]' if summary['promotions_working'] else '[ERROR]'}")
        
        return jsonify({
            'summary': summary,
            'detailed_results': results,
            'diagnosis': diagnose_issue(summary, results)
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'error': str(e)})

def diagnose_issue(summary, results):
    """Analyzes test results and provides diagnosis."""
    diagnosis = []
    
    if not summary['collections_working']:
        coll_result = results.get('collections', {})
        status = coll_result.get('status_code')
        
        if status == 401:
            diagnosis.append(" DIAGNOSIS: Token lacks permissions for SmartCollections endpoint")
            diagnosis.append("   Solution: Need to capture token from a page that loads collections")
        elif status == 403:
            diagnosis.append(" DIAGNOSIS: Token is valid but forbidden from accessing collections")
            diagnosis.append("   Solution: User account may need elevated permissions")
        elif status == 404:
            diagnosis.append(" DIAGNOSIS: Collections endpoint may have moved")
            diagnosis.append("   Solution: Check Blaze API documentation for endpoint changes")
        else:
            diagnosis.append(f" DIAGNOSIS: Collections API returned {status}")
            diagnosis.append(f"   Error: {coll_result.get('error', 'Unknown')}")
    else:
        count = results.get('collections', {}).get('count', 0)
        if count == 0:
            diagnosis.append("[!] [EMOJI]√É‚Äö√Ç¬è[EMOJI]√É‚Äö√Ç¬è Collections endpoint works but returns 0 items")
            diagnosis.append("   Check: Are there actually Smart Collections in Blaze admin?")
        else:
            diagnosis.append(f"[SUCCESS] Collections working correctly ({count} items found)")
    
    if summary['shops_working'] and summary['promotions_working'] and not summary['collections_working']:
        diagnosis.append("\n PATTERN: Promotions & Shops work, but Collections fail")
        diagnosis.append("   This suggests the token has LIMITED scope")
    
    return diagnosis

@app.route('/api/mis/match', methods=['POST'])
def api_mis_match():
    """Match Google Sheet rows to MIS IDs with brand list AND Settings tab support."""
    try:
        tab_name = request.form.get('tab')
        csv_file = request.files.get('csv')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab'})
        
        # --- NEW: Check both uploaded file AND pulled CSV ---
        mis_df = None
        
        if csv_file:
            # User uploaded a CSV file
            print("[MATCHER] Using uploaded CSV file")
            mis_df = pd.read_csv(csv_file)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            # Use the pulled CSV from disk
            pulled_csv_path = GLOBAL_DATA['mis']['mis_csv_filepath']
            print(f"[MATCHER] Using pulled CSV: {GLOBAL_DATA['mis'].get('mis_csv_filename')}")
            
            if Path(pulled_csv_path).exists():
                mis_df = pd.read_csv(pulled_csv_path)
            else:
                return jsonify({'success': False, 'error': f'Pulled CSV not found: {pulled_csv_path}'})
        else:
            return jsonify({'success': False, 'error': 'No CSV available. Please pull CSV or upload manually.'})
        
        GLOBAL_DATA['mis']['mis_df'] = mis_df
        
        # --- NEW: Update Brand List ---
        brand_list = manage_brand_list(mis_df)
        
        # Fetch Google Sheet data (Returns Dictionary of DataFrames)
        sections_data = fetch_google_sheet_data(tab_name)
        
        # Check if all empty
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found in any section'})
        
        # --- NEW: Load brand settings from Settings tab ---
        print("[MATCHER] Loading brand settings from Settings tab...")
        # We must pass the spreadsheet_id currently stored in GLOBAL_DATA
        brand_settings = load_brand_settings(GLOBAL_DATA['mis']['spreadsheet_id'])
        if brand_settings:
            print(f"[MATCHER] Loaded {len(brand_settings)} brand relationship rules.")
        else:
            print("[MATCHER] No brand settings found or Settings tab not available.")
            brand_settings = {}
        
        # Run matching for each section
        all_matches = {}
        for section in ['weekly', 'monthly', 'sale']:
            df = sections_data.get(section, pd.DataFrame())
            if not df.empty:
                # PASS section_type HERE
                matches = enhanced_match_mis_ids(df, mis_df, brand_list, brand_settings, section_type=section)
                all_matches[section] = matches
                print(f"[MATCHER] Section {section}: {len(matches)} matches generated")
            else:
                all_matches[section] = []
                print(f"[MATCHER] Section {section}: DataFrame is empty")
                
        GLOBAL_DATA['mis']['match_results'] = all_matches
        
        print(f"[MATCHER] Final response: weekly={len(all_matches.get('weekly', []))}, monthly={len(all_matches.get('monthly', []))}, sale={len(all_matches.get('sale', []))}")
        return jsonify({'success': True, 'matches': all_matches})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/apply-matches', methods=['POST'])
def api_mis_apply_matches():
    """
    Apply MIS ID matches from ID MATCHER tab.
    v10.9: Uses section-aware tags (W1, M1, S1) based on deal type.
    """
    try:
        data = request.get_json()
        matches = data.get('matches', {})
        if not matches:
            return jsonify({'success': False, 'error': 'No matches'})
        service = GLOBAL_DATA['sheets_service']
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        sheet_name = GLOBAL_DATA['mis']['current_sheet']
        if not service or not spreadsheet_id or not sheet_name:
            return jsonify({'success': False, 'error': 'Not configured'})
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{sheet_name}'!A1:BZ20"
        ).execute()
        values = result.get('values', [])
        if not values:
            return jsonify({'success': False, 'error': 'Sheet empty'})
        header_row_idx = detect_header_row(values)
        headers = values[header_row_idx]
        mis_id_col = None
        for idx, header in enumerate(headers):
            if 'MIS ID' in str(header) or header == 'ID':
                mis_id_col = idx
                break
        if mis_id_col is None:
            return jsonify({'success': False, 'error': 'MIS ID column not found'})
        
        def get_col_letter(n):
            string = ""
            while n >= 0:
                string = chr((n % 26) + 65) + string
                n = (n // 26) - 1
            return string
        
        target_col_letter = get_col_letter(mis_id_col)
        
        # First, read all current values for the rows we're updating
        row_numbers = [int(r) for r in matches.keys()]
        current_values = {}
        
        # Batch read current values
        ranges = [f"'{sheet_name}'!{target_col_letter}{row}" for row in row_numbers]
        if ranges:
            try:
                batch_result = service.spreadsheets().values().batchGet(
                    spreadsheetId=spreadsheet_id,
                    ranges=ranges
                ).execute()
                
                value_ranges = batch_result.get('valueRanges', [])
                for i, vr in enumerate(value_ranges):
                    vals = vr.get('values', [[]])
                    current_values[row_numbers[i]] = vals[0][0] if vals and vals[0] else ''
            except Exception as e:
                print(f"[APPLY-MATCHES] Warning: Could not batch read: {e}")
        
        # Build updates with section-aware tags
        updates = []
        for google_row, match_data in matches.items():
            sheet_row = int(google_row)
            
            # v12.1: Handle new format with mis_ids array (multi-brand) or legacy formats
            if isinstance(match_data, dict):
                # Check for multi-brand format (mis_ids array)
                if 'mis_ids' in match_data and isinstance(match_data['mis_ids'], list):
                    mis_ids = match_data['mis_ids']
                    is_multi_brand = match_data.get('is_multi_brand', False)
                elif 'mis_id' in match_data:
                    mis_ids = [str(match_data.get('mis_id', '')).strip()]
                    is_multi_brand = False
                else:
                    mis_ids = []
                    is_multi_brand = False
                section = match_data.get('section', 'weekly').lower()
            else:
                # Legacy format: just the MIS ID string
                mis_ids = [str(match_data).strip()]
                section = 'weekly'
                is_multi_brand = False
            
            # Determine tag based on section
            if section == 'monthly':
                tag = 'm1'
                tag_display = 'M1'
            elif section == 'sale':
                tag = 's1'
                tag_display = 'S1'
            else:
                tag = 'w1'
                tag_display = 'W1'
            
            # Get existing content
            existing = current_values.get(sheet_row, '')
            
            # v12.1: For multi-brand, apply each MIS ID sequentially with the same tag
            new_value = existing
            first_id = True  # Track if this is the first ID being added
            for mis_id in mis_ids:
                mis_id = str(mis_id).strip()
                if not mis_id:
                    continue
                    
                if new_value:
                    # Use update function to merge with existing content
                    # v12.1: Use append_mode for multi-brand after first ID
                    append_mode = is_multi_brand and not first_id
                    new_value = update_tagged_mis_cell(new_value, tag, mis_id, append_mode=append_mode)
                else:
                    # No existing content - create new entry with section-based tag
                    new_value = f"{tag_display}: {mis_id}"
                first_id = False
            
            if new_value != existing:  # Only add update if value changed
                updates.append({
                    'range': f"'{sheet_name}'!{target_col_letter}{sheet_row}",
                    'values': [[new_value]]
                })
                
                if is_multi_brand:
                    print(f"[APPLY-MATCHES] Row {sheet_row}: Multi-brand {len(mis_ids)} IDs: {mis_ids} (section: {section})")
                else:
                    print(f"[APPLY-MATCHES] Row {sheet_row}: {tag_display}: {mis_ids[0] if mis_ids else 'N/A'} (section: {section})")
        
        body = {
            'valueInputOption': 'RAW',
            'data': updates
        }
        service.spreadsheets().values().batchUpdate(
            spreadsheetId=spreadsheet_id,
            body=body
        ).execute()
        
        return jsonify({'success': True, 'updated': len(updates)})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# v12.5: New endpoint to apply Blaze Discount Titles to Google Sheet
@app.route('/api/mis/apply-blaze-titles', methods=['POST'])
def api_mis_apply_blaze_titles():
    """
    Apply Blaze Discount Titles from ID MATCHER tab to Google Sheet.
    Writes to the "Blaze Discount Title" column (typically column 28/AC).
    
    v12.5: Writes newline-separated titles to preserve order.
    """
    try:
        data = request.get_json()
        matches = data.get('matches', {})
        if not matches:
            return jsonify({'success': False, 'error': 'No matches'})
        
        service = GLOBAL_DATA['sheets_service']
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        sheet_name = GLOBAL_DATA['mis']['current_sheet']
        
        if not service or not spreadsheet_id or not sheet_name:
            return jsonify({'success': False, 'error': 'Not configured'})
        
        # Get headers to find Blaze Discount Title column
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{sheet_name}'!A1:BZ20"
        ).execute()
        values = result.get('values', [])
        if not values:
            return jsonify({'success': False, 'error': 'Sheet empty'})
        
        header_row_idx = detect_header_row(values)
        headers = values[header_row_idx]
        
        # Find "Blaze Discount Title" column
        blaze_col = None
        for idx, header in enumerate(headers):
            header_clean = str(header).strip().lower()
            if 'blaze' in header_clean and ('discount' in header_clean or 'title' in header_clean):
                blaze_col = idx
                break
        
        if blaze_col is None:
            # Try exact match
            for idx, header in enumerate(headers):
                if str(header).strip() == 'Blaze Discount Title':
                    blaze_col = idx
                    break
        
        if blaze_col is None:
            return jsonify({'success': False, 'error': 'Blaze Discount Title column not found in headers'})
        
        def get_col_letter(n):
            string = ""
            while n >= 0:
                string = chr((n % 26) + 65) + string
                n = (n // 26) - 1
            return string
        
        target_col_letter = get_col_letter(blaze_col)
        print(f"[APPLY-BLAZE] Found Blaze Discount Title at column {target_col_letter} (index {blaze_col})")
        
        # Build updates
        updates = []
        for google_row, match_data in matches.items():
            sheet_row = int(google_row)
            
            # Get blaze_titles from match_data
            blaze_titles = []
            not_found_titles = []  # v12.7: Track which titles don't exist in Blaze
            if isinstance(match_data, dict):
                blaze_titles = match_data.get('blaze_titles', [])
                not_found_titles = match_data.get('blaze_titles_not_found', [])  # v12.7
            
            if not blaze_titles:
                continue  # Skip rows with no Blaze titles selected
            
            # v12.7: Append "(NOTE: Needs to be created)" for not-found titles
            formatted_titles = []
            for title in blaze_titles:
                if title in not_found_titles:
                    formatted_titles.append(f"{title} (NOTE: Needs to be created)")
                else:
                    formatted_titles.append(title)
            
            # Join titles with newlines (preserving order from queue)
            new_value = '\n'.join(formatted_titles)
            
            # TODO (Future Enhancement): Use Google Sheets API's textFormat to make
            # only the "(NOTE: Needs to be created)" text red, not the entire title.
            # This requires spreadsheets.batchUpdate with textFormatRuns instead of values().update()
            
            updates.append({
                'range': f"'{sheet_name}'!{target_col_letter}{sheet_row}",
                'values': [[new_value]]
            })
            
            print(f"[APPLY-BLAZE] Row {sheet_row}: {len(blaze_titles)} titles")
        
        if not updates:
            return jsonify({'success': True, 'updated': 0, 'message': 'No Blaze titles to apply'})
        
        body = {
            'valueInputOption': 'RAW',
            'data': updates
        }
        service.spreadsheets().values().batchUpdate(
            spreadsheetId=spreadsheet_id,
            body=body
        ).execute()
        
        print(f"[APPLY-BLAZE] Successfully updated {len(updates)} rows")
        return jsonify({'success': True, 'updated': len(updates)})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# v88: New endpoint to apply split MIS ID (with append logic)
@app.route('/api/mis/apply-split-id', methods=['POST'])
def api_mis_apply_split_id():
    """
    Apply a MIS ID to a specific Google Sheet row using tagged format.
    
    v10.9: Uses section-based tags (W1/W2/WP, M1/M2/MP, S1/S2/SP)
    
    Parameters:
        google_row: Row number in Google Sheet
        new_mis_id: The MIS ID to apply (just the number, no tag)
        tag: The tag type ('w1', 'w2', 'wp', 'm1', 'm2', 'mp', 's1', 's2', 'sp')
             Also accepts legacy: 'part1', 'part2', 'gap', 'patch'
        section: Optional - 'weekly', 'monthly', or 'sale' (used with legacy tags)
        append: If True, merge with existing content; if False, replace
    
    New format uses newline-separated tagged entries:
        W1: 12345
        WP: 67890
        W2: 54321
    """
    try:
        data = request.get_json()
        google_row = data.get('google_row')
        new_mis_id = str(data.get('new_mis_id', '')).strip()
        tag = data.get('tag', 'w1').lower()  # v10.9: Default to w1
        section = data.get('section', 'weekly').lower()  # v10.9: Section for tag conversion
        append = data.get('append', True)
        
        # Strip any existing tag from the MIS ID (in case it was passed with a tag)
        new_mis_id = strip_mis_id_tag(new_mis_id)
        
        if not google_row or not new_mis_id:
            return jsonify({'success': False, 'error': 'Missing google_row or new_mis_id'})
        
        if not new_mis_id.isdigit():
            return jsonify({'success': False, 'error': f'Invalid MIS ID format: {new_mis_id}'})
        
        service = GLOBAL_DATA['sheets_service']
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        sheet_name = GLOBAL_DATA['mis']['current_sheet']
        
        if not service or not spreadsheet_id or not sheet_name:
            return jsonify({'success': False, 'error': 'Not configured. Please open a Google Sheet tab first.'})
        
        # Get headers to find MIS ID column
        result = service.spreadsheets().values().get(
            spreadsheetId=spreadsheet_id,
            range=f"'{sheet_name}'!A1:BZ20"
        ).execute()
        values = result.get('values', [])
        if not values:
            return jsonify({'success': False, 'error': 'Sheet empty'})
        
        header_row_idx = detect_header_row(values)
        headers = values[header_row_idx]
        
        mis_id_col = None
        for idx, header in enumerate(headers):
            if 'MIS ID' in str(header) or header == 'ID':
                mis_id_col = idx
                break
        
        if mis_id_col is None:
            return jsonify({'success': False, 'error': 'MIS ID column not found in headers'})
        
        def get_col_letter(n):
            string = ""
            while n >= 0:
                string = chr((n % 26) + 65) + string
                n = (n // 26) - 1
            return string
        
        target_col_letter = get_col_letter(mis_id_col)
        cell_range = f"'{sheet_name}'!{target_col_letter}{google_row}"
        
        # Get current value
        current_value = ''
        try:
            current_result = service.spreadsheets().values().get(
                spreadsheetId=spreadsheet_id,
                range=cell_range
            ).execute()
            current_values = current_result.get('values', [[]])
            current_value = current_values[0][0] if current_values and current_values[0] else ''
            current_value = str(current_value).strip()
        except Exception as e:
            print(f"[SPLIT-ID] Warning: Could not read current value: {e}")
        
        # v10.9: Convert legacy tags to section-based tags
        section_prefix = 'W' if section == 'weekly' else ('M' if section == 'monthly' else 'S')
        
        # Map legacy tags to new format
        tag_mapping = {
            'part1': f'{section_prefix.lower()}1',
            'part2': f'{section_prefix.lower()}2',
            'part3': f'{section_prefix.lower()}3',
            'gap': f'{section_prefix.lower()}1',  # GAP uses interrupting section's tag
            'patch': f'{section_prefix.lower()}p',
        }
        
        # Convert legacy tag if needed
        if tag in tag_mapping:
            tag = tag_mapping[tag]
        
        # Build final value using tagged format
        if append and current_value:
            # Merge with existing content
            final_value = update_tagged_mis_cell(current_value, tag, new_mis_id)
        else:
            # Create new tagged entry with section-based format
            tag_upper = tag.upper()
            final_value = f"{tag_upper}: {new_mis_id}"
        
        # Write the value
        body = {
            'values': [[final_value]]
        }
        service.spreadsheets().values().update(
            spreadsheetId=spreadsheet_id,
            range=cell_range,
            valueInputOption='RAW',
            body=body
        ).execute()
        
        print(f"[SPLIT-ID] Applied {tag.upper()}: {new_mis_id} to row {google_row} (section: {section})")
        print(f"[SPLIT-ID] Final cell value:\n{final_value}")
        
        return jsonify({
            'success': True,
            'google_row': google_row,
            'tag': tag,
            'mis_id': new_mis_id,
            'new_value': final_value,
            'appended': append and current_value != ''
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# ============================================================================
# v12.1: MAudit - Google Sheet vs MIS CSV Verification
# ============================================================================
@app.route('/api/mis/maudit', methods=['POST'])
def api_mis_maudit():
    """
    v12.1: MAudit - Verify Google Sheet deals against MIS CSV data.
    Compares: Discount, Vendor %, Start/End Dates, Brand, Locations
    Groups results by verification status.
    """
    try:
        tab_name = request.form.get('tab')
        csv_file = request.files.get('csv')
        local_csv_path = request.form.get('local_csv_path')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab selected'})
        
        # Load MIS CSV
        mis_df = None
        if csv_file:
            print("[MAUDIT] Using uploaded CSV file")
            mis_df = pd.read_csv(csv_file)
        elif local_csv_path and Path(local_csv_path).exists():
            print(f"[MAUDIT] Using local CSV: {local_csv_path}")
            mis_df = pd.read_csv(local_csv_path)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            pulled_csv_path = GLOBAL_DATA['mis']['mis_csv_filepath']
            print(f"[MAUDIT] Using pulled CSV: {GLOBAL_DATA['mis'].get('mis_csv_filename')}")
            if Path(pulled_csv_path).exists():
                mis_df = pd.read_csv(pulled_csv_path)
            else:
                return jsonify({'success': False, 'error': f'Pulled CSV not found: {pulled_csv_path}'})
        else:
            return jsonify({'success': False, 'error': 'No CSV available. Please pull CSV or upload manually.'})
        
        # Fetch Google Sheet data
        sections_data = fetch_google_sheet_data(tab_name)
        
        results = {
            'verified': [],
            'mismatches': [],
            'not_found': [],
            'missing_id': []
        }
        
        # Find ID column in CSV
        id_col = None
        for col in ['ID', 'id', 'MIS ID', 'Mis Id']:
            if col in mis_df.columns:
                id_col = col
                break
        
        if not id_col:
            return jsonify({'success': False, 'error': 'Cannot find ID column in CSV'})
        
        # Process each section
        for section_name in ['weekly', 'monthly', 'sale']:
            df = sections_data.get(section_name, pd.DataFrame())
            if df.empty:
                continue
            
            for idx, row in df.iterrows():
                row_num = idx + 2  # Account for header row
                brand = str(row.get('Brand', '')).strip()
                mis_id_cell = str(row.get('MIS ID', '')).strip()
                discount = str(row.get('Discount', '')).strip()
                vendor_pct = str(row.get('Vendor %', row.get('Vendor', ''))).strip()
                locations = str(row.get('Location', row.get('Locations', ''))).strip()
                weekday = str(row.get('Weekday', '')).strip() if section_name == 'weekly' else ''
                start_date = str(row.get('Start Date', '')).strip() if section_name != 'weekly' else ''
                end_date = str(row.get('End Date', '')).strip() if section_name != 'weekly' else ''
                
                # Skip empty rows
                if not brand or brand in ['nan', 'None', '-', '']:
                    continue
                
                # Check if MIS ID exists
                if not mis_id_cell or mis_id_cell in ['nan', 'None', '-', '']:
                    results['missing_id'].append({
                        'row': row_num,
                        'section': section_name,
                        'brand': brand,
                        'weekday': weekday,
                        'start_date': start_date,
                        'discount': discount,
                        'locations': locations
                    })
                    continue
                
                # Parse MIS ID (get first part for now)
                parsed = parse_mis_id_cell(mis_id_cell, section_name)
                first_mis_id = None
                section_key = section_name
                if parsed.get(section_key) and parsed[section_key].get('parts'):
                    first_mis_id = parsed[section_key]['parts'][0]
                elif parsed.get('parts'):
                    first_mis_id = parsed['parts'][0] if parsed['parts'] else None
                
                if not first_mis_id:
                    # Try to extract any numeric ID
                    import re
                    ids = re.findall(r'\d{5,7}', mis_id_cell)
                    if ids:
                        first_mis_id = ids[0]
                
                if not first_mis_id:
                    results['missing_id'].append({
                        'row': row_num,
                        'section': section_name,
                        'brand': brand,
                        'weekday': weekday,
                        'start_date': start_date,
                        'discount': discount,
                        'locations': locations,
                        'note': 'Could not parse MIS ID'
                    })
                    continue
                
                # Look up in CSV
                csv_matches = mis_df[mis_df[id_col].astype(str).str.strip() == str(first_mis_id).strip()]
                
                if csv_matches.empty:
                    results['not_found'].append({
                        'row': row_num,
                        'section': section_name,
                        'brand': brand,
                        'mis_id': first_mis_id,
                        'weekday': weekday,
                        'start_date': start_date,
                        'discount': discount
                    })
                    continue
                
                # Compare fields
                csv_row = csv_matches.iloc[0]
                issues = []
                matches = 0
                total_fields = 0
                
                # Compare Brand (fuzzy)
                csv_brand = str(csv_row.get('Brand', '')).strip()
                total_fields += 1
                if fuzz.token_set_ratio(brand.lower(), csv_brand.lower()) >= 80:
                    matches += 1
                else:
                    issues.append(f"Brand: '{brand}' vs '{csv_brand}'")
                
                # Compare Discount
                csv_discount = str(csv_row.get('Discount', '')).strip()
                total_fields += 1
                if discount.replace('%', '').strip() == csv_discount.replace('%', '').strip():
                    matches += 1
                else:
                    issues.append(f"Discount: '{discount}' vs '{csv_discount}'")
                
                # Compare Vendor %
                csv_vendor = str(csv_row.get('Vendor %', csv_row.get('Vendor', ''))).strip()
                total_fields += 1
                if vendor_pct.replace('%', '').strip() == csv_vendor.replace('%', '').strip():
                    matches += 1
                else:
                    issues.append(f"Vendor: '{vendor_pct}' vs '{csv_vendor}'")
                
                # For weekly, compare weekday; for others compare dates
                if section_name == 'weekly':
                    csv_weekday = str(csv_row.get('Weekday', '')).strip()
                    total_fields += 1
                    if weekday.lower() == csv_weekday.lower():
                        matches += 1
                    else:
                        issues.append(f"Weekday: '{weekday}' vs '{csv_weekday}'")
                else:
                    # Compare dates
                    csv_start = str(csv_row.get('Start Date', '')).strip()
                    csv_end = str(csv_row.get('End Date', '')).strip()
                    total_fields += 2
                    if start_date == csv_start:
                        matches += 1
                    else:
                        issues.append(f"Start: '{start_date}' vs '{csv_start}'")
                    if end_date == csv_end:
                        matches += 1
                    else:
                        issues.append(f"End: '{end_date}' vs '{csv_end}'")
                
                match_percent = int((matches / total_fields) * 100) if total_fields > 0 else 0
                
                result_item = {
                    'row': row_num,
                    'section': section_name,
                    'brand': brand,
                    'mis_id': first_mis_id,
                    'weekday': weekday,
                    'start_date': start_date,
                    'discount': discount,
                    'match_percent': match_percent,
                    'issues': issues
                }
                
                if match_percent == 100:
                    results['verified'].append(result_item)
                else:
                    results['mismatches'].append(result_item)
        
        return jsonify({'success': True, 'results': results})
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/mis/cleanup-audit', methods=['POST'])
def api_mis_cleanup_audit():
    """
    Cleanup Audit: Find active MIS entries that should be turned off.
    
    Two detection methods:
    1. Full Field Match: Brand + Weekday + Discount + Vendor% + Locations don't match any Google Sheet row
    2. MIS ID Only: MIS ID doesn't appear anywhere in Google Sheet's MIS ID column
    """
    try:
        tab_name = request.form.get('tab')
        csv_file = request.files.get('csv')
        local_csv_path = request.form.get('local_csv_path')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab selected'})
        
        # Load MIS CSV
        mis_df = None
        if csv_file:
            mis_df = pd.read_csv(csv_file)
        elif local_csv_path and Path(local_csv_path).exists():
            mis_df = pd.read_csv(local_csv_path)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            pulled_csv_path = GLOBAL_DATA['mis']['mis_csv_filepath']
            if Path(pulled_csv_path).exists():
                mis_df = pd.read_csv(pulled_csv_path)
        
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'No MIS CSV available'})
        
        # Fetch Google Sheet data
        sections_data = fetch_google_sheet_data(tab_name)
        
        # Get today's date for "active" check
        from datetime import datetime
        today = datetime.now().date()
        
        # Helper: Parse date string
        def parse_date(date_str):
            if not date_str or str(date_str).lower() in ['', 'nan', 'none', 'nat']:
                return None
            date_str = str(date_str).strip()
            for fmt in ['%m/%d/%Y', '%Y-%m-%d', '%m/%d/%y', '%m-%d-%Y']:
                try:
                    return datetime.strptime(date_str, fmt).date()
                except:
                    continue
            return None
        
        # Helper: Check if MIS entry is "active"
        def is_active(row):
            end_date = parse_date(row.get('End date', ''))
            if end_date is None:
                return True  # No end date = still active
            return end_date >= today
        
        # Helper: Determine section from weekday
        def get_section_from_weekday(weekday_str):
            if not weekday_str or str(weekday_str).lower() in ['', 'nan', 'none']:
                return 'sale'  # No weekday typically means sale/monthly
            weekday_lower = str(weekday_str).lower()
            # Check if it looks like day-of-month numbers
            if any(c.isdigit() for c in weekday_lower):
                if '-' in weekday_lower or '/' in weekday_lower:
                    return 'monthly'  # Date range pattern
            # Check for weekday names
            weekdays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun']
            if any(day in weekday_lower for day in weekdays):
                return 'weekly'
            return 'monthly'  # Default for non-weekday patterns
        
        # Helper: Normalize location set for comparison
        def normalize_location_set(loc_str):
            if not loc_str or loc_str.lower() in ['all locations', 'all', '-']:
                return frozenset(['all'])
            locs = [l.strip().lower() for l in loc_str.replace('\n', ',').split(',') if l.strip()]
            return frozenset(locs)
        
        # Collect all Google Sheet MIS IDs
        all_sheet_mis_ids = set()
        sheet_entries = []  # For full field matching
        
        for section_name, df in sections_data.items():
            if df is None or df.empty:
                continue
            for _, row in df.iterrows():
                # Get MIS ID column
                mis_id_cell = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                
                # Parse all MIS IDs from the cell
                parsed = parse_mis_id_cell(mis_id_cell)
                for tag, mid in parsed.get('all_tagged', []):
                    all_sheet_mis_ids.add(str(mid).strip())
                for mid in parsed.get('untagged', []):
                    all_sheet_mis_ids.add(str(mid).strip())
                
                # Collect entry data for full field matching
                brand = str(row.get('Brand', '')).strip()
                weekday = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                discount = parse_percentage(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], ''))
                vendor_pct = parse_percentage(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], ''))
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = normalize_location_set(format_location_display(loc_raw, exc_raw))
                
                if brand:
                    # Handle multi-brand
                    individual_brands = parse_multi_brand(brand)
                    for b in individual_brands:
                        sheet_entries.append({
                            'section': section_name,
                            'brand': b.lower().strip(),
                            'weekday': weekday.lower(),
                            'discount': discount,
                            'vendor_pct': vendor_pct,
                            'locations': locations
                        })
        
        # Results containers
        full_match_issues = []
        id_only_issues = []
        
        # Get ID column from MIS CSV
        id_col = None
        for col in ['ID', 'id', 'MIS ID', 'Mis Id']:
            if col in mis_df.columns:
                id_col = col
                break
        
        if not id_col:
            return jsonify({'success': False, 'error': 'MIS CSV missing ID column'})
        
        # Scan MIS CSV for stale entries
        for _, mis_row in mis_df.iterrows():
            # Skip inactive entries
            if not is_active(mis_row):
                continue
            
            mis_id = str(mis_row.get(id_col, '')).strip()
            if mis_id.endswith('.0'):
                mis_id = mis_id[:-2]
            
            if not mis_id or mis_id.lower() in ['', 'nan', 'none']:
                continue
            
            # Get MIS entry data
            mis_brand = str(mis_row.get('Brand', '')).strip()
            mis_weekday = str(mis_row.get('Weekday', '')).strip()
            mis_discount = float(mis_row.get('Daily Deal Discount', 0) or 0)
            mis_vendor = float(mis_row.get('Discount paid by vendor', 0) or 0)
            mis_store = str(mis_row.get('Store', '')).strip()
            mis_locs = normalize_location_set(mis_store if mis_store else 'All Locations')
            mis_start = str(mis_row.get('Start date', '')).strip()
            mis_end = str(mis_row.get('End date', '')).strip()
            
            section = get_section_from_weekday(mis_weekday)
            
            # Build result entry
            result_entry = {
                'mis_id': mis_id,
                'brand': mis_brand,
                'weekday': mis_weekday,
                'discount': mis_discount,
                'vendor_pct': mis_vendor,
                'locations': mis_store if mis_store else 'All Locations',
                'start_date': mis_start,
                'end_date': mis_end,
                'section': section
            }
            
            # Method 1: Full Field Match
            found_full_match = False
            partial_match_details = []
            
            for entry in sheet_entries:
                # Check brand (strict match)
                brand_match = entry['brand'] == mis_brand.lower().strip()
                
                if not brand_match:
                    continue
                
                # Found brand match - check other fields
                weekday_match = True
                if section == 'weekly':
                    # For weekly, compare weekdays
                    mis_weekday_lower = mis_weekday.lower()
                    entry_weekday_lower = entry['weekday'].lower()
                    # Normalize weekday comparison
                    mis_days = set(d.strip()[:3] for d in mis_weekday_lower.replace(',', ' ').split() if d.strip())
                    entry_days = set(d.strip()[:3] for d in entry_weekday_lower.replace(',', ' ').split() if d.strip())
                    weekday_match = mis_days == entry_days or not mis_days or not entry_days
                
                discount_match = abs(entry['discount'] - mis_discount) < 0.01
                vendor_match = abs(entry['vendor_pct'] - mis_vendor) < 0.01
                loc_match = entry['locations'] == mis_locs or 'all' in entry['locations'] or 'all' in mis_locs
                
                if weekday_match and discount_match and vendor_match and loc_match:
                    found_full_match = True
                    break
                else:
                    # Partial match - collect details
                    diffs = []
                    if not weekday_match:
                        diffs.append('Weekday')
                    if not discount_match:
                        diffs.append('Discount')
                    if not vendor_match:
                        diffs.append('Vendor%')
                    if not loc_match:
                        diffs.append('Locations')
                    if diffs:
                        partial_match_details.append(', '.join(diffs))
            
            if not found_full_match:
                result_entry_full = result_entry.copy()
                if partial_match_details:
                    result_entry_full['status'] = 'PARTIAL_MATCH'
                    result_entry_full['partial_match_details'] = 'Diff: ' + partial_match_details[0]
                else:
                    result_entry_full['status'] = 'NOT_IN_SHEET'
                full_match_issues.append(result_entry_full)
            
            # Method 2: MIS ID Only
            if mis_id not in all_sheet_mis_ids:
                result_entry_id = result_entry.copy()
                result_entry_id['status'] = 'ID_NOT_TRACKED'
                id_only_issues.append(result_entry_id)
        
        return jsonify({
            'success': True,
            'results': {
                'fullMatch': full_match_issues,
                'idOnly': id_only_issues
            }
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


@app.route('/api/mis/audit', methods=['POST'])
def api_mis_audit():
    """Run audit comparison."""
    try:
        tab_name = request.form.get('tab')
        csv_file = request.files.get('csv')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab'})
        
        # --- NEW: Check both uploaded file AND pulled CSV ---
        mis_df = None
        
        if csv_file:
            # User uploaded a CSV file
            print("[AUDIT] Using uploaded CSV file")
            mis_df = pd.read_csv(csv_file)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            # Use the pulled CSV from disk
            pulled_csv_path = GLOBAL_DATA['mis']['mis_csv_filepath']
            print(f"[AUDIT] Using pulled CSV: {GLOBAL_DATA['mis'].get('mis_csv_filename')}")
            
            if Path(pulled_csv_path).exists():
                mis_df = pd.read_csv(pulled_csv_path)
            else:
                return jsonify({'success': False, 'error': f'Pulled CSV not found: {pulled_csv_path}'})
        else:
            return jsonify({'success': False, 'error': 'No CSV available. Please pull CSV or upload manually.'})
        
        GLOBAL_DATA['mis']['mis_df'] = mis_df
        
        # Fetch Google Sheet data (Returns Dictionary)
        sections_data = fetch_google_sheet_data(tab_name)
        
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found'})
        
        # Run audit per section
        all_results = {}
        for section in ['weekly', 'monthly', 'sale']:
            df = sections_data.get(section, pd.DataFrame())
            if not df.empty:
                # PASS section_type HERE
                results = audit_google_vs_mis(df, mis_df, section_type=section)
                all_results[section] = results
            else:
                all_results[section] = []
                all_results[section] = []
        
        return jsonify({'success': True, 'results': all_results})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/review-discrepancy', methods=['POST'])
def api_mis_review_discrepancy():
    try:
        data = request.get_json()
        mis_id = data.get('mis_id', '').replace(' (Estimated)', '').strip()
        
        # Strip any tag prefixes (Part 1:, GAP:, Patch:, etc.)
        mis_id = strip_mis_id_tag(mis_id)
        
        true_row = int(data.get('google_row', 0))
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        mis_status = "MIS ID skipped"
        if mis_id and mis_id != '-':
            # INTELLIGENT MIS SESSION CHECK
            try:
                creds = load_credentials_config()
                mis_user = creds.get('mis_username', '')
                mis_pass = creds.get('mis_password', '')
                ensure_mis_ready(driver, mis_user, mis_pass)
                
                if filter_and_open_mis_id(driver, mis_id):
                    mis_status = f"Opened MIS ID {mis_id}"
                else:
                    mis_status = f"Failed to open MIS ID {mis_id}"
            except Exception as e:
                mis_status = f"MIS error: {str(e)}"
        spreadsheet_id = GLOBAL_DATA['mis']['spreadsheet_id']
        sheet_name = GLOBAL_DATA['mis']['current_sheet']
        sheet_status = "Sheet not configured"
        if spreadsheet_id and sheet_name:
            if open_google_sheet_in_browser(spreadsheet_id, sheet_name, true_row):
                sheet_status = f"Opened Sheet Row {true_row}"
            else:
                sheet_status = "Failed to open Sheet"
        return jsonify({'success': True, 'message': f'{sheet_status} | {mis_status}'})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/open-sheet-row', methods=['POST'])
def api_mis_open_sheet_row():
    try:
        data = request.get_json()
        row_number = int(data.get('row', 0))
        if not row_number:
            return jsonify({'success': False, 'error': 'No row specified'})
        spreadsheet_id = GLOBAL_DATA['mis'].get('spreadsheet_id')
        sheet_name = GLOBAL_DATA['mis'].get('current_sheet')
        if not spreadsheet_id or not sheet_name:
            return jsonify({'success': False, 'error': 'Sheet not configured'})
        if open_google_sheet_in_browser(spreadsheet_id, sheet_name, row_number):
            return jsonify({'success': True, 'message': f'Opened row {row_number}'})
        return jsonify({'success': False, 'error': 'Failed to open'})
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/lookup-mis-id', methods=['POST'])
def api_mis_lookup_mis_id():
    try:
        # Set automation flag
        GLOBAL_DATA['automation_in_progress'] = True
        
        data = request.get_json()
        mis_id = str(data.get('mis_id', '')).strip()
        row_data = data.get('row_data', None)  # NEW: Get row data for validation
        
        if not mis_id:
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': False, 'error': 'No ID'})
        
        # Strip any tag prefixes (Part 1:, Part 2:, GAP:, Patch:, etc.)
        mis_id = strip_mis_id_tag(mis_id)
        
        if not mis_id or not mis_id.isdigit():
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': False, 'error': f'Invalid MIS ID format: {data.get("mis_id")}'})
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        # INTELLIGENT MIS SESSION CHECK - ensures tab exists and is logged in
        try:
            creds = load_credentials_config()
            mis_user = creds.get('mis_username', '')
            mis_pass = creds.get('mis_password', '')
            ensure_mis_ready(driver, mis_user, mis_pass)
        except Exception as e:
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': False, 'error': str(e)})
        
        print(f"[MIS LOOKUP] Looking up MIS ID: {mis_id}")
        
        # SMART FALLBACK: If no row data provided, try to fetch from Google Sheet
        if not row_data:
            print(f"[MIS LOOKUP] No row data provided, searching Google Sheet...")
            try:
                # Try to get Google Sheet data from GLOBAL_DATA
                google_df = GLOBAL_DATA.get('google_df')
                if google_df is not None and not google_df.empty:
                    # Search for matching MIS ID in Google Sheet
                    # Check both 'ID' and 'MIS ID' columns
                    id_col = None
                    for col in ['MIS ID', 'ID', 'Mis Id', 'MIS_ID', 'mis_id']:
                        if col in google_df.columns:
                            id_col = col
                            break
                    
                    if id_col:
                        # Search for the MIS ID
                        for idx, row in google_df.iterrows():
                            sheet_mis_id = str(row.get(id_col, '')).strip()
                            # Handle multi-part IDs (W1: 123, W2: 456)
                            if mis_id in sheet_mis_id or sheet_mis_id == mis_id:
                                # Found it! Extract row data
                                row_data = {
                                    'brand': str(row.get('Brand', '')).strip(),
                                    'linked_brand': str(row.get('Linked Brand', '')).strip(),
                                    'weekday': str(row.get('Weekday', '')).strip(),
                                    'categories': str(row.get('Categories', '')).strip(),
                                    'discount': str(row.get('Discount', '')).strip(),
                                    'vendor_contrib': str(row.get('Vendor %', '')).strip(),
                                    'locations': str(row.get('Locations', 'All Locations')).strip(),
                                    'rebate_type': str(row.get('Rebate Type', '')).strip(),
                                    'after_wholesale': str(row.get('After Wholesale', '')).strip().lower() in ['yes', 'true', '1']
                                }
                                print(f"[MIS LOOKUP] ‚úÖ Found row data in Google Sheet!")
                                print(f"[MIS LOOKUP] Brand: {row_data['brand']}, Weekday: {row_data['weekday']}")
                                break
                    else:
                        print(f"[MIS LOOKUP] ‚ö†Ô∏è Could not find MIS ID column in Google Sheet")
                else:
                    print(f"[MIS LOOKUP] ‚ö†Ô∏è No Google Sheet data available")
            except Exception as e:
                print(f"[MIS LOOKUP] ‚ö†Ô∏è Error searching Google Sheet: {e}")
        else:
            print(f"[MIS LOOKUP] Row data provided by frontend")
        
        # Open the entry modal
        if filter_and_open_mis_id(driver, mis_id):
            # NEW: If row data provided, inject validation
            if row_data:
                try:
                    # Format row data for validation (similar to create_deal)
                    expected_data = {
                        'brand': row_data.get('brand', ''),
                        'linked_brand': row_data.get('linked_brand', ''),
                        'weekday': row_data.get('weekday', ''),
                        'categories': row_data.get('categories', ''),
                        'discount': row_data.get('discount', ''),
                        'vendor_contrib': row_data.get('vendor_contrib', ''),
                        'locations': row_data.get('locations', 'All Locations'),
                        'rebate_type': row_data.get('rebate_type', ''),
                        'after_wholesale': row_data.get('after_wholesale', False)
                    }
                    
                    print(f"[MIS LOOKUP] Injecting validation with row data")
                    print(f"[MIS LOOKUP] Expected: Brand={expected_data['brand']}, Weekday={expected_data['weekday']}")
                    
                    inject_mis_validation(driver, expected_data)
                    print(f"[MIS LOOKUP] ‚úÖ Validation injected for MIS ID {mis_id}")
                    
                except Exception as e:
                    print(f"[MIS LOOKUP] ‚ö†Ô∏è Could not inject validation: {e}")
            else:
                print(f"[MIS LOOKUP] No row data provided - skipping validation")
            
            # Clear automation flag
            GLOBAL_DATA['automation_in_progress'] = False
            return jsonify({'success': True, 'message': f'Lookup successful for ID {mis_id}'})
        
        GLOBAL_DATA['automation_in_progress'] = False
        return jsonify({'success': False, 'error': f'Failed to lookup ID {mis_id}'})
        
    except Exception as e:
        GLOBAL_DATA['automation_in_progress'] = False
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/mis/search-brand', methods=['POST'])
def api_mis_search_brand():
    try:
        data = request.get_json()
        brand = data.get('brand', '').strip()
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        # INTELLIGENT MIS SESSION CHECK
        try:
            creds = load_credentials_config()
            mis_user = creds.get('mis_username', '')
            mis_pass = creds.get('mis_password', '')
            ensure_mis_ready(driver, mis_user, mis_pass)
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)})
        
        try:
            close_buttons = driver.find_elements(By.CSS_SELECTOR, "button.close[data-dismiss='modal']")
            for btn in close_buttons:
                if btn.is_displayed():
                    btn.click()
                    time.sleep(0.3)
                    break
        except:
            pass
        
        try:
            search_input = WebDriverWait(driver, 3).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
            )
            search_input.click()
            search_input.send_keys(Keys.CONTROL + "a")
            search_input.send_keys(Keys.DELETE)
            search_input.send_keys(brand)
            search_input.send_keys(Keys.RETURN)
            return jsonify({'success': True})
        except Exception as e:
            return jsonify({'success': False, 'error': f"Search failed: {str(e)}"})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# ============================================
# UPDATE MIS END DATE (v12.2 - Expand & Attack Fix)
# ============================================
@app.route('/api/mis/update-end-date', methods=['POST'])
def api_mis_update_end_date():
    """
    Update the end date of a MIS entry using EXPAND & ATTACK strategy.
    
    The MIS DataTable uses Responsive Mode where the Edit button is hidden
    in a child row. We must EXPAND the row first to access the button.
    
    Workflow:
    1. Filter: Enter MIS ID into search bar
    2. Expand: Click first cell (td:first-child) to expand child row
    3. Click: Wait for expansion, find Edit button (a.btn-table-dialog), click it
    4. Update: Fill in new date and save
    """
    try:
        data = request.get_json()
        mis_id = str(data.get('mis_id', '')).strip()
        new_date = str(data.get('new_date', '')).strip()
        
        if not mis_id:
            return jsonify({'success': False, 'error': 'No MIS ID provided'})
        if not new_date:
            return jsonify({'success': False, 'error': 'No new date provided'})
        
        # Strip any tag prefixes
        mis_id = strip_mis_id_tag(mis_id)
        
        if not mis_id or not mis_id.isdigit():
            return jsonify({'success': False, 'error': f'Invalid MIS ID format: {data.get("mis_id")}'})
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        # INTELLIGENT MIS SESSION CHECK - ensures tab exists and is logged in
        try:
            creds = load_credentials_config()
            mis_user = creds.get('mis_username', '')
            mis_pass = creds.get('mis_password', '')
            ensure_mis_ready(driver, mis_user, mis_pass)
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)})
        
        print(f"[MIS UPDATE END DATE] Starting Expand & Attack for MIS ID: {mis_id}")
        
        # Close any open modals first
        try:
            close_buttons = driver.find_elements(By.CSS_SELECTOR, "button.close[data-dismiss='modal'], .modal button.close, .btn-close")
            for btn in close_buttons:
                if btn.is_displayed():
                    btn.click()
                    time.sleep(0.3)
                    break
        except:
            pass
        
        # ========================================
        # STEP 1: FILTER - Enter MIS ID in search
        # ========================================
        try:
            search_input = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "input[type='search']"))
            )
            search_input.click()
            search_input.send_keys(Keys.CONTROL + "a")
            search_input.send_keys(Keys.DELETE)
            search_input.send_keys(mis_id)
            print(f"[MIS UPDATE END DATE] Step 1: Filtered by MIS ID: {mis_id}")
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not find search input: {e}'})
        
        # Wait for table to filter
        time.sleep(1.5)
        
        # ========================================
        # STEP 2: EXPAND - Click first cell to show child row
        # ========================================
        try:
            # Wait for filtered results
            WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "#daily-discount tbody tr"))
            )
            time.sleep(0.5)
            
            # Find the row containing our MIS ID
            table_rows = driver.find_elements(By.CSS_SELECTOR, "#daily-discount tbody tr:not(.child)")
            target_row = None
            
            print(f"[MIS UPDATE END DATE] Found {len(table_rows)} parent rows in table")
            
            for row in table_rows:
                try:
                    row_text = row.text
                    if mis_id in row_text:
                        target_row = row
                        print(f"[MIS UPDATE END DATE] Found target row containing MIS ID {mis_id}")
                        break
                except:
                    continue
            
            if not target_row:
                return jsonify({'success': False, 'error': f'Could not find row with MIS ID {mis_id} in table'})
            
            # Click the FIRST CELL to trigger DataTable expansion
            first_cell = target_row.find_element(By.CSS_SELECTOR, "td:first-child")
            print(f"[MIS UPDATE END DATE] Step 2: Clicking first cell to expand row...")
            
            # Use ActionChains for reliable click
            actions = ActionChains(driver)
            actions.move_to_element(first_cell)
            actions.click()
            actions.perform()
            
            print(f"[MIS UPDATE END DATE] Clicked first cell, waiting for expansion...")
            time.sleep(1)  # Wait for expansion animation
            
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not expand row: {e}'})
        
        # ========================================
        # STEP 3: CLICK - Find and click Edit button in child row
        # ========================================
        try:
            # The Edit button should now be visible in the expanded child row
            # It uses class "btn-table-dialog" (anchor tag)
            print(f"[MIS UPDATE END DATE] Step 3: Looking for Edit button...")
            
            edit_button = None
            
            # Method A: Look for Edit button in child row
            try:
                edit_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, "tr.child a.btn-table-dialog"))
                )
                print(f"[MIS UPDATE END DATE] Found Edit button in child row")
            except:
                pass
            
            # Method B: Look for any visible Edit button with btn-table-dialog class
            if not edit_button:
                try:
                    buttons = driver.find_elements(By.CSS_SELECTOR, "a.btn-table-dialog")
                    for btn in buttons:
                        if btn.is_displayed():
                            edit_button = btn
                            print(f"[MIS UPDATE END DATE] Found visible Edit button")
                            break
                except:
                    pass
            
            # Method C: Look for button with "Edit" text or edit icon
            if not edit_button:
                try:
                    buttons = driver.find_elements(By.XPATH, "//a[contains(@class, 'btn') and (contains(text(), 'Edit') or contains(@class, 'edit'))]")
                    for btn in buttons:
                        if btn.is_displayed():
                            edit_button = btn
                            print(f"[MIS UPDATE END DATE] Found Edit button via XPath")
                            break
                except:
                    pass
            
            if not edit_button:
                return jsonify({'success': False, 'error': 'Could not find Edit button after expanding row'})
            
            # Click the Edit button
            print(f"[MIS UPDATE END DATE] Clicking Edit button...")
            actions = ActionChains(driver)
            actions.move_to_element(edit_button)
            actions.click()
            actions.perform()
            
            print(f"[MIS UPDATE END DATE] Edit button clicked, waiting for modal...")
            
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not click Edit button: {e}'})
        
        # ========================================
        # STEP 4: UPDATE - Wait for modal and update date
        # ========================================
        # Wait for edit modal to open
        time.sleep(2)
        
        # Find and update the date_end field
        try:
            date_end_input = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, "input#date_end, input[name='date_end']"))
            )
            
            original_value = date_end_input.get_attribute('value')
            print(f"[MIS UPDATE END DATE] Step 4: Found date_end field, current value: {original_value}")
            
            # Clear and enter new date
            date_end_input.click()
            time.sleep(0.3)
            
            # Select all and delete
            date_end_input.send_keys(Keys.CONTROL + "a")
            time.sleep(0.1)
            date_end_input.send_keys(Keys.DELETE)
            time.sleep(0.3)
            
            # Type new date
            date_end_input.send_keys(new_date)
            time.sleep(0.5)
            
            # Click elsewhere to trigger any change events (blur the field)
            try:
                form_element = driver.find_element(By.CSS_SELECTOR, "form, .modal-body, body")
                form_element.click()
            except:
                pass
            time.sleep(0.3)
            
            # Verify the date was entered correctly
            updated_value = date_end_input.get_attribute('value')
            print(f"[MIS UPDATE END DATE] After update, value is: {updated_value}")
            
            # Check if the date matches (handle different formats)
            date_matches = False
            # Normalize both dates for comparison
            new_date_parts = new_date.split('/')
            updated_parts = updated_value.split('/')
            
            if len(new_date_parts) == 3 and len(updated_parts) == 3:
                # Compare month and day directly
                if new_date_parts[0] == updated_parts[0] and new_date_parts[1] == updated_parts[1]:
                    # Compare year (handle 2-digit vs 4-digit)
                    new_year = new_date_parts[2]
                    updated_year = updated_parts[2]
                    if len(new_year) == 2:
                        new_year = '20' + new_year
                    if len(updated_year) == 2:
                        updated_year = '20' + updated_year
                    date_matches = (new_year == updated_year)
            
            if not date_matches:
                # Try direct comparison
                date_matches = (new_date == updated_value) or (new_date.replace('/20', '/') == updated_value)
            
            if not date_matches:
                return jsonify({
                    'success': False, 
                    'error': f'Date verification failed. Expected: {new_date}, Got: {updated_value}'
                })
            
            print(f"[MIS UPDATE END DATE] Date verified successfully: {updated_value}")
            
            # Now click the Save button
            try:
                # Look for save button - common patterns
                save_button = None
                save_selectors = [
                    "button[type='submit']",
                    "button.btn-primary:contains('Save')",
                    "button.btn-success",
                    "input[type='submit']",
                    ".modal-footer button.btn-primary",
                    "button.save-btn",
                    "#save-btn",
                    "button:contains('Save')",
                    "button:contains('Update')"
                ]
                
                for selector in save_selectors:
                    try:
                        if ':contains' in selector:
                            # Use XPath for text matching
                            text = selector.split("'")[1]
                            buttons = driver.find_elements(By.XPATH, f"//button[contains(text(), '{text}')]")
                            for btn in buttons:
                                if btn.is_displayed() and btn.is_enabled():
                                    save_button = btn
                                    break
                        else:
                            buttons = driver.find_elements(By.CSS_SELECTOR, selector)
                            for btn in buttons:
                                if btn.is_displayed() and btn.is_enabled():
                                    btn_text = btn.text.lower()
                                    # Make sure it's a save-type button, not cancel
                                    if 'save' in btn_text or 'update' in btn_text or 'submit' in btn_text or btn_text == '':
                                        save_button = btn
                                        break
                        if save_button:
                            break
                    except:
                        continue
                
                if save_button:
                    print(f"[MIS UPDATE END DATE] Found save button: {save_button.text or 'No text'}")
                    save_button.click()
                    time.sleep(2)
                    print("[MIS UPDATE END DATE] Save button clicked!")
                    
                    return jsonify({
                        'success': True, 
                        'message': f'End date updated to {new_date} and saved!',
                        'mis_id': mis_id,
                        'new_date': new_date,
                        'saved': True
                    })
                else:
                    print("[MIS UPDATE END DATE] Could not find save button")
                    return jsonify({
                        'success': True, 
                        'message': f'End date updated to {new_date}. Could not find Save button - please save manually.',
                        'mis_id': mis_id,
                        'new_date': new_date,
                        'saved': False
                    })
                    
            except Exception as save_err:
                print(f"[MIS UPDATE END DATE] Save button error: {save_err}")
                return jsonify({
                    'success': True, 
                    'message': f'End date updated to {new_date}. Save button click failed - please save manually.',
                    'mis_id': mis_id,
                    'new_date': new_date,
                    'saved': False
                })
            
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not find/update date_end field: {e}'})
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# ============================================
# CREATE DEAL IN MIS (v12.3)
# ============================================
def inject_mis_validation(driver, expected_data=None):
    """
    v12.11 - Comprehensive Banner: Inject MIS validation JavaScript.
    
    Phase 1 (CRITICAL - RED):
    - Rebate Type must not be "- Select -"
    - Blocks Save button until fixed
    
    Phase 2 (ADVISORY - ORANGE):
    - Compares all fields to expected_data (Google Sheet)
    - Shows ORANGE boxes for mismatches
    - Does NOT block Save button
    
    v12.9 Enhancements:
    - Persistent banner (always visible until Save clicked)
    - Save button detection (stops validation)
    - Cancel button detection (switches to manual mode)
    - Manual vs Automation mode tracking
    - Category and Linked Brand validation
    
    Args:
        driver: Selenium WebDriver instance
        expected_data: Dict of expected values from Google Sheet
            {
                'brand': str,
                'linked_brand': str,
                'categories': str,  # Comma-separated
                'weekday': str,
                'discount': str/float,
                'vendor_contrib': str/float,
                'locations': str,
                'rebate_type': str,
                'after_wholesale': bool
            }
    """
    # Prepare expected data as JSON for JavaScript
    import json
    expected_json = json.dumps(expected_data) if expected_data else 'null'
    
    validation_js = f"""
    (function() {{
        console.log('[MIS-VALIDATION] v12.9 - Persistent Validator Starting...');
        
        // Prevent multiple injections
        if (window.MIS_VALIDATOR_ACTIVE) {{
            console.log('[MIS-VALIDATION] Already active, skipping injection');
            return;
        }}
        window.MIS_VALIDATOR_ACTIVE = true;
        
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {{
            checkInterval: 500,
            modalSelector: '.modal-content',
            modalTitleText: 'Add New Daily Discount',
            saveButtonSelector: '.btn-submit',
            cancelButtonSelector: 'button.btn-default, button:contains("Close")',
            
            // Field IDs
            brandId: 'brand_id',
            brandContainerId: 'select2-brand_id-container',
            linkedBrandId: 'linked_brand_id',
            linkedBrandContainerId: 'select2-linked_brand_id-container',
            weekdayId: 'weekday_ids',
            categoryId: 'category_ids',
            storeId: 'store_ids',
            discountId: 'discount_rate',
            rebateTypeId: 'daily_discount_type_id',
            rebateTypeContainerId: 'select2-daily_discount_type_id-container',
            vendorContribId: 'rebate_percent',
            afterWholesaleId: 'rebate_wholesale_discount'
        }};
        
        // Expected data from Google Sheet (Phase 2) - CAN BE CLEARED
        let EXPECTED_DATA = {expected_json};
        
        // Validation mode: 'automation' or 'manual'
        let VALIDATION_MODE = EXPECTED_DATA ? 'automation' : 'manual';
        
        // ============================================
        // STATE
        // ============================================
        let validationState = {{
            modalOpen: false,
            rebateTypeValid: false,
            weekdayValid: false,  // NEW: Track weekday validity (CRITICAL)
            fieldWarnings: {{}},
            saveButtonHidden: false,
            originalSaveButton: null,
            errorBox: null,
            forceButton: null,
            summaryBanner: null,
            saveButtonListener: null,
            cancelButtonListener: null
        }};
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function log(message, level) {{
            level = level || 'INFO';  // Default to 'INFO' if not provided
            console.log(`[MIS-VALIDATION] [${{level}}] ${{message}}`);
        }}
        
        function isModalOpen() {{
            const modal = document.querySelector(CONFIG.modalSelector);
            if (!modal) return false;
            
            const modalTitle = modal.querySelector('.modal-title');
            if (!modalTitle) return false;
            
            return modalTitle.textContent.includes(CONFIG.modalTitleText);
        }}
        
        // ============================================
        // BUTTON DETECTION
        // ============================================
        function attachSaveButtonListener() {{
            const saveBtn = document.querySelector(CONFIG.saveButtonSelector);
            if (!saveBtn || validationState.saveButtonListener) return;
            
            validationState.saveButtonListener = function() {{
                log('Save button clicked - Stopping validation', 'INFO');
                handleSaveClick();
            }};
            
            saveBtn.addEventListener('click', validationState.saveButtonListener);
            log('Save button listener attached', 'DEBUG');
        }}
        
        function attachCancelButtonListener() {{
            const modal = document.querySelector(CONFIG.modalSelector);
            if (!modal) {{
                log('Modal not found for cancel detection', 'WARN');
                return;
            }}
            
            // Skip if already attached
            if (validationState.cancelButtonListener) return;
            
            // Method 1: Find all buttons with data-dismiss="modal" attribute
            // This catches: <button data-dismiss="modal">Close</button>
            //           and: <button data-dismiss="modal">√ó</button>
            const dismissButtons = modal.querySelectorAll('[data-dismiss="modal"]');
            
            // Method 2: Find by specific class names
            // This catches: <button class="btn-modal-close">...</button>
            //           and: <button class="close">√ó</button>
            const closeButtons = modal.querySelectorAll('.btn-modal-close, .close');
            
            // Combine both sets (use Set to avoid duplicates)
            const allCancelButtons = new Set([...dismissButtons, ...closeButtons]);
            
            if (allCancelButtons.size === 0) {{
                log('No cancel buttons found (Close/X)', 'WARN');
                return;
            }}
            
            // Create the handler function once
            validationState.cancelButtonListener = function() {{
                log('Close/X button clicked - Switching to manual mode', 'WARN');
                handleCancelClick();
            }};
            
            // Attach listener to all cancel buttons
            let attachedCount = 0;
            allCancelButtons.forEach(btn => {{
                // Skip if already has listener (prevent double-attach)
                if (btn.dataset.cancelListenerAttached) return;
                
                btn.addEventListener('click', validationState.cancelButtonListener);
                btn.dataset.cancelListenerAttached = 'true';
                attachedCount++;
            }});
            
            log(`Cancel listeners attached to ${{attachedCount}} button(s) (Close/X)`, 'DEBUG');
        }}
        
        function handleSaveClick() {{
            // Stop validation - user is saving
            log('Cleaning up for Save...', 'INFO');
            removeSummaryBanner();
            removeForceButton();
            // Don't set modalOpen = false, let natural modal close handle it
        }}
        
        function handleCancelClick() {{
            // User clicked Close/X button - switch to manual mode immediately
            log('Handling cancel - clearing automation data', 'INFO');
            
            // Clear expected data and switch to manual mode
            EXPECTED_DATA = null;
            VALIDATION_MODE = 'manual';
            
            // Clear all validation state
            validationState.fieldWarnings = {{}};
            validationState.criticalErrors = {{}};
            validationState.rebateTypeValid = false;
            validationState.weekdayValid = false;
            
            // Remove all visual indicators immediately (clean slate)
            removeAllRedBoxes();
            removeAllOrangeBoxes();
            removeSummaryBanner();
            
            log('Switched to MANUAL mode (Rebate Type + Weekday only)', 'SUCCESS');
            log('Expected data cleared - next entry will be manual', 'INFO');
            log('All validation boxes cleared - clean slate', 'DEBUG');
        }}
        
        // ============================================
        // FIELD VALUE GETTERS (FIXED MULTI-SELECT)
        // ============================================
        function getRebateTypeValue() {{
            const container = document.getElementById(CONFIG.rebateTypeContainerId);
            if (!container) return null;
            return container.getAttribute('title');
        }}
        
        function getBrandValue() {{
            const container = document.getElementById(CONFIG.brandContainerId);
            if (!container) return null;
            return container.getAttribute('title');
        }}
        
        function getLinkedBrandValue() {{
            const container = document.getElementById(CONFIG.linkedBrandContainerId);
            if (!container) return null;
            return container.getAttribute('title');
        }}
        
        function getWeekdayValues() {{
            const select = document.getElementById(CONFIG.weekdayId);
            if (!select) {{
                log('Weekday select not found', 'WARN');
                return [];
            }}
            
            const selected = [];
            // Use proper iteration for HTMLOptionsCollection
            for (let i = 0; i < select.options.length; i++) {{
                const option = select.options[i];
                if (option.selected) {{
                    selected.push(option.text.trim());
                }}
            }}
            
            log(`Weekday values: [${{selected.join(', ')}}] (count: ${{selected.length}})`, 'DEBUG');
            return selected;
        }}
        
        function getCategoryValues() {{
            const select = document.getElementById(CONFIG.categoryId);
            if (!select) {{
                log('Category select not found', 'WARN');
                return [];
            }}
            
            const selected = [];
            for (let i = 0; i < select.options.length; i++) {{
                const option = select.options[i];
                if (option.selected) {{
                    selected.push(option.text.trim());
                }}
            }}
            
            log(`Category values: [${{selected.join(', ')}}] (count: ${{selected.length}})`, 'DEBUG');
            return selected;
        }}
        
        function getStoreValues() {{
            const select = document.getElementById(CONFIG.storeId);
            if (!select) {{
                log('Store select not found', 'WARN');
                return [];
            }}
            
            const selected = [];
            for (let i = 0; i < select.options.length; i++) {{
                const option = select.options[i];
                if (option.selected) {{
                    selected.push(option.text.trim());
                }}
            }}
            
            log(`Store values: [${{selected.join(', ')}}] (count: ${{selected.length}})`, 'DEBUG');
            return selected;
        }}
        
        function getDiscountValue() {{
            const input = document.getElementById(CONFIG.discountId);
            if (!input) return null;
            return input.value.trim();
        }}
        
        function getVendorContribValue() {{
            const input = document.getElementById(CONFIG.vendorContribId);
            if (!input) return null;
            return input.value.trim();
        }}
        
        function getAfterWholesaleValue() {{
            const checkbox = document.getElementById(CONFIG.afterWholesaleId);
            if (!checkbox) return false;
            return checkbox.checked;
        }}
        
        // ============================================
        // CRITICAL VALIDATION (RED - BLOCKS SAVE)
        // ============================================
        function isRebateTypeValid() {{
            const value = getRebateTypeValue();
            return value && value !== '- Select -';
        }}
        
        function isWeekdayValid() {{
            // Weekday MUST have at least one day selected
            const selected = getWeekdayValues();
            const valid = selected.length > 0;
            log(`Weekday validation: ${{valid ? 'VALID' : 'INVALID'}} (${{selected.length}} days selected)`, valid ? 'SUCCESS' : 'ERROR');
            return valid;
        }}
        
        function validateAllFields() {{
            if (!EXPECTED_DATA || VALIDATION_MODE === 'manual') {{
                log('Manual mode - skipping Phase 2 validation', 'DEBUG');
                return {{}};
            }}
            
            const warnings = {{}};
            
            // Brand
            if (EXPECTED_DATA.brand) {{
                const actual = getBrandValue();
                if (actual && actual !== '- Select -' && actual !== EXPECTED_DATA.brand) {{
                    warnings.brand = {{
                        expected: EXPECTED_DATA.brand,
                        actual: actual,
                        message: `Brand mismatch: Expected "${{EXPECTED_DATA.brand}}", found "${{actual}}"`
                    }};
                }}
            }}
            
            // Linked Brand
            if (EXPECTED_DATA.linked_brand) {{
                const actual = getLinkedBrandValue();
                if (actual && actual !== '- Select -' && actual !== EXPECTED_DATA.linked_brand) {{
                    warnings.linked_brand = {{
                        expected: EXPECTED_DATA.linked_brand,
                        actual: actual,
                        message: `Linked Brand mismatch: Expected "${{EXPECTED_DATA.linked_brand}}", found "${{actual}}"`
                    }};
                }}
            }}
            
            // Weekday (CASE-INSENSITIVE)
            if (EXPECTED_DATA.weekday) {{
                const actual = getWeekdayValues();
                const expected = EXPECTED_DATA.weekday;
                
                const actualLower = actual.map(d => d.toLowerCase());
                const expectedLower = expected.toLowerCase();
                
                if (actual.length > 0 && !actualLower.includes(expectedLower)) {{
                    warnings.weekday = {{
                        expected: expected,
                        actual: actual.join(', '),
                        message: `Weekday mismatch: Expected "${{expected}}", found "${{actual.join(', ')}}"`
                    }};
                }}
            }}
            
            // Categories (ENHANCED LOGIC - similar to Stores)
            if (EXPECTED_DATA.categories) {{
                const actual = getCategoryValues();
                const expectedText = EXPECTED_DATA.categories.trim();
                const expectedLower = expectedText.toLowerCase();
                
                // Case 1: "All Categories" or "All" - blank actual is correct
                if (expectedLower === 'all categories' || expectedLower === 'all') {{
                    if (actual.length > 0) {{
                        warnings.categories = {{
                            expected: 'All Categories (blank)',
                            actual: actual.join(', '),
                            message: `Category mismatch: Expected "All Categories" (blank), found "${{actual.join(', ')}}"`
                        }};
                    }}
                    // If actual is blank, that's correct - no warning
                }}
                // Case 2: "All Categories (Except: X, Y)" - ignore "*" exceptions
                else if (expectedText.toLowerCase().includes('except')) {{
                    const exceptMatch = expectedText.match(/except[:\\s]*(.+?)(?:\\)|$)/i);
                    if (exceptMatch) {{
                        const exceptionsText = exceptMatch[1];
                        const rawExceptions = exceptionsText.split(',').map(s => s.trim());
                        
                        // Filter out "*" (filler exception) and empty strings
                        const exceptions = rawExceptions.filter(exc => 
                            exc && exc !== '*' && exc.toLowerCase() !== 'none'
                        ).map(s => s.toLowerCase());
                        
                        // If no real exceptions (only "*"), treat as "All Categories"
                        if (exceptions.length === 0) {{
                            if (actual.length > 0) {{
                                warnings.categories = {{
                                    expected: 'All Categories (blank)',
                                    actual: actual.join(', '),
                                    message: `Category mismatch: Expected "All Categories" (blank), found "${{actual.join(', ')}}"`
                                }};
                            }}
                        }} else {{
                            // Has real exceptions - validate properly
                            // For categories, we don't have a master list, so just check if expected text makes sense
                            log(`Categories with real exceptions: ${{exceptions.join(', ')}}`, 'DEBUG');
                            // For now, if blank actual with real exceptions, that might be wrong
                            // But we can't fully validate without master category list
                        }}
                    }}
                }}
                // Case 3: Specific categories
                else {{
                    const expected = expectedText.split(',').map(s => s.trim());
                    const expectedLower = expected.map(s => s.toLowerCase());
                    const actualLower = actual.map(s => s.toLowerCase());
                    
                    const missing = expected.filter(e => !actualLower.includes(e.toLowerCase()));
                    const extra = actual.filter(a => !expectedLower.includes(a.toLowerCase()));
                    
                    if (missing.length > 0 || extra.length > 0) {{
                        warnings.categories = {{
                            expected: expected.join(', '),
                            actual: actual.join(', ') || '(blank)',
                            message: `Category mismatch: Expected "${{expected.join(', ')}}", found "${{actual.join(', ') || '(blank)'}}"`
                        }};
                    }}
                }}
            }}
            
            // Discount
            if (EXPECTED_DATA.discount != null) {{
                const actual = getDiscountValue();
                const expected = String(EXPECTED_DATA.discount);
                if (actual && actual !== expected) {{
                    warnings.discount = {{
                        expected: expected + '%',
                        actual: actual + '%',
                        message: `Discount mismatch: Expected "${{expected}}%", found "${{actual}}%"`
                    }};
                }}
            }}
            
            // Vendor Contribution
            if (EXPECTED_DATA.vendor_contrib != null) {{
                const actual = getVendorContribValue();
                const expected = String(EXPECTED_DATA.vendor_contrib);
                if (actual && actual !== expected) {{
                    warnings.vendor_contrib = {{
                        expected: expected + '%',
                        actual: actual + '%',
                        message: `Vendor Contribution mismatch: Expected "${{expected}}%", found "${{actual}}%"`
                    }};
                }}
            }}
            
            // After Wholesale toggle
            if (EXPECTED_DATA.after_wholesale != null) {{
                const actual = getAfterWholesaleValue();
                const expected = EXPECTED_DATA.after_wholesale;
                if (actual !== expected) {{
                    warnings.after_wholesale = {{
                        expected: expected ? 'ON' : 'OFF',
                        actual: actual ? 'ON' : 'OFF',
                        message: `After Wholesale toggle mismatch: Expected "${{expected ? 'ON' : 'OFF'}}", found "${{actual ? 'ON' : 'OFF'}}"`
                    }};
                }}
            }}
            
            // Stores (ENHANCED LOGIC - 3 cases)
            if (EXPECTED_DATA.locations) {{
                const actual = getStoreValues();
                const expectedText = EXPECTED_DATA.locations.trim();
                const expectedLower = expectedText.toLowerCase();
                
                // Case 1: "All Locations"
                if (expectedLower === 'all locations' || expectedLower === 'all') {{
                    if (actual.length > 0) {{
                        warnings.stores = {{
                            expected: 'All Locations (blank)',
                            actual: actual.join(', '),
                            message: `Store mismatch: Expected "All Locations" (blank), found "${{actual.join(', ')}}"`
                        }};
                    }}
                }}
                // Case 2: "All Locations Except: X, Y"
                else if (expectedText.toLowerCase().includes('except')) {{
                    const exceptMatch = expectedText.match(/except[:\\s]*(.+?)(?:\\)|$)/i);
                    if (exceptMatch) {{
                        const exceptionsText = exceptMatch[1];
                        const exceptions = exceptionsText.split(',').map(s => s.trim().toLowerCase());
                        
                        const masterStores = [
                            'Beverly', 'Davis', 'Dixon', 'El Sobrante', 'Fresno', 'Fresno Shaw',
                            'Hawthorne', 'Koreatown', 'Laguna Woods', 'Oxnard', 'Riverside', 'West Hollywood'
                        ];
                        
                        const expectedStores = masterStores.filter(store => {{
                            const storeLower = store.toLowerCase();
                            return !exceptions.some(exc => storeLower.includes(exc) || exc.includes(storeLower));
                        }});
                        
                        const actualLower = actual.map(s => s.toLowerCase());
                        const expectedLower = expectedStores.map(s => s.toLowerCase());
                        
                        const missing = expectedStores.filter(s => !actualLower.includes(s.toLowerCase()));
                        const extra = actual.filter(s => !expectedLower.includes(s.toLowerCase()));
                        
                        if (missing.length > 0 || extra.length > 0) {{
                            warnings.stores = {{
                                expected: expectedStores.join(', '),
                                actual: actual.join(', ') || '(blank)',
                                message: `Store mismatch: Expected "${{expectedStores.join(', ')}}", found "${{actual.join(', ') || '(blank)'}}"`
                            }};
                        }}
                    }}
                }}
                // Case 3: Specific stores
                else {{
                    const expected = expectedText.split(',').map(s => s.trim());
                    const expectedLower = expected.map(s => s.toLowerCase());
                    const actualLower = actual.map(s => s.toLowerCase());
                    
                    const missing = expected.filter(e => !actualLower.includes(e.toLowerCase()));
                    const extra = actual.filter(a => !expectedLower.includes(a.toLowerCase()));
                    
                    if (missing.length > 0 || extra.length > 0) {{
                        warnings.stores = {{
                            expected: expected.join(', '),
                            actual: actual.join(', ') || '(blank)',
                            message: `Store mismatch: Expected "${{expected.join(', ')}}", found "${{actual.join(', ') || '(blank)'}}"`
                        }};
                    }}
                }}
            }}
            
            return warnings;
        }}
        
        // ============================================
        // VISUAL INDICATORS - RED (CRITICAL)
        // ============================================
        function addRedBox(fieldId, containerId, tooltip) {{
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            const container = field.nextElementSibling;
            if (container && container.classList.contains('select2')) {{
                container.style.border = '3px solid #dc3545';
                container.style.borderRadius = '4px';
                container.style.boxShadow = '0 0 10px rgba(220, 53, 69, 0.5)';
                container.setAttribute('title', tooltip);
            }}
            
            log(`Added RED box to ${{fieldId}}`, 'WARN');
        }}
        
        function removeRedBox(fieldId, containerId) {{
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            const container = field.nextElementSibling;
            if (container && container.classList.contains('select2')) {{
                container.style.border = '';
                container.style.borderRadius = '';
                container.style.boxShadow = '';
                container.removeAttribute('title');
            }}
            
            log(`Removed RED box from ${{fieldId}}`, 'SUCCESS');
        }}
        
        function removeAllRedBoxes() {{
            // Remove RED boxes from all critical fields
            removeRedBox(CONFIG.rebateTypeId, CONFIG.rebateTypeContainerId);
            removeRedBox(CONFIG.weekdayId, null);
            log('Removed all RED boxes', 'DEBUG');
        }}
        
        // ============================================
        // VISUAL INDICATORS - ORANGE (ADVISORY)
        // ============================================
        function addOrangeBox(fieldId, isSelect2, tooltip) {{
            const field = document.getElementById(fieldId);
            if (!field) {{
                log(`Field not found: ${{fieldId}}`, 'WARN');
                return;
            }}
            
            if (isSelect2) {{
                const container = field.nextElementSibling;
                if (container && container.classList.contains('select2')) {{
                    container.style.border = '3px solid #ff9800';
                    container.style.borderRadius = '4px';
                    container.style.boxShadow = '0 0 10px rgba(255, 152, 0, 0.5)';
                    container.setAttribute('title', tooltip);
                    log(`Added ORANGE box to ${{fieldId}} (Select2)`, 'WARN');
                }} else {{
                    log(`Select2 container not found for ${{fieldId}}`, 'WARN');
                }}
            }} else if (fieldId === CONFIG.afterWholesaleId) {{
                const row = field.closest('.input-row');
                if (row) {{
                    row.style.border = '3px solid #ff9800';
                    row.style.borderRadius = '4px';
                    row.style.boxShadow = '0 0 10px rgba(255, 152, 0, 0.5)';
                    row.style.padding = '5px';
                    row.setAttribute('title', tooltip);
                    log(`Added ORANGE box to After Wholesale (toggle row)`, 'WARN');
                }} else {{
                    log(`Toggle row not found for ${{fieldId}}`, 'WARN');
                }}
            }} else {{
                field.style.border = '3px solid #ff9800';
                field.style.borderRadius = '4px';
                field.style.boxShadow = '0 0 10px rgba(255, 152, 0, 0.5)';
                field.setAttribute('title', tooltip);
                log(`Added ORANGE box to ${{fieldId}} (input)`, 'WARN');
            }}
        }}
        
        function removeOrangeBox(fieldId, isSelect2) {{
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            if (isSelect2) {{
                const container = field.nextElementSibling;
                if (container && container.classList.contains('select2')) {{
                    container.style.border = '';
                    container.style.borderRadius = '';
                    container.style.boxShadow = '';
                    container.removeAttribute('title');
                }}
            }} else if (fieldId === CONFIG.afterWholesaleId) {{
                const row = field.closest('.input-row');
                if (row) {{
                    row.style.border = '';
                    row.style.borderRadius = '';
                    row.style.boxShadow = '';
                    row.style.padding = '';
                    row.removeAttribute('title');
                }}
            }} else {{
                field.style.border = '';
                field.style.borderRadius = '';
                field.style.boxShadow = '';
                field.removeAttribute('title');
            }}
        }}
        
        function removeAllOrangeBoxes() {{
            // Remove ORANGE boxes from all advisory fields
            removeOrangeBox(CONFIG.brandId, true);
            removeOrangeBox(CONFIG.linkedBrandId, true);
            removeOrangeBox(CONFIG.weekdayId, true);
            removeOrangeBox(CONFIG.categoryId, true);
            removeOrangeBox(CONFIG.storeId, true);
            removeOrangeBox(CONFIG.discountId, false);
            removeOrangeBox(CONFIG.vendorContribId, false);
            removeOrangeBox(CONFIG.afterWholesaleId, false);
            log('Removed all ORANGE boxes', 'DEBUG');
        }}
        
        function updateFieldWarnings(warnings) {{
            // Remove all orange boxes first
            removeOrangeBox(CONFIG.brandId, true);
            removeOrangeBox(CONFIG.linkedBrandId, true);
            removeOrangeBox(CONFIG.weekdayId, true);
            removeOrangeBox(CONFIG.categoryId, true);
            removeOrangeBox(CONFIG.storeId, true);
            removeOrangeBox(CONFIG.discountId, false);
            removeOrangeBox(CONFIG.vendorContribId, false);
            removeOrangeBox(CONFIG.afterWholesaleId, false);
            
            // Add orange boxes for warnings
            if (warnings.brand) {{
                addOrangeBox(CONFIG.brandId, true, `‚ö†Ô∏è ${{warnings.brand.message}}`);
            }}
            if (warnings.linked_brand) {{
                addOrangeBox(CONFIG.linkedBrandId, true, `‚ö†Ô∏è ${{warnings.linked_brand.message}}`);
            }}
            if (warnings.weekday) {{
                addOrangeBox(CONFIG.weekdayId, true, `‚ö†Ô∏è ${{warnings.weekday.message}}`);
            }}
            if (warnings.categories) {{
                addOrangeBox(CONFIG.categoryId, true, `‚ö†Ô∏è ${{warnings.categories.message}}`);
            }}
            if (warnings.stores) {{
                addOrangeBox(CONFIG.storeId, true, `‚ö†Ô∏è ${{warnings.stores.message}}`);
            }}
            if (warnings.discount) {{
                addOrangeBox(CONFIG.discountId, false, `‚ö†Ô∏è ${{warnings.discount.message}}`);
            }}
            if (warnings.vendor_contrib) {{
                addOrangeBox(CONFIG.vendorContribId, false, `‚ö†Ô∏è ${{warnings.vendor_contrib.message}}`);
            }}
            if (warnings.after_wholesale) {{
                addOrangeBox(CONFIG.afterWholesaleId, false, `‚ö†Ô∏è ${{warnings.after_wholesale.message}}`);
            }}
        }}
        
        // ============================================
        // PERSISTENT SUMMARY BANNER
        // ============================================
        function createSummaryBanner(warnings, criticalErrors) {{
            // Remove existing banner
            if (validationState.summaryBanner) {{
                validationState.summaryBanner.remove();
                validationState.summaryBanner = null;
            }}
            
            const criticalCount = Object.keys(criticalErrors || {{}}).length;
            const warningCount = Object.keys(warnings || {{}}).length;
            const totalIssues = criticalCount + warningCount;
            
            const banner = document.createElement('div');
            banner.id = 'mis-validation-summary';
            
            // Determine banner color: RED for critical, ORANGE for advisory only, GREEN for all correct
            if (totalIssues === 0) {{
                // ALL CORRECT - Green banner
                banner.style.cssText = `
                    background: #28a745;
                    color: white;
                    padding: 12px 15px;
                    margin-bottom: 15px;
                    border-radius: 4px;
                    font-weight: bold;
                    text-align: center;
                `;
                
                if (VALIDATION_MODE === 'automation') {{
                    banner.innerHTML = `
                        <div style="font-size: 1.1em;">
                            ‚úÖ All Fields Correct - Ready to Save!
                        </div>
                        <div style="font-weight: normal; font-size: 0.85em; margin-top: 5px;">
                            Automation mode: Validating against Google Sheet
                        </div>
                    `;
                }} else {{
                    banner.innerHTML = `
                        <div style="font-size: 1.1em;">
                            ‚úÖ Critical Fields Filled - Ready to Save!
                        </div>
                        <div style="font-weight: normal; font-size: 0.85em; margin-top: 5px;">
                            Manual mode: Validating Rebate Type + Weekday only
                        </div>
                    `;
                }}
            }} else {{
                // HAS ISSUES - RED for critical, ORANGE for advisory only
                const hasCritical = criticalCount > 0;
                const bgColor = hasCritical ? '#dc3545' : '#ff9800';  // RED or ORANGE
                
                banner.style.cssText = `
                    background: ${{bgColor}};
                    color: white;
                    padding: 12px 15px;
                    margin-bottom: 15px;
                    border-radius: 4px;
                    font-weight: bold;
                    text-align: left;
                `;
                
                // Build comprehensive error list
                let errorList = '';
                
                // Field name mapping
                const criticalFieldNames = {{
                    rebateType: 'Rebate Type',
                    weekday: 'Weekday'
                }};
                
                const advisoryFieldNames = {{
                    brand: 'Brand',
                    linked_brand: 'Linked Brand',
                    weekday: 'Weekday',
                    categories: 'Categories',
                    stores: 'Stores/Locations',
                    discount: 'Discount',
                    vendor_contrib: 'Vendor Contribution',
                    after_wholesale: 'After Wholesale'
                }};
                
                // Add CRITICAL errors first (with üî¥ and BLOCKS SAVE)
                for (const [key, error] of Object.entries(criticalErrors || {{}})) {{
                    const fieldName = criticalFieldNames[key] || key;
                    errorList += `
                        <div style="margin: 5px 0; padding-left: 15px; font-size: 0.9em;">
                            <strong style="color: #ffcccc;">üî¥ ${{fieldName}}:</strong>
                            <span style="font-weight: normal;">
                                ${{error.message}} <strong>(BLOCKS SAVE)</strong>
                            </span>
                        </div>
                    `;
                }}
                
                // Add ADVISORY warnings second (with üüß)
                for (const [key, warning] of Object.entries(warnings || {{}})) {{
                    const fieldName = advisoryFieldNames[key] || key;
                    errorList += `
                        <div style="margin: 5px 0; padding-left: 15px; font-size: 0.9em;">
                            <strong style="color: #fff3cd;">üüß ${{fieldName}}:</strong><br>
                            <span style="font-weight: normal; padding-left: 10px;">
                                Expected: <span style="background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 3px;">${{warning.expected}}</span><br>
                                <span style="padding-left: 10px;">Actual: <span style="background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 3px;">${{warning.actual}}</span></span>
                            </span>
                        </div>
                    `;
                }}
                
                // Build header text
                const plural = totalIssues > 1 ? 's' : '';
                let headerText = '';
                let subtitleText = '';
                
                if (hasCritical) {{
                    // RED banner - has critical errors
                    const blockingText = criticalCount === 1 ? '1 error blocking' : `${{criticalCount}} errors blocking`;
                    headerText = `‚ö†Ô∏è ${{totalIssues}} Issue${{plural}} Found (${{blockingText}} save)`;
                    subtitleText = 'Critical errors must be fixed before saving';
                }} else {{
                    // ORANGE banner - advisory only
                    headerText = `‚ö†Ô∏è ${{totalIssues}} Field${{plural}} May Need Review`;
                    subtitleText = 'Advisory warnings - you can still save if Rebate Type and Weekday are filled';
                }}
                
                banner.innerHTML = `
                    <div style="text-align: center; margin-bottom: 8px;">
                        ${{headerText}}
                    </div>
                    <div style="font-weight: normal; text-align: center; font-size: 0.85em; margin-bottom: 10px;">
                        ${{subtitleText}}
                    </div>
                    <div style="border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px;">
                        ${{errorList}}
                    </div>
                `;
            }}
            
            // Insert at top of modal body
            const modalBody = document.querySelector('.modal-body');
            if (modalBody) {{
                modalBody.insertBefore(banner, modalBody.firstChild);
                validationState.summaryBanner = banner;
                
                if (totalIssues === 0) {{
                    log(`Persistent banner created: ALL CORRECT`, 'INFO');
                }} else {{
                    log(`Persistent banner created: ${{criticalCount}} critical, ${{warningCount}} advisory`, 'INFO');
                }}
            }}
        }}
        
        function removeSummaryBanner() {{
            if (validationState.summaryBanner) {{
                validationState.summaryBanner.remove();
                validationState.summaryBanner = null;
            }}
        }}
        
        // ============================================
        // SAVE BUTTON CONTROL
        // ============================================
        function hideSaveButton() {{
            if (validationState.saveButtonHidden) return;
            
            const saveBtn = document.querySelector(CONFIG.saveButtonSelector);
            if (!saveBtn) {{
                log('Save button not found', 'ERROR');
                return;
            }}
            
            validationState.originalSaveButton = saveBtn;
            saveBtn.style.display = 'none';
            
            const errorBox = document.createElement('div');
            errorBox.id = 'mis-validation-error-box';
            errorBox.style.cssText = `
                background: #dc3545;
                color: white;
                padding: 10px 15px;
                border-radius: 4px;
                margin-bottom: 10px;
                font-weight: bold;
                text-align: center;
            `;
            errorBox.innerHTML = `
                ‚ö†Ô∏è CRITICAL ERROR - Cannot Save<br>
                <small style="font-weight: normal;">‚Ä¢ Rebate Type must be selected (Wholesale or Retail)</small>
            `;
            
            saveBtn.parentNode.insertBefore(errorBox, saveBtn);
            validationState.errorBox = errorBox;
            validationState.saveButtonHidden = true;
            log('Save button hidden - Rebate Type validation failed', 'WARN');
        }}
        
        function showSaveButton() {{
            if (!validationState.saveButtonHidden) return;
            
            if (validationState.errorBox) {{
                validationState.errorBox.remove();
                validationState.errorBox = null;
            }}
            
            if (validationState.originalSaveButton) {{
                validationState.originalSaveButton.style.display = '';
                log('Save button restored - Validation passed', 'SUCCESS');
            }}
            
            validationState.saveButtonHidden = false;
        }}
        
        // ============================================
        // FORCE SHOW SAVE BUTTON (SAFETY OVERRIDE)
        // ============================================
        function createForceButton() {{
            if (validationState.forceButton) return;
            
            const forceBtn = document.createElement('button');
            forceBtn.id = 'force-show-save-btn';
            forceBtn.textContent = 'Force Show Save';
            forceBtn.style.cssText = `
                position: fixed;
                top: 10px;
                left: 10px;
                z-index: 99999;
                background: #ffc107;
                color: #000;
                border: 2px solid #ff9800;
                padding: 8px 12px;
                border-radius: 4px;
                font-weight: bold;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            `;
            forceBtn.onclick = function() {{
                log('FORCE OVERRIDE: User clicked Force Show Save', 'WARN');
                showSaveButton();
                log('Force button remains active (persistent during validation)', 'INFO');
            }};
            
            document.body.appendChild(forceBtn);
            validationState.forceButton = forceBtn;
            log('Force Show Save button created (persistent safety override)', 'INFO');
        }}
        
        function removeForceButton() {{
            if (validationState.forceButton) {{
                validationState.forceButton.remove();
                validationState.forceButton = null;
                log('Force Show Save button removed (modal closed)', 'INFO');
            }}
        }}
        
        // ============================================
        // VALIDATION LOOP
        // ============================================
        function runValidation() {{
            const modalOpen = isModalOpen();
            
            if (modalOpen !== validationState.modalOpen) {{
                validationState.modalOpen = modalOpen;
                
                if (modalOpen) {{
                    log('Modal detected - Starting validation', 'INFO');
                    log(`Validation mode: ${{VALIDATION_MODE}}`, 'INFO');
                    createForceButton();
                    attachSaveButtonListener();
                    attachCancelButtonListener();
                }} else {{
                    log('Modal closed - Cleaning up', 'INFO');
                    removeForceButton();
                    removeSummaryBanner();
                    validationState.saveButtonHidden = false;
                    validationState.rebateTypeValid = false;
                    validationState.weekdayValid = false;
                    validationState.fieldWarnings = {{}};
                }}
            }}
            
            if (!modalOpen) return;
            
            // Phase 1: CRITICAL - Rebate Type AND Weekday
            const rebateValid = isRebateTypeValid();
            const weekdayValid = isWeekdayValid();
            
            // Check if validation state changed
            const rebateChanged = rebateValid !== validationState.rebateTypeValid;
            const weekdayChanged = weekdayValid !== validationState.weekdayValid;
            
            if (rebateChanged) {{
                validationState.rebateTypeValid = rebateValid;
                
                if (rebateValid) {{
                    log('Rebate Type is valid', 'SUCCESS');
                    removeRedBox(CONFIG.rebateTypeId, CONFIG.rebateTypeContainerId);
                }} else {{
                    log('Rebate Type is INVALID', 'ERROR');
                    addRedBox(CONFIG.rebateTypeId, CONFIG.rebateTypeContainerId, 
                        '‚ùå Rebate Type is required! Must be Wholesale or Retail');
                }}
            }}
            
            if (weekdayChanged) {{
                validationState.weekdayValid = weekdayValid;
                
                if (weekdayValid) {{
                    log('Weekday is valid', 'SUCCESS');
                    removeRedBox(CONFIG.weekdayId, null);
                }} else {{
                    log('Weekday is INVALID', 'ERROR');
                    addRedBox(CONFIG.weekdayId, null,
                        '‚ùå Weekday is required! Must select at least one day');
                }}
            }}
            
            // Update Save button based on BOTH critical fields
            const bothValid = rebateValid && weekdayValid;
            const eitherInvalid = !rebateValid || !weekdayValid;
            
            if (rebateChanged || weekdayChanged) {{
                if (bothValid) {{
                    showSaveButton();
                }} else {{
                    hideSaveButton(!rebateValid, !weekdayValid);
                }}
            }}
            
            // Build critical errors object
            const criticalErrors = {{}};
            if (!rebateValid) {{
                criticalErrors.rebateType = {{
                    message: 'Must be selected'
                }};
            }}
            if (!weekdayValid) {{
                criticalErrors.weekday = {{
                    message: 'Must have at least one day'
                }};
            }}
            
            // Phase 2: ADVISORY - All other fields (only in automation mode)
            const warnings = validateAllFields();
            
            // Deep compare: Check if ANY warning changed (not just count)
            const currentWarningsJson = JSON.stringify(warnings);
            const oldWarningsJson = JSON.stringify(validationState.fieldWarnings);
            const warningsChanged = currentWarningsJson !== oldWarningsJson;
            
            // Check if critical validation changed
            const currentCriticalJson = JSON.stringify(criticalErrors);
            const oldCriticalJson = JSON.stringify(validationState.criticalErrors || {{}});
            const criticalChanged = currentCriticalJson !== oldCriticalJson;
            
            // ALWAYS create banner if it doesn't exist (first run after modal opens)
            const bannerMissing = !validationState.summaryBanner;
            
            // Update banner when ANYTHING changes (critical OR advisory OR missing)
            if (criticalChanged || warningsChanged || bannerMissing) {{
                validationState.fieldWarnings = warnings;
                validationState.criticalErrors = criticalErrors;
                updateFieldWarnings(warnings);
                
                // ALWAYS update banner - pass BOTH critical and advisory
                removeSummaryBanner();
                createSummaryBanner(warnings, criticalErrors);
                
                const warningCount = Object.keys(warnings).length;
                const criticalCount = Object.keys(criticalErrors).length;
                
                if (criticalCount > 0) {{
                    log(`Phase 1: ${{criticalCount}} CRITICAL error(s) found`, 'ERROR');
                }}
                if (warningCount > 0) {{
                    log(`Phase 2: ${{warningCount}} advisory warning(s) found`, 'WARN');
                }}
                if (criticalCount === 0 && warningCount === 0) {{
                    log('All validation passed - all fields correct', 'SUCCESS');
                }}
                
                if (bannerMissing) {{
                    log('Initial banner created (first validation run)', 'INFO');
                }}
            }}
        }}
        
        // ============================================
        // START MONITORING
        // ============================================
        log('Starting validation monitor (500ms interval)');
        log('Phase 1: Rebate Type + Weekday (CRITICAL - blocks save)');
        log('Phase 2: All fields (ADVISORY - warnings only)');
        log('Features: Persistent banner, Save/Cancel detection');
        setInterval(runValidation, CONFIG.checkInterval);
        
        runValidation();
        
        log('v12.11 validation system active!');
    }})();
    """
    
    try:
        # DIAGNOSTIC: Pre-execution checks
        print("[VALIDATION-INJECT] Starting injection...")
        print(f"[VALIDATION-INJECT] Driver type: {type(driver)}")
        print(f"[VALIDATION-INJECT] Expected data: {expected_data is not None}")
        print(f"[VALIDATION-INJECT] JavaScript length: {len(validation_js)} characters")
        
        # DIAGNOSTIC: Save JavaScript to file for inspection
        import datetime
        debug_file = f"reports/validation_debug_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.js"
        try:
            with open(debug_file, 'w', encoding='utf-8') as f:
                f.write(validation_js)
            print(f"[VALIDATION-INJECT] üìÅ Saved JavaScript to: {debug_file}")
        except Exception as e:
            print(f"[VALIDATION-INJECT] ‚ö†Ô∏è Could not save debug file: {e}")
        
        driver.execute_script(validation_js)
        print("[MIS-VALIDATION] v12.10 JavaScript injected successfully")
        print("[VALIDATION-INJECT] ‚úÖ Injection completed successfully")
        
    except Exception as e:
        # ENHANCED ERROR LOGGING
        import traceback
        error_details = traceback.format_exc()
        print(f"[VALIDATION-INJECT] ‚ùå JavaScript execution FAILED!")
        print(f"[VALIDATION-INJECT] Error type: {type(e).__name__}")
        print(f"[VALIDATION-INJECT] Error message: {str(e)}")
        print(f"[VALIDATION-INJECT] Full traceback:\n{error_details}")
        print(f"[MIS-VALIDATION] Error injecting JavaScript: {e}")
        raise


@app.route('/api/mis/create-deal', methods=['POST'])
def api_mis_create_deal():
    """
    Create a new deal in MIS based on Google Sheet data.
    
    Steps:
    1. Navigate to MIS daily-discount page
    2. Click "Add New" button
    3. Fill out form fields from Google Sheet data
    4. (Does NOT click Save - user reviews first)
    """
    try:
        # Set automation flag (prevents background validation monitor from interfering)
        GLOBAL_DATA['automation_in_progress'] = True
        
        data = request.get_json()
        start_date = data.get('start_date', '')
        end_date = data.get('end_date', '')
        sheet_data = data.get('sheet_data', {})
        
        if not start_date or not end_date:
            return jsonify({'success': False, 'error': 'Start and end dates are required'})
        
        warnings = []
        
        # Extract sheet data
        brand = sheet_data.get('brand', '')
        linked_brand = sheet_data.get('linked_brand', '')
        weekday = sheet_data.get('weekday', '')
        discount = sheet_data.get('discount', '')
        vendor_contrib = sheet_data.get('vendor_contrib', '')
        locations = sheet_data.get('locations', '')
        categories = sheet_data.get('categories', '')
        raw_row_data = sheet_data.get('raw_row_data', {})
        
        print(f"[MIS CREATE DEAL] Starting deal creation for brand: {brand}")
        print(f"[MIS CREATE DEAL] Weekday: {weekday}, Discount: {discount}%, Vendor: {vendor_contrib}%")
        print(f"[MIS CREATE DEAL] Dates: {start_date} to {end_date}")
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized. Please click Initialize first.'})
        
        # INTELLIGENT MIS SESSION CHECK - ensures tab exists and is logged in
        try:
            # Load credentials from config for auto-login if needed
            creds = load_credentials_config()
            mis_user = creds.get('mis_username', '')
            mis_pass = creds.get('mis_password', '')
            ensure_mis_ready(driver, mis_user, mis_pass)
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)})
        
        # ensure_mis_ready guarantees we're on MIS tab and logged in
        
        # Click "Add New" button
        try:
            add_btn = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "button.btn-add-dialog"))
            )
            add_btn.click()
            print("[MIS CREATE DEAL] Clicked 'Add New' button")
            time.sleep(2)
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not find Add New button: {e}'})
        
        # Wait for modal to open
        try:
            WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((By.ID, "discount_rate"))
            )
            print("[MIS CREATE DEAL] Modal opened successfully")
        except:
            return jsonify({'success': False, 'error': 'Deal creation modal did not open'})
        
        # ============================================
        # ATOMIC TRANSACTIONS FORM FILLING
        # ============================================
        # Strategy: Find -> Click -> Action -> Backdrop Click -> Verify
        # Each field is an isolated mission - no TAB navigation
        
        # Master store list for parsing "All Locations Except" logic
        # NOTE: "Green Easy (Old)" exists in dropdown but should NEVER be selected
        MASTER_STORE_LIST = [
            'Beverly', 'Davis', 'Dixon', 'El Sobrante', 'Fresno', 'Fresno Shaw',
            'Hawthorne', 'Koreatown', 'Laguna Woods', 'Oxnard', 'Riverside', 'West Hollywood'
        ]
        
        def log(message, level="INFO"):
            """Debug logging with timestamp."""
            timestamp = time.strftime("%H:%M:%S")
            print(f"[{timestamp}] [{level}] {message}")
        
        def click_backdrop():
            """Click neutral element to force-close any Select2 dropdown and reset focus."""
            try:
                # Try clicking the modal title (always visible, neutral)
                backdrop = driver.find_element(By.CSS_SELECTOR, "h4.modal-title, .modal-header, .modal-body h5")
                backdrop.click()
                log("Clicked backdrop to reset focus", "DEBUG")
                time.sleep(0.1)  # Reduced from 0.3
            except:
                try:
                    # Fallback: press ESCAPE
                    ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                    time.sleep(0.08)  # Reduced from 0.2
                except:
                    pass
        
        def build_xpath_contains(text):
            """Build XPath contains() that handles apostrophes correctly."""
            if "'" in text:
                # Use concat() to handle apostrophes
                parts = text.split("'")
                concat_parts = []
                for i, part in enumerate(parts):
                    if part:
                        concat_parts.append(f"'{part}'")
                    if i < len(parts) - 1:
                        concat_parts.append('"\'"')
                return f"concat({', '.join(concat_parts)})"
            else:
                return f"'{text}'"
        
        def fast_type_or_paste(element, text, field_name="field"):
            """
            Fast input: Try JavaScript injection first, fall back to send_keys.
            Optimized for speed with minimal delays.
            """
            text = str(text)
            
            # Method 1: JavaScript injection (fastest)
            try:
                # Set value via JS and trigger input/change events for Select2
                driver.execute_script("""
                    var element = arguments[0];
                    var text = arguments[1];
                    element.value = text;
                    element.dispatchEvent(new Event('input', { bubbles: true }));
                    element.dispatchEvent(new Event('keyup', { bubbles: true }));
                """, element, text)
                log(f"  [{field_name}] Fast-typed '{text}' via JS", "DEBUG")
                time.sleep(0.15)  # Reduced from 0.3 - Give Select2 time to filter
                return True
            except Exception as e:
                log(f"  [{field_name}] JS injection failed: {e}", "DEBUG")
            
            # Method 2: Direct send_keys (still fast, sends all at once)
            try:
                element.send_keys(text)
                log(f"  [{field_name}] Typed '{text}' via send_keys", "DEBUG")
                time.sleep(0.15)  # Reduced from 0.3
                return True
            except Exception as e:
                log(f"  [{field_name}] send_keys failed: {e}", "DEBUG")
            
            # Method 3: Character by character (slowest, most reliable)
            try:
                for char in text:
                    element.send_keys(char)
                    time.sleep(0.015)  # Reduced from 0.02
                log(f"  [{field_name}] Typed '{text}' char-by-char", "DEBUG")
                time.sleep(0.15)  # Reduced from 0.3
                return True
            except Exception as e:
                log(f"  [{field_name}] Char-by-char failed: {e}", "ERROR")
                return False
        
        def atomic_single_select(label_text, value, field_name):
            """
            Fill a single-select dropdown using SIMULATED MOUSE CLICKS.
            Handles BOTH searchable and non-searchable dropdowns (like Rebate Type).
            """
            if not value:
                log(f"Skipping {field_name} (no value)", "SKIP")
                return True
            
            log(f"ATOMIC SINGLE-SELECT: {field_name} = {value}", "INFO")
            
            # Map field names to their Select2 select element IDs
            FIELD_SELECT_MAP = {
                'Brand': 'brand_id',
                'Linked Brand': 'linked_brand_id',
                'Rebate Type': 'daily_discount_type_id'
            }
            
            select_id = FIELD_SELECT_MAP.get(field_name, field_name.lower().replace(' ', '_'))
            
            try:
                # Step 1: Close any open dropdown
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.1)
                click_backdrop()
                time.sleep(0.15)
                
                # Step 2: Find the Select2 container
                container = None
                
                # Method A: Find by select ID
                try:
                    container_css = f"select#{select_id} + .select2-container, " \
                                   f".select2-container[aria-labelledby*='{select_id}']"
                    container = driver.find_element(By.CSS_SELECTOR, container_css)
                    log(f"  [{field_name}] Found container via select ID", "DEBUG")
                except:
                    pass
                
                # Method B: Find by label
                if not container:
                    try:
                        xpath_value = build_xpath_contains(label_text)
                        container_xpath = f"//label[contains(text(), {xpath_value})]/following::span[contains(@class, 'select2-container')][1]"
                        container = driver.find_element(By.XPATH, container_xpath)
                        log(f"  [{field_name}] Found container via label", "DEBUG")
                    except:
                        pass
                
                # Method C: Known IDs fallback
                if not container:
                    try:
                        id_map = {
                            'Brand': 'select2-brand_id-container',
                            'Linked Brand': 'select2-linked_brand_id-container',
                            'Rebate Type': 'select2-daily_discount_type_id-container'
                        }
                        if field_name in id_map:
                            container = driver.find_element(By.ID, id_map[field_name])
                            log(f"  [{field_name}] Found container via known ID", "DEBUG")
                    except:
                        pass
                
                if not container:
                    log(f"  [{field_name}] Could not find Select2 container!", "ERROR")
                    return False
                
                # Step 3: SIMULATE MOUSE CLICK to open dropdown
                log(f"  [{field_name}] Simulating mouse click on container...", "DEBUG")
                actions = ActionChains(driver)
                actions.move_to_element(container)
                actions.click()
                actions.perform()
                time.sleep(0.25)
                
                # Step 4: Check if search input exists and is VISIBLE
                search_input = None
                search_is_visible = False
                
                try:
                    # Look for search input that is NOT hidden
                    search_elements = driver.find_elements(By.CSS_SELECTOR, 
                        ".select2-dropdown .select2-search__field")
                    for elem in search_elements:
                        if elem.is_displayed():
                            search_input = elem
                            search_is_visible = True
                            break
                    
                    if search_is_visible:
                        log(f"  [{field_name}] Search input is VISIBLE - will type to filter", "DEBUG")
                    else:
                        log(f"  [{field_name}] Search input is HIDDEN - will click option directly", "DEBUG")
                except:
                    log(f"  [{field_name}] No search input found - will click option directly", "DEBUG")
                
                # Step 5: If search is visible, type to filter; otherwise skip
                if search_is_visible and search_input:
                    actions = ActionChains(driver)
                    actions.move_to_element(search_input)
                    actions.click()
                    actions.perform()
                    time.sleep(0.1)
                    
                    # Fast type the value
                    fast_type_or_paste(search_input, str(value), field_name)
                
                # Step 6: Find and click the matching option directly
                try:
                    # Build XPath for exact or contains match
                    option_xpath_value = build_xpath_contains(str(value))
                    
                    # Try exact text match first, then contains
                    option = None
                    
                    # Method A: Exact text match
                    try:
                        exact_xpath = f"//li[contains(@class, 'select2-results__option') and normalize-space(text())={option_xpath_value}]"
                        option = WebDriverWait(driver, 1).until(
                            EC.element_to_be_clickable((By.XPATH, exact_xpath))
                        )
                        log(f"  [{field_name}] Found option via exact match", "DEBUG")
                    except:
                        pass
                    
                    # Method B: Contains text match
                    if not option:
                        try:
                            contains_xpath = f"//li[contains(@class, 'select2-results__option') and contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 1.5).until(
                                EC.element_to_be_clickable((By.XPATH, contains_xpath))
                            )
                            log(f"  [{field_name}] Found option via contains match", "DEBUG")
                        except:
                            pass
                    
                    # Method C: Find by results list ID (for Rebate Type specifically)
                    if not option and field_name == 'Rebate Type':
                        try:
                            # Rebate Type options have specific IDs
                            results_xpath = f"//ul[@id='select2-daily_discount_type_id-results']//li[contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 1).until(
                                EC.element_to_be_clickable((By.XPATH, results_xpath))
                            )
                            log(f"  [{field_name}] Found option via results list ID", "DEBUG")
                        except:
                            pass
                    
                    if option:
                        # Simulate click on option
                        actions = ActionChains(driver)
                        actions.move_to_element(option)
                        actions.click()
                        actions.perform()
                        log(f"  [{field_name}] √¢≈ì‚Äú Selected '{value}'", "SUCCESS")
                    else:
                        raise Exception(f"Could not find option '{value}'")
                        
                except Exception as e:
                    # Last resort: try keyboard navigation
                    log(f"  [{field_name}] Click failed, trying ENTER: {e}", "WARN")
                    if search_input and search_is_visible:
                        search_input.send_keys(Keys.ENTER)
                    else:
                        # Press down arrow to move to first real option, then ENTER
                        ActionChains(driver).send_keys(Keys.ARROW_DOWN).perform()
                        time.sleep(0.1)
                        ActionChains(driver).send_keys(Keys.ENTER).perform()
                    log(f"  [{field_name}] √¢≈ì‚Äú Selected '{value}' via keyboard", "SUCCESS")
                
                time.sleep(0.1)
                
                # Step 7: Cleanup
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.08)
                click_backdrop()
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_single_select for {field_name}: {e}", "ERROR")
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                click_backdrop()
                return False
        
        def atomic_multi_select(label_text, values, field_name):
            """
            Fill a multi-select dropdown by CLICKING OPTIONS DIRECTLY.
            
            Speed optimization: Instead of typing to filter, we:
            1. Open dropdown once
            2. Find each option by text and click it
            3. Dropdown stays open for multi-select
            4. Repeat until all values selected
            """
            if not values or len(values) == 0:
                log(f"Skipping {field_name} (no values)", "SKIP")
                return True
            
            log(f"ATOMIC MULTI-SELECT: {field_name} = {values} ({len(values)} items)", "INFO")
            
            # Map field names to their results list IDs
            FIELD_RESULTS_MAP = {
                'Weekday': 'select2-weekday_ids-results',
                'Store': 'select2-store_ids-results', 
                'Category': 'select2-category_ids-results'
            }
            
            # Map field names to their Select2 container IDs
            FIELD_SELECT_MAP = {
                'Weekday': 'weekday_ids',
                'Store': 'store_ids', 
                'Category': 'category_ids'
            }
            
            select_id = FIELD_SELECT_MAP.get(field_name, field_name.lower())
            results_id = FIELD_RESULTS_MAP.get(field_name, f"select2-{select_id}-results")
            
            try:
                # Step 1: Close any previously open dropdown
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.08)
                click_backdrop()
                time.sleep(0.1)
                
                # Step 2: Find and open THIS field's dropdown ONCE
                container = None
                
                # Method A: Find by select element ID
                try:
                    container_css = f"select#{select_id} + .select2-container, " \
                                   f"select[name='{select_id}'] + .select2-container, " \
                                   f".select2-container[aria-labelledby*='{select_id}']"
                    container = driver.find_element(By.CSS_SELECTOR, container_css)
                    log(f"  [{field_name}] Found container via select ID", "DEBUG")
                except:
                    pass
                
                # Method B: Find by label text
                if not container:
                    try:
                        xpath_label = build_xpath_contains(label_text)
                        container_xpath = f"//label[contains(text(), {xpath_label})]/following::span[contains(@class, 'select2-container')][1]"
                        container = driver.find_element(By.XPATH, container_xpath)
                        log(f"  [{field_name}] Found container via label", "DEBUG")
                    except:
                        pass
                
                if not container:
                    log(f"  [{field_name}] Could not find Select2 container!", "ERROR")
                    return False
                
                # Step 3: Click to open the dropdown
                log(f"  [{field_name}] Opening dropdown...", "DEBUG")
                actions = ActionChains(driver)
                actions.move_to_element(container)
                actions.click()
                actions.perform()
                time.sleep(0.2)
                
                # Verify dropdown opened
                try:
                    WebDriverWait(driver, 2).until(
                        lambda d: 'select2-container--open' in container.get_attribute('class')
                    )
                    log(f"  [{field_name}] Dropdown opened", "DEBUG")
                except:
                    log(f"  [{field_name}] Dropdown may not have opened", "WARN")
                
                # Step 4: Select each value by CLICKING DIRECTLY (no typing!)
                selected_count = 0
                for i, value in enumerate(values):
                    value = value.strip()
                    if not value:
                        continue
                    
                    log(f"  [{field_name}] ({i+1}/{len(values)}) Selecting '{value}'...", "DEBUG")
                    
                    # Find the option directly in the results list
                    option = None
                    option_xpath_value = build_xpath_contains(value)
                    
                    # Method A: Find by results list ID (most reliable)
                    try:
                        results_xpath = f"//ul[@id='{results_id}']//li[normalize-space(text())={option_xpath_value}]"
                        option = WebDriverWait(driver, 1).until(
                            EC.element_to_be_clickable((By.XPATH, results_xpath))
                        )
                        log(f"  [{field_name}] Found '{value}' via results list", "DEBUG")
                    except:
                        pass
                    
                    # Method B: Find by contains text in any visible option
                    if not option:
                        try:
                            contains_xpath = f"//li[contains(@class, 'select2-results__option') and contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 0.5).until(
                                EC.element_to_be_clickable((By.XPATH, contains_xpath))
                            )
                            log(f"  [{field_name}] Found '{value}' via contains", "DEBUG")
                        except:
                            pass
                    
                    # Method C: If dropdown closed, reopen and try again
                    if not option:
                        log(f"  [{field_name}] Option not found, reopening dropdown...", "WARN")
                        actions = ActionChains(driver)
                        actions.move_to_element(container)
                        actions.click()
                        actions.perform()
                        time.sleep(0.15)
                        
                        try:
                            results_xpath = f"//ul[@id='{results_id}']//li[contains(text(), {option_xpath_value})]"
                            option = WebDriverWait(driver, 1).until(
                                EC.element_to_be_clickable((By.XPATH, results_xpath))
                            )
                        except:
                            log(f"  [{field_name}] Could not find option '{value}'!", "ERROR")
                            continue
                    
                    if option:
                        # Click the option using ActionChains
                        actions = ActionChains(driver)
                        actions.move_to_element(option)
                        actions.click()
                        actions.perform()
                        selected_count += 1
                        log(f"  [{field_name}] √¢≈ì‚Äú Selected '{value}'", "SUCCESS")
                        time.sleep(0.08)  # Very short pause between selections
                
                # Step 5: Close the dropdown after ALL selections
                log(f"  [{field_name}] Selected {selected_count}/{len(values)} items, closing dropdown", "DEBUG")
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                time.sleep(0.08)
                click_backdrop()
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_multi_select for {field_name}: {e}", "ERROR")
                ActionChains(driver).send_keys(Keys.ESCAPE).perform()
                click_backdrop()
                return False
        
        def atomic_text_input(input_id, value, field_name):
            """
            Fill a text input using direct ID lookup.
            """
            if value is None or value == '':
                log(f"Skipping {field_name} (no value)", "SKIP")
                return True
            
            log(f"ATOMIC TEXT INPUT: {field_name} = {value}", "INFO")
            
            try:
                # Step 1: Click backdrop first
                click_backdrop()
                time.sleep(0.2)
                
                # Step 2: Find input by ID
                input_el = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.ID, input_id))
                )
                
                # Step 3: Click to focus
                input_el.click()
                time.sleep(0.1)
                
                # Step 4: Clear and type
                input_el.send_keys(Keys.CONTROL + "a")
                input_el.send_keys(Keys.DELETE)
                time.sleep(0.1)
                
                value_str = str(value).replace('%', '').strip()
                input_el.send_keys(value_str)
                log(f"Typed '{value_str}' into {field_name}", "SUCCESS")
                
                # Step 5: Click backdrop
                click_backdrop()
                
                return True
                
            except Exception as e:
                log(f"Error in atomic_text_input for {field_name}: {e}", "ERROR")
                click_backdrop()
                return False
        
        def atomic_toggle(label_for_id, should_enable, field_name):
            """
            Toggle a checkbox/switch by clicking its label.
            """
            if not should_enable:
                log(f"Skipping {field_name} (not enabled)", "SKIP")
                return True
            
            log(f"ATOMIC TOGGLE: {field_name} = ON", "INFO")
            
            try:
                # Click backdrop first
                click_backdrop()
                time.sleep(0.2)
                
                # Find and click the label
                label = driver.find_element(By.XPATH, f"//label[@for='{label_for_id}']")
                label.click()
                log(f"Toggled {field_name} ON", "SUCCESS")
                time.sleep(0.2)
                
                click_backdrop()
                return True
                
            except Exception as e:
                log(f"Error in atomic_toggle for {field_name}: {e}", "ERROR")
                return False
        
        def resolve_store_selection(locations_text):
            """
            Parse store selection text and return list of stores to select.
            Handles: "All Locations", "All Locations Except: X, Y", or specific stores.
            """
            if not locations_text:
                return []
            
            text = locations_text.strip()
            text_lower = text.lower()
            
            # Case 1: All Locations (leave blank - default)
            if text_lower == 'all locations' or text_lower == 'all':
                log("Store logic: All Locations (leaving blank)", "DEBUG")
                return []
            
            # Case 2: All Locations Except
            if 'except' in text_lower:
                # Extract exceptions
                # Handle formats like "All Locations (Except: X, Y)" or "All Locations Except: X, Y"
                import re
                match = re.search(r'except[:\s]*(.+?)(?:\)|$)', text_lower, re.IGNORECASE)
                if match:
                    exceptions_text = match.group(1)
                    exceptions = [e.strip() for e in exceptions_text.split(',') if e.strip()]
                    
                    # Return master list minus exceptions
                    result = []
                    for store in MASTER_STORE_LIST:
                        store_lower = store.lower()
                        is_exception = any(exc.lower() in store_lower or store_lower in exc.lower() for exc in exceptions)
                        if not is_exception:
                            result.append(store)
                    
                    log(f"Store logic: All except {exceptions} = {result}", "DEBUG")
                    return result
            
            # Case 3: Specific stores
            stores = [s.strip() for s in text.split(',') if s.strip()]
            log(f"Store logic: Specific stores = {stores}", "DEBUG")
            return stores
        
        # ============================================
        # PARSE INPUT DATA
        # ============================================
        log("=" * 60, "INFO")
        log("PREPARING FORM DATA", "INFO")
        log("=" * 60, "INFO")
        
        # Parse weekdays
        weekdays_to_select = []
        if weekday:
            weekday_lower = weekday.lower().strip()
            if weekday_lower == 'all week' or weekday_lower == 'everyday':
                weekdays_to_select = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
            else:
                day_map = {
                    'mon': 'Monday', 'monday': 'Monday',
                    'tue': 'Tuesday', 'tuesday': 'Tuesday', 'tues': 'Tuesday',
                    'wed': 'Wednesday', 'wednesday': 'Wednesday',
                    'thu': 'Thursday', 'thursday': 'Thursday', 'thur': 'Thursday', 'thurs': 'Thursday',
                    'fri': 'Friday', 'friday': 'Friday',
                    'sat': 'Saturday', 'saturday': 'Saturday',
                    'sun': 'Sunday', 'sunday': 'Sunday'
                }
                import re
                parts = re.split(r'[,\s]+', weekday_lower)
                for part in parts:
                    part = part.strip()
                    if part in day_map:
                        weekdays_to_select.append(day_map[part])
        log(f"Weekdays: {weekdays_to_select}", "DATA")
        
        # Parse stores using resolver
        stores_to_select = resolve_store_selection(locations)
        log(f"Stores: {stores_to_select}", "DATA")
        
        # Parse brand
        primary_brand = ''
        if brand:
            brands = parse_multi_brand(brand)
            primary_brand = brands[0] if brands else brand
        log(f"Brand: {primary_brand}", "DATA")
        log(f"Linked Brand: {linked_brand}", "DATA")
        
        # Parse categories
        categories_to_select = []
        if categories:
            cat_lower = categories.lower().strip()
            if cat_lower not in ['all', 'all categories', '']:
                categories_to_select = [c.strip() for c in categories.split(',') if c.strip()]
        log(f"Categories: {categories_to_select}", "DATA")
        
        # Parse rebate type
        wholesale_checked = False
        retail_checked = False
        wholesale_col_found = False
        retail_col_found = False
        
        # Debug: Log all keys AND values in raw_row_data to help diagnose
        log(f"raw_row_data keys: {list(raw_row_data.keys())}", "DEBUG")
        log(f"raw_row_data full content:", "DEBUG")
        for k, v in raw_row_data.items():
            log(f"  '{k}' = '{v}'", "DEBUG")
        
        for key, val in raw_row_data.items():
            key_lower = key.lower()
            # Check for various column name formats
            if 'wholesale' in key_lower:
                wholesale_col_found = True
                val_str = str(val).strip().upper()
                log(f"Found wholesale column: '{key}' = '{val}' (normalized: '{val_str}')", "DEBUG")
                # Google Sheets checkboxes return TRUE/FALSE as strings
                if val_str in ['TRUE', 'YES', '1', 'X', '√¢≈ì‚Äú', 'CHECKED']:
                    wholesale_checked = True
                elif val_str in ['FALSE', 'NO', '0', '', 'UNCHECKED']:
                    wholesale_checked = False
            if 'retail' in key_lower:
                retail_col_found = True
                val_str = str(val).strip().upper()
                log(f"Found retail column: '{key}' = '{val}' (normalized: '{val_str}')", "DEBUG")
                if val_str in ['TRUE', 'YES', '1', 'X', '√¢≈ì‚Äú', 'CHECKED']:
                    retail_checked = True
                elif val_str in ['FALSE', 'NO', '0', '', 'UNCHECKED']:
                    retail_checked = False
        
        # Log if columns weren't found at all
        if not wholesale_col_found:
            log("WARNING: No 'Wholesale' column found in raw_row_data!", "WARN")
        if not retail_col_found:
            log("WARNING: No 'Retail' column found in raw_row_data!", "WARN")
        
        log(f"Wholesale checked: {wholesale_checked}, Retail checked: {retail_checked}", "DEBUG")
        
        rebate_type = None
        rebate_type_error = False
        
        if wholesale_checked and retail_checked:
            warnings.append('√¢≈°¬† REBATE TYPE ERROR: Both Wholesale AND Retail are TRUE - only one can be selected!')
            log("REBATE TYPE ERROR: Both checked!", "WARN")
            rebate_type_error = True
            # Highlight the Rebate Type field with red border
            try:
                driver.execute_script("""
                    var container = document.querySelector('#select2-daily_discount_type_id-container');
                    if (container) {
                        container.parentElement.style.border = '3px solid red';
                        container.parentElement.style.borderRadius = '4px';
                    }
                """)
                log("Added red highlight to Rebate Type field", "DEBUG")
            except:
                pass
                
        elif not wholesale_checked and not retail_checked:
            warnings.append('√¢≈°¬† REBATE TYPE ERROR: Neither Wholesale nor Retail is TRUE - one must be selected!')
            log("REBATE TYPE ERROR: Neither checked!", "WARN")
            rebate_type_error = True
            # Highlight the Rebate Type field with red border
            try:
                driver.execute_script("""
                    var container = document.querySelector('#select2-daily_discount_type_id-container');
                    if (container) {
                        container.parentElement.style.border = '3px solid red';
                        container.parentElement.style.borderRadius = '4px';
                    }
                """)
                log("Added red highlight to Rebate Type field", "DEBUG")
            except:
                pass
                
        elif wholesale_checked:
            rebate_type = 'Wholesale'
        elif retail_checked:
            rebate_type = 'Retail'
        log(f"Rebate Type: {rebate_type}", "DATA")
        log(f"Discount: {discount}", "DATA")
        log(f"Vendor Contrib: {vendor_contrib}", "DATA")
        
        # Parse toggles
        after_wholesale = False
        for key, val in raw_row_data.items():
            if 'after wholesale' in key.lower():
                after_wholesale = str(val).upper() == 'TRUE'
                break
        log(f"After Wholesale: {after_wholesale}", "DATA")
        
        # Parse weight info
        weight_info = parse_weight_exception(raw_row_data)
        min_weight = weight_info.get('min_weight') if weight_info else None
        max_weight = weight_info.get('max_weight') if weight_info else None
        log(f"Min Weight: {min_weight}, Max Weight: {max_weight}", "DATA")
        log(f"Start Date: {start_date}, End Date: {end_date}", "DATA")
        
        # ============================================
        # FILL FORM USING ATOMIC TRANSACTIONS
        # ============================================
        log("=" * 60, "INFO")
        log("STARTING ATOMIC FORM FILL", "INFO")
        log("=" * 60, "INFO")
        
        # Initial backdrop click to ensure clean state
        click_backdrop()
        time.sleep(0.5)
        
        # 1. WEEKDAY (multi-select)
        if weekdays_to_select:
            if not atomic_multi_select("Weekday", weekdays_to_select, "Weekday"):
                warnings.append('√¢≈°¬† Could not fill Weekday')
        
        # 2. STORE (multi-select) - only if specific stores needed
        if stores_to_select:
            if not atomic_multi_select("Store", stores_to_select, "Store"):
                warnings.append('√¢≈°¬† Could not fill Store')
        
        # 3. BRAND (single-select)
        if primary_brand:
            if not atomic_single_select("Brand", primary_brand, "Brand"):
                warnings.append('√¢≈°¬† Could not fill Brand')
        
        # 4. LINKED BRAND (single-select)
        if linked_brand:
            if not atomic_single_select("Linked Brand", linked_brand, "Linked Brand"):
                warnings.append('√¢≈°¬† Could not fill Linked Brand')
        
        # 5. CATEGORY (multi-select)
        if categories_to_select:
            if not atomic_multi_select("Category", categories_to_select, "Category"):
                warnings.append('√¢≈°¬† Could not fill Category')
        
        # 6. DISCOUNT RATE (text input)
        if discount is not None and str(discount).strip() != '':
            if not atomic_text_input("discount_rate", discount, "Discount Rate"):
                warnings.append('√¢≈°¬† Could not fill Discount Rate')
        
        # 7. REBATE TYPE (single-select)
        if rebate_type:
            if not atomic_single_select("Rebate Type", rebate_type, "Rebate Type"):
                warnings.append('√¢≈°¬† Could not fill Rebate Type')
        
        # 8. VENDOR REBATE % (text input)
        if vendor_contrib is not None and str(vendor_contrib).strip() != '':
            if not atomic_text_input("rebate_percent", vendor_contrib, "Vendor Rebate"):
                warnings.append('√¢≈°¬† Could not fill Vendor Rebate')
        
        # 9. TOGGLE: After Wholesale
        if after_wholesale:
            if not atomic_toggle("rebate_wholesale_discount", True, "After Wholesale"):
                warnings.append('√¢≈°¬† Could not toggle After Wholesale')
        
        # 10. START DATE (text input)
        if start_date:
            if not atomic_text_input("date_start", start_date, "Start Date"):
                warnings.append('√¢≈°¬† Could not fill Start Date')
        
        # 11. END DATE (text input)
        if end_date:
            if not atomic_text_input("date_end", end_date, "End Date"):
                warnings.append('√¢≈°¬† Could not fill End Date')
        
        # 12. MIN WEIGHT (text input)
        if min_weight is not None:
            if not atomic_text_input("min_weight", min_weight, "Min Weight"):
                warnings.append('√¢≈°¬† Could not fill Min Weight')
        
        # 13. MAX WEIGHT (text input)
        if max_weight is not None:
            if not atomic_text_input("max_weight", max_weight, "Max Weight"):
                warnings.append('√¢≈°¬† Could not fill Max Weight')
        
        # ============================================
        # FORM FILL COMPLETE
        # ============================================
        log("=" * 60, "INFO")
        log("FORM FILL COMPLETE", "SUCCESS")
        log("=" * 60, "INFO")
        
        # v12.8 Phase 2: Inject validation system after form fill with expected data
        try:
            # Prepare expected data for validation
            expected_data = {
                'brand': primary_brand,  # Use primary_brand, not just brand
                'linked_brand': linked_brand,
                'weekday': weekday,
                'categories': ','.join(categories_to_select) if categories_to_select else '',
                'discount': discount,
                'vendor_contrib': vendor_contrib,
                'locations': locations,
                'rebate_type': rebate_type,
                'after_wholesale': after_wholesale
            }
            
            # DIAGNOSTIC: Log validation injection attempt
            print("[VALIDATION-DIAGNOSTIC] Attempting to inject validation system...")
            print(f"[VALIDATION-DIAGNOSTIC] Driver available: {driver is not None}")
            print(f"[VALIDATION-DIAGNOSTIC] Expected data keys: {list(expected_data.keys())}")
            
            inject_mis_validation(driver, expected_data)
            log("Validation system injected with Phase 2 field comparison", "SUCCESS")
            print("[VALIDATION-DIAGNOSTIC] ‚úÖ Validation injection successful!")
            
        except Exception as e:
            # ENHANCED ERROR LOGGING
            import traceback
            error_details = traceback.format_exc()
            print(f"[VALIDATION-DIAGNOSTIC] ‚ùå Validation injection FAILED!")
            print(f"[VALIDATION-DIAGNOSTIC] Error type: {type(e).__name__}")
            print(f"[VALIDATION-DIAGNOSTIC] Error message: {str(e)}")
            print(f"[VALIDATION-DIAGNOSTIC] Full traceback:\n{error_details}")
            
            log(f"Warning: Could not inject validation: {e}", "WARN")
            warnings.append(f'‚ö†Ô∏è Validation system not loaded: {type(e).__name__}')
        
        # Clear automation flag
        GLOBAL_DATA['automation_in_progress'] = False
        
        return jsonify({
            'success': True,
            'message': 'Deal form filled. Please review and click Save.',
            'warnings': warnings
        })
        
    except Exception as e:
        # Clear automation flag on error
        GLOBAL_DATA['automation_in_progress'] = False
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


def parse_weight_exception(raw_row_data):
    """
    Parse weight exceptions from Category Except or Special Notes columns.
    
    Patterns:
    - "Except 3.5g" -> max_weight = 3.0 (0.5 below stated)
    - "Only 3.5g" -> min_weight = 3.4 (0.1 below), max_weight = 3.5
    
    Weight conversions:
    - quarter = 7g
    - half/half ounce/half oz = 14g
    - ounce/full ounce/oz/1oz = 28g
    """
    import re
    
    # Weight word to grams mapping
    weight_map = {
        'quarter': 7,
        'half': 14, 'half ounce': 14, 'half oz': 14,
        'ounce': 28, 'full ounce': 28, 'oz': 28, '1oz': 28
    }
    
    def extract_weight(text):
        """Extract weight value from text."""
        text = text.lower()
        
        # Check for word-based weights first
        for word, grams in weight_map.items():
            if word in text:
                return grams
        
        # Look for numeric weight (e.g., "3.5g", "3.5 g", "3.5")
        match = re.search(r'(\d+\.?\d*)\s*g?', text)
        if match:
            return float(match.group(1))
        
        return None
    
    result = {}
    
    # Search in relevant columns
    search_columns = ['category except', 'special notes', 'notes', 'exceptions']
    
    for key, value in raw_row_data.items():
        key_lower = key.lower()
        if any(col in key_lower for col in search_columns):
            if not value or str(value).strip().lower() in ['', 'nan', 'none']:
                continue
            
            value_str = str(value).lower()
            weight = extract_weight(value_str)
            
            if weight:
                if 'except' in value_str:
                    # "Except X" -> max_weight = X - 0.5
                    result['max_weight'] = weight - 0.5
                    print(f"[WEIGHT PARSE] Found 'Except {weight}g' -> max_weight = {result['max_weight']}")
                elif 'only' in value_str:
                    # "Only X" -> min_weight = X - 0.1, max_weight = X
                    result['min_weight'] = weight - 0.1
                    result['max_weight'] = weight
                    print(f"[WEIGHT PARSE] Found 'Only {weight}g' -> min={result['min_weight']}, max={result['max_weight']}")
    
    return result if result else None


# v12.8: Standalone endpoint to inject validation (for manual entry monitoring)
@app.route('/api/mis/inject-validation', methods=['POST'])
def api_mis_inject_validation():
    """
    Inject MIS validation system into the current page.
    Can be called independently to enable validation for manual entries.
    """
    try:
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        
        # Switch to MIS tab
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if "mymis.net" in driver.current_url or "mis" in driver.current_url.lower():
                break
        
        inject_mis_validation(driver, expected_data=None)
        
        return jsonify({
            'success': True,
            'message': 'Validation system injected. Modal monitoring active.'
        })
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})


# ============================================
# GOOGLE SHEET CONFLICT AUDIT (Pre-Flight Check)
# ============================================
@app.route('/api/mis/gsheet-conflict-audit', methods=['POST'])
def api_gsheet_conflict_audit():
    """
    DATE-AWARE Pre-flight check: Scans the Google Sheet for cross-section brand conflicts.
    Returns TWO sets of conflicts:
    1. Date Conflicts: Same Brand + Same Date overlap.
    2. Brand Conflicts: Same Brand in multiple sections (regardless of date).
    """
    try:
        data = request.get_json() or {}
        tab_name = data.get('tab', '')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab specified. Please select a Google Sheet tab in Setup.'})

        # 1. Parse tab name to get month/year context
        target_month, target_year = parse_tab_month_year(tab_name)
        print(f"[GSHEET AUDIT] Tab: {tab_name} -> Month: {target_month}, Year: {target_year}")

        # 2. Fetch data from Google Sheet (splits into sections)
        sections_data = fetch_google_sheet_data(tab_name)
        
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found in the selected sheet tab.'})

        # 3. Process each section
        # We need two maps: one for date-specific checking, one for general brand checking
        brand_date_map = {}     # Key: (brand, date) -> list of rows
        brand_general_map = {}  # Key: brand -> list of rows (all sections)
        
        section_counts = {'weekly': 0, 'monthly': 0, 'sale': 0}
        unique_brands = set()

        for section_key in ['weekly', 'monthly', 'sale']:
            section_df = sections_data.get(section_key, pd.DataFrame())
            if section_df.empty:
                continue
                
            # Apply multi-day grouping FIRST (for Weekly deals)
            multi_day_groups, row_to_group = detect_multi_day_groups(section_df, section_key)
            processed_groups = set()

            for idx, row in section_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand: continue
                
                unique_brands.add(brand)
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                group_id = row_to_group.get(true_row)
                
                # --- EXTRACT DATA ---
                weekday_raw = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '-')).strip()
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                mis_id = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                special_notes = str(row.get('SPECIAL NOTES', '')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)

                # --- DATE EXPANSION LOGIC ---
                expanded_dates = []
                is_multi_day_parent = False
                
                if section_key == 'weekly':
                    if group_id and group_id in multi_day_groups:
                        if group_id in processed_groups: 
                            continue 
                        processed_groups.add(group_id)
                        is_multi_day_parent = True
                        expanded_dates = get_all_weekdays_for_multiday_group(
                            multi_day_groups[group_id], section_df, section_key, target_month, target_year
                        )
                        weekday_raw = ', '.join(multi_day_groups[group_id].get('weekdays', []))
                    else:
                        expanded_dates = expand_weekday_to_dates(weekday_raw, target_month, target_year)
                
                elif section_key == 'monthly':
                    expanded_dates = parse_monthly_dates(weekday_raw, target_month, target_year)
                    
                elif section_key == 'sale':
                    expanded_dates = parse_sale_dates(weekday_raw, target_month, target_year)

                section_counts[section_key] += 1

                # Prepare Base Row Detail
                row_detail = {
                    'section': section_key,
                    'row_num': true_row,
                    'weekday_raw': weekday_raw if weekday_raw and weekday_raw != '[!] [EMOJI]√É‚Äö√Ç¬è  MISSING' else '-',
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'notes': special_notes,
                    'mis_id': mis_id,
                    'brand_display': brand, # Store original casing
                    'conflict_date': None 
                }

                # A) POPULATE DATE MAP (For specific date conflicts)
                for d in expanded_dates:
                    key = (brand.lower(), d)
                    if key not in brand_date_map:
                        brand_date_map[key] = []
                    
                    date_specific_detail = row_detail.copy()
                    date_specific_detail['conflict_date'] = d.strftime('%Y-%m-%d')
                    brand_date_map[key].append(date_specific_detail)

                # B) POPULATE GENERAL MAP (For broad brand conflicts)
                # If it's a multi-day parent, we add it once. If single, we add it once.
                # We do NOT add per expanded date here, just per logical deal row.
                if brand.lower() not in brand_general_map:
                    brand_general_map[brand.lower()] = []
                brand_general_map[brand.lower()].append(row_detail)


        # 4. Detect Conflicts (Type A: DATE BASED)
        date_conflicts_grouped = {} 

        for (brand_lower, date_obj), entries in brand_date_map.items():
            sections_present = set(e['section'] for e in entries)
            
            if len(sections_present) > 1:
                # DATE CONFLICT FOUND
                date_str = date_obj.strftime('%Y-%m-%d')
                brand_display = entries[0].get('brand_display', brand_lower.title()) 
                
                # Restore casing
                for b in unique_brands:
                    if b.lower() == brand_lower:
                        brand_display = b
                        break
                
                if brand_display not in date_conflicts_grouped:
                    date_conflicts_grouped[brand_display] = {
                        'brand': brand_display,
                        'sections': set(),
                        'conflicting_dates': set(),
                        'rows': []
                    }
                
                date_conflicts_grouped[brand_display]['sections'].update(sections_present)
                date_conflicts_grouped[brand_display]['conflicting_dates'].add(date_str)
                
                existing_rows = {r['row_num'] for r in date_conflicts_grouped[brand_display]['rows']}
                for e in entries:
                    if e['row_num'] not in existing_rows:
                        date_conflicts_grouped[brand_display]['rows'].append(e)
                        existing_rows.add(e['row_num'])

        # 5. Detect Conflicts (Type B: BRAND BASED)
        brand_conflicts_grouped = {}
        
        for brand_lower, entries in brand_general_map.items():
            sections_present = set(e['section'] for e in entries)
            
            if len(sections_present) > 1:
                # BRAND CONFLICT FOUND (Appears in >1 section types)
                brand_display = entries[0].get('brand_display', brand_lower.title())
                for b in unique_brands:
                    if b.lower() == brand_lower:
                        brand_display = b
                        break
                
                brand_conflicts_grouped[brand_display] = {
                    'brand': brand_display,
                    'sections': list(sections_present),
                    'rows': sorted(entries, key=lambda x: x['row_num'])
                }

        # Format Outputs
        final_date_conflicts = []
        for brand, data in date_conflicts_grouped.items():
            final_date_conflicts.append({
                'brand': brand,
                'sections': list(data['sections']),
                'total_conflict_dates': len(data['conflicting_dates']),
                'conflicting_dates': [{'date': d} for d in sorted(list(data['conflicting_dates']))],
                'rows': sorted(data['rows'], key=lambda x: x['row_num'])
            })
            
        final_brand_conflicts = []
        for brand, data in brand_conflicts_grouped.items():
            final_brand_conflicts.append({
                'brand': brand,
                'sections': data['sections'],
                'rows': data['rows']
            })

        return jsonify({
            'success': True, 
            'date_conflicts': final_date_conflicts,
            'brand_conflicts': final_brand_conflicts,
            'summary': {
                'weekly_count': section_counts['weekly'],
                'monthly_count': section_counts['monthly'],
                'sale_count': section_counts['sale'],
                'unique_brands': len(unique_brands)
            },
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}"
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================================
# SPLIT AUDIT API ROUTES (V29)
# ============================================================================
def simulate_calendar_hierarchy(weekly_deals: List[Dict], tier1_deals: List[Dict], target_month: int, target_year: int) -> Dict:
    """
    Build a virtual calendar for the target month with deal dominance.
    Tier 1 (Sale/Monthly) locks dates. Tier 2 (Weekly) fills remaining dates.
    Returns: {date_str: {'dominant': deal_info, 'conflicts': [...]}}
    """
    import calendar
    from datetime import date
    
    num_days = calendar.monthrange(target_year, target_month)[1]
    calendar_map = {}
    
    # Initialize calendar
    for day in range(1, num_days + 1):
        d = date(target_year, target_month, day)
        date_str = d.strftime('%Y-%m-%d')
        calendar_map[date_str] = {
            'date': d,
            'tier1_deals': [],  # Sale/Monthly - highest priority
            'tier2_deals': [],  # Weekly - lower priority
            'dominant': None
        }
    
    # Populate Tier 1 (Sale/Monthly) deals
    for deal in tier1_deals:
        for d in deal.get('expanded_dates', []):
            date_str = d.strftime('%Y-%m-%d')
            if date_str in calendar_map:
                calendar_map[date_str]['tier1_deals'].append(deal)
    
    # Populate Tier 2 (Weekly) deals
    for deal in weekly_deals:
        for d in deal.get('expanded_dates', []):
            date_str = d.strftime('%Y-%m-%d')
            if date_str in calendar_map:
                calendar_map[date_str]['tier2_deals'].append(deal)
    
    # Determine dominance for each date
    for date_str, day_data in calendar_map.items():
        if day_data['tier1_deals']:
            # Tier 1 dominates
            day_data['dominant'] = day_data['tier1_deals'][0]
            day_data['dominant']['tier'] = 1
        elif day_data['tier2_deals']:
            # Tier 2 fills in
            day_data['dominant'] = day_data['tier2_deals'][0]
            day_data['dominant']['tier'] = 2
    
    return calendar_map


def detect_split_requirements(weekly_deals: List[Dict], tier1_deals: List[Dict], target_month: int, target_year: int) -> Tuple[List[Dict], List[Dict]]:
    """
    Identify Weekly deals that conflict with Tier 1 deals and require splitting.
    Returns: (splits_required, no_conflict)
    """
    from datetime import date
    import calendar
    
    splits_required = []
    no_conflict = []
    
    # Build Tier 1 date map: {(brand_lower, date): deal_info}
    tier1_date_map = {}
    for deal in tier1_deals:
        brand_lower = deal.get('brand', '').lower()
        for d in deal.get('expanded_dates', []):
            key = (brand_lower, d)
            if key not in tier1_date_map:
                tier1_date_map[key] = []
            tier1_date_map[key].append(deal)
    
    # Check each Weekly deal for conflicts
    for weekly in weekly_deals:
        brand_lower = weekly.get('brand', '').lower()
        weekly_dates = weekly.get('expanded_dates', [])
        
        conflict_dates = []
        interrupting_deals = []
        
        for d in weekly_dates:
            key = (brand_lower, d)
            if key in tier1_date_map:
                conflict_dates.append(d)
                interrupting_deals.extend(tier1_date_map[key])
        
        if conflict_dates:
            # v94: Location-aware conflict detection
            has_conflict, conflict_stores, non_conflict_stores, conflict_type = calculate_location_conflict(
                weekly.get('locations', ''),
                interrupting_deals[0].get('locations', '') if interrupting_deals else ''
            )
            
            # If no actual location overlap, skip this (shouldn't happen but safety check)
            if not has_conflict or conflict_type == 'NONE':
                no_conflict.append({
                    'brand': weekly.get('brand'),
                    'weekday': weekly.get('weekday'),
                    'section': 'Weekly',
                    'discount': weekly.get('discount'),
                    'vendor_contrib': weekly.get('vendor_contrib'),
                    'locations': weekly.get('locations'),
                    'google_row': weekly.get('google_row'),
                    'mis_id': weekly.get('mis_id'),
                    'deal_info': weekly.get('deal_info', ''),
                    'special_notes': weekly.get('special_notes', ''),
                    'categories': weekly.get('categories', '')
                })
                continue
            
            overlap_locations = list(conflict_stores)
            
            # Generate split plan with location awareness
            conflict_dates_sorted = sorted(set(conflict_dates))
            plan = generate_split_plan(weekly, conflict_dates_sorted, target_month, target_year, conflict_type, non_conflict_stores)
            
            # Attribute comparison
            attr_comparison = {
                'weekly': {
                    'discount': weekly.get('discount'),
                    'vendor_contrib': weekly.get('vendor_contrib'),
                    'locations': weekly.get('locations')
                },
                'tier1': {
                    'discount': interrupting_deals[0].get('discount') if interrupting_deals else None,
                    'vendor_contrib': interrupting_deals[0].get('vendor_contrib') if interrupting_deals else None,
                    'locations': interrupting_deals[0].get('locations') if interrupting_deals else None
                }
            }
            
            splits_required.append({
                'brand': weekly.get('brand'),
                'weekday': weekly.get('weekday'),
                'section': 'weekly',  # v10.8: Section being split (weekly, monthly, sale)
                'original_mis_id': weekly.get('mis_id'),
                # v10.8: Parse MIS ID cell with section-based format (W1, W2, WP, etc.)
                'parsed_mis_ids': parse_mis_id_cell(weekly.get('mis_id', '')),
                # v88: Additional fields for enhanced display
                'discount': weekly.get('discount'),
                'vendor_contrib': weekly.get('vendor_contrib'),
                'locations': weekly.get('locations'),
                'google_row': weekly.get('google_row'),
                'deal_info': weekly.get('deal_info', ''),
                'special_notes': weekly.get('special_notes', ''),
                'categories': weekly.get('categories', ''),
                'conflict_type': conflict_type,
                'conflict_dates': [d.strftime('%m/%d') for d in conflict_dates_sorted],
                'interrupting_deal_type': interrupting_deals[0].get('section', 'monthly').lower() if interrupting_deals else 'monthly',
                'interrupting_deal': {
                    'brand': interrupting_deals[0].get('brand') if interrupting_deals else '',
                    'discount': interrupting_deals[0].get('discount') if interrupting_deals else '',
                    'vendor_contrib': interrupting_deals[0].get('vendor_contrib') if interrupting_deals else '',
                    'locations': format_location_set(conflict_stores) if conflict_stores else (interrupting_deals[0].get('locations') if interrupting_deals else ''),  # v94: Only conflicting stores
                    'google_row': interrupting_deals[0].get('google_row') if interrupting_deals else None,
                    'mis_id': interrupting_deals[0].get('mis_id') if interrupting_deals else '',
                    'deal_info': interrupting_deals[0].get('deal_info') if interrupting_deals else '',
                    'special_notes': interrupting_deals[0].get('special_notes') if interrupting_deals else '',
                    'categories': interrupting_deals[0].get('categories') if interrupting_deals else ''
                },
                'overlap_locations': overlap_locations,
                'plan': plan,
                'attribute_comparison': attr_comparison
            })
        else:
            no_conflict.append({
                'brand': weekly.get('brand'),
                'weekday': weekly.get('weekday'),
                'section': 'Weekly',
                # v88: Additional fields for enhanced display
                'discount': weekly.get('discount'),
                'vendor_contrib': weekly.get('vendor_contrib'),
                'locations': weekly.get('locations'),
                'google_row': weekly.get('google_row'),
                'mis_id': weekly.get('mis_id'),
                'deal_info': weekly.get('deal_info', ''),
                'special_notes': weekly.get('special_notes', ''),
                'categories': weekly.get('categories', '')
            })
    
    return splits_required, no_conflict


def generate_split_plan(weekly: Dict, conflict_dates: List, target_month: int, target_year: int, conflict_type: str = 'FULL', non_conflict_stores: set = None) -> List[Dict]:
    """
    Generate the MIS entry plan for splitting a Weekly deal around conflict dates.
    v94: Now includes PATCH entries for partial location conflicts.
    """
    import calendar
    from datetime import date, timedelta
    
    plan = []
    weekly_dates = sorted(weekly.get('expanded_dates', []))
    
    if not weekly_dates or not conflict_dates:
        return plan
    
    # Find continuous segments before, during, and after conflicts
    conflict_set = set(conflict_dates)
    
    # Part 1: Dates before first conflict
    part1_dates = [d for d in weekly_dates if d < min(conflict_dates)]
    if part1_dates:
        plan.append({
            'action': 'CREATE_PART1',
            'dates': f"{part1_dates[0].strftime('%m/%d')} - {part1_dates[-1].strftime('%m/%d')}",
            'notes': f"End date: {(min(conflict_dates) - timedelta(days=1)).strftime('%m/%d')}"
        })
    
    # GAP: The conflict dates (Tier 1 deal runs here)
    plan.append({
        'action': 'GAP',
        'dates': ', '.join([d.strftime('%m/%d') for d in sorted(conflict_dates)]),
        'notes': 'Tier 1 deal active - Weekly pauses at conflicting locations'
    })
    
    # PATCH: If partial conflict, Weekly continues at non-conflicting locations
    if conflict_type == 'PARTIAL' and non_conflict_stores:
        patch_locations = format_location_set(non_conflict_stores, weekly.get('locations', ''))
        plan.append({
            'action': 'PATCH',
            'dates': ', '.join([d.strftime('%m/%d') for d in sorted(conflict_dates)]),
            'notes': f"Weekly continues at: {patch_locations}",
            'locations': patch_locations,
            'discount': weekly.get('discount'),
            'vendor_contrib': weekly.get('vendor_contrib')
        })
    
    # Part 2: Dates after last conflict
    part2_dates = [d for d in weekly_dates if d > max(conflict_dates)]
    if part2_dates:
        plan.append({
            'action': 'CREATE_PART2',
            'dates': f"{part2_dates[0].strftime('%m/%d')} - {part2_dates[-1].strftime('%m/%d')}",
            'notes': f"Start date: {(max(conflict_dates) + timedelta(days=1)).strftime('%m/%d')} (New MIS ID required)"
        })
    
    return plan


@app.route('/api/mis/split-audit/planning', methods=['POST'])
def api_split_audit_planning():
    """
    Phase 1: Planning - Analyze Google Sheet for split requirements.
    Returns a To-Do list of MIS entries needed.
    """
    try:
        data = request.get_json() or {}
        tab_name = data.get('tab', '')
        
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab specified.'})
        
        # Parse month/year context
        target_month, target_year = parse_tab_month_year(tab_name)
        print(f"[SPLIT AUDIT] Planning for {tab_name} -> {target_month}/{target_year}")
        
        # Fetch Google Sheet data
        sections_data = fetch_google_sheet_data(tab_name)
        
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found in sheet.'})
        
        # Process Weekly deals (Tier 2)
        weekly_deals = []
        weekly_df = sections_data.get('weekly', pd.DataFrame())
        
        if not weekly_df.empty:
            multi_day_groups, row_to_group = detect_multi_day_groups(weekly_df, 'weekly')
            processed_groups = set()
            
            for idx, row in weekly_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand:
                    continue
                
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                group_id = row_to_group.get(true_row)
                
                weekday_raw = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '-')).strip()
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                mis_id = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)
                
                # Expand dates
                if group_id and group_id in multi_day_groups:
                    if group_id in processed_groups:
                        continue
                    processed_groups.add(group_id)
                    expanded_dates = get_all_weekdays_for_multiday_group(
                        multi_day_groups[group_id], weekly_df, 'weekly', target_month, target_year
                    )
                    weekday_raw = ', '.join(multi_day_groups[group_id].get('weekdays', []))
                else:
                    expanded_dates = expand_weekday_to_dates(weekday_raw, target_month, target_year)
                
                # v88: Get additional fields for enhanced display
                deal_info = str(get_col(row, ['Deal info', 'Deal Info', 'Deal'], '')).strip()
                special_notes = str(get_col(row, ['Special Notes', 'Notes'], '')).strip()
                categories = str(get_col(row, ['Category', 'Categories'], '')).strip()
                
                weekly_deals.append({
                    'brand': brand,
                    'weekday': weekday_raw,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'mis_id': mis_id,
                    'expanded_dates': expanded_dates,
                    'section': 'weekly',
                    # v88: Additional fields
                    'google_row': true_row,
                    'deal_info': deal_info,
                    'special_notes': special_notes,
                    'categories': categories
                })
        
        # Process Tier 1 deals (Monthly + Sale)
        tier1_deals = []
        
        for section_key in ['monthly', 'sale']:
            section_df = sections_data.get(section_key, pd.DataFrame())
            if section_df.empty:
                continue
            
            for idx, row in section_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand:
                    continue
                
                # v88: Get google_row for interrupting deal Row button
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                
                date_raw = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '-')).strip()
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)
                
                # Expand dates based on section type
                if section_key == 'monthly':
                    expanded_dates = parse_monthly_dates(date_raw, target_month, target_year)
                else:  # sale
                    expanded_dates = parse_sale_dates(date_raw, target_month, target_year)
                
                mis_id = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                deal_info = str(get_col(row, ['Deal info', 'Deal Info', 'Deal'], '')).strip()
                special_notes = str(get_col(row, ['Special Notes', 'Notes'], '')).strip()
                categories = str(get_col(row, ['Category', 'Categories'], '')).strip()
                
                tier1_deals.append({
                    'brand': brand,
                    'date_raw': date_raw,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'mis_id': mis_id,
                    'expanded_dates': expanded_dates,
                    'section': section_key,
                    'google_row': true_row,
                    'deal_info': deal_info,
                    'special_notes': special_notes,
                    'categories': categories
                })
        
        # Detect split requirements
        splits_required, no_conflict = detect_split_requirements(
            weekly_deals, tier1_deals, target_month, target_year
        )
        
        return jsonify({
            'success': True,
            'splits_required': splits_required,
            'no_conflict': no_conflict,
            'summary': {
                'weekly_count': len(weekly_deals),
                'monthly_count': len([d for d in tier1_deals if d['section'] == 'monthly']),
                'sale_count': len([d for d in tier1_deals if d['section'] == 'sale'])
            },
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}"
        })
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500
def check_mis_weekday_active(target_date: date, mis_weekday_str: str) -> bool:
    """
    Checks if a specific date's day-of-week is present in the MIS Weekday column.
    Example: target_date=Dec 25 (Thursday). mis_str="Mon, Wed, Fri". Returns False.
    """
    if not mis_weekday_str or str(mis_weekday_str).lower() in ['nan', 'none', '', '-']:
        return False # No weekdays listed = Not active? Or assume all? Usually specific.
        
    # Get day name from date (e.g., 'Thursday')
    target_day_full = target_date.strftime('%A').lower() # thursday
    target_day_abbr = target_date.strftime('%a').lower() # thu
    
    # MIS formats usually: "Monday", "Mon", "Mon, Wed", "Monday, Wednesday"
    mis_clean = str(mis_weekday_str).lower()
    
    # Simple check: is 'thu' or 'thursday' in the string?
    # We map standard days to ensure we don't partial match 'mon' inside 'month' (unlikely but safe)
    day_map = {
        'monday': ['mon', 'monday'],
        'tuesday': ['tue', 'tues', 'tuesday'],
        'wednesday': ['wed', 'wednesday'],
        'thursday': ['thu', 'thur', 'thurs', 'thursday'],
        'friday': ['fri', 'friday'],
        'saturday': ['sat', 'saturday'],
        'sunday': ['sun', 'sunday']
    }
    
    valid_tokens = day_map.get(target_day_full, [])
    
    for token in valid_tokens:
        if token in mis_clean:
            return True
            
    return False

@app.route('/api/mis/split-audit/gap-check', methods=['POST'])
def api_split_audit_gap_check():
    """
    Phase 2: Gap Check - Verifies that MIS CSV has gaps on conflict dates.
    Input: Google Sheet (Plan) + MIS CSV (Actual).
    """
    try:
        # 1. LOAD INPUTS
        tab_name = request.form.get('tab')
        if not tab_name: return jsonify({'success': False, 'error': 'No tab specified.'})

        mis_df = None
        if request.files.get('csv'):
            mis_df = pd.read_csv(request.files['csv'])
        elif request.form.get('local_csv_path'):
            path = request.form.get('local_csv_path')
            if os.path.exists(path):
                mis_df = pd.read_csv(path)
        
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'MIS CSV data missing.'})

        # 2. GENERATE PLAN (Re-run Phase 1 Logic)
        target_month, target_year = parse_tab_month_year(tab_name)
        sections_data = fetch_google_sheet_data(tab_name)
        
        # Prepare Tier 1 Deals
        tier1_deals = []
        for sec in ['sale', 'monthly']:
            df = sections_data.get(sec, pd.DataFrame())
            if not df.empty:
                for idx, row in df.iterrows():
                    brand = str(row.get('Brand', '')).strip()
                    if not brand: continue
                    if sec == 'sale':
                        d_str = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                        dates = parse_sale_dates(d_str, target_month, target_year)
                    else:
                        d_str = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                        dates = parse_monthly_dates(d_str, target_month, target_year)
                    if dates:
                        tier1_deals.append({'brand': brand, 'section': sec, 'expanded_dates': dates, 'locations': format_location_display(*resolve_location_columns(row))})

        # Prepare Weekly Deals
        weekly_deals = []
        weekly_df = sections_data.get('weekly', pd.DataFrame())
        if not weekly_df.empty:
            multi_day_groups, row_to_group = detect_multi_day_groups(weekly_df, 'weekly')
            processed_groups = set()
            for idx, row in weekly_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand: continue
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                group_id = row_to_group.get(true_row)
                
                if group_id and group_id in multi_day_groups:
                    if group_id in processed_groups: continue
                    processed_groups.add(group_id)
                    dates = get_all_weekdays_for_multiday_group(multi_day_groups[group_id], weekly_df, 'weekly', target_month, target_year)
                    wk_str = ', '.join(multi_day_groups[group_id].get('weekdays', []))
                else:
                    wk_str = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                    dates = expand_weekday_to_dates(wk_str, target_month, target_year)
                
                if dates:
                    weekly_deals.append({
                        'brand': brand, 'weekday': wk_str, 'expanded_dates': dates,
                        'locations': format_location_display(*resolve_location_columns(row)),
                        'mis_id': str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                    })

        # 3. IDENTIFY REQUIRED GAPS
        splits_required, _ = detect_split_requirements(weekly_deals, tier1_deals, target_month, target_year)
        
        missing_gaps = []
        verified_gaps = []

        # 4. CHECK MIS DATA
        mis_df['Start_DT'] = pd.to_datetime(mis_df['Start date'], errors='coerce')
        mis_df['End_DT'] = pd.to_datetime(mis_df['End date'], errors='coerce')

        for req in splits_required:
            brand = req['brand']
            conflict_dates_str = req['conflict_dates'] 
            
            # Fuzzy match Brand
            relevant_mis = mis_df[mis_df['Brand'].astype(str).apply(lambda x: fuzz.token_set_ratio(x.lower(), brand.lower()) > 85)]
            
            if relevant_mis.empty: continue 
            
            for d_str in conflict_dates_str:
                try:
                    parts = d_str.split('/')
                    check_date = datetime(target_year, int(parts[0]), int(parts[1]))
                    # Convert to pandas Timestamp for date comparison
                    ts_check_date = pd.Timestamp(check_date)
                    
                    # --- NEW LOGIC: Check Date Range AND Weekday Column ---
                    active_on_conflict = relevant_mis[
                        (relevant_mis['Start_DT'] <= ts_check_date) & 
                        (relevant_mis['End_DT'] >= ts_check_date)
                    ]
                    
                    # Filter further: Is the deal actually running on this specific weekday?
                    actually_active = []
                    for _, m_row in active_on_conflict.iterrows():
                        mis_weekdays = str(m_row.get('Weekday', ''))
                        # Only count as active if the Weekday column confirms it
                        if check_mis_weekday_active(check_date, mis_weekdays):
                            actually_active.append(m_row)
                    
                    if len(actually_active) > 0:
                        # FAILURE: Deal is running on a conflict date!
                        row = actually_active[0]
                        missing_gaps.append({
                            'brand': brand,
                            'weekday': req['weekday'],
                            'mis_id': str(row.get('ID', 'Unknown')),
                            'mis_end_date': str(row.get('End date', '')),
                            'expected_gap_dates': [d_str] 
                        })
                    else:
                        # SUCCESS: No deal found active on this date + weekday
                        verified_gaps.append({'brand': brand, 'gap_date': d_str})

                except Exception as e:
                    print(f"Gap check error for {brand} on {d_str}: {e}")
                    continue

        return jsonify({
            'success': True,
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}",
            'summary': {'weekly_checked': len(weekly_deals), 'tier1_conflicts': len(splits_required)},
            'missing_gaps': missing_gaps,
            'verified_gaps': verified_gaps
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/mis/split-audit/final', methods=['POST'])
def api_split_audit_final():
    """
    Phase 3: Final Audit - Ensures exactly 1 dominant deal exists on conflict dates.
    Input: MIS CSV only (but uses Sheet to find conflict dates).
    """
    try:
        # 1. LOAD INPUTS
        tab_name = request.form.get('tab')
        if not tab_name: return jsonify({'success': False, 'error': 'No tab specified.'})

        mis_df = None
        if request.files.get('csv'):
            mis_df = pd.read_csv(request.files['csv'])
        elif request.form.get('local_csv_path'):
            path = request.form.get('local_csv_path')
            if os.path.exists(path):
                mis_df = pd.read_csv(path)
        
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'MIS CSV data missing.'})

        # 2. IDENTIFY ALL CONFLICT DATES (From Sheet)
        target_month, target_year = parse_tab_month_year(tab_name)
        sections_data = fetch_google_sheet_data(tab_name)
        
        tier1_map = {} # {date_obj: [deal_info]}
        for sec in ['sale', 'monthly']:
            df = sections_data.get(sec, pd.DataFrame())
            if df.empty: continue
            for _, row in df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand: continue
                if sec == 'sale':
                    d_str = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                    dates = parse_sale_dates(d_str, target_month, target_year)
                else:
                    d_str = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '')).strip()
                    dates = parse_monthly_dates(d_str, target_month, target_year)
                for d in dates:
                    if d not in tier1_map: tier1_map[d] = []
                    tier1_map[d].append({'brand': brand, 'type': sec})

        # 3. VALIDATE MIS CSV
        mis_df['Start_DT'] = pd.to_datetime(mis_df['Start date'], errors='coerce')
        mis_df['End_DT'] = pd.to_datetime(mis_df['End date'], errors='coerce')
        
        double_dips = []
        empty_gaps = []
        valid_dates = []
        
        processed_dates = sorted(tier1_map.keys())
        
        for check_date in processed_dates:
            expected_deals = tier1_map[check_date]
            ts_check_date = pd.Timestamp(check_date) # Conversion for comparison

            for expected in expected_deals:
                brand = expected['brand']
                
                # Broad Filter: Brand + Date Range
                potential_deals = mis_df[
                    (mis_df['Brand'].astype(str).apply(lambda x: fuzz.token_set_ratio(x.lower(), brand.lower()) > 85)) &
                    (mis_df['Start_DT'] <= ts_check_date) &
                    (mis_df['End_DT'] >= ts_check_date)
                ]
                
                # Strict Filter: Check Weekday Column
                active_deals = []
                for _, row in potential_deals.iterrows():
                    mis_weekdays = str(row.get('Weekday', ''))
                    # NEW: Verify this specific date matches the weekday string
                    if check_mis_weekday_active(check_date, mis_weekdays):
                        active_deals.append(row)
                
                date_str = check_date.strftime('%Y-%m-%d')
                
                if len(active_deals) == 0:
                    empty_gaps.append({
                        'date': date_str, 'brand': brand, 
                        'expected_source': expected['type'].title()
                    })
                elif len(active_deals) > 1:
                    # DOUBLE DIP!
                    deals_info = []
                    for row in active_deals:
                        deals_info.append({
                            'mis_id': str(row.get('ID', '')),
                            'deal_type': 'Active Deal',
                            'discount': str(row.get('Daily Deal Discount', ''))
                        })
                    double_dips.append({'date': date_str, 'brand': brand, 'deals': deals_info})
                else:
                    # Perfect
                    row = active_deals[0]
                    valid_dates.append({
                        'date': date_str, 'brand': brand,
                        'active_deal_type': expected['type'].title(),
                        'mis_id': str(row.get('ID', ''))
                    })

        return jsonify({
            'success': True,
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}",
            'summary': {'conflict_dates_checked': len(processed_dates)},
            'double_dips': double_dips, 'empty_gaps': empty_gaps, 'valid_dates': valid_dates
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500

# END SPLIT AUDIT API ROUTES (Phase 1 & Legacy Gap Check)

# ============================================================================
# PHASE 2: FINAL VERIFICATION - Helper Functions
# ============================================================================

def parse_mis_id_cell(cell_value: str, section: str = None) -> Dict[str, any]:
    """
    Parse a Google Sheet MIS ID cell that may contain tagged IDs.
    
    v10.8.1: Uses regex for robust parsing regardless of line break format.
    
    v10.8 NEW FORMAT (newline-separated with section-based tags):
        W1: 12345     (Weekly Original)
        WP: 67890     (Weekly Patch)
        W2: 54321     (Weekly Continuation)
        M1: 99999     (Monthly Original)
        MP: 88888     (Monthly Patch)
        M2: 77777     (Monthly Continuation)
        S1: 66666     (Sale Original)
        SP: 55555     (Sale Patch)
        S2: 44444     (Sale Continuation)
    
    Tag format: {Section Letter}{Number or P}: {MIS ID}
        W = Weekly, M = Monthly, S = Sale
        1, 2, 3... = Parts (Original, Continuation 1, Continuation 2...)
        P = Patch
    
    Args:
        cell_value: The MIS ID cell content
        section: Optional - 'weekly', 'monthly', or 'sale' to filter results
    
    Returns dict with:
        'weekly': {'parts': [W1, W2, ...], 'patch': WP or None}
        'monthly': {'parts': [M1, M2, ...], 'patch': MP or None}
        'sale': {'parts': [S1, S2, ...], 'patch': SP or None}
        'parts': All parts combined (for backward compat)
        'patches': All patches combined (for backward compat)
        'raw': Original cell value
        'is_tagged': True if new tagged format detected
    """
    import re
    
    result = {
        'weekly': {'parts': [], 'patch': None},
        'monthly': {'parts': [], 'patch': None},
        'sale': {'parts': [], 'patch': None},
        'parts': [],      # Combined parts for backward compat
        'patches': [],    # Combined patches for backward compat
        'gaps': [],       # Legacy GAP support
        'raw': str(cell_value).strip() if cell_value else '',
        'is_tagged': False,
        'all_tagged': []  # v12.1: All (tag, id) pairs in order, including duplicates for multi-brand
    }
    
    if not cell_value or str(cell_value).strip() in ['', 'nan', 'None', '-']:
        print(f"[PARSE] Empty or invalid cell value: '{cell_value}'")
        return result
    
    raw = str(cell_value).strip()
    print(f"[PARSE] Raw input: '{raw}'")
    
    # v12.1: Universal pattern to capture ALL tagged IDs in order (for multi-brand support)
    # This captures W1, W2, WP, M1, M2, MP, S1, S2, SP and the ID
    universal_pattern = r'([WwMmSs])([1-9Pp])\s*:\s*(\d+)'
    for match in re.finditer(universal_pattern, raw):
        section_letter = match.group(1).upper()
        part_indicator = match.group(2).upper()
        mis_id = match.group(3)
        tag = f"{section_letter}{part_indicator}"
        result['all_tagged'].append((tag, mis_id))
    
    # v10.8.1: Use regex to find all tagged IDs regardless of separator format
    # Pattern matches: W1: 12345, W2: 67890, WP: 99999, M1: 11111, etc.
    # Works with newlines, literal \n, commas, or any separator
    
    # Weekly parts (W1, W2, W3, etc.)
    weekly_parts_pattern = r'[Ww](\d+)\s*:\s*(\d+)'
    for match in re.finditer(weekly_parts_pattern, raw):
        part_num = int(match.group(1))
        mis_id = match.group(2)
        print(f"[PARSE] Found W{part_num}: {mis_id}")
        # Ensure parts list is long enough and insert at correct position
        while len(result['weekly']['parts']) < part_num:
            result['weekly']['parts'].append(None)
        result['weekly']['parts'][part_num - 1] = mis_id
        if mis_id not in result['parts']:
            result['parts'].append(mis_id)
        result['is_tagged'] = True
    
    # Weekly patch (WP)
    weekly_patch_pattern = r'[Ww][Pp]\s*:\s*(\d+)'
    match = re.search(weekly_patch_pattern, raw)
    if match:
        mis_id = match.group(1)
        print(f"[PARSE] Found WP: {mis_id}")
        result['weekly']['patch'] = mis_id
        result['patches'].append(mis_id)
        result['is_tagged'] = True
    
    # Monthly parts (M1, M2, M3, etc.)
    monthly_parts_pattern = r'[Mm](\d+)\s*:\s*(\d+)'
    for match in re.finditer(monthly_parts_pattern, raw):
        part_num = int(match.group(1))
        mis_id = match.group(2)
        print(f"[PARSE] Found M{part_num}: {mis_id}")
        while len(result['monthly']['parts']) < part_num:
            result['monthly']['parts'].append(None)
        result['monthly']['parts'][part_num - 1] = mis_id
        if mis_id not in result['parts']:
            result['parts'].append(mis_id)
        result['is_tagged'] = True
    
    # Monthly patch (MP)
    monthly_patch_pattern = r'[Mm][Pp]\s*:\s*(\d+)'
    match = re.search(monthly_patch_pattern, raw)
    if match:
        mis_id = match.group(1)
        print(f"[PARSE] Found MP: {mis_id}")
        result['monthly']['patch'] = mis_id
        result['patches'].append(mis_id)
        result['is_tagged'] = True
    
    # Sale parts (S1, S2, S3, etc.)
    sale_parts_pattern = r'[Ss](\d+)\s*:\s*(\d+)'
    for match in re.finditer(sale_parts_pattern, raw):
        part_num = int(match.group(1))
        mis_id = match.group(2)
        print(f"[PARSE] Found S{part_num}: {mis_id}")
        while len(result['sale']['parts']) < part_num:
            result['sale']['parts'].append(None)
        result['sale']['parts'][part_num - 1] = mis_id
        if mis_id not in result['parts']:
            result['parts'].append(mis_id)
        result['is_tagged'] = True
    
    # Sale patch (SP)
    sale_patch_pattern = r'[Ss][Pp]\s*:\s*(\d+)'
    match = re.search(sale_patch_pattern, raw)
    if match:
        mis_id = match.group(1)
        print(f"[PARSE] Found SP: {mis_id}")
        result['sale']['patch'] = mis_id
        result['patches'].append(mis_id)
        result['is_tagged'] = True
    
    # LEGACY: Part 1, Part 2, etc.
    legacy_part_pattern = r'[Pp]art\s*(\d+)\s*:\s*(\d+)'
    for match in re.finditer(legacy_part_pattern, raw):
        part_num = int(match.group(1))
        mis_id = match.group(2)
        print(f"[PARSE] Found legacy Part {part_num}: {mis_id}")
        while len(result['weekly']['parts']) < part_num:
            result['weekly']['parts'].append(None)
        if result['weekly']['parts'][part_num - 1] is None:
            result['weekly']['parts'][part_num - 1] = mis_id
        if mis_id not in result['parts']:
            result['parts'].append(mis_id)
        result['is_tagged'] = True
    
    # LEGACY: GAP
    gap_pattern = r'[Gg][Aa][Pp]\s*:\s*(\d+)'
    for match in re.finditer(gap_pattern, raw):
        mis_id = match.group(1)
        print(f"[PARSE] Found legacy GAP: {mis_id}")
        result['gaps'].append(mis_id)
        result['is_tagged'] = True
    
    # LEGACY: Patch (without section prefix)
    legacy_patch_pattern = r'[Pp]atch\s*:\s*(\d+)'
    match = re.search(legacy_patch_pattern, raw)
    if match:
        mis_id = match.group(1)
        print(f"[PARSE] Found legacy Patch: {mis_id}")
        if result['weekly']['patch'] is None:
            result['weekly']['patch'] = mis_id
        if mis_id not in result['patches']:
            result['patches'].append(mis_id)
        result['is_tagged'] = True
    
    # If no tags found, try plain number (untagged single ID)
    if not result['is_tagged']:
        # Check for plain numeric ID
        plain_id_pattern = r'^(\d{5,7})$'
        match = re.match(plain_id_pattern, raw)
        if match:
            mis_id = match.group(1)
            print(f"[PARSE] Found plain ID: {mis_id}")
            result['weekly']['parts'].append(mis_id)
            result['parts'].append(mis_id)
    
    # Remove None values from parts lists
    result['weekly']['parts'] = [p for p in result['weekly']['parts'] if p is not None]
    result['monthly']['parts'] = [p for p in result['monthly']['parts'] if p is not None]
    result['sale']['parts'] = [p for p in result['sale']['parts'] if p is not None]
    
    # Add part1 for backward compatibility
    result['part1'] = result['parts'][0] if result['parts'] else None
    
    print(f"[PARSE] Result: weekly={result['weekly']}, monthly={result['monthly']}, sale={result['sale']}")
    
    return result


# ============================================================================
# MULTI-BRAND SUPPORT FUNCTIONS (v12.1)
# ============================================================================

def parse_multi_brand(brand_str: str) -> List[str]:
    """
    Parse a brand string that may contain multiple brands.
    
    v12.1: Multi-brand support - handles comma-separated brands from dropdown multi-select.
    v12.2: Preserve brands that legitimately contain "&" (Papa & Barkley, Hash & Flowers)
    
    Examples:
        "Stiiizy" -> ["Stiiizy"]
        "Stiiizy, Shryne" -> ["Stiiizy", "Shryne"]
        "Brand A / Brand B" -> ["Brand A", "Brand B"]
        "Papa & Barkley" -> ["Papa & Barkley"]  # Preserved!
        "Hash & Flowers" -> ["Hash & Flowers"]  # Preserved!
    
    Returns: List of individual brand names
    """
    if not brand_str or str(brand_str).strip() in ['', 'nan', 'None', '-']:
        return []
    
    brand_str = str(brand_str).strip()
    
    # v12.2: Known brands that contain "&" - these should NOT be split
    # Use placeholders to preserve them during normalization
    AMPERSAND_BRANDS = [
        'Papa & Barkley',
        'Hash & Flowers',
    ]
    
    # Replace known ampersand brands with placeholders
    preserved = {}
    for i, ab in enumerate(AMPERSAND_BRANDS):
        placeholder = f"__AMPERSAND_BRAND_{i}__"
        # Case-insensitive replacement
        import re
        pattern = re.compile(re.escape(ab), re.IGNORECASE)
        if pattern.search(brand_str):
            # Get the actual matched text to preserve original case
            match = pattern.search(brand_str)
            preserved[placeholder] = match.group(0)
            brand_str = pattern.sub(placeholder, brand_str)
    
    # Normalize separators: / becomes , (but NOT & anymore since we've preserved known brands)
    # Only treat standalone & as separator if it's surrounded by spaces
    import re
    # Replace " / " with comma
    normalized = re.sub(r'\s*/\s*', ', ', brand_str)
    # Replace " & " with comma ONLY if it's not a preserved placeholder
    # Don't replace & at all now - only commas and slashes are separators
    
    # Split on comma and clean up
    brands = [b.strip() for b in normalized.split(',') if b.strip()]
    
    # Restore preserved brands
    result = []
    for b in brands:
        for placeholder, original in preserved.items():
            b = b.replace(placeholder, original)
        result.append(b)
    
    return result


def is_multi_brand(brand_str: str) -> bool:
    """Check if a brand string contains multiple brands."""
    return len(parse_multi_brand(brand_str)) > 1


def get_brand_from_mis_id(mis_id: str, mis_df) -> Optional[str]:
    """
    Look up a MIS ID in the CSV and return the brand name.
    Used to determine which brand a MIS ID belongs to in multi-brand deals.
    """
    if not mis_id or mis_df is None or mis_df.empty:
        return None
    
    mis_id = str(mis_id).strip()
    if mis_id.endswith('.0'):
        mis_id = mis_id[:-2]
    
    # Find ID column
    id_col = None
    for col in ['ID', 'id', 'MIS ID', 'Mis Id']:
        if col in mis_df.columns:
            id_col = col
            break
    
    if not id_col:
        return None
    
    # Search for the ID
    matches = mis_df[mis_df[id_col].astype(str).str.strip() == mis_id]
    
    if matches.empty:
        return None
    
    return str(matches.iloc[0].get('Brand', '')).strip()


def match_mis_ids_to_brands(mis_id_cell: str, brands: List[str], mis_df) -> Dict[str, List]:
    """
    Given a MIS ID cell with multiple IDs and a list of brands,
    match each MIS ID to its corresponding brand by looking up in CSV.
    
    v12.2: Uses strict matching to avoid confusing similar brands
           (e.g., "Stiiizy" vs "Stiiizy Accessories")
    
    Args:
        mis_id_cell: The MIS ID cell content (e.g., "W1: 12345\\nW1: 67890\\nW2: 11111\\nW2: 22222")
        brands: List of brand names (e.g., ["Stiiizy", "Stiiizy Accessories"])
        mis_df: The MIS CSV DataFrame
    
    Returns:
        Dict mapping brand name to list of (tag, id) tuples
        e.g., {"Stiiizy": [("W1", "919")], 
               "Stiiizy Accessories": [("W1", "920")]}
    """
    parsed = parse_mis_id_cell(mis_id_cell)
    all_tagged = parsed.get('all_tagged', [])
    
    result = {brand: [] for brand in brands}
    unmatched = []
    
    for tag, mis_id in all_tagged:
        csv_brand = get_brand_from_mis_id(mis_id, mis_df)
        
        if csv_brand:
            csv_brand_lower = csv_brand.lower().strip()
            matched = False
            
            # v12.2: STRICT MATCHING - prioritize exact matches first
            # This prevents "Stiiizy" from matching "Stiiizy Accessories"
            
            # Pass 1: Exact match (case-insensitive)
            for brand in brands:
                if csv_brand_lower == brand.lower().strip():
                    result[brand].append((tag, mis_id))
                    matched = True
                    break
            
            # Pass 2: If no exact match, check for partial containment carefully
            # Only match if csv_brand contains the sheet brand AND they're "close enough"
            # But NOT if one is a substring of the other with extra words
            if not matched:
                for brand in brands:
                    brand_lower = brand.lower().strip()
                    
                    # Skip if one contains the other but they're not equal
                    # This prevents "Stiiizy" matching "Stiiizy Accessories"
                    if brand_lower in csv_brand_lower and brand_lower != csv_brand_lower:
                        continue
                    if csv_brand_lower in brand_lower and brand_lower != csv_brand_lower:
                        continue
                    
                    # Fuzzy match only for completely different spellings
                    # (e.g., typos, slight variations)
                    ratio = fuzz.token_set_ratio(csv_brand_lower, brand_lower)
                    if ratio >= 95:  # Very high threshold for non-exact matches
                        result[brand].append((tag, mis_id))
                        matched = True
                        break
            
            if not matched:
                unmatched.append((tag, mis_id, csv_brand))
        else:
            unmatched.append((tag, mis_id, None))
    
    # Add unmatched to a special key
    if unmatched:
        result['_unmatched'] = unmatched
    
    return result


def format_brand_mis_ids(tagged_ids: List[tuple]) -> str:
    """
    Format a list of (tag, id) tuples back into a cell string.
    e.g., [("W1", "12345"), ("W2", "67890")] -> "W1: 12345, W2: 67890"
    """
    if not tagged_ids:
        return ''
    return ', '.join([f"{tag}: {mid}" for tag, mid in tagged_ids])


def format_tagged_mis_cell(section: str, parts: List[str] = None, patch: str = None, 
                           existing_content: str = None) -> str:
    """
    Format MIS IDs into the new tagged newline-separated format.
    
    v10.8: Section-based tags (W1/W2/WP, M1/M2/MP, S1/S2/SP)
    
    Args:
        section: 'weekly', 'monthly', or 'sale'
        parts: List of part IDs [Original, Continuation1, Continuation2, ...]
        patch: Patch ID (if any)
        existing_content: Existing cell content to preserve other section's IDs
    
    Returns formatted string like:
        W1: 12345
        WP: 67890
        W2: 54321
    """
    # Determine section prefix
    section_lower = section.lower() if section else 'weekly'
    if section_lower.startswith('week') or section_lower == 'w':
        prefix = 'W'
    elif section_lower.startswith('month') or section_lower == 'm':
        prefix = 'M'
    elif section_lower.startswith('sale') or section_lower == 's':
        prefix = 'S'
    else:
        prefix = 'W'  # Default to Weekly
    
    # Parse existing content to preserve other sections
    existing = parse_mis_id_cell(existing_content) if existing_content else None
    
    lines = []
    
    # If we have existing content, preserve other sections first
    if existing and existing['raw']:
        raw_lines = existing['raw'].replace('\r\n', '\n').split('\n')
        for line in raw_lines:
            line = line.strip()
            if not line:
                continue
            line_lower = line.lower()
            # Keep lines that don't start with our section prefix
            if line_lower and line_lower[0] != prefix.lower():
                lines.append(line)
    
    # Add parts for this section (W1, W2, W3... or M1, M2, M3... or S1, S2, S3...)
    if parts:
        for i, part_id in enumerate(parts, 1):
            if part_id:
                lines.append(f"{prefix}{i}: {part_id}")
    
    # Add patch for this section (WP, MP, or SP)
    if patch:
        lines.append(f"{prefix}P: {patch}")
    
    return '\n'.join(lines)


def update_tagged_mis_cell(existing_content: str, tag: str, new_id: str, append_mode: bool = False) -> str:
    """
    Update a specific tag in a MIS ID cell, preserving other content.
    
    v10.8: Section-based tags
    tag: 'w1', 'w2', 'wp', 'm1', 'm2', 'mp', 's1', 's2', 'sp'
         (also accepts legacy: 'part1', 'part2', 'gap', 'patch')
    new_id: The MIS ID to set
    append_mode: v12.1 - If True, always append new line even if tag exists (for multi-brand)
    
    If tag already exists and append_mode=False, updates it. Otherwise, appends it.
    """
    if not new_id or not new_id.strip():
        return existing_content
    
    new_id = str(new_id).strip()
    tag_lower = tag.lower().strip()
    
    # Strip any existing tag from the MIS ID (in case it was passed with a tag)
    new_id = strip_mis_id_tag(new_id)
    
    # Parse existing content
    existing_lines = []
    if existing_content:
        existing_lines = [l.strip() for l in existing_content.replace('\r\n', '\n').split('\n') if l.strip()]
    
    # Determine the tag prefix to look for and the line to add
    # v10.8: New format (W1, W2, WP, M1, M2, MP, S1, S2, SP)
    new_line = ''
    tag_prefix = ''
    
    if tag_lower in ['w1', 'weekly1', 'weekly_1']:
        new_line = f"W1: {new_id}"
        tag_prefix = 'w1'
    elif tag_lower in ['w2', 'weekly2', 'weekly_2']:
        new_line = f"W2: {new_id}"
        tag_prefix = 'w2'
    elif tag_lower in ['w3', 'weekly3', 'weekly_3']:
        new_line = f"W3: {new_id}"
        tag_prefix = 'w3'
    elif tag_lower in ['wp', 'weekly_patch', 'weeklypatch']:
        new_line = f"WP: {new_id}"
        tag_prefix = 'wp'
    elif tag_lower in ['m1', 'monthly1', 'monthly_1']:
        new_line = f"M1: {new_id}"
        tag_prefix = 'm1'
    elif tag_lower in ['m2', 'monthly2', 'monthly_2']:
        new_line = f"M2: {new_id}"
        tag_prefix = 'm2'
    elif tag_lower in ['m3', 'monthly3', 'monthly_3']:
        new_line = f"M3: {new_id}"
        tag_prefix = 'm3'
    elif tag_lower in ['mp', 'monthly_patch', 'monthlypatch']:
        new_line = f"MP: {new_id}"
        tag_prefix = 'mp'
    elif tag_lower in ['s1', 'sale1', 'sale_1']:
        new_line = f"S1: {new_id}"
        tag_prefix = 's1'
    elif tag_lower in ['s2', 'sale2', 'sale_2']:
        new_line = f"S2: {new_id}"
        tag_prefix = 's2'
    elif tag_lower in ['s3', 'sale3', 'sale_3']:
        new_line = f"S3: {new_id}"
        tag_prefix = 's3'
    elif tag_lower in ['sp', 'sale_patch', 'salepatch']:
        new_line = f"SP: {new_id}"
        tag_prefix = 'sp'
    # Legacy support
    elif tag_lower in ['part1', 'part_1', 'part 1']:
        new_line = f"W1: {new_id}"
        tag_prefix = 'w1'
    elif tag_lower in ['part2', 'part_2', 'part 2']:
        new_line = f"W2: {new_id}"
        tag_prefix = 'w2'
    elif tag_lower in ['gap']:
        # GAP is deprecated but convert to appropriate section if known
        new_line = f"M1: {new_id}"  # Assume monthly for legacy GAP
        tag_prefix = 'm1'
    elif tag_lower in ['patch']:
        new_line = f"WP: {new_id}"  # Assume weekly patch for legacy
        tag_prefix = 'wp'
    else:
        # Unknown tag - just add as W1
        new_line = f"W1: {new_id}"
        tag_prefix = 'w1'
    
    # Look for existing line with same tag and replace (unless append_mode), or append
    found = False
    result_lines = []
    
    for line in existing_lines:
        line_lower = line.lower()
        # Check if this line has the same tag prefix
        if line_lower.startswith(tag_prefix + ':') or line_lower.startswith(tag_prefix + ' :'):
            if append_mode:
                # v12.1: In append mode, keep existing line AND add new one later
                result_lines.append(line)
            else:
                # Replace mode: replace existing line with new one
                result_lines.append(new_line)
                found = True
        else:
            result_lines.append(line)
    
    if not found or append_mode:
        result_lines.append(new_line)
    
    return '\n'.join(result_lines)


def strip_mis_id_tag(tagged_id: str) -> str:
    """
    Strip any tag prefix from a MIS ID for display or lookup.
    
    v10.8 examples:
    'W1: 12345' -> '12345'
    'WP: 67890' -> '67890'
    'M1: 99999' -> '99999'
    'S2: 88888' -> '88888'
    
    Legacy examples:
    'Part 1: 12345' -> '12345'
    'GAP: 67890' -> '67890'
    '12345' -> '12345'
    """
    if not tagged_id:
        return ''
    
    tagged_id = str(tagged_id).strip()
    
    if ':' in tagged_id:
        return tagged_id.split(':', 1)[1].strip()
    
    return tagged_id


def find_mis_entry_by_id(mis_df: pd.DataFrame, mis_id: str) -> Optional[Dict]:
    """
    Find a deal in the MIS CSV by its ID.
    Returns a dict with deal attributes or None if not found.
    v10.7: More robust ID column detection and debug output
    """
    if not mis_id or mis_df is None or mis_df.empty:
        print(f"[FIND-MIS] Skipping - mis_id={mis_id}, df_empty={mis_df is None or mis_df.empty if mis_df is not None else True}")
        return None
    
    # Clean the ID - strip tags if present
    mis_id = str(mis_id).strip()
    mis_id = strip_mis_id_tag(mis_id)  # Remove "Part 1:", "GAP:", etc.
    
    if not mis_id or not mis_id.isdigit():
        print(f"[FIND-MIS] Invalid MIS ID after cleaning: '{mis_id}'")
        return None
    
    # v10.7: Try multiple possible ID column names
    id_columns = ['ID', 'id', 'MIS ID', 'Mis Id', 'MIS_ID', 'mis_id']
    id_col = None
    
    for col in id_columns:
        if col in mis_df.columns:
            id_col = col
            break
    
    if not id_col:
        print(f"[FIND-MIS] ERROR: No ID column found. Available columns: {list(mis_df.columns)}")
        return None
    
    # Search in the ID column
    matches = mis_df[mis_df[id_col].astype(str).str.strip() == mis_id]
    
    if matches.empty:
        print(f"[FIND-MIS] No match for ID '{mis_id}' in column '{id_col}'")
        return None
    
    row = matches.iloc[0]
    print(f"[FIND-MIS] [OK] Found MIS ID {mis_id}: Brand='{row.get('Brand', 'N/A')}'")
    
    return {
        'mis_id': str(row.get(id_col, '')),
        'brand': str(row.get('Brand', '')).strip(),
        'discount': str(row.get('Daily Deal Discount', '')).strip(),
        'vendor_pct': str(row.get('Discount paid by vendor', '')).strip(),
        'start_date': str(row.get('Start date', '')).strip(),
        'end_date': str(row.get('End date', '')).strip(),
        'locations': str(row.get('Store', '')).strip(),
        'weekday': str(row.get('Weekday', '')).strip(),
        'category': str(row.get('Category', '')).strip()
    }


def compare_deal_attributes(expected: Dict, actual: Dict) -> Tuple[bool, List[str]]:
    """
    Compare expected deal attributes against actual MIS entry.
    Returns: (all_match, list_of_issues)
    """
    issues = []
    
    if not actual:
        return False, ['MIS entry not found']
    
    def normalize_numeric_value(val):
        """
        Normalize numeric values for comparison.
        Handles: '50%' -> 50.0, '50' -> 50.0, 50 -> 50.0, '0.50' -> 0.50
        Also handles: '50% off', '$20', '20.5%', etc.
        """
        if val is None:
            return None
        
        # Convert to string and clean
        val_str = str(val).strip().lower()
        if not val_str or val_str in ['', '-', 'nan', 'none', 'n/a']:
            return None
        
        # Remove common suffixes and prefixes
        val_str = val_str.replace('off', '').replace('discount', '').strip()
        
        # Extract numeric portion: remove %, $, and other non-numeric chars except decimal and minus
        cleaned = ''
        found_decimal = False
        for c in val_str:
            if c.isdigit():
                cleaned += c
            elif c == '.' and not found_decimal:
                cleaned += c
                found_decimal = True
            elif c == '-' and cleaned == '':
                cleaned += c
        
        if not cleaned or cleaned == '-':
            return val_str  # Return original if no numbers found
        
        try:
            num = float(cleaned)
            # Handle decimal percentages (0.50 -> 50 if expected is likely a percentage)
            # Only do this if the number is between 0 and 1 and original had no % sign
            if 0 < num < 1 and '%' not in str(val):
                num = num * 100
            return num
        except:
            return val_str
    
    def values_match(exp_val, act_val, tolerance=0.5):
        """Compare two normalized values with tolerance."""
        if exp_val is None or act_val is None:
            return True  # Skip comparison if either is missing
        
        if isinstance(exp_val, float) and isinstance(act_val, float):
            # Allow tolerance for floating point comparison
            return abs(exp_val - act_val) <= tolerance
        
        # String comparison as fallback
        return str(exp_val).lower() == str(act_val).lower()
    
    # Compare discount
    exp_discount = normalize_numeric_value(expected.get('discount', ''))
    act_discount = normalize_numeric_value(actual.get('discount', ''))
    
    if not values_match(exp_discount, act_discount):
        issues.append(f"Discount: expected '{expected.get('discount')}', got '{actual.get('discount')}'")
    
    # Compare vendor percentage
    exp_vendor = normalize_numeric_value(expected.get('vendor_pct', ''))
    act_vendor = normalize_numeric_value(actual.get('vendor_pct', ''))
    
    if not values_match(exp_vendor, act_vendor):
        issues.append(f"Vendor%: expected '{expected.get('vendor_pct')}', got '{actual.get('vendor_pct')}'")
    
    # Compare dates (if provided in expected)
    if expected.get('start_date'):
        exp_start = expected.get('start_date', '').strip()
        act_start = actual.get('start_date', '').strip()
        if exp_start and act_start and exp_start != act_start:
            issues.append(f"Start date: expected '{exp_start}', got '{act_start}'")
    
    if expected.get('end_date'):
        exp_end = expected.get('end_date', '').strip()
        act_end = actual.get('end_date', '').strip()
        if exp_end and act_end and exp_end != act_end:
            issues.append(f"End date: expected '{exp_end}', got '{act_end}'")
    
    # Compare locations (if provided)
    if expected.get('locations'):
        exp_loc = expected.get('locations', '').strip().lower()
        act_loc = actual.get('locations', '').strip().lower()
        
        # Treat NaN/empty/blank as "All Locations"
        if not act_loc or act_loc in ['nan', 'none', '', '-', 'n/a']:
            act_loc = 'all locations'
        if not exp_loc or exp_loc in ['nan', 'none', '', '-', 'n/a']:
            exp_loc = 'all locations'
        
        # Fuzzy location comparison (they might be formatted differently)
        if exp_loc and act_loc:
            # "All Locations" matches anything or empty
            if exp_loc == 'all locations' or act_loc == 'all locations':
                pass  # No issue - All Locations matches everything
            elif fuzz.token_set_ratio(exp_loc, act_loc) < 80:
                issues.append(f"Locations: expected '{expected.get('locations')}', got '{actual.get('locations')}'")
    
    return len(issues) == 0, issues


def generate_fuzzy_suggestions(expected_deal: Dict, mis_df: pd.DataFrame, max_results: int = 3) -> List[Dict]:
    """
    Find similar deals in MIS CSV when exact MIS ID is missing.
    Scores by: brand (40pts), discount (20pts), vendor% (10pts), dates (20pts), locations (10pts)
    """
    if mis_df is None or mis_df.empty:
        return []
    
    suggestions = []
    exp_brand = str(expected_deal.get('brand', '')).lower()
    exp_discount = str(expected_deal.get('discount', '')).lower()
    exp_vendor = str(expected_deal.get('vendor_pct', '')).lower()
    exp_locations = str(expected_deal.get('locations', '')).lower()
    
    for _, row in mis_df.iterrows():
        score = 0
        
        # Brand match (40 pts max)
        act_brand = str(row.get('Brand', '')).lower()
        brand_score = fuzz.token_set_ratio(exp_brand, act_brand)
        if brand_score >= 85:
            score += 40
        elif brand_score >= 70:
            score += 25
        elif brand_score >= 50:
            score += 10
        
        # Discount match (20 pts max)
        act_discount = str(row.get('Daily Deal Discount', '')).lower()
        if exp_discount and act_discount and exp_discount == act_discount:
            score += 20
        elif exp_discount and act_discount and fuzz.ratio(exp_discount, act_discount) > 80:
            score += 10
        
        # Vendor % match (10 pts max)
        act_vendor = str(row.get('Discount paid by vendor', '')).lower()
        if exp_vendor and act_vendor and exp_vendor == act_vendor:
            score += 10
        
        # Location match (10 pts max)
        act_locations = str(row.get('Store', '')).lower()
        if exp_locations and act_locations:
            loc_score = fuzz.token_set_ratio(exp_locations, act_locations)
            if loc_score >= 80:
                score += 10
            elif loc_score >= 60:
                score += 5
        
        # Only include if score is meaningful
        if score >= 30:
            suggestions.append({
                'mis_id': str(row.get('ID', '')),
                'score': score,
                'brand': str(row.get('Brand', '')),
                'discount': str(row.get('Daily Deal Discount', '')),
                'vendor_pct': str(row.get('Discount paid by vendor', '')),
                'locations': str(row.get('Store', '')),
                'start_date': str(row.get('Start date', '')),
                'end_date': str(row.get('End date', '')),
                'weekday': str(row.get('Weekday', ''))
            })
    
    # Sort by score descending and return top results
    suggestions.sort(key=lambda x: x['score'], reverse=True)
    return suggestions[:max_results]


@app.route('/api/mis/split-audit/final-check', methods=['POST'])
def api_split_audit_final_check():
    """
    Phase 2: Final Verification - Compares expected plan against actual MIS CSV.
    
    1. Regenerates expected plan (same as Phase 1)
    2. Parses MIS IDs from Google Sheet (with prefix handling)
    3. Matches each entry in CSV and verifies attributes
    4. Returns color-coded verification results
    """
    try:
        # 1. LOAD INPUTS
        tab_name = request.form.get('tab')
        if not tab_name:
            return jsonify({'success': False, 'error': 'No tab specified.'})
        
        # Load MIS CSV - check multiple sources in priority order
        mis_df = None
        csv_source = None
        
        # Priority 1: Uploaded file in request
        if request.files.get('csv'):
            mis_df = pd.read_csv(request.files['csv'])
            csv_source = "uploaded file"
        
        # Priority 2: local_csv_path from form data (sent by frontend)
        elif request.form.get('local_csv_path'):
            path = request.form.get('local_csv_path')
            if Path(path).exists():
                mis_df = pd.read_csv(path)
                csv_source = f"local path: {path}"
        
        # Priority 3: Global path stored from previous pull
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            path = GLOBAL_DATA['mis']['mis_csv_filepath']
            if Path(path).exists():
                mis_df = pd.read_csv(path)
                csv_source = f"global CSV: {GLOBAL_DATA['mis'].get('mis_csv_filename')}"
        
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'No MIS CSV available. Please pull or upload a CSV in Setup tab.'})
        
        print(f"[FINAL-CHECK] Using {csv_source}")
        
        # Store for later use
        GLOBAL_DATA['mis']['mis_df'] = mis_df
        
        # 2. REGENERATE EXPECTED PLAN (Same as Phase 1)
        target_month, target_year = parse_tab_month_year(tab_name)
        print(f"[FINAL-CHECK] Verifying {tab_name} -> {target_month}/{target_year}")
        
        sections_data = fetch_google_sheet_data(tab_name)
        
        if all(df.empty for df in sections_data.values()):
            return jsonify({'success': False, 'error': 'No data found in sheet.'})
        
        # Process Weekly deals (Tier 2)
        weekly_deals = []
        weekly_df = sections_data.get('weekly', pd.DataFrame())
        
        if not weekly_df.empty:
            multi_day_groups, row_to_group = detect_multi_day_groups(weekly_df, 'weekly')
            processed_groups = set()
            
            for idx, row in weekly_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand:
                    continue
                
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                group_id = row_to_group.get(true_row)
                
                weekday_raw = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '-')).strip()
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                mis_id_raw = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)
                
                deal_info = str(get_col(row, ['Deal info', 'Deal Info', 'Deal'], '')).strip()
                special_notes = str(get_col(row, ['Special Notes', 'Notes'], '')).strip()
                categories = str(get_col(row, ['Category', 'Categories'], '')).strip()
                
                # Handle multi-day groups
                if group_id and group_id in multi_day_groups:
                    if group_id in processed_groups:
                        continue
                    processed_groups.add(group_id)
                    expanded_dates = get_all_weekdays_for_multiday_group(
                        multi_day_groups[group_id], weekly_df, 'weekly', target_month, target_year
                    )
                    weekday_raw = ', '.join(multi_day_groups[group_id].get('weekdays', []))
                else:
                    expanded_dates = expand_weekday_to_dates(weekday_raw, target_month, target_year)
                
                if expanded_dates:
                    weekly_deals.append({
                        'brand': brand,
                        'weekday': weekday_raw,
                        'discount': discount,
                        'vendor_contrib': vendor_contrib,
                        'locations': locations,
                        'mis_id': mis_id_raw,
                        'expanded_dates': expanded_dates,
                        'google_row': true_row,
                        'deal_info': deal_info,
                        'special_notes': special_notes,
                        'categories': categories
                    })
        
        # Process Tier 1 deals (Sale/Monthly)
        tier1_deals = []
        for section_key in ['sale', 'monthly']:
            section_df = sections_data.get(section_key, pd.DataFrame())
            if section_df.empty:
                continue
            
            for idx, row in section_df.iterrows():
                brand = str(row.get('Brand', '')).strip()
                if not brand:
                    continue
                
                true_row = int(row.get('_SHEET_ROW_NUM', idx + 2))
                date_raw = str(get_col(row, ['Weekday/ Day of Month', 'Day of Week', 'Weekday'], '-')).strip()
                discount = str(get_col(row, ['Deal Discount Value/Type', 'Deal Discount'], '-')).strip()
                vendor_contrib = str(get_col(row, ['Brand Contribution % (Credit)', 'Vendor Contribution'], '-')).strip()
                
                loc_raw, exc_raw = resolve_location_columns(row)
                locations = format_location_display(loc_raw, exc_raw)
                
                mis_id = str(get_col(row, ['MIS ID', 'ID'], '')).strip()
                
                if section_key == 'monthly':
                    expanded_dates = parse_monthly_dates(date_raw, target_month, target_year)
                else:
                    expanded_dates = parse_sale_dates(date_raw, target_month, target_year)
                
                tier1_deals.append({
                    'brand': brand,
                    'date_raw': date_raw,
                    'discount': discount,
                    'vendor_contrib': vendor_contrib,
                    'locations': locations,
                    'mis_id': mis_id,
                    'expanded_dates': expanded_dates,
                    'section': section_key,
                    'google_row': true_row
                })
        
        # 3. DETECT SPLIT REQUIREMENTS (Reuse Phase 1 logic)
        splits_required, no_conflict = detect_split_requirements(
            weekly_deals, tier1_deals, target_month, target_year
        )
        
        # 4. VERIFY EACH SPLIT
        verification_results = []
        summary = {
            'total_splits': len(splits_required),
            'fully_correct': 0,
            'partial_errors': 0,
            'missing_ids': 0,
            'no_conflict_count': len(no_conflict)
        }
        
        for split in splits_required:
            brand = split.get('brand')
            google_row = split.get('google_row')
            mis_id_raw = split.get('original_mis_id', '')
            plan = split.get('plan', [])
            section = split.get('section', 'weekly').lower()  # v10.8: Get section being split
            int_section = split.get('interrupting_deal_type', 'monthly').lower()  # v10.8: Interrupting section
            
            # v10.8: Parse MIS IDs from Google Sheet cell with section awareness
            parsed_ids = parse_mis_id_cell(mis_id_raw)
            section_ids = parsed_ids.get(section, {}) or {'parts': [], 'patch': None}
            
            # v10.8: Debug output with new format
            print(f"[PHASE2] Brand: {brand}, Row: {google_row}, Section: {section}")
            print(f"[PHASE2]   Raw MIS ID cell: '{mis_id_raw}'")
            print(f"[PHASE2]   {section.upper()} IDs: parts={section_ids.get('parts', [])}, patch={section_ids.get('patch')}")
            
            # Track indices for multiple parts
            part_idx = 0  # 0 = Original, 1 = Cont1, etc.
            
            # Build verification entry for each plan action
            entry_verifications = []
            has_error = False
            has_missing = False
            
            for plan_item in plan:
                action = plan_item.get('action', '')
                entry_result = {
                    'action': action,
                    'expected_dates': plan_item.get('dates', ''),
                    'expected_notes': plan_item.get('notes', ''),
                    'status': 'PENDING',
                    'issues': [],
                    'actual': None,
                    'mis_id': None,
                    'suggestions': []
                }
                
                # v10.8: Determine which MIS ID to use based on action and section
                if action == 'CREATE_PART1':
                    # Original: First in section's parts list (W1, M1, S1)
                    parts = section_ids.get('parts', [])
                    entry_result['mis_id'] = parts[0] if parts else None
                    part_idx = 1  # Next part will be Continuation
                    expected_attrs = {
                        'discount': split.get('discount'),
                        'vendor_pct': split.get('vendor_contrib'),
                        'locations': split.get('locations')
                    }
                    
                elif action == 'GAP':
                    # v10.8: Interrupting deal's MIS ID comes from its own row
                    int_deal = split.get('interrupting_deal', {})
                    tier1_mis_id = int_deal.get('mis_id', '')
                    if tier1_mis_id:
                        # Parse the interrupting deal's MIS ID cell
                        tier1_parsed = parse_mis_id_cell(tier1_mis_id)
                        # Get the interrupting section's IDs (M1, S1, etc.)
                        int_section_ids = tier1_parsed.get(int_section, {}) or {'parts': [], 'patch': None}
                        int_parts = int_section_ids.get('parts', [])
                        if int_parts:
                            entry_result['mis_id'] = int_parts[0]
                        elif tier1_parsed.get('parts'):
                            # Fallback to legacy parts list
                            entry_result['mis_id'] = tier1_parsed['parts'][0]
                        else:
                            # Use raw value if no tags found
                            entry_result['mis_id'] = strip_mis_id_tag(tier1_mis_id)
                    
                    # GAP uses Tier 1 deal attributes
                    expected_attrs = {
                        'discount': int_deal.get('discount'),
                        'vendor_pct': int_deal.get('vendor_contrib'),
                        'locations': int_deal.get('locations')
                    }
                    
                elif action == 'PATCH':
                    # v10.8: Patch ID from section (WP, MP, SP)
                    entry_result['mis_id'] = section_ids.get('patch')
                    
                    expected_attrs = {
                        'discount': plan_item.get('discount', split.get('discount')),
                        'vendor_pct': plan_item.get('vendor_contrib', split.get('vendor_contrib')),
                        'locations': plan_item.get('locations', '')
                    }
                    
                elif action.startswith('CREATE_PART'):
                    # v10.8: Continuation (W2, W3, M2, M3, S2, S3)
                    parts = section_ids.get('parts', [])
                    if part_idx < len(parts):
                        entry_result['mis_id'] = parts[part_idx]
                    part_idx += 1
                    
                    expected_attrs = {
                        'discount': split.get('discount'),
                        'vendor_pct': split.get('vendor_contrib'),
                        'locations': split.get('locations')
                    }
                else:
                    expected_attrs = {}
                
                entry_result['expected'] = expected_attrs
                
                # Verify the entry
                if entry_result['mis_id']:
                    actual = find_mis_entry_by_id(mis_df, entry_result['mis_id'])
                    entry_result['actual'] = actual
                    
                    if actual:
                        all_match, issues = compare_deal_attributes(expected_attrs, actual)
                        if all_match:
                            entry_result['status'] = 'CORRECT'
                        else:
                            entry_result['status'] = 'ERROR'
                            entry_result['issues'] = issues
                            has_error = True
                    else:
                        entry_result['status'] = 'NOT_FOUND'
                        entry_result['issues'] = [f"MIS ID {entry_result['mis_id']} not found in CSV"]
                        has_error = True
                else:
                    # No MIS ID - generate suggestions
                    entry_result['status'] = 'MISSING_ID'
                    has_missing = True
                    
                    # Generate fuzzy suggestions
                    suggestions = generate_fuzzy_suggestions(expected_attrs, mis_df)
                    entry_result['suggestions'] = suggestions
                
                entry_verifications.append(entry_result)
            
            # Determine overall status
            if has_missing:
                overall_status = 'MISSING_ID'
                summary['missing_ids'] += 1
            elif has_error:
                overall_status = 'PARTIAL_ERROR'
                summary['partial_errors'] += 1
            else:
                overall_status = 'CORRECT'
                summary['fully_correct'] += 1
            
            verification_results.append({
                'brand': brand,
                'weekday': split.get('weekday'),
                'google_row': google_row,
                'conflict_type': split.get('conflict_type'),
                'conflict_dates': split.get('conflict_dates', []),
                'interrupting_deal': split.get('interrupting_deal', {}),
                'overall_status': overall_status,
                'parsed_ids': parsed_ids,
                'details': entry_verifications
            })
        
        # 5. RETURN RESULTS
        return jsonify({
            'success': True,
            'date_context': f"{datetime(target_year, target_month, 1).strftime('%B %Y')}",
            'verification_results': verification_results,
            'no_conflict': no_conflict,
            'summary': summary
        })
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/mis/split-audit/fuzzy-suggestions', methods=['POST'])
def api_split_audit_fuzzy_suggestions():
    """
    Get fuzzy match suggestions for a missing MIS ID.
    Called when user needs help finding the correct MIS entry.
    """
    try:
        data = request.get_json() or {}
        expected = data.get('expected', {})
        
        # Use global MIS CSV
        mis_df = GLOBAL_DATA['mis'].get('mis_df')
        if mis_df is None or mis_df.empty:
            return jsonify({'success': False, 'error': 'No MIS CSV loaded.'})
        
        suggestions = generate_fuzzy_suggestions(expected, mis_df, max_results=5)
        
        return jsonify({
            'success': True,
            'suggestions': suggestions
        })
    
    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/mis/conflict-audit', methods=['POST'])
def api_mis_conflict_audit():
    """
    Scans the MIS CSV for internal conflicts (Active deals with matching parameters).
    Criteria: Start Date <= Today <= End Date AND Exact Match on (Brand, Weekday).
    Ignores Location.
    """
    try:
        # 1. Load Data (Prefer pulled CSV, fallback to upload)
        csv_file = request.files.get('csv')
        df = None
        
        if csv_file:
            df = pd.read_csv(csv_file)
        elif GLOBAL_DATA['mis'].get('mis_csv_filepath'):
            path = GLOBAL_DATA['mis']['mis_csv_filepath']
            if Path(path).exists():
                df = pd.read_csv(path)
        
        if df is None or df.empty:
            return jsonify({'success': False, 'error': 'No MIS CSV loaded. Please pull or upload a CSV in Setup.'})

        # 2. Filter for ACTIVE deals
        # Logic: Start Date <= Today AND (End Date >= Today OR End Date is Empty)
        today = datetime.now()
        today = today.replace(hour=0, minute=0, second=0, microsecond=0)
        
        active_rows = []
        
        for idx, row in df.iterrows():
            # Parse Dates
            start_str = str(row.get('Start date', '')).strip()
            end_str = str(row.get('End date', '')).strip()
            
            try:
                # Helper to parse flexible date formats
                def parse_dt(d_str):
                    if not d_str or d_str.lower() == 'nan': return None
                    for fmt in ('%Y-%m-%d', '%m/%d/%Y', '%m-%d-%Y'):
                        try:
                            return datetime.strptime(d_str, fmt)
                        except: continue
                    return None

                s_date = parse_dt(start_str)
                e_date = parse_dt(end_str)
                
                # Active Logic
                is_started = s_date is None or s_date <= today
                is_not_ended = e_date is None or e_date >= today
                
                if is_started and is_not_ended:
                    active_rows.append(row)
                    
            except Exception:
                # If date parse fails, assume active to be safe (or skip)
                continue

        if not active_rows:
            return jsonify({'success': True, 'conflicts': [], 'message': 'No active deals found.'})

        # 3. Group by Fingerprint
        # Fingerprint: Brand + Weekday (Ignores Discount/Category to find conflicting OFFERS)
        grouped = {}
        
        for row in active_rows:
            brand = str(row.get('Brand', 'N/A')).strip()
            cat = str(row.get('Category', 'N/A')).strip()
            disc = str(row.get('Daily Deal Discount', '0')).strip()
            weekday = str(row.get('Weekday', 'All')).strip()
            
            # UPDATED: Relaxed fingerprint to find DIFFERENT deals for the SAME brand
            # We group purely by Brand + Weekday.
            fingerprint = f"{brand}|{weekday}".lower()
            
            if fingerprint not in grouped:
                grouped[fingerprint] = []
            
            # Store the row data needed for display
            grouped[fingerprint].append({
                'mis_id': str(row.get('ID', '')),
                'brand': brand,
                'category': cat,
                'discount': disc,
                'weekday': weekday,
                'locations': str(row.get('Store', 'All Locations')),
                'start': str(row.get('Start date', '')),
                'end': str(row.get('End date', ''))
            })

        # 4. Filter for Conflicts (Groups with > 1 item)
        conflicts = []
        for key, rows in grouped.items():
            if len(rows) > 1:
                # Add metadata for the group header
                first = rows[0]
                
                # Create a summary of the conflicting discounts (e.g. "20% vs BOGO")
                discounts_found = list(set([r['discount'] for r in rows]))
                disc_summary = " vs ".join(discounts_found)
                if len(disc_summary) > 50: disc_summary = disc_summary[:47] + "..."
                
                conflicts.append({
                    'fingerprint': key,
                    # Updated Title to show the conflict type
                    'title': f"{first['brand']} ({first['weekday']}) - [{disc_summary}]",
                    'count': len(rows),
                    'rows': rows
                })
        
        # Sort by count (most conflicting first)
        conflicts.sort(key=lambda x: x['count'], reverse=True)
        
        # --- THIS WAS MISSING ---
        return jsonify({
            'success': True, 
            'conflicts': conflicts, 
            'total_active': len(active_rows),
            'conflict_groups': len(conflicts)
        })

    except Exception as e:
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/blaze/refresh')
def api_blaze_refresh():
    data, error = scrape_blaze_data_from_browser()
    if error:
        return jsonify(success=False, message=error)
    GLOBAL_DATA['blaze']['df_raw'] = pd.DataFrame(data)
    groups = load_groups()
    return jsonify(success=True, data=data, groups=groups)

@app.route('/api/blaze/poll-update')
def api_blaze_poll_update():
    try:
        # Frontend sends its last known timestamp
        client_ts = float(request.args.get('ts', 0))
        server_ts = GLOBAL_DATA['blaze'].get('last_update_ts', 0)
        
        # If server has newer data than client, signal an update
        if server_ts > client_ts:
            return jsonify({'update': True, 'ts': server_ts})
            
        return jsonify({'update': False})
    except Exception as e:
        return jsonify({'update': False, 'error': str(e)})

@app.route('/api/blaze/get-cache')
def api_blaze_get_cache():
    try:
        # Get data from memory
        df = GLOBAL_DATA['blaze'].get('df_raw')
        if df is None or df.empty:
            return jsonify(success=False, message="No data")
        
        # Convert to dictionary for JSON
        # Replace NaN with None to avoid invalid JSON errors
        data = df.where(pd.notnull(df), None).to_dict('records')
        
        # Get current timestamp to keep client in sync
        server_ts = GLOBAL_DATA['blaze'].get('last_update_ts', 0)
        
        return jsonify(success=True, data=data, ts=server_ts)
    except Exception as e:
        return jsonify(success=False, message=str(e))

@app.route('/api/blaze/export-csv')
def api_blaze_export_csv():
    try:
        # Check if data exists
        if 'blaze' not in GLOBAL_DATA or 'df_raw' not in GLOBAL_DATA['blaze'] or GLOBAL_DATA['blaze']['df_raw'].empty:
            return "No Blaze data found. Please click 'Refresh / Sync Data' first.", 400
            
        # Get the dataframe - USE DEEP COPY to protect live dashboard
        df = GLOBAL_DATA['blaze']['df_raw'].copy(deep=True)
        
        # Helper to flatten the group dictionaries into comma-separated strings for CSV
        def flatten_groups(val):
            if isinstance(val, list):
                # Extract 'name' from each group dict
                return ", ".join([str(g.get('name', '')) for g in val])
            return str(val)

        # Apply flattening to the group columns
        if 'buy_groups' in df.columns:
            df['buy_groups'] = df['buy_groups'].apply(flatten_groups)
        if 'get_groups' in df.columns:
            df['get_groups'] = df['get_groups'].apply(flatten_groups)
            
        # Generate filename
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"blaze_full_report_{timestamp}.csv"
        filepath = BASE_DIR / filename
        
        # Save and send
        df.to_csv(filepath, index=False)
        return send_file(filepath, as_attachment=True, download_name=filename)

    except Exception as e:
        traceback.print_exc()
        return str(e), 500


@app.route('/api/blaze/export-filtered-csv', methods=['POST'])
def api_blaze_export_filtered_csv():
    """Export only the filtered/visible rows as CSV."""
    try:
        data = request.get_json()
        ids = data.get('ids', [])
        
        if not ids:
            return "No IDs provided", 400
            
        # Check if data exists
        if 'blaze' not in GLOBAL_DATA or 'df_raw' not in GLOBAL_DATA['blaze'] or GLOBAL_DATA['blaze']['df_raw'].empty:
            return "No Blaze data found. Please click 'Refresh / Sync Data' first.", 400
            
        # Get the dataframe - USE DEEP COPY
        df = GLOBAL_DATA['blaze']['df_raw'].copy(deep=True)
        
        # Filter to only requested IDs
        df_filtered = df[df['ID'].astype(str).isin([str(i) for i in ids])]
        
        if df_filtered.empty:
            return "No matching rows found", 404
        
        # Helper to flatten groups
        def flatten_groups(val):
            if isinstance(val, list):
                return ", ".join([str(g.get('name', '')) for g in val])
            return str(val)

        if 'buy_groups' in df_filtered.columns:
            df_filtered['buy_groups'] = df_filtered['buy_groups'].apply(flatten_groups)
        if 'get_groups' in df_filtered.columns:
            df_filtered['get_groups'] = df_filtered['get_groups'].apply(flatten_groups)
            
        # Generate CSV in memory
        import io
        output = io.StringIO()
        df_filtered.to_csv(output, index=False)
        output.seek(0)
        
        # Create response
        from flask import Response
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"blaze_filtered_report_{timestamp}.csv"
        
        return Response(
            output.getvalue(),
            mimetype='text/csv',
            headers={'Content-Disposition': f'attachment; filename={filename}'}
        )

    except Exception as e:
        traceback.print_exc()
        return str(e), 500


@app.route('/api/blaze/zombie-disable', methods=['POST'])
def api_blaze_zombie_disable():
    """
    Disable a single zombie promotion via browser automation.
    Steps:
    1. Navigate to promo page and click Setup tab
    2. Find and click the Status toggle to disable
    3. Click dropdown to reveal Save button
    4. Click Save
    5. Wait for popup to close (indicates success)
    """
    try:
        data = request.get_json()
        promo_id = data.get('promo_id')
        
        if not promo_id:
            return jsonify({'success': False, 'error': 'No promo_id provided'})
        
        driver = GLOBAL_DATA.get('browser_instance')
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not ready'})
        
        print(f"[ZOMBIE] Starting disable for promo ID: {promo_id}")
        
        # Step 1: Switch to Blaze tab
        for h in driver.window_handles:
            driver.switch_to.window(h)
            if "blaze.me" in driver.current_url:
                break
        
        # Step 2: Navigate to the promotion Setup page
        target_url = f'https://retail.blaze.me/company-promotions/promotions/{promo_id}#setup'
        driver.get(target_url)
        print(f"[ZOMBIE] Navigated to: {target_url}")
        
        # Step 3: Click Setup tab (with retry logic from existing navBlaze)
        max_attempts = 5
        setup_clicked = False
        
        for attempt in range(1, max_attempts + 1):
            try:
                # Check if we're already on Setup (Name input visible)
                try:
                    name_input = driver.find_element(By.ID, "name")
                    if name_input.is_displayed():
                        print(f"[ZOMBIE] Setup tab already active (attempt {attempt})")
                        setup_clicked = True
                        break
                except:
                    pass
                
                # Click Setup tab
                setup_container = WebDriverWait(driver, 2).until(
                    EC.presence_of_element_located((By.XPATH, "//p[text()='Setup']/parent::div/parent::div"))
                )
                
                if setup_container.is_displayed():
                    driver.execute_script("arguments[0].click();", setup_container)
                    print(f"[ZOMBIE] Clicked Setup tab (attempt {attempt})")
                
                time.sleep(0.7)
                
            except Exception as e:
                print(f"[ZOMBIE] Setup tab attempt {attempt} waiting... ({e})")
                time.sleep(0.7)
        
        # Step 4: Wait for Status toggle to appear and click it
        print("[ZOMBIE] Looking for Status toggle...")
        
        try:
            # Wait for the Status toggle container
            # Using the specific MUI switch structure
            status_toggle = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((
                    By.XPATH, 
                    "//label[contains(text(),'Status')]/ancestor::div[contains(@class,'inlineContainer')]//input[@type='checkbox']"
                ))
            )
            
            # Check if already disabled
            is_checked = status_toggle.get_attribute('checked')
            print(f"[ZOMBIE] Status toggle found. Currently checked: {is_checked}")
            
            if is_checked:
                # Click to disable
                # Use JavaScript click since MUI switches can be tricky
                parent_switch = status_toggle.find_element(By.XPATH, "./ancestor::span[contains(@class,'MuiSwitch-root')]")
                driver.execute_script("arguments[0].click();", parent_switch)
                print("[ZOMBIE] [OK] Clicked Status toggle to disable")
                time.sleep(0.5)
                
                # Verify it's now unchecked
                is_checked_after = status_toggle.get_attribute('checked')
                if is_checked_after:
                    print("[ZOMBIE] [!] [EMOJI]√É‚Äö√Ç¬è Toggle may not have changed - trying direct input click")
                    driver.execute_script("arguments[0].click();", status_toggle)
                    time.sleep(0.5)
            else:
                print("[ZOMBIE] Already disabled, proceeding to save...")
        
        except TimeoutException:
            return jsonify({'success': False, 'error': 'Could not find Status toggle within timeout'})
        except Exception as e:
            print(f"[ZOMBIE] Error with Status toggle: {e}")
            return jsonify({'success': False, 'error': f'Status toggle error: {str(e)}'})
        
        # Step 5: Click the Schedule tab to navigate to that section
        print("[ZOMBIE] Clicking Schedule tab...")
        
        # Import ActionChains for human-like interactions
        # ActionChains already imported globally
        
        try:
            # Find the Schedule tab - it's a <p> element with text "Schedule"
            schedule_tab = WebDriverWait(driver, 5).until(
                EC.presence_of_element_located((
                    By.XPATH,
                    "//p[text()='Schedule']"
                ))
            )
            
            # Scroll into view
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", schedule_tab)
            time.sleep(0.3)
            
            # Click the Schedule tab
            ActionChains(driver).move_to_element(schedule_tab).pause(0.2).click().perform()
            print("[ZOMBIE] [OK] Clicked Schedule tab")
            time.sleep(0.5)
            
        except TimeoutException:
            print("[ZOMBIE] ERROR: Could not find Schedule tab")
            return jsonify({'success': False, 'error': 'Could not find Schedule tab'})
        except Exception as e:
            print(f"[ZOMBIE] ERROR: Schedule tab error: {e}")
            return jsonify({'success': False, 'error': f'Schedule tab error: {str(e)}'})
        
        # Step 6: Click the Save button (direct button, not dropdown menu)
        print("[ZOMBIE] Looking for Save button...")
        
        try:
            # Wait for the Save button to appear - it's a submit button with text "Save"
            save_btn = WebDriverWait(driver, 5).until(
                EC.element_to_be_clickable((
                    By.XPATH,
                    "//button[@type='submit' and contains(text(),'Save')]"
                ))
            )
            
            # Click Save using ActionChains
            ActionChains(driver).move_to_element(save_btn).pause(0.2).click().perform()
            print("[ZOMBIE] [OK] Clicked Save button")
            
        except TimeoutException:
            # Try alternate selector
            print("[ZOMBIE] Primary Save selector failed, trying alternate...")
            try:
                save_btn = driver.find_element(By.XPATH, "//button[contains(@class,'MuiButton-contained') and contains(text(),'Save')]")
                driver.execute_script("arguments[0].click();", save_btn)
                print("[ZOMBIE] [OK] Clicked Save (alternate selector)")
            except:
                return jsonify({'success': False, 'error': 'Could not find Save button'})
        except Exception as e:
            print(f"[ZOMBIE] ERROR: Save button error: {e}")
            return jsonify({'success': False, 'error': f'Save button error: {str(e)}'})
        
        # Step 7: Wait for save to complete
        print("[ZOMBIE] Waiting for save to complete...")
        
        try:
            # Wait for save operation - look for loading state to appear and disappear
            # or wait for a success indicator
            time.sleep(1)  # Brief pause for save to initiate
            
            # Try to detect if page is processing (button becomes disabled or shows loading)
            try:
                # Wait for any loading spinner to disappear (if present)
                WebDriverWait(driver, 10).until_not(
                    EC.presence_of_element_located((
                        By.XPATH,
                        "//span[contains(@class,'spinner')]"
                    ))
                )
            except:
                pass  # No spinner found, that's fine
            
            # Additional wait to ensure save completed
            time.sleep(1)
            print("[ZOMBIE] [OK] Save completed")
            
        except Exception as e:
            print(f"[ZOMBIE] [!] [EMOJI]√É‚Äö√Ç¬è Save wait issue: {e}, but proceeding...")
        
        # Small delay before next operation
        time.sleep(1)
        
        print(f"[ZOMBIE] [OK] Successfully disabled promo ID: {promo_id}")
        return jsonify({'success': True, 'message': f'Disabled promo {promo_id}'})
        
    except Exception as e:
        print(f"[ZOMBIE] Error: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/blaze/navigate', methods=['POST'])
def api_blaze_navigate():
    try:
        data = request.get_json()
        target_url = data.get('url')
        if not target_url: return jsonify({'success': False})
            
        driver = GLOBAL_DATA['browser_instance']
        if not driver: return jsonify({'success': False, 'error': 'Browser not ready'})
            
        # Switch tab logic
        for h in driver.window_handles:
            driver.switch_to.window(h)
            if "blaze.me" in driver.current_url: break
        
        driver.get(target_url)
        
        # --- ROBUST SETUP CLICKER (Restored) ---
        max_attempts = 5
        click_success = False
        
        print(f"[BLAZE] Navigating... Starting Setup Tab search (Max {max_attempts} attempts)")
        
        for attempt in range(1, max_attempts + 1):
            try:
                # 1. Check if we succeeded (Is the Title/Name input visible?)
                try:
                    name_input = driver.find_element(By.ID, "name")
                    if name_input.is_displayed():
                        print(f"[BLAZE] Success! Detected Promotion Title element on attempt {attempt}.")
                        click_success = True
                        break 
                except:
                    pass

                # 2. If not found, Click the Setup Tab
                # Matches the container <div> that holds the "Setup" text
                setup_container = WebDriverWait(driver, 2).until(
                    EC.presence_of_element_located((By.XPATH, "//p[text()='Setup']/parent::div/parent::div"))
                )
                
                if setup_container.is_displayed():
                    driver.execute_script("arguments[0].click();", setup_container)
                    print(f"[BLAZE] Clicked 'Setup' (Attempt {attempt})")
                
                time.sleep(0.7)
                
            except Exception as e:
                print(f"[BLAZE] Attempt {attempt} waiting for page load...")
                time.sleep(0.7)

        if not click_success:
            print("[BLAZE] WARN: Reached max attempts. Setup tab might not be active.")
        
        # START WATCHER THREAD (For Single Row Sync)
        promo_id = None
        if "/promotions/" in target_url:
            parts = target_url.split("/promotions/")
            if len(parts) > 1:
                promo_id = parts[1].split("#")[0].split("?")[0]

        if promo_id:
            # Assumes monitor_browser_return function exists in your script (it should be there from previous edits)
            thread = threading.Thread(target=monitor_browser_return, args=(promo_id,), daemon=True)
            thread.start()
        
        return jsonify({'success': True})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

# v12.7: Create Blaze Discount Automation Endpoint
@app.route('/api/blaze/create-discount', methods=['POST'])
def api_blaze_create_discount():
    """
    Automates creation of a new discount in Blaze.
    Expects: {'title': str, 'type': str, 'description': str}
    
    Steps:
    1. Switch to/open Blaze browser tab
    2. Login if needed
    3. Navigate directly to creation URL (bypasses button detection)
    4. Wait for discount type options to appear (validates page loaded)
    5. Select discount type from dropdown
    6. Fill in title field
    7. PAUSE for manual completion (future: auto-fill remaining fields)
    """
    try:
        data = request.get_json()
        title = data.get('title', '').strip()
        discount_type = data.get('type', '').strip()
        description = data.get('description', '').strip()
        
        if not title or not discount_type:
            return jsonify({'success': False, 'error': 'Title and discount type required'})
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'})
        
        print(f"[CREATE-BLAZE] Starting automation for: {title} ({discount_type})")
        
        # Step 1: Switch to Blaze tab or open new one
        blaze_found = False
        for handle in driver.window_handles:
            driver.switch_to.window(handle)
            if "blaze.me" in driver.current_url:
                blaze_found = True
                print("[CREATE-BLAZE] Switched to existing Blaze tab")
                break
        
        if not blaze_found:
            print("[CREATE-BLAZE] Opening new Blaze tab...")
            driver.execute_script("window.open('https://retail.blaze.me/', '_blank');")
            time.sleep(1)
            driver.switch_to.window(driver.window_handles[-1])
        
        # Step 2: Check if logged in (look for login fields)
        try:
            username_field = driver.find_element(By.NAME, "username")
            # Login page detected - need to login
            print("[CREATE-BLAZE] Login page detected, logging in...")
            
            # Get credentials from config
            creds = load_credentials()
            if not creds or 'blaze_username' not in creds:
                return jsonify({'success': False, 'error': 'Blaze credentials not configured'})
            
            username_field.send_keys(creds['blaze_username'])
            password_field = driver.find_element(By.NAME, "password")
            password_field.send_keys(creds['blaze_password'])
            password_field.send_keys(Keys.RETURN)
            
            time.sleep(3)  # Wait for login
            print("[CREATE-BLAZE] Login completed")
        except:
            print("[CREATE-BLAZE] Already logged in")
        
        # Step 3: Navigate directly to creation URL (bypasses button detection)
        # v12.7.3: Direct navigation is more reliable than finding/clicking button
        creation_url = "https://retail.blaze.me/company-promotions/promotions/add#promotion-type"
        print(f"[CREATE-BLAZE] Navigating to creation URL: {creation_url}")
        driver.get(creation_url)
        time.sleep(2)  # Allow page to load
        
        # Step 4: Wait for discount type options to be present (validates page loaded)
        print("[CREATE-BLAZE] Waiting for discount type options to appear...")
        try:
            # Wait for any of the discount type buttons to be present
            # This confirms the creation interface loaded successfully
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, "//div[@role='button']//p[text()='BOGO' or text()='Bundle' or text()='Global Product Discount' or text()='Collection Discount']"))
            )
            print("[CREATE-BLAZE] Creation interface loaded successfully")
        except Exception as e:
            return jsonify({'success': False, 'error': f'Creation interface did not load properly: {str(e)}'})
        
        # Step 5: Select discount type from dropdown
        type_mapping = {
            'Bundle': "//div[@role='button'][@tabindex='3']//p[text()='Bundle']",
            'BOGO': "//div[@role='button'][@tabindex='0']//p[text()='BOGO']",
            'Global Product Discount': "//div[@role='button'][@tabindex='2']//p[text()='Global Product Discount']",
            'Collection Discount': "//div[@role='button'][@tabindex='1']//p[text()='Collection Discount']"
        }
        
        type_xpath = type_mapping.get(discount_type)
        if not type_xpath:
            return jsonify({'success': False, 'error': f'Unknown discount type: {discount_type}'})
        
        try:
            type_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, type_xpath))
            )
            driver.execute_script("arguments[0].click();", type_button)
            print(f"[CREATE-BLAZE] Selected discount type: {discount_type}")
            time.sleep(1)
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not select discount type: {str(e)}'})
        
        # Step 6: Fill in title field
        try:
            title_input = WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "name"))
            )
            title_input.clear()
            title_input.send_keys(title)
            print(f"[CREATE-BLAZE] Filled title: {title}")
        except Exception as e:
            return jsonify({'success': False, 'error': f'Could not fill title field: {str(e)}'})
        
        # Step 7: PAUSE - Future automation will fill remaining fields
        # TODO (Future Enhancement): Auto-fill dates, products, locations, etc.
        #   - Fill Start/End dates from Google Sheet data
        #   - Select products/collections based on category
        #   - Select locations from Google Sheet locations column
        #   - Fill description field
        #   - Set discount value/type
        #   - Configure advanced settings
        
        print("[CREATE-BLAZE] Automation PAUSED - Manual completion required")
        print("[CREATE-BLAZE] Title filled successfully. Please complete remaining fields manually.")
        
        return jsonify({
            'success': True,
            'message': 'Discount creation started. Title filled. Please complete remaining fields manually.',
            'title': title,
            'type': discount_type
        })
        
    except Exception as e:
        print(f"[CREATE-BLAZE] ERROR: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/tax-rates')
def api_get_tax_rates():
    """
    Fetch tax rates (defaults + local overrides from tax_config.json).
    Returns: {'success': True, 'rates': {...}} or {'success': False, 'error': '...'}
    """
    try:
        rates = fetch_tax_rates()
        if rates:
            return jsonify({'success': True, 'rates': rates})
        else:
            return jsonify({'success': False, 'error': 'No tax rates available.'})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/save-tax-rates', methods=['POST'])
def api_save_tax_rates():
    """
    Save user-edited tax rates to tax_config.json.
    Expects JSON: {'rates': {'Store Name': 1.0975, ...}}
    Returns: {'success': True} or {'success': False, 'error': '...'}
    """
    try:
        data = request.get_json()
        rates = data.get('rates', {})
        
        if not rates:
            return jsonify({'success': False, 'error': 'No rates provided'})
        
        # Validate rates are numbers
        for store, rate in rates.items():
            try:
                float(rate)
            except (ValueError, TypeError):
                return jsonify({'success': False, 'error': f'Invalid rate for {store}: {rate}'})
        
        # Save to tax_config.json
        with open(TAX_CONFIG_FILE, 'w') as f:
            json.dump(rates, f, indent=2)
        
        print(f"[TAX] Saved {len(rates)} tax rates to {TAX_CONFIG_FILE}")
        return jsonify({'success': True, 'message': f'Saved {len(rates)} tax rates'})
        
    except Exception as e:
        print(f"[ERROR] Failed to save tax rates: {e}")
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)})

@app.route('/api/debug/analyze-collections', methods=['GET'])
def api_debug_analyze_collections():
    """
    DIAGNOSTIC: Navigate to Collections page and analyze network traffic.
    Access: http://127.0.0.1:5100/api/debug/analyze-collections
    """
    try:
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'error': 'Browser not initialized'})
        
        # Navigate to Smart Collections
        for h in driver.window_handles:
            driver.switch_to.window(h)
            if "blaze.me" in driver.current_url:
                break
        
        print("[DIAG] Navigating to Smart Collections page...")
        driver.get("https://retail.blaze.me/company-promotions/smart-collections")
        time.sleep(5)  # Wait for page to fully load
        
        # Analyze traffic
        analyze_blaze_network_traffic()
        
        return jsonify({
            'success': True,
            'message': 'Check CMD console for network traffic analysis'
        })
        
    except Exception as e:
        traceback.print_exc()
        return jsonify({'error': str(e)})

# ============================================================================
# BLAZE TAG UPDATER INTEGRATION (Tier Promotions)
# ============================================================================
def run_tier_promotion_update_logic(driver):
    """
    Adapted from blaze_tag_updater.py v3.8.
    Executes the Tag Update sequence using the existing browser session.
    """
    # ActionChains already imported globally
    
    # --- CONFIGURATION ---
    DISCOUNTS_TO_UPDATE = ["T1 BAG DAY", "T2 BAG DAY", "T3 BAG DAY"]
    EXCLUDED_STORES = ["Davis", "Dixon"]
    
    # --- SELECTORS ---
# Updated to target the specific promotion search bar using data-cy
    SEL_SEARCH_BAR = "input[data-cy='testSearch']"
    SEL_EDIT_BTN = "//button[contains(., 'Edit')]"
    SEL_SAVE_BTN = "//button[contains(@class, 'btn-success') and contains(text(), 'Save')]"
    SEL_CLEAR_FILTERS = "//button[contains(text(), 'Clear')]"
    SEL_ACTIVE_CHIP_DEL = "//div[contains(@class, 'MuiChip')]//span[text()='Active']/following-sibling::*[name()='svg']"

    # --- HELPERS ---
    def btu_force_click(element):
        driver.execute_script("arguments[0].click();", element)

    def btu_open_dropdown():
        try:
            dropdown = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "span[data-cy='lbl-shop-name']"))
            )
            btu_force_click(dropdown)
            WebDriverWait(driver, 3).until(EC.presence_of_element_located((By.CSS_SELECTOR, "li.shopElement")))
            return True
        except TimeoutException: 
            return False

    def btu_switch_store(store_name):
        print(f"[TAG-UPDATER] Switching to: {store_name}...")
        if not btu_open_dropdown(): 
            print("[TAG-UPDATER] Failed to open store dropdown.")
            return False
        
        try:
            options = driver.find_elements(By.CSS_SELECTOR, "li.shopElement span")
            for opt in options:
                if store_name in opt.text:
                    driver.execute_script("arguments[0].scrollIntoView(true);", opt)
                    time.sleep(0.5)
                    btu_force_click(opt)
                    time.sleep(5) 
                    return True
            ActionChains(driver).send_keys(Keys.ESCAPE).perform()
            return False
        except Exception as e:
            print(f"[TAG-UPDATER] Error switching store: {e}")
            ActionChains(driver).send_keys(Keys.ESCAPE).perform()
            return False

    def btu_clear_active_filter():
        try:
            clear_btns = driver.find_elements(By.XPATH, SEL_CLEAR_FILTERS)
            for btn in clear_btns:
                if btn.is_displayed():
                    btu_force_click(btn)
                    time.sleep(1)
                    return
        except: pass
        try:
            active_chip_x = driver.find_elements(By.XPATH, SEL_ACTIVE_CHIP_DEL)
            for x in active_chip_x:
                if x.is_displayed():
                    btu_force_click(x)
                    time.sleep(1)
        except: pass

    def btu_perform_react_search(text):
        try:
            search_input = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, SEL_SEARCH_BAR))
            )
            search_input.click()
            search_input.send_keys(Keys.CONTROL + "a")
            search_input.send_keys(Keys.BACKSPACE)
            time.sleep(0.2)
            search_input.send_keys(text)
            search_input.send_keys(Keys.RETURN)
            
            print(f"[TAG-UPDATER] Search sent: '{text}'. Waiting 3s...")
            time.sleep(3) 
            return True
        except Exception as e:
            print(f"[TAG-UPDATER] Search Failed: {e}")
            return False

    def btu_find_and_click_promo_row(promo_name):
        lower_name = promo_name.lower()
        xpath_by_title = f"//div[@role='gridcell'][contains(translate(@title, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '{lower_name}')]"
        xpath_by_text = f"//div[@role='gridcell'][contains(translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '{lower_name}')]"
        xpath_by_link = f"//a[contains(@class, 'virtualized_row_link')][.//div[contains(translate(., 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '{lower_name}')]]"

        for attempt in range(1, 4):
            try:
                try:
                    target = driver.find_element(By.XPATH, xpath_by_title)
                    btu_force_click(target)
                    return True
                except NoSuchElementException: pass

                try:
                    target = driver.find_element(By.XPATH, xpath_by_text)
                    btu_force_click(target)
                    return True
                except NoSuchElementException: pass

                target = driver.find_element(By.XPATH, xpath_by_link)
                btu_force_click(target)
                return True

            except (Exception):
                time.sleep(1.5)
                
        return False

    def btu_update_product_tags():
        print("[TAG-UPDATER] Scrolling to BOTTOM...")
        driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        time.sleep(1.5) 
        
        # 1. FIND ARROW
        arrow_xpath = "//b[contains(text(), 'Product Tags')]/ancestor::div[1]//span[contains(@class, 'Select-arrow-zone')]"
        
        try:
            arrow_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, arrow_xpath))
            )
            print("[TAG-UPDATER] Clicking Dropdown Arrow...")
            ActionChains(driver).move_to_element(arrow_btn).click().perform()
        except TimeoutException:
            print("[TAG-UPDATER] Arrow click failed. Using fallback...")
            box_xpath = "//b[contains(text(), 'Product Tags')]/ancestor::div[1]//div[contains(@class, 'Select-control')]"
            box = driver.find_element(By.XPATH, box_xpath)
            ActionChains(driver).move_to_element(box).click().perform()

        time.sleep(1) 
        
        actions = ActionChains(driver)
        
        # 2. CLEAR
        print("[TAG-UPDATER] Clearing tags (Backspace x5)...")
        for _ in range(5):
            actions.send_keys(Keys.BACKSPACE).perform()
            time.sleep(0.1) 
            
        # 3. TYPE
        print("[TAG-UPDATER] Typing new tags...")
        
        actions.send_keys("Promo").perform()
        time.sleep(0.5)
        actions.send_keys(Keys.RETURN).perform()
        time.sleep(0.5)
        
        actions.send_keys("promo").perform()
        time.sleep(0.5)
        actions.send_keys(Keys.RETURN).perform()
        time.sleep(0.5)

    def btu_process_discount(discount_name):
        print(f"[TAG-UPDATER] Processing: {discount_name}")
        
        driver.get("https://retail.blaze.me/promotions")
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, SEL_SEARCH_BAR)))
        
        btu_clear_active_filter()
        
        if not btu_perform_react_search(discount_name): return False
        if not btu_find_and_click_promo_row(discount_name): return False
        
        time.sleep(4) 

        try:
            # Edit
            edit_btn = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, SEL_EDIT_BTN)))
            btu_force_click(edit_btn)
            print("[TAG-UPDATER] Edit mode enabled. Waiting 2s...")
            time.sleep(2) 
            
            # Update Tags
            btu_update_product_tags()
            
            # SAVE LOGIC
            print("[TAG-UPDATER] Clicking Save...")
            save_btn = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, SEL_SAVE_BTN))
            )
            
            # Ensure visible
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", save_btn)
            time.sleep(0.5)
            btu_force_click(save_btn)
            
            # BLIND WAIT (Fire & Forget)
            print("[TAG-UPDATER] Save clicked. Blind wait (2s)...")
            time.sleep(2) 

            return True

        except Exception as e:
            print(f"[TAG-UPDATER] Failed during edit/save: {e}")
            return False
        finally:
            print("[TAG-UPDATER] Returning to list...")
            driver.get("https://retail.blaze.me/promotions")
            time.sleep(3)

    # --- EXECUTION ---
    try:
        # 1. Go to Promotions to get Store List
        print("[TAG-UPDATER] Initializing Sequence...")
        driver.get("https://retail.blaze.me/promotions")
        time.sleep(3)

        # 2. Get Stores
        print("[TAG-UPDATER] Fetching store list...")
        btu_open_dropdown()
        time.sleep(1)
        options = driver.find_elements(By.CSS_SELECTOR, "li.shopElement span")
        all_shops = [o.text.strip() for o in options if o.text.strip()]
        ActionChains(driver).send_keys(Keys.ESCAPE).perform() 
        
        target_shops = [s for s in all_shops if not any(ex in s for ex in EXCLUDED_STORES)]
        target_shops.sort()
        print(f"[TAG-UPDATER] Target Stores: {target_shops}")
        
        # 3. Execute Loop
        for shop in target_shops:
            if btu_switch_store(shop):
                for promo_name in DISCOUNTS_TO_UPDATE:
                    btu_process_discount(promo_name)
        
        return "Sequence Complete!"

    except Exception as e:
        print(f"[TAG-UPDATER] Fatal Error: {e}")
        return f"Error: {str(e)}"

@app.route('/api/blaze/update-tags', methods=['POST'])
def api_blaze_update_tags():
    """Trigger the Tier Promotion Tag Update sequence in background."""
    # Get credentials for safety check (passed to background executor)
    data = request.get_json() or {}
    gui_username = data.get('mis_username', '').strip()
    gui_password = data.get('mis_password', '').strip()
    
    print("[API] Received request to Update Tier Promotions...")
    
    # Use execute_in_background to handle tab switching/creation
    result = execute_in_background('blaze', run_tier_promotion_update_logic, gui_username=gui_username, gui_password=gui_password)
    
    if result['success']:
        return jsonify({'success': True, 'message': 'Tier Promotion Update Started (Check Console)'})
    else:
        return jsonify({'success': False, 'error': result['error']})

# ============================================================================
# INVENTORY API ROUTES
# ============================================================================
@app.route('/api/blaze/inventory/start', methods=['POST'])
def api_blaze_inventory_start():
    """Start inventory report generation in background thread."""
    target_store = request.json.get('target_store', 'ALL')
    
    if GLOBAL_DATA['blaze']['inventory_running']:
        return jsonify({'error': 'Report already running'}), 409

    def run_in_thread():
        reporter = BlazeInventoryReporter()
        reporter.run_report(target_store)
    
    thread = threading.Thread(target=run_in_thread, daemon=True)
    thread.start()
    
    return jsonify({'success': True})

@app.route('/api/blaze/inventory/status')
def api_blaze_inventory_status():
    return jsonify({
        'running': GLOBAL_DATA['blaze']['inventory_running'],
        'logs': GLOBAL_DATA['blaze']['inventory_logs']
    })

@app.route('/api/blaze/inventory/data')
def api_blaze_inventory_data():
    """Return current inventory data for UI display."""
    df = GLOBAL_DATA['blaze'].get('inventory_data')
    
    if df is None or df.empty:
        return jsonify({'success': False, 'error': 'No data available'})
    
    # Convert DataFrame to list of dicts
    data = df.to_dict('records')
    
    return jsonify({'success': True, 'data': data})

@app.route('/api/blaze/inventory/download')
def api_blaze_inventory_download():
    """Redirect to inventory folder (Windows Explorer or Finder)."""
    import subprocess
    import platform
    
    if platform.system() == 'Windows':
        subprocess.Popen(f'explorer "{INVENTORY_DIR}"')
    elif platform.system() == 'Darwin':  # macOS
        subprocess.Popen(['open', str(INVENTORY_DIR)])
    else:  # Linux
        subprocess.Popen(['xdg-open', str(INVENTORY_DIR)])
    
    return jsonify({'success': True})

@app.route('/api/blaze/inventory/fetch', methods=['POST'])
def api_blaze_inventory_fetch():
    """
    Fetch inventory data and cache it per store.
    Payload: { "store": "store_name", "fresh": true/false, "force_reset": true/false }
    Returns: Success status (data loaded via separate endpoint)
    """
    try:
        payload = request.json
        store = payload.get('store', '')
        use_fresh = payload.get('fresh', False)
        force_reset = payload.get('force_reset', False)
        
        if not store:
            return jsonify({'success': False, 'error': 'Store parameter required'}), 400
        
        # --- CRITICAL FIX START: UNLOCK IF REQUESTED ---
        if force_reset:
            GLOBAL_DATA['blaze']['inventory_running'] = False
            GLOBAL_DATA['blaze']['inventory_start_time'] = None
            print("[WARN] Force reset requested - clearing stuck state")
        # --- CRITICAL FIX END ---

        # Check for stuck operations (Timeout after 5 mins)
        if GLOBAL_DATA['blaze']['inventory_running']:
            start_time = GLOBAL_DATA['blaze'].get('inventory_start_time')
            if start_time:
                elapsed = datetime.now() - start_time
                if elapsed > timedelta(minutes=5):
                    GLOBAL_DATA['blaze']['inventory_running'] = False
                    print(f"[WARN] Auto-reset stuck inventory operation (timeout: {elapsed})")
        
        # Now check again - if still running and NO force reset, then error
        if GLOBAL_DATA['blaze']['inventory_running']:
            return jsonify({
                'success': False, 
                'error': 'Another inventory operation is running. Use force_reset=true to override.'
            }), 409
        
        # Run fetch operation
        reporter = BlazeInventoryReporter()
        success = reporter.run_report(store)
        
        if success and GLOBAL_DATA['blaze'].get('inventory_data') is not None:
            df = GLOBAL_DATA['blaze']['inventory_data']
            
            # Filter by store
            if store != 'ALL':
                df = df[df['Store'] == store]
            
            # NEW: Cache the data for this store
            GLOBAL_DATA['blaze']['inventory_cache'][store] = {
                'data': df,
                'timestamp': datetime.now()
            }
            
            print(f"[CACHE] Stored inventory data for '{store}' ({len(df)} rows)")
            
            # Return success WITHOUT data (frontend will fetch via get-tab-data)
            return jsonify({
                'success': True, 
                'message': f'Inventory data cached successfully',
                'row_count': len(df)
            })
        else:
            return jsonify({'success': False, 'error': 'Failed to fetch inventory data'}), 500
            
    except Exception as e:
        # Always reset on error
        GLOBAL_DATA['blaze']['inventory_running'] = False
        GLOBAL_DATA['blaze']['inventory_start_time'] = None
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/blaze/inventory/get-tab-data', methods=['POST'])
def api_get_inventory_tab_data():
    """
    Retrieve cached inventory data for a specific store (lazy loading).
    Payload: { "store": "store_name" }
    Returns: { "success": true, "data": [...rows...], "timestamp": "..." }
    """
    try:
        payload = request.json
        store = payload.get('store', '')
        
        if not store:
            return jsonify({'success': False, 'error': 'Store parameter required'}), 400
        
        # Check cache
        cache_entry = GLOBAL_DATA['blaze']['inventory_cache'].get(store)
        
        if cache_entry is None:
            return jsonify({
                'success': False, 
                'error': f'No cached data found for store: {store}. Please fetch first.'
            }), 404
        
        # Convert DataFrame to JSON
        df = cache_entry['data']
        data = df.to_dict('records')
        timestamp = cache_entry['timestamp'].strftime('%Y-%m-%d %H:%M:%S')
        
        print(f"[CACHE] Retrieved {len(data)} rows for '{store}' (cached at {timestamp})")
        
        return jsonify({
            'success': True,
            'data': data,
            'timestamp': timestamp,
            'row_count': len(data)
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/blaze/inventory/export', methods=['POST'])
def api_blaze_inventory_export():
    """
    Generate CSV/Excel export based on modal selections.
    Payload: {
        "mode": "full" or "filtered",
        "stores": ["store1", "store2"] or ["ALL"],
        "fresh": true/false,
        "filtered_data": [...] (only if mode="filtered")
    }
    Returns: CSV file download
    """
    try:
        payload = request.json
        mode = payload.get('mode', 'full')
        stores = payload.get('stores', [])
        use_fresh = payload.get('fresh', False)
        filtered_data = payload.get('filtered_data', None)
        
        if not stores:
            return jsonify({'error': 'No stores selected'}), 400
        
        # Mode: filtered - Use provided filtered_data
        if mode == 'filtered' and filtered_data:
            df = pd.DataFrame(filtered_data)
        else:
            # Mode: full - Fetch all data for selected stores
            if use_fresh or GLOBAL_DATA['blaze'].get('inventory_data') is None:
                # Run fresh fetch
                if GLOBAL_DATA['blaze']['inventory_running']:
                    return jsonify({'error': 'Another operation is running'}), 409
                
                reporter = BlazeInventoryReporter()
                if 'ALL' in stores:
                    reporter.run_report('ALL')
                else:
                    # Run for each store and combine
                    for store in stores:
                        reporter.run_report(store)
            
            # Get data from GLOBAL_DATA
            df = GLOBAL_DATA['blaze'].get('inventory_data')
            if df is None or df.empty:
                return jsonify({'error': 'No data available'}), 404
            
            # Filter by stores if not ALL
            if 'ALL' not in stores:
                df = df[df['Store'].isin(stores)]
        
        # Generate CSV in memory
        from io import StringIO
        output = StringIO()
        df.to_csv(output, index=False)
        output.seek(0)
        
        # Create response with CSV download
        from flask import make_response
        response = make_response(output.getvalue())
        response.headers['Content-Type'] = 'text/csv'
        response.headers['Content-Disposition'] = f'attachment; filename=Inventory_Export_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
        
        return response
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/blaze/inventory/list-reports')
def api_blaze_inventory_list_reports():
    """
    List all available inventory CSV files in the INVENTORY directory.
    Returns: { "success": true, "reports": ["filename1.csv", "filename2.csv", ...] }
    """
    try:
        if not INVENTORY_DIR.exists():
            return jsonify({'success': True, 'reports': []})
        
        # Get all CSV files
        csv_files = [f.name for f in INVENTORY_DIR.glob('*.csv')]
        csv_files.sort(reverse=True)  # Most recent first
        
        return jsonify({'success': True, 'reports': csv_files})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/blaze/inventory/load-report', methods=['POST'])
def api_blaze_inventory_load_report():
    """
    Load a saved inventory report from file.
    Payload: { "filename": "filename.csv" }
    Returns: { "success": true, "data": [...rows...] }
    """
    try:
        payload = request.json
        filename = payload.get('filename', '')
        
        if not filename:
            return jsonify({'success': False, 'error': 'Filename required'}), 400
        
        filepath = INVENTORY_DIR / filename
        
        if not filepath.exists():
            return jsonify({'success': False, 'error': 'File not found'}), 404
        
        # Load CSV file
        df = pd.read_csv(filepath)
        data = df.to_dict('records')
        
        return jsonify({'success': True, 'data': data})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/blaze/inventory/export-tabs', methods=['POST'])
def api_blaze_inventory_export_tabs():
    """
    Export selected tabs as CSV (single tab) or XLSX (multiple tabs).
    Payload: { "tabs": { "Store1": [...data...], "Store2": [...data...], ... } }
    Returns: CSV or XLSX file download
    """
    try:
        payload = request.json
        tabs = payload.get('tabs', {})
        
        if not tabs:
            return jsonify({'error': 'No tabs provided'}), 400
        
        from flask import make_response
        
        if len(tabs) == 1:
            # Single tab: Export as CSV
            store_name = list(tabs.keys())[0]
            df = pd.DataFrame(tabs[store_name])
            
            from io import StringIO
            output = StringIO()
            df.to_csv(output, index=False)
            output.seek(0)
            
            response = make_response(output.getvalue())
            response.headers['Content-Type'] = 'text/csv'
            safe_name = store_name.replace(" ", "_").replace("/", "-")
            response.headers['Content-Disposition'] = f'attachment; filename={safe_name}_Inventory_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv'
            
        else:
            # Multiple tabs: Export as XLSX
            from io import BytesIO
            output = BytesIO()
            
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                for store_name, data in tabs.items():
                    df = pd.DataFrame(data)
                    # Excel sheet names have 31 char limit
                    safe_name = store_name[:30].replace("/", "-")
                    df.to_excel(writer, sheet_name=safe_name, index=False)
            
            output.seek(0)
            
            response = make_response(output.getvalue())
            response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            response.headers['Content-Disposition'] = f'attachment; filename=Multi_Store_Inventory_{datetime.now().strftime("%Y%m%d_%H%M%S")}.xlsx'
        
        return response
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/blaze/inventory/navigate-to-product', methods=['POST'])
def navigate_to_product():
    """
    Navigate Blaze browser to specific product page.
    Steps:
    1. Navigate to inventory URL
    2. Check/change store location
    3. Navigate to product page
    4. Bring tab to front
    """
    try:
        data = request.json
        store_name = data.get('store_name')
        blaze_id = data.get('blaze_id')
        
        if not store_name or not blaze_id:
            return jsonify({'success': False, 'error': 'Missing store_name or blaze_id'}), 400
        
        driver = GLOBAL_DATA['browser_instance']
        if not driver:
            return jsonify({'success': False, 'error': 'Browser not initialized'}), 500
        
        with BROWSER_LOCK:
            # STEP 0: Find or create Blaze tab (don't hijack active tab)
            print(f"[NAVIGATE] Finding or creating Blaze tab...")
            blaze_handle = None
            original_handle = driver.current_window_handle
            
            # Look for existing retail.blaze.me tab
            for handle in driver.window_handles:
                driver.switch_to.window(handle)
                if 'retail.blaze.me' in driver.current_url:
                    print(f"[NAVIGATE] [OK] Found existing Blaze tab")
                    blaze_handle = handle
                    break
            
            # If no Blaze tab found, create a new one
            if not blaze_handle:
                print(f"[NAVIGATE] Creating new Blaze tab...")
                driver.execute_script("window.open('https://retail.blaze.me/inventory', '_blank');")
                time.sleep(2)  # Wait for new tab to open
                # Switch to the newly created tab (last one)
                driver.switch_to.window(driver.window_handles[-1])
                blaze_handle = driver.current_window_handle
                print(f"[NAVIGATE] [OK] Created new Blaze tab")
            else:
                # Already on Blaze tab from the search above
                print(f"[NAVIGATE] Using existing Blaze tab")
            
            # STEP 1: Navigate to inventory page (in Blaze tab)
            print(f"[NAVIGATE] Navigating to inventory page...")
            driver.get('https://retail.blaze.me/inventory')
            time.sleep(2)  # Wait for page load
            
            # STEP 2: Check and change store if needed
            max_attempts = 3
            for attempt in range(1, max_attempts + 1):
                print(f"[NAVIGATE] Attempt {attempt}/{max_attempts} - Checking store location...")
                
                # Check current store
                try:
                    current_store_elem = driver.find_element(By.CSS_SELECTOR, 'span[data-cy="lbl-shop-name"]')
                    current_store = current_store_elem.text.strip()
                    print(f"[NAVIGATE] Current store: {current_store}")
                    print(f"[NAVIGATE] Target store: {store_name}")
                    
                    if current_store == store_name:
                        print(f"[NAVIGATE] [OK] Already on correct store!")
                        break
                    else:
                        print(f"[NAVIGATE] Need to change store...")
                        
                        # Click dropdown to open menu
                        dropdown_button = driver.find_element(By.CSS_SELECTOR, 'div.shopDropdown')
                        dropdown_button.click()
                        time.sleep(1)
                        
                        # Extract location part from store name (text after " - ")
                        # "The Artist Tree - Koreatown" ->[EMOJI] "Koreatown"
                        if ' - ' in store_name:
                            location_part = store_name.split(' - ')[-1].strip()
                        else:
                            location_part = store_name.strip()
                        
                        print(f"[NAVIGATE] Searching for store with location: '{location_part}'")
                        
                        # Find and click target store in dropdown using partial text match
                        # This handles variations like:
                        # - "The Artist Tree - Koreatown"
                        # - "Davisville Business Enterprises, Inc. - Davis"
                        # - "The Artist Tree - Fresno (Shaw Ave)"
                        try:
                            # Use XPath to find span that contains the location text
                            # The xpath looks for: <span data-cy="...">Text containing location</span>
                            xpath = f"//li[@class='shopElement']//span[contains(text(), '{location_part}')]"
                            target_store_elem = driver.find_element(By.XPATH, xpath)
                            
                            # Log what we found
                            found_text = target_store_elem.text.strip()
                            print(f"[NAVIGATE] [OK] Found store: '{found_text}'")
                            
                            target_store_elem.click()
                            print(f"[NAVIGATE] [OK] Clicked target store")
                            
                            # Wait for page refresh
                            time.sleep(3)
                            
                            # Verify store changed (check if location part is in current store name)
                            current_store_elem = driver.find_element(By.CSS_SELECTOR, 'span[data-cy="lbl-shop-name"]')
                            current_store = current_store_elem.text.strip()
                            
                            # Success if location part is in the current store name
                            if location_part in current_store:
                                print(f"[NAVIGATE] [OK] Store changed successfully to: '{current_store}'")
                                break
                            else:
                                print(f"[NAVIGATE] [OK][EMOJI]√É‚Äö√Ç¬ù Store change failed, retrying...")
                                
                        except NoSuchElementException:
                            return jsonify({
                                'success': False, 
                                'error': f'Store with location "{location_part}" not found in dropdown menu'
                            }), 404
                
                except NoSuchElementException as e:
                    print(f"[NAVIGATE] Error finding store elements: {e}")
                    if attempt == max_attempts:
                        return jsonify({
                            'success': False,
                            'error': 'Could not find store dropdown elements'
                        }), 500
                    time.sleep(2)
            else:
                # Max attempts reached without success
                return jsonify({
                    'success': False,
                    'error': f'Failed to change to store "{store_name}" after {max_attempts} attempts'
                }), 500
            
            # STEP 3: Navigate to product page
            product_url = f'https://retail.blaze.me/inventory/product/{blaze_id}'
            print(f"[NAVIGATE] Navigating to product: {product_url}")
            driver.get(product_url)
            time.sleep(2)
            
            # STEP 4: Ensure Blaze tab is in front (we already have the handle)
            try:
                driver.switch_to.window(blaze_handle)
                print(f"[NAVIGATE] [OK] Blaze tab is in focus")
            except Exception as e:
                print(f"[NAVIGATE] Warning: Could not ensure tab focus: {e}")
            
            return jsonify({
                'success': True,
                'message': f'Navigated to product {blaze_id} in store {store_name}',
                'url': product_url
            })
        
    except Exception as e:
        print(f"[NAVIGATE] Error: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


def convert_store_name_to_data_cy(store_name):
    """
    Convert store display name to data-cy format.
    Example: "The Artist Tree - Koreatown" ->[EMOJI] "lbl-TheArtistTree-Koreatown"
    """
    # Remove spaces and hyphens between words
    # "The Artist Tree - Koreatown" ->[EMOJI] "TheArtistTree-Koreatown"
    parts = store_name.split(' - ')
    if len(parts) == 2:
        company_part = parts[0].replace(' ', '')  # "TheArtistTree"
        location_part = parts[1].replace(' ', '')  # "Koreatown"
        result = f"lbl-{company_part}-{location_part}"
    else:
        # Fallback for different formats
        result = f"lbl-{store_name.replace(' ', '').replace('-', '')}"
    
    return result


# ============================================================================
# STARTUP
# ============================================================================
# ============================================================================
# STARTUP
# ============================================================================
def background_validation_monitor():
    """
    Background thread that ensures validation system is always active on MIS daily-discount page.
    Runs every 10 seconds, non-blocking, skips if automation is in progress.
    """
    print("[VALIDATION-MONITOR] Background validation monitor starting...")
    time.sleep(5)  # Wait for browser to initialize
    
    while True:
        try:
            time.sleep(10)  # Check every 10 seconds
            
            # SAFETY: Skip if automation is running
            if GLOBAL_DATA.get('automation_in_progress', False):
                continue
            
            # SAFETY: Skip if browser not initialized
            driver = GLOBAL_DATA.get('browser_instance')
            if not driver:
                continue
            
            # Check if we're on the daily-discount page
            try:
                current_url = driver.current_url
                if "daily-discount" not in current_url:
                    continue
                
                # Quick check if validation already active
                is_active = driver.execute_script(
                    "return window.MIS_VALIDATOR_ACTIVE || false;"
                )
                
                if not is_active:
                    # Inject validation in manual mode (no expected data)
                    inject_mis_validation(driver, expected_data=None)
                    print("[VALIDATION-MONITOR] ‚úÖ Injected manual validation (was missing)")
                    
            except Exception:
                # Silently skip on any error (don't crash the monitor)
                pass
                
        except Exception as e:
            # Log but don't crash
            print(f"[VALIDATION-MONITOR] ‚ö†Ô∏è Error: {e}")
            time.sleep(30)  # Wait longer on error

def open_browser_to_dashboard():
    time.sleep(2)
    print("[STARTUP] Initializing unified browser...")
    driver = init_browser()
    if driver:
        print("[STARTUP] Navigating to dashboard...")
        # FIX: Explicitly switch to the existing window [0]
        try:
            if len(driver.window_handles) > 0:
                driver.switch_to.window(driver.window_handles[0])
        except:
            pass
        driver.get("http://127.0.0.1:5100")
        print("[OK] Dashboard loaded")
    else:
        print("[ERROR] Browser init failed")

def main():
    print("="*70)
    print("BLAZE MIS Audit Pro - Project 2 v12")
    print("="*70)
    print(f"[PROFILE] Active: {ACTIVE_PROFILE['handle']}")
    print("[INFO] MULTI-DAY DEAL DETECTION ENABLED")
    print("[INFO] DATE-AWARE CONFLICT AUDIT ENABLED")
    print("[INFO] UP-DOWN PLANNING - Logic Gap & Split Management")
    print("[INFO] 3 Main Tabs: Setup | Audit | BLAZE")
    print(f"[INFO] Reports: {REPORTS_DIR}")
    print("="*70)

    GLOBAL_DATA['blaze']['inventory_running'] = False # Force clear lock on startup
    
    browser_thread = threading.Thread(target=open_browser_to_dashboard, daemon=True)
    browser_thread.start()
    
    # Start background validation monitor
    validation_monitor_thread = threading.Thread(target=background_validation_monitor, daemon=True)
    validation_monitor_thread.start()
    
    print("[START] Starting Flask server on http://127.0.0.1:5100")
    
    # Run Flask without reloader to prevent duplicate threads
    app.run(port=5100, debug=False, use_reloader=False)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[EXIT] Shutting down...")
        sys.exit(0)
    except Exception as e:
        print(f"\n[CRITICAL ERROR] {e}")
        traceback.print_exc()
        input("Press Enter to exit...")
